<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Vanara.PInvoke.ShlwApi</name>
    </assembly>
    <members>
        <member name="T:Vanara.PInvoke.ShlwApi">
            <summary>Exposes interfaces, functions and structures defined in shlwapi.dll.</summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.ASSOCDATA">
            <summary>
            <para>Used by IQueryAssociations::GetData to define the type of data that is to be returned.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCDATA.ASSOCDATA_MSIDESCRIPTOR">
            <summary>The component descriptor to pass to the Windows Installer API.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCDATA.ASSOCDATA_NOACTIVATEHANDLER">
            <summary>Attempts to activate a window are restricted. There is no data associated with this value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCDATA.ASSOCDATA_UNUSED1">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCDATA.ASSOCDATA_HASPERUSERASSOC">
            <summary>Defaults to user specified association.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCDATA.ASSOCDATA_EDITFLAGS">
            <summary>
            Internet Explorer version 6 or later. Gets the data stored in the EditFlags value of a file association PROGID registry key.
            This value consists of one or more FILETYPEATTRIBUTEFLAGS. Compare against those values to determine which attributes have
            been set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCDATA.ASSOCDATA_VALUE">
            <summary>
            Internet Explorer version 6 or later. Uses the parameter from the IQueryAssociations::GetData method as the value name.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCDATA.ASSOCDATA_MAX">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.ASSOCENUM">
            <summary>
            <para>Used by IQueryAssociations::GetEnum to define the type of enum that is to be returned.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCENUM.ASSOCENUM_NONE">
            <summary>Nothing.</summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.FDTF">
            <summary>Format flags for SHFormatDateTime.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FDTF.FDTF_SHORTTIME">
            <summary>
            Formats the time of day as specified by the Regional and Language Options application in Control Panel, but without seconds.
            This flag cannot be combined with FDTF_LONGTIME.
            <para>The short time was successfully formatted.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FDTF.FDTF_SHORTDATE">
            <summary>
            Formats the date as specified by the short date format in the Regional and Language Options application in Control Panel.
            This flag cannot be combined with FDTF_LONGDATE.
            <para>The short date was successfully formatted.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FDTF.FDTF_DEFAULT">
            <summary>Equivalent to FDTF_SHORTDATE | FDTF_SHORTTIME.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FDTF.FDTF_LONGDATE">
            <summary>
            Formats the date as specified by the long date format in the Regional and Language Options application in Control Panel. This
            flag cannot be combined with FDTF_SHORTDATE.
            <para>The long date was successfully formatted.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FDTF.FDTF_LONGTIME">
            <summary>
            Formats the time of day as specified by the Regional and Language Options application in Control Panel, including seconds.
            This flag cannot be combined with FDTF_SHORTTIME.
            <para>The long time was successfully formatted.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FDTF.FDTF_RELATIVE">
            <summary>
            If the FDTF_LONGDATE flag is set and the date in the FILETIME structure is the same date that SHFormatDateTime is called,
            then the day of the week (if present) is changed to "Today". If the date in the structure is the previous day, then the day
            of the week (if present) is changed to "Yesterday".
            <para>Relative notation was used for the date.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FDTF.FDTF_LTRDATE">
            <summary>Adds marks for left-to-right reading layout. This flag cannot be combined with FDTF_RTLDATE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FDTF.FDTF_RTLDATE">
            <summary>Adds marks for right-to-left reading layout. This flag cannot be combined with FDTF_LTRDATE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FDTF.FDTF_NOAUTOREADINGORDER">
            <summary>
            No reading order marks are inserted. Normally, in the absence of the FDTF_LTRDATE or FDTF_RTLDATE flag, SHFormatDateTime
            determines the reading order from the user's default locale, inserts reading order marks, and updates the pdwFlags output
            value appropriately. This flag prevents that process from occurring. It is used most commonly by legacy callers of
            SHFormatDateTime. This flag cannot be combined with FDTF_RTLDATE or FDTF_LTRDATE.
            <para>Windows Server 2003 and Windows XP: This value is not available.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS">
            <summary>
            <para>
            Indicates <c>FILETYPEATTRIBUTEFLAGS</c> constants that are used in the EditFlags value of a file association PROGID registry key.
            </para>
            </summary>
            <remarks>
            <para>
            These flags represent possible attributes stored in the EditFlags value of a ProgID registration. The EditFlags data is a single REG_DWORD.
            </para>
            <para>
            The following example shows the <c><c>FTA_NoRemove</c></c> (0x00000010) and <c><c>FTA_NoNewVerb</c></c> (0x00000020) attributes
            assigned to the .myp file type.
            </para>
            <para><c>.myp</c> (Default) = MyProgram.1 <c>MyProgram.1</c> (Default) = MyProgram Application <c>EditFlags</c> = 0x00000030</para>
            <para>
            APIs such as IQueryAssociations::GetData can retrieve that EditFlags data. Compare the numerical equivalents of these
            <c>FILETYPEATTRIBUTEFLAGS</c> flags against that retrived value to determine which flags are set.
            </para>
            <para>The following example demonstrates the use of IQueryAssociations::GetData to determine if those values are set.</para>
            <para>
            To set an EditFlags attribute, you can use the RegSetValueEx or SHSetValue functions. First use IQueryAssociations::GetData to
            retrieve the current set of attributes as shown in the example above, add the desired <c>FILETYPEATTRIBUTEFLAGS</c> to that
            value, then write that value back to the registry using one of the two set functions.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_None">
            <summary>No FILETYPEATTRIBUTEFLAGS options set.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_Exclude">
            <summary>Excludes the file type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_Show">
            <summary>Shows file types, such as folders, that are not associated with a file name extension.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_HasExtension">
            <summary>Indicates that the file type has a file name extension.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_NoEdit">
            <summary>
            Prohibits editing of the registry entries associated with this file type, the addition of new entries, and the deletion or
            modification of existing entries.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_NoRemove">
            <summary>Prohibits deletion of the registry entries associated with this file type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_NoNewVerb">
            <summary>Prohibits the addition of new verbs to the file type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_NoEditVerb">
            <summary>Prohibits the modification or deletion of canonical verbs such as open and print.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_NoRemoveVerb">
            <summary>Prohibits the deletion of canonical verbs such as open and print.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_NoEditDesc">
            <summary>Prohibits the modification or deletion of the description of the file type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_NoEditIcon">
            <summary>Prohibits the modification or deletion of the icon assigned to the file type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_NoEditDflt">
            <summary>Prohibits the modification of the default verb.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_NoEditVerbCmd">
            <summary>Prohibits the modification of the commands associated with verbs.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_NoEditVerbExe">
            <summary>Prohibits the modification or deletion of verbs.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_NoDDE">
            <summary>Prohibits the modification or deletion of the entries related to DDE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_NoEditMIME">
            <summary>Prohibits the modification or deletion of the content type and default extension entries.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_OpenIsSafe">
            <summary>
            Indicates that the file type's open verb can be safely invoked for downloaded files. This flag applies only to safe file
            types, as identified by AssocIsDangerous. To improve the user experience and reduce unnecessary user prompts when downloading
            and activating items, file type owners should specify this flag and applications that download and activate files should
            respect this flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_AlwaysUnsafe">
            <summary>
            Prevents the Never ask me check box from being enabled. Use of this flag means FTA_OpenIsSafe is not respected and
            AssocIsDangerous always returns TRUE. If your file type can execute code, you should always use this flag or ensure that the
            file type handlers mitigate risks, for example, by producing warning prompts before running the code. The user can override
            this attribute through the File Type dialog box.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_NoRecentDocs">
            <summary>
            Prohibits the addition of members of this file type to the Recent Documents folder. Additionally, in Windows 7 and later,
            prohibits the addition of members of this file type to the automatic Recent or Frequent category of an application's Jump
            List. This flag does not restrict members of this file type from being added to a custom Jump List. It also places no
            restriction on the file type being added to the automatic Jump Lists of other applications in the case that other
            applications use this file type.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_SafeForElevation">
            <summary>
            Introduced in Windows 8. Marks the file as safe to be passed from a low trust application to a full trust application. Files
            that originate from the Internet or an app container are examples where the file is considered untrusted. Untrusted files
            that contain code are especially dangerous, and appropriate security mitigations must be applied if the file is to be opened
            by a full trust application. File type owners for file formats that have the ability to execute code should specify this flag
            only if their program mitigates elevation-of-privilege threats that are associated with running code at a higher integrity
            level. Mitigations include prompting the user before code is executed or executing the code with reduced privileges. By
            specifying this flag for an entire file type, an app running within an app container can pass files of this type to a program
            running at full trust. Some file types are recognized as inherently dangerous due to their ability to execute code and will
            be blocked if you don't specify this value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.FILETYPEATTRIBUTEFLAGS.FTA_AlwaysUseDirectInvoke">
            <summary>
            Introduced in Windows 8. Ensures that the verbs for the file type are invoked with a URI instead of a downloaded version of
            the file. Use this flag only if you've registered the file type's verb to support DirectInvoke through the SupportedProtocols
            or UseUrl registration.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.GCT">
            <summary>Return values for <see cref="M:Vanara.PInvoke.ShlwApi.PathGetCharType(System.Char)"/></summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.GCT.GCT_INVALID">
            <summary>The character is not valid in a path.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.GCT.GCT_LFNCHAR">
            <summary>The character is valid in a long file name.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.GCT.GCT_SHORTCHAR">
            <summary>The character is valid in a short (8.3) file name.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.GCT.GCT_WILD">
            <summary>The character is a wildcard character.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.GCT.GCT_SEPARATOR">
            <summary>The character is a path separator.</summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.OS">
            <summary>Options for <see cref="M:Vanara.PInvoke.ShlwApi.IsOS(Vanara.PInvoke.ShlwApi.OS)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_WINDOWS">
            <summary>
            The program is running on one of the following versions of Windows:
            <list type="bullet">
            <item>
            <term>Windows 95</term>
            </item>
            <item>
            <term>Windows 98</term>
            </item>
            <item>
            <term>Windows Me</term>
            </item>
            </list>
            <para>
            Equivalent to VER_PLATFORM_WIN32_WINDOWS. Note that none of those systems are supported at this time. OS_WINDOWS returns
            FALSE on all supported systems.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_NT">
            <summary>Always returns TRUE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_WIN95ORGREATER">
            <summary>Always returns FALSE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_NT4ORGREATER">
            <summary>Always returns FALSE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_WIN98ORGREATER">
            <summary>Always returns FALSE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_WIN98_GOLD">
            <summary>Always returns FALSE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_WIN2000ORGREATER">
            <summary>The program is running on Windows 2000 or one of its successors.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_WIN2000PRO">
            <summary>Do not use; use OS_PROFESSIONAL.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_WIN2000SERVER">
            <summary>Do not use; use OS_SERVER.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_WIN2000ADVSERVER">
            <summary>Do not use; use OS_ADVSERVER.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_WIN2000DATACENTER">
            <summary>Do not use; use OS_DATACENTER.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_WIN2000TERMINAL">
            <summary>
            The program is running on Windows 2000 Terminal Server in either Remote Administration mode or Application Server mode, or
            Windows Server 2003 (or one of its successors) in Terminal Server mode or Remote Desktop for Administration mode. Consider
            using a more specific value such as OS_TERMINALSERVER, OS_TERMINALREMOTEADMIN, or OS_PERSONALTERMINALSERVER.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_EMBEDDED">
            <summary>The program is running on Windows Embedded, any version. Equivalent to VER_SUITE_EMBEDDEDNT.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_TERMINALCLIENT">
            <summary>The program is running as a Terminal Server client. Equivalent to GetSystemMetrics(SM_REMOTESESSION).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_TERMINALREMOTEADMIN">
            <summary>
            The program is running on Windows 2000 Terminal Server in the Remote Administration mode or Windows Server 2003 (or
            one of its successors) in the Remote Desktop for Administration mode (these are the default installation modes). This is
            equivalent to VER_SUITE_TERMINAL &amp;&amp; VER_SUITE_SINGLEUSERTS.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_WIN95_GOLD">
            <summary>Always returns FALSE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_MEORGREATER">
            <summary>Always returns FALSE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_XPORGREATER">
            <summary>Always returns FALSE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_HOME">
            <summary>Always returns FALSE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_PROFESSIONAL">
            <summary>The program is running on Windows NT Workstation or Windows 2000 (or one of its successors) Professional. Equivalent
            to VER_PLATFORM_WIN32_NT  &amp;&amp; VER_NT_WORKSTATION.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_DATACENTER">
            <summary>The program is running on Windows Datacenter Server or Windows Server Datacenter Edition, any version. Equivalent to
            (VER_NT_SERVER || VER_NT_DOMAIN_CONTROLLER)  &amp;&amp; VER_SUITE_DATACENTER.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_ADVSERVER">
            <summary>The program is running on Windows Advanced Server or Windows Server Enterprise Edition, any version. Equivalent to
            (VER_NT_SERVER || VER_NT_DOMAIN_CONTROLLER)  &amp;&amp; VER_SUITE_ENTERPRISE  &amp;&amp; !VER_SUITE_DATACENTER.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_SERVER">
            <summary>
            The program is running on Windows Server (Standard) or Windows Server Standard Edition, any version. This value will not
            return true for VER_SUITE_DATACENTER, VER_SUITE_ENTERPRISE, VER_SUITE_SMALLBUSINESS, or VER_SUITE_SMALLBUSINESS_RESTRICTED.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_TERMINALSERVER">
            <summary>The program is running on Windows 2000 Terminal Server in Application Server mode, or on Windows Server 2003 (or one
            of its successors) in Terminal Server mode. This is equivalent to VER_SUITE_TERMINAL &amp;&amp; VER_SUITE_SINGLEUSERTS.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_PERSONALTERMINALSERVER">
            <summary>The program is running on Windows XP (or one of its successors), Home Edition or Professional. This is equivalent to
            VER_SUITE_SINGLEUSERTS  &amp;&amp; !VER_SUITE_TERMINAL.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_FASTUSERSWITCHING">
            <summary>Fast user switching is enabled.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_WELCOMELOGONUI">
            <summary>Always returns FALSE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_DOMAINMEMBER">
            <summary>The computer is joined to a domain.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_ANYSERVER">
            <summary>The program is running on any Windows Server product. Equivalent to VER_NT_SERVER || VER_NT_DOMAIN_CONTROLLER.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_WOW6432">
            <summary>The program is a 32-bit program running on 64-bit Windows.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_WEBSERVER">
            <summary>Always returns FALSE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_SMALLBUSINESSSERVER">
            <summary>
            The program is running on Microsoft Small Business Server with restrictive client license in force. Equivalent to VER_SUITE_SMALLBUSINESS_RESTRICTED.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_TABLETPC">
            <summary>The program is running on Windows XP Tablet PC Edition, or one of its successors.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_SERVERADMINUI">
            <summary>
            The user should be presented with administrator UI. It is possible to have server administrative UI on a non-server machine.
            This value informs the application that an administrator's profile has roamed to a non-server, and UI should be appropriate
            to an administrator. Otherwise, the user is shown a mix of administrator and nonadministrator settings.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_MEDIACENTER">
            <summary>The program is running on Windows XP Media Center Edition, or one of its successors. Equivalent to GetSystemMetrics(SM_MEDIACENTER).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.OS.OS_APPLIANCE">
            <summary>The program is running on Windows Appliance Server.</summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.SHACF">
            <summary>The flags to control the operation of SHAutoComplete.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHACF.SHACF_AUTOAPPEND_FORCE_OFF">
            <summary>
            Ignore the registry default and force the AutoAppend feature off. This flag must be used in combination with one or more of
            the SHACF_FILESYS* or SHACF_URL* flags.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHACF.SHACF_AUTOAPPEND_FORCE_ON">
            <summary>
            Ignore the registry value and force the AutoAppend feature on. The completed string will be displayed in the edit box with
            the added characters highlighted. This flag must be used in combination with one or more of the SHACF_FILESYS* or SHACF_URL* flags.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHACF.SHACF_AUTOSUGGEST_FORCE_OFF">
            <summary>
            Ignore the registry default and force the AutoSuggest feature off. This flag must be used in combination with one or more of
            the SHACF_FILESYS* or SHACF_URL* flags.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHACF.SHACF_AUTOSUGGEST_FORCE_ON">
            <summary>
            Ignore the registry value and force the AutoSuggest feature on. A selection of possible completed strings will be displayed
            as a drop-down list, below the edit box. This flag must be used in combination with one or more of the SHACF_FILESYS* or
            SHACF_URL* flags.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHACF.SHACF_DEFAULT">
            <summary>
            The default setting, equivalent to SHACF_FILESYSTEM | SHACF_URLALL. SHACF_DEFAULT cannot be combined with any other flags.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHACF.SHACF_FILESYS_ONLY">
            <summary>Include the file system only.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHACF.SHACF_FILESYS_DIRS">
            <summary>Include the file system and directories, UNC servers, and UNC server shares.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHACF.SHACF_FILESYSTEM">
            <summary>Include the file system and the rest of the Shell (Desktop, Computer, and Control Panel, for example).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHACF.SHACF_URLALL">
            <summary>Include the URLs in the users History and Recently Used lists. Equivalent to SHACF_URLHISTORY | SHACF_URLMRU.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHACF.SHACF_URLHISTORY">
            <summary>Include the URLs in the user's History list.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHACF.SHACF_URLMRU">
            <summary>Include the URLs in the user's Recently Used list.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHACF.SHACF_USETAB">
            <summary>
            Allow the user to select from the autosuggest list by pressing the TAB key. If this flag is not set, pressing the TAB key
            will shift focus to the next control and close the autosuggest list. If SHACF_USETAB is set, pressing the TAB key will select
            the first item in the list. Pressing TAB again will select the next item in the list, and so on. When the user reaches the
            end of the list, the next TAB key press will cycle the focus back to the edit control. This flag must be used in combination
            with one or more of the SHACF_FILESYS* or SHACF_URL* flags listed on this page.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHACF.SHACF_VIRTUAL_NAMESPACE">
            <summary>Also include the virtual namespace</summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.SHCT_FLAGS">
            <summary>
            <para>
            Flags that control the calling function's behavior. Used by <c>SHCreateThread</c> and <c>SHCreateThreadWithHandle</c>. In those
            functions, these values are defined as being of type SHCT_FLAGS.
            </para>
            <para>
            <list type="table">
            <listheader>
            <term>Constant/value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>CTF_INSIST0x00000001</term>
            <term>
            0x00000001. If the attempt to create the thread with CreateThread fails, setting this flag will cause the function pointed to by
            pfnThreadProc to be called synchronously from the calling thread. This flag can be used only if pfnCallback is NULL.
            </term>
            </item>
            <item>
            <term>CTF_THREAD_REF0x00000002</term>
            <term>
            0x00000002. Hold a reference to the creating thread for the duration of the call to the function pointed to by pfnThreadProc.
            This reference must have been set with SHSetThreadRef.
            </term>
            </item>
            <item>
            <term>CTF_PROCESS_REF0x00000004</term>
            <term>
            0x00000004. Hold a reference to the Windows Explorer process for the duration of the call to the function pointed to by
            pfnThreadProc. This flag is useful for Shell extension handlers, which might need to keep the Windows Explorer process from
            closing prematurely. This action is useful during tasks such as working on a background thread or copying files. For more
            information, see SHGetInstanceExplorer.
            </term>
            </item>
            <item>
            <term>CTF_COINIT_STA0x00000008</term>
            <term>
            0x00000008. Initialize COM as a Single Threaded Apartment (STA) for the created thread before calling either the optional
            function pointed to by pfnCallback or the function pointed to by pfnThreadProc. This flag is useful when COM needs to be
            initialized for a thread. COM will automatically be uninitialized as well.
            </term>
            </item>
            <item>
            <term>CTF_COINIT0x00000008</term>
            <term>Equivalent to CTF_COINIT_STA.</term>
            </item>
            <item>
            <term>CTF_FREELIBANDEXIT0x00000010</term>
            <term>
            0x00000010. Internet Explorer 6 or later.LoadLibrary will be called on the DLL that contains the pfnThreadProc function to
            prevent it from being unloaded. After pfnThreadProc returns, the DLL will be freed with FreeLibrary, thereby decrementing the DLL
            reference count. Pass this flag to prevent the DLL from being unloaded prematurely; for example, by CoFreeUnusedLibraries. Note
            that if this flag is passed, the pfnThreadProc function must reside in a DLL. This flag is implicit in Windows Vista and later.
            </term>
            </item>
            <item>
            <term>CTF_REF_COUNTED0x00000020</term>
            <term>
            0x00000020. Internet Explorer 6 or later. A thread reference will automatically be created for the created thread and set with
            SHSetThreadRef. After the pfnThreadProc returns, the thread reference is released and messages are sent until the reference count
            on the thread reference drops to zero, that is, until threads that are dependent on the created thread have released their references.
            </term>
            </item>
            <item>
            <term>CTF_WAIT_ALLOWCOM0x00000040</term>
            <term>
            0x00000040. Internet Explorer 6 or later. The calling thread waits and pumps COM and SendMessage messages. If the synchronous
            procedure attempts to send a Windows message with SendMessage to a window hosted on the calling thread, the message will arrive
            successfully. If the synchronous procedure attempts to use COM to communicate with an STA object hosted on the calling thread,
            the function call will successfully reach the intended object. The calling thread is open to re-entrance fragility. While the
            calling thread can handle the synchronous procedure's use of SendMessage and COM, if other threads are using SendMessage or COM
            to communicate to objects hosted on the calling thread, then these might be unexpected messages or function calls which are
            processed while the synchronous procedure is completing.
            </term>
            </item>
            <item>
            <term>CTF_UNUSED0x00000080</term>
            <term>0x00000080. Internet Explorer 7 or later. Not used.</term>
            </item>
            <item>
            <term>CTF_INHERITWOW640x00000100</term>
            <term>
            0x00000100. Internet Explorer 7 or later. The new thread inherits the Windows-on-Windows 64-bit (WOW64) disable state for the
            file system redirector.
            </term>
            </item>
            <item>
            <term>CTF_WAIT_NO_REENTRANCY0x00000200</term>
            <term>
            0x00000200. Windows Vista or later. The calling thread blocks all other processes while waiting for the synchronous procedure to
            run on the new thread. If the synchronous procedure attempts to send a Windows message with SendMessage to a window hosted on the
            calling thread, this causes the synchronous procedure to deadlock. If the synchronous procedure attempts to use COM to talk to an
            STA object hosted on the calling thread, this also causes the synchronous procedure to deadlock. The calling thread is protected
            from all re-entrance concerns by specifying this flag.
            </term>
            </item>
            <item>
            <term>CTF_KEYBOARD_LOCALE0x00000400</term>
            <term>0x00000400. Windows 7 or later. Use the keyboard locale from the original thread in the new thread that it spawns.</term>
            </item>
            <item>
            <term>CTF_OLEINITIALIZE0x00000800</term>
            <term>0x00000800. Windows 7 or later. Initialize COM with the single-threaded apartment (STA) model for the created thread.</term>
            </item>
            <item>
            <term>CTF_COINIT_MTA0x00001000</term>
            <term>0x00001000. Windows 7 and later. Initialize COM with the multithreaded apartment (MTA) model for the created thread.</term>
            </item>
            <item>
            <term>CTF_NOADDREFLIB0x00002000</term>
            <term>
            0x00002000. Windows 7 or later. This flag is essentially the opposite of CTF_FREELIBANDEXIT. This avoids
            LoadLibrary/FreeLibraryAndExitThread calls that can result in contention for the loader lock. Use CTF_NOADDREFLIB only when the
            new thread has means to ensure that the code of the original thread procedure will remain loaded. This value should not be used
            in the context of COM objects, because COM objects must ensure that the DLL stays loaded (normally, COM unloads the DLLs).
            </term>
            </item>
            </list>
            </para>
            </summary>
            <returns></returns>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHCT_FLAGS.CTF_INSIST">
            <summary>
            If the attempt to create the thread with CreateThread fails, setting this flag will cause the function pointed to by
            pfnThreadProc to be called synchronously from the calling thread. This flag can be used only if pfnCallback is NULL.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHCT_FLAGS.CTF_THREAD_REF">
            <summary>
            Hold a reference to the creating thread for the duration of the call to the function pointed to by pfnThreadProc. This
            reference must have been set with SHSetThreadRef.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHCT_FLAGS.CTF_PROCESS_REF">
            <summary>
            Hold a reference to the Windows Explorer process for the duration of the call to the function pointed to by pfnThreadProc.
            This flag is useful for Shell extension handlers, which might need to keep the Windows Explorer process from closing
            prematurely. This action is useful during tasks such as working on a background thread or copying files. For more
            information, see SHGetInstanceExplorer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHCT_FLAGS.CTF_COINIT_STA">
            <summary>
            Initialize COM as a Single Threaded Apartment (STA) for the created thread before calling either the optional function
            pointed to by pfnCallback or the function pointed to by pfnThreadProc. This flag is useful when COM needs to be initialized
            for a thread. COM will automatically be uninitialized as well.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHCT_FLAGS.CTF_COINIT">
            <summary>Equivalent to CTF_COINIT_STA.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHCT_FLAGS.CTF_FREELIBANDEXIT">
            <summary>
            Internet Explorer 6 or later. LoadLibrary will be called on the DLL that contains the pfnThreadProc function to prevent it
            from being unloaded. After pfnThreadProc returns, the DLL will be freed with FreeLibrary, thereby decrementing the DLL
            reference count. Pass this flag to prevent the DLL from being unloaded prematurely; for example, by CoFreeUnusedLibraries.
            Note that if this flag is passed, the pfnThreadProc function must reside in a DLL. This flag is implicit in Windows Vista and later.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHCT_FLAGS.CTF_REF_COUNTED">
            <summary>
            Internet Explorer 6 or later. A thread reference will automatically be created for the created thread and set with
            SHSetThreadRef. After the pfnThreadProc returns, the thread reference is released and messages are sent until the reference
            count on the thread reference drops to zero, that is, until threads that are dependent on the created thread have released
            their references.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHCT_FLAGS.CTF_WAIT_ALLOWCOM">
            <summary>
            Internet Explorer 6 or later. The calling thread waits and pumps COM and SendMessage messages. If the synchronous procedure
            attempts to send a Windows message with SendMessage to a window hosted on the calling thread, the message will arrive
            successfully. If the synchronous procedure attempts to use COM to communicate with an STA object hosted on the calling
            thread, the function call will successfully reach the intended object. The calling thread is open to re-entrance fragility.
            While the calling thread can handle the synchronous procedure's use of SendMessage and COM, if other threads are using
            SendMessage or COM to communicate to objects hosted on the calling thread, then these might be unexpected messages or
            function calls which are processed while the synchronous procedure is completing.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHCT_FLAGS.CTF_UNUSED">
            <summary>Internet Explorer 7 or later. Not used.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHCT_FLAGS.CTF_INHERITWOW64">
            <summary>
            Internet Explorer 7 or later. The new thread inherits the Windows-on-Windows 64-bit (WOW64) disable state for the file system redirector.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHCT_FLAGS.CTF_WAIT_NO_REENTRANCY">
            <summary>
            Windows Vista or later. The calling thread blocks all other processes while waiting for the synchronous procedure to run on
            the new thread. If the synchronous procedure attempts to send a Windows message with SendMessage to a window hosted on the
            calling thread, this causes the synchronous procedure to deadlock. If the synchronous procedure attempts to use COM to talk
            to an STA object hosted on the calling thread, this also causes the synchronous procedure to deadlock. The calling thread is
            protected from all re-entrance concerns by specifying this flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHCT_FLAGS.CTF_KEYBOARD_LOCALE">
            <summary>Windows 7 or later. Use the keyboard locale from the original thread in the new thread that it spawns.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHCT_FLAGS.CTF_OLEINITIALIZE">
            <summary>Windows 7 or later. Initialize COM with the single-threaded apartment (STA) model for the created thread.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHCT_FLAGS.CTF_COINIT_MTA">
            <summary>Windows 7 and later. Initialize COM with the multithreaded apartment (MTA) model for the created thread.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHCT_FLAGS.CTF_NOADDREFLIB">
            <summary>
            Windows 7 or later. This flag is essentially the opposite of CTF_FREELIBANDEXIT. This avoids LoadLibrary/
            FreeLibraryAndExitThread calls that can result in contention for the loader lock. Use CTF_NOADDREFLIB only when the new
            thread has means to ensure that the code of the original thread procedure will remain loaded. This value should not be used
            in the context of COM objects, because COM objects must ensure that the DLL stays loaded (normally, COM unloads the DLLs).
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.SHELLPLATFORM">
            <summary>Value that indicates the type of Shell32.dll that the platform contains.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHELLPLATFORM.PLATFORM_UNKNOWN">
            <summary>The function was unable to determine the Shell32.dll version.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHELLPLATFORM.PLATFORM_IE3">
            <summary>Obsolete: Use PLATFORM_BROWSERONLY.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHELLPLATFORM.PLATFORM_BROWSERONLY">
            <summary>The Shell32.dll version is browser-only, with no new shell.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHELLPLATFORM.PLATFORM_INTEGRATED">
            <summary>The platform contains an integrated shell.</summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.SHGVSPB">
            <summary>Flags used by <see cref="M:Vanara.PInvoke.ShlwApi.SHGetViewStatePropertyBag(System.IntPtr,System.String,Vanara.PInvoke.ShlwApi.SHGVSPB,System.Guid@,System.Object@)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHGVSPB.SHGVSPB_PERUSER">
            <summary>Returns the per-user properties for the specified pidl.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHGVSPB.SHGVSPB_ALLUSERS">
            <summary>
            Returns the All User properties for the specified pidl.
            <para>One value from the following set of flags is required.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHGVSPB.SHGVSPB_PERFOLDER">
            <summary>Returns the property bag for the folder specified by the pidl parameter.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHGVSPB.SHGVSPB_ALLFOLDERS">
            <summary>Returns the property bag that applies to all folders.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHGVSPB.SHGVSPB_INHERIT">
            <summary>
            Returns the property bag used to provide defaults for subfolders that do not have their property bag.
            <para>The following flags are optional.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHGVSPB.SHGVSPB_ROAM">
            <summary>Allows the property bag to roam. See Roaming User Profiles. This flag cannot be combined with SHGVSPB_ALLFOLDERS.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHGVSPB.SHGVSPB_NOAUTODEFAULTS">
            <summary>
            Suppresses the search for a suitable default when the property bag cannot be found for the specified folder. By default, if
            SHGVSPB_INHERIT is not specified and a property bag cannot be found for the specified folder, the system searches for
            identically named property bags in other locations that may be able to provide default values. For example, the system
            searches in the ancestors of the folder to see if any of them provide a SHGVSPB_INHERIT property bag. Other places the system
            searches are in the user defaults and the global defaults.
            <para>The following set of flags consists of values that combine some flags listed above, and are used for brevity and convenience.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHGVSPB.SHGVSPB_FOLDER">
            <summary>Combines SHGVSPB_PERUSER and SHGVSPB_PERFOLDER.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHGVSPB.SHGVSPB_FOLDERNODEFAULTS">
            <summary>Combines SHGVSPB_PERUSER, SHGVSPB_PERFOLDER, and SHGVSPB_NOAUTODEFAULTS.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHGVSPB.SHGVSPB_USERDEFAULTS">
            <summary>Combines SHGVSPB_PERUSER and SHGVSPB_ALLFOLDERS.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHGVSPB.SHGVSPB_GLOBALDEFAULTS">
            <summary>
            Combines SHGVSPB_ALLUSERS and SHGVSPB_ALLFOLDERS.
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</c> This flag is named SHGVSPB_GLOBALDEAFAULTS.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.SHREGDEL_FLAGS">
            <summary>
            <para>Provides a set of values that indicate from which base key an item will be deleted.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHREGDEL_FLAGS.SHREGDEL_DEFAULT">
            <summary>Deletes from HKEY_CURRENT_USER. If the specified item is not found under HKEY_CURRENT_USER, deletes from HKEY_LOCAL_MACHINE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHREGDEL_FLAGS.SHREGDEL_HKCU">
            <summary>Enumerates from HKEY_CURRENT_USER only.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHREGDEL_FLAGS.SHREGDEL_HKLM">
            <summary>Enumerates under HKEY_LOCAL_MACHINE only.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHREGDEL_FLAGS.SHREGDEL_BOTH">
            <summary>Deletes from both HKEY_CURRENT_USER and HKEY_LOCAL_MACHINE.</summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.SHREGENUM_FLAGS">
            <summary>
            <para>Provides a set of values that indicate the base key that will be used for an enumeration.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHREGENUM_FLAGS.SHREGENUM_DEFAULT">
            <summary>
            Enumerates under HKEY_CURRENT_USER, or, if the specified item is not found in HKEY_CURRENT_USER, enumerates under HKEY_LOCAL_MACHINE.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHREGENUM_FLAGS.SHREGENUM_HKCU">
            <summary>Enumerates under HKEY_CURRENT_USER only.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHREGENUM_FLAGS.SHREGENUM_HKLM">
            <summary>Enumerates under HKEY_LOCAL_MACHINE only.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHREGENUM_FLAGS.SHREGENUM_BOTH">
            <summary>Not used.</summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.SHREGSET">
            <summary>Flags used by <see cref="M:Vanara.PInvoke.ShlwApi.SHRegCreateUSKey(System.String,System.UInt32,Vanara.PInvoke.ShlwApi.HUSKEY,Vanara.PInvoke.ShlwApi.SafeHUSKEY@,Vanara.PInvoke.ShlwApi.SHREGSET)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHREGSET.SHREGSET_DEFAULT">
            <summary>
            Create/open the key under both <c>HKEY_CURRENT_USER</c> (forced) and <c>HKEY_LOCAL_MACHINE</c> (only if empty). This flag is
            the equivalent of ( <c>SHREGSET_FORCE_HKCU</c> | <c>SHREGSET_HKLM</c>).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHREGSET.SHREGSET_HKCU">
            <summary>Create/open the key under <c>HKEY_CURRENT_USER</c>. Only creates a key if it is empty.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHREGSET.SHREGSET_FORCE_HKCU">
            <summary>Create/open the key under <c>HKEY_CURRENT_USER</c>. Creates a key even if it is not empty.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHREGSET.SHREGSET_HKLM">
            <summary>Create/open the key under <c>HKEY_LOCAL_MACHINE</c>. Only creates a key if it is empty.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SHREGSET.SHREGSET_FORCE_HKLM">
            <summary>Create/open the key under <c>HKEY_LOCAL_MACHINE</c>. Creates a key even if it is not empty.</summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.SRRF">
            <summary>Flags that restrict the data to be set or returned.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_RT_REG_NONE">
            <summary>Type REG_NONE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_RT_REG_SZ">
            <summary>Type REG_SZ. REG_EXPAND_SZ types are automatically converted to REG_SZ unless the SRRF_NOEXPAND flag is specified.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_RT_REG_EXPAND_SZ">
            <summary>
            Type REG_EXPAND_SZ. If retrieving a value, you must also get the SRRF_NOEXPAND flag, or SHRegGetValue fails with ERROR_INVALID_PARAMETER.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_RT_REG_BINARY">
            <summary>Type REG_BINARY.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_RT_REG_DWORD">
            <summary>Type REG_DWORD.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_RT_REG_MULTI_SZ">
            <summary>Type REG_MULTI_SZ.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_RT_REG_QWORD">
            <summary>Type REG_QWORD.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_RT_DWORD">
            <summary>
            REG_DWORD and 32-bit REG_BINARY types. This is equivalent to SRRF_RT_REG_BINARY | SRRF_RT_REG_DWORD. If retrieving a value,
            if the value's binary data is larger than 32 bits, it is not returned.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_RT_QWORD">
            <summary>
            REG_QWORD and 64-bit REG_BINARY types. This is equivalent to SRRF_RT_REG_BINARY | SRRF_RT_REG_QWORD. If retrieving a value,
            if the value's binary data is larger than 64 bits, it is not returned.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_RT_ANY">
            <summary>All types. Set this flag if no other SRRF_RT value is set.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_RM_ANY">
            <summary>No mode restriction. This is the default value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_RM_NORMAL">
            <summary>Restrict system startup mode to "normal boot".</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_RM_SAFE">
            <summary>Restrict system startup mode to "safe mode".</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_RM_SAFENETWORK">
            <summary>Restrict system startup mode to "safe mode with networking".</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_NOEXPAND">
            <summary>Do not automatically expand REG_EXPAND_SZ environment strings.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_ZEROONFAILURE">
            <summary>If retrieving a value, if pvData is not NULL, set the contents of the pvData buffer to all zeros on failure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SRRF.SRRF_NOVIRT">
            <summary>When retrieving a value, if the requested key is virtualized, fail with ERROR_FILE_NOT_FOUND.</summary>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.ChrCmpI(System.UInt16,System.UInt16)">
            <summary>
            <para>Performs a comparison between two characters. The comparison is not case-sensitive.</para>
            </summary>
            <param name="w1">
            <para>Type: <c>TCHAR</c></para>
            <para>The first character to be compared.</para>
            </param>
            <param name="w2">
            <para>Type: <c>TCHAR</c></para>
            <para>The second character to be compared.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns zero if the two characters are the same, or nonzero otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.ColorAdjustLuma(Vanara.PInvoke.COLORREF,System.Int32,System.Boolean)">
            <summary>
            <para>Changes the luminance of a RGB value. Hue and saturation are not affected.</para>
            </summary>
            <param name="clrRGB">
            <para>Type: <c>COLORREF</c></para>
            <para>The initial RGB value.</para>
            </param>
            <param name="n">
            <para>Type: <c>int</c></para>
            <para>
            The luminance in units of 0.1 percent of the total range. For example, a value of n = 50 corresponds to 5 percent of the maximum luminance.
            </para>
            </param>
            <param name="fScale">
            <para>Type: <c>BOOL</c></para>
            <para>
            If fScale is set to <c>TRUE</c>, n specifies how much to increment or decrement the current luminance. If fScale is set to
            <c>FALSE</c>, n specifies the absolute luminance.
            </para>
            </param>
            <returns>
            <para>Type: <c>COLORREF</c></para>
            <para>Returns the modified RGB value.</para>
            </returns>
            <remarks>
            <para>If fScale is set to <c>TRUE</c>, n can range from -1000 to +1000.</para>
            <para>
            If fScale is set to <c>FALSE</c>, n can range from 0 to 1000. Available luminance values range from 0 to a maximum. If the
            requested value is negative or exceeds the maximum, the luminance will be set to either zero or the maximum value, respectively.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.ColorHLSToRGB(System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            <para>Converts colors from hue-luminance-saturation (HLS) to RGB format.</para>
            </summary>
            <param name="wHue">
            <para>Type: <c>WORD</c></para>
            <para>The original HLS hue value.</para>
            </param>
            <param name="wLuminance">
            <para>Type: <c>WORD</c></para>
            <para>The original HLS luminance value.</para>
            </param>
            <param name="wSaturation">
            <para>Type: <c>WORD</c></para>
            <para>The original HLS saturation value.</para>
            </param>
            <returns>
            <para>Type: <c>COLORREF</c></para>
            <para>Returns the RGB value.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.ColorRGBToHLS(Vanara.PInvoke.COLORREF,System.UInt16@,System.UInt16@,System.UInt16@)">
            <summary>
            <para>Converts colors from RGB to hue-luminance-saturation (HLS) format.</para>
            </summary>
            <param name="clrRGB">
            <para>Type: <c>COLORREF</c></para>
            <para>The original RGB color.</para>
            </param>
            <param name="pwHue">
            <para>Type: <c>WORD*</c></para>
            <para>A pointer to a value that, when this method returns successfully, receives the HLS hue value.</para>
            </param>
            <param name="pwLuminance">
            <para>Type: <c>WORD*</c></para>
            <para>A pointer to a value that, when this method returns successfully, receives the HLS luminance value.</para>
            </param>
            <param name="pwSaturation">
            <para>Type: <c>WORD*</c></para>
            <para>A pointer to a value that, when this method returns successfully, receives the HLS saturation value.</para>
            </param>
            <returns>
            <para>This function does not return a value.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.ConnectToConnectionPoint(System.Object,System.Guid@,System.Boolean,System.Object,System.UInt32@,System.Runtime.InteropServices.ComTypes.IConnectionPoint@)">
            <summary>
            <para>
            [This function is available through Windows XP and Windows Server 2003. It might be altered or unavailable in subsequent versions
            of Windows.]
            </para>
            <para>Establishes or terminates a connection between a client's sink and a connection point container.</para>
            </summary>
            <param name="punk">
            <para>Type: <c>IUnknown*</c></para>
            <para>
            A pointer to the IUnknown interface of the object to be connected to the connection point container. If you set fConnect to
            <c>FALSE</c> to indicate that you are disconnecting the object, this parameter is ignored and can be set to <c>NULL</c>.
            </para>
            </param>
            <param name="riidEvent">
            <para>Type: <c>REFIID</c></para>
            <para>The IID of the interface on the connection point container whose connection point object is being requested.</para>
            </param>
            <param name="fConnect">
            <para>Type: <c>BOOL</c></para>
            <para><c>TRUE</c> if a connection is being established; <c>FALSE</c> if a connection is being broken.</para>
            </param>
            <param name="punkTarget">
            <para>Type: <c>IUnknown*</c></para>
            <para>A pointer to the connection point container's IUnknown interface.</para>
            </param>
            <param name="pdwCookie">
            <para>Type: <c>DWORD*</c></para>
            <para>
            A connection token. If you set fConnect to <c>TRUE</c> to make a new connection, this parameter receives a token that uniquely
            identifies the connection. If you set fConnect to <c>FALSE</c> to break a connection, this parameter must point to the token that
            you received when you called <c>ConnectToConnectionPoint</c> to establish the connection.
            </para>
            </param>
            <param name="ppcpOut">
            <para>Type: <c>IConnectionPoint**</c></para>
            <para>
            A pointer to the connection point container's IConnectionPoint interface, if the operation was successful. The calling
            application must release this pointer when it is no longer needed. If the request is unsuccessful, the pointer receives
            <c>NULL</c>. This parameter is optional and can be <c>NULL</c>.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.ConnectToConnectionPoint(System.Object,System.Guid@,System.Boolean,System.Object,System.UInt32@,System.IntPtr)">
            <summary>
            <para>
            [This function is available through Windows XP and Windows Server 2003. It might be altered or unavailable in subsequent versions
            of Windows.]
            </para>
            <para>Establishes or terminates a connection between a client's sink and a connection point container.</para>
            </summary>
            <param name="punk">
            <para>Type: <c>IUnknown*</c></para>
            <para>
            A pointer to the IUnknown interface of the object to be connected to the connection point container. If you set fConnect to
            <c>FALSE</c> to indicate that you are disconnecting the object, this parameter is ignored and can be set to <c>NULL</c>.
            </para>
            </param>
            <param name="riidEvent">
            <para>Type: <c>REFIID</c></para>
            <para>The IID of the interface on the connection point container whose connection point object is being requested.</para>
            </param>
            <param name="fConnect">
            <para>Type: <c>BOOL</c></para>
            <para><c>TRUE</c> if a connection is being established; <c>FALSE</c> if a connection is being broken.</para>
            </param>
            <param name="punkTarget">
            <para>Type: <c>IUnknown*</c></para>
            <para>A pointer to the connection point container's IUnknown interface.</para>
            </param>
            <param name="pdwCookie">
            <para>Type: <c>DWORD*</c></para>
            <para>
            A connection token. If you set fConnect to <c>TRUE</c> to make a new connection, this parameter receives a token that uniquely
            identifies the connection. If you set fConnect to <c>FALSE</c> to break a connection, this parameter must point to the token that
            you received when you called <c>ConnectToConnectionPoint</c> to establish the connection.
            </para>
            </param>
            <param name="ppcpOut">
            <para>Type: <c>IConnectionPoint**</c></para>
            <para>
            A pointer to the connection point container's IConnectionPoint interface, if the operation was successful. The calling
            application must release this pointer when it is no longer needed. If the request is unsuccessful, the pointer receives
            <c>NULL</c>. This parameter is optional and can be <c>NULL</c>.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.GetAcceptLanguages(System.Text.StringBuilder,System.UInt32@)">
            <summary>
            <para>Retrieves a string used with websites when specifying language preferences.</para>
            </summary>
            <param name="pszLanguages">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer to a string that, when this function returns successfully, receives the language preferences information. We recommend
            that this buffer be of size 2048 characters to ensure sufficient space to return the full string. You can also call this function
            with this parameter set to NULL to retrieve the size of the string that will be returned.
            </para>
            </param>
            <param name="pcchLanguages">
            <para>Type: <c>DWORD*</c></para>
            <para>A pointer to the size, in characters, of the string at pszLanguages.</para>
            <para>On entry, this value is the size of pszLanguages, including the terminating null character.</para>
            <para>On exit, it is the actual size of pszLanguages, not including the terminating null character.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            For those versions of Windows that do not include <c>GetAcceptLanguages</c> in Shlwapi.h, this function's individual ANSI or
            Unicode version must be called directly from Shlwapi.dll. <c>GetAcceptLanguagesA</c> is ordinal 14 and <c>GetAcceptLanguagesW</c>
            is ordinal 15.
            </para>
            <para>
            Some websites offer content in multiple languages. You can specify your language preferences in the Internet Options item in
            Control Panel. <c>GetAcceptLanguages</c> retrieves a string that represents those preferences. That string is sent in an
            additional language header when negotiating HTTP connections.
            </para>
            <para>
            <c>Note</c> If your app or service passes language tags from this function to any National Language Support functions, or to
            Microsoft .NET, it must first convert the tags through the ResolveLocaleName function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.GetMenuPosFromID(Vanara.PInvoke.HMENU,System.UInt32)">
            <summary>
            <para>
            [ <c>GetMenuPosFromID</c> is available for use in the operating systems specified in the Requirements section. It may be altered
            or unavailable in subsequent versions.]
            </para>
            <para>Determines the position of an item in a menu. Used in the case where the item's ID is known.</para>
            </summary>
            <param name="hmenu">
            <para>Type: <c>HMENU</c></para>
            <para>The handle of the menu.</para>
            </param>
            <param name="id">
            <para>Type: <c>UINT</c></para>
            <para>An application-defined 16-bit value that identifies the menu item.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>The item's zero-based position in the menu.</para>
            </returns>
            <remarks>
            <para>Beginning with Windows Vista, this function is declared in Shlwapi.h.</para>
            <para><c>Windows XP:</c> This function is declared in Shlwapi.dll.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.HashData(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)">
            <summary>
            <para>Hashes an array of data.</para>
            </summary>
            <param name="pbData">
            <para>Type: <c>BYTE*</c></para>
            <para>A pointer to the data array.</para>
            </param>
            <param name="cbData">
            <para>Type: <c>DWORD</c></para>
            <para>The number of elements in the array at pbData.</para>
            </param>
            <param name="pbHash">
            <para>Type: <c>BYTE*</c></para>
            <para>A pointer to a value that, when this function returns successfully, receives the hashed array.</para>
            </param>
            <param name="cbHash">
            <para>Type: <c>DWORD</c></para>
            <para>The number of elements in pbHash. It should be no larger than 256.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IsCharSpace(System.Char)">
            <summary>
            <para>Determines whether a character represents a space.</para>
            </summary>
            <param name="wch">
            <para>Type: <c>TCHAR</c></para>
            <para>A single character.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if the character is a space; otherwise, <c>FALSE</c>.</para>
            </returns>
            <remarks>
            <para>
            For those versions of Windows that do not include <c>IsCharSpace</c> in Shlwapi.h, <c>IsCharSpaceW</c> must be called directly
            from Shlwapi.dll (ordinal 29), using a WCHAR in the wch parameter. <c>IsCharSpaceA</c> is not available in versions of Windows
            that do not include <c>IsCharSpace</c> in Shlwapi.h.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IsInternetESCEnabled">
            <summary>
            <para>Determines whether Windows Internet Explorer is in the Enhanced Security Configuration.</para>
            </summary>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if Internet Explorer is in the Enhanced Security Configuration, and <c>FALSE</c> otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IsOS(Vanara.PInvoke.ShlwApi.OS)">
            <summary>
            <para>Checks for specified operating systems and operating system features.</para>
            </summary>
            <param name="dwOS">
            <para>Type: <c>DWORD</c></para>
            <para>
            A value that specifies which operating system or operating system feature to check for. One of the following values (you cannot
            combine values).
            </para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OS_WINDOWS</term>
            <term>0</term>
            <term>
            The program is running on one of the following versions of Windows: Equivalent to VER_PLATFORM_WIN32_WINDOWS. Note that none of
            those systems are supported at this time. OS_WINDOWS returns FALSE on all supported systems.
            </term>
            </item>
            <item>
            <term>OS_NT</term>
            <term>1</term>
            <term>Always returns TRUE.</term>
            </item>
            <item>
            <term>OS_WIN95ORGREATER</term>
            <term>2</term>
            <term>Always returns FALSE.</term>
            </item>
            <item>
            <term>OS_NT4ORGREATER</term>
            <term>3</term>
            <term>Always returns FALSE.</term>
            </item>
            <item>
            <term>OS_WIN98ORGREATER</term>
            <term>5</term>
            <term>Always returns FALSE.</term>
            </item>
            <item>
            <term>OS_WIN98_GOLD</term>
            <term>6</term>
            <term>Always returns FALSE.</term>
            </item>
            <item>
            <term>OS_WIN2000ORGREATER</term>
            <term>7</term>
            <term>The program is running on Windows 2000 or one of its successors.</term>
            </item>
            <item>
            <term>OS_WIN2000PRO</term>
            <term>8</term>
            <term>Do not use; use OS_PROFESSIONAL.</term>
            </item>
            <item>
            <term>OS_WIN2000SERVER</term>
            <term>9</term>
            <term>Do not use; use OS_SERVER.</term>
            </item>
            <item>
            <term>OS_WIN2000ADVSERVER</term>
            <term>10</term>
            <term>Do not use; use OS_ADVSERVER.</term>
            </item>
            <item>
            <term>OS_WIN2000DATACENTER</term>
            <term>11</term>
            <term>Do not use; use OS_DATACENTER.</term>
            </item>
            <item>
            <term>OS_WIN2000TERMINAL</term>
            <term>12</term>
            <term>
            The program is running on Windows 2000 Terminal Server in either Remote Administration mode or Application Server mode, or
            Windows Server 2003 (or one of its successors) in Terminal Server mode or Remote Desktop for Administration mode. Consider using
            a more specific value such as OS_TERMINALSERVER, OS_TERMINALREMOTEADMIN, or OS_PERSONALTERMINALSERVER.
            </term>
            </item>
            <item>
            <term>OS_EMBEDDED</term>
            <term>13</term>
            <term>The program is running on Windows Embedded, any version. Equivalent to VER_SUITE_EMBEDDEDNT.</term>
            </item>
            <item>
            <term>OS_TERMINALCLIENT</term>
            <term>14</term>
            <term>The program is running as a Terminal Server client. Equivalent to GetSystemMetrics(SM_REMOTESESSION).</term>
            </item>
            <item>
            <term>OS_TERMINALREMOTEADMIN</term>
            <term>15</term>
            <term>
            The program is running on Windows 2000 Terminal Server in the Remote Administration mode or Windows Server 2003 (or one of its
            successors) in the Remote Desktop for Administration mode (these are the default installation modes). This is equivalent to
            VER_SUITE_TERMINAL &amp;&amp; VER_SUITE_SINGLEUSERTS.
            </term>
            </item>
            <item>
            <term>OS_WIN95_GOLD</term>
            <term>16</term>
            <term>Always returns FALSE.</term>
            </item>
            <item>
            <term>OS_MEORGREATER</term>
            <term>17</term>
            <term>Always returns FALSE.</term>
            </item>
            <item>
            <term>OS_XPORGREATER</term>
            <term>18</term>
            <term>Always returns FALSE.</term>
            </item>
            <item>
            <term>OS_HOME</term>
            <term>19</term>
            <term>Always returns FALSE.</term>
            </item>
            <item>
            <term>OS_PROFESSIONAL</term>
            <term>20</term>
            <term>
            The program is running on Windows NT Workstation or Windows 2000 (or one of its successors) Professional. Equivalent to
            VER_PLATFORM_WIN32_NT &amp;&amp; VER_NT_WORKSTATION.
            </term>
            </item>
            <item>
            <term>OS_DATACENTER</term>
            <term>21</term>
            <term>
            The program is running on Windows Datacenter Server or Windows Server Datacenter Edition, any version. Equivalent to
            (VER_NT_SERVER || VER_NT_DOMAIN_CONTROLLER) &amp;&amp; VER_SUITE_DATACENTER.
            </term>
            </item>
            <item>
            <term>OS_ADVSERVER</term>
            <term>22</term>
            <term>
            The program is running on Windows Advanced Server or Windows Server Enterprise Edition, any version. Equivalent to (VER_NT_SERVER
            || VER_NT_DOMAIN_CONTROLLER) &amp;&amp; VER_SUITE_ENTERPRISE &amp;&amp; !VER_SUITE_DATACENTER.
            </term>
            </item>
            <item>
            <term>OS_SERVER</term>
            <term>23</term>
            <term>
            The program is running on Windows Server (Standard) or Windows Server Standard Edition, any version. This value will not return
            true for VER_SUITE_DATACENTER, VER_SUITE_ENTERPRISE, VER_SUITE_SMALLBUSINESS, or VER_SUITE_SMALLBUSINESS_RESTRICTED.
            </term>
            </item>
            <item>
            <term>OS_TERMINALSERVER</term>
            <term>24</term>
            <term>
            The program is running on Windows 2000 Terminal Server in Application Server mode, or on Windows Server 2003 (or one of its
            successors) in Terminal Server mode. This is equivalent to VER_SUITE_TERMINAL &amp;&amp; VER_SUITE_SINGLEUSERTS.
            </term>
            </item>
            <item>
            <term>OS_PERSONALTERMINALSERVER</term>
            <term>25</term>
            <term>
            The program is running on Windows XP (or one of its successors), Home Edition or Professional. This is equivalent to
            VER_SUITE_SINGLEUSERTS &amp;&amp; !VER_SUITE_TERMINAL.
            </term>
            </item>
            <item>
            <term>OS_FASTUSERSWITCHING</term>
            <term>26</term>
            <term>Fast user switching is enabled.</term>
            </item>
            <item>
            <term>OS_WELCOMELOGONUI</term>
            <term>27</term>
            <term>Always returns FALSE.</term>
            </item>
            <item>
            <term>OS_DOMAINMEMBER</term>
            <term>28</term>
            <term>The computer is joined to a domain.</term>
            </item>
            <item>
            <term>OS_ANYSERVER</term>
            <term>29</term>
            <term>The program is running on any Windows Server product. Equivalent to VER_NT_SERVER || VER_NT_DOMAIN_CONTROLLER.</term>
            </item>
            <item>
            <term>OS_WOW6432</term>
            <term>30</term>
            <term>The program is a 32-bit program running on 64-bit Windows.</term>
            </item>
            <item>
            <term>OS_WEBSERVER</term>
            <term>31</term>
            <term>Always returns FALSE.</term>
            </item>
            <item>
            <term>OS_SMALLBUSINESSSERVER</term>
            <term>32</term>
            <term>The program is running on Microsoft Small Business Server with restrictive client license in force. Equivalent to VER_SUITE_SMALLBUSINESS_RESTRICTED.</term>
            </item>
            <item>
            <term>OS_TABLETPC</term>
            <term>33</term>
            <term>The program is running on Windows XP Tablet PC Edition, or one of its successors.</term>
            </item>
            <item>
            <term>OS_SERVERADMINUI</term>
            <term>34</term>
            <term>
            The user should be presented with administrator UI. It is possible to have server administrative UI on a non-server machine. This
            value informs the application that an administrator's profile has roamed to a non-server, and UI should be appropriate to an
            administrator. Otherwise, the user is shown a mix of administrator and nonadministrator settings.
            </term>
            </item>
            <item>
            <term>OS_MEDIACENTER</term>
            <term>35</term>
            <term>The program is running on Windows XP Media Center Edition, or one of its successors. Equivalent to GetSystemMetrics(SM_MEDIACENTER).</term>
            </item>
            <item>
            <term>OS_APPLIANCE</term>
            <term>36</term>
            <term>The program is running on Windows Appliance Server.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns a nonzero value if the specified operating system or operating system feature is detected, otherwise <c>FALSE</c>.</para>
            </returns>
            <remarks>
            <para>
            Values are not provided for Windows Vista and Windows 7. To determine whether either of those operating systems are present, use VerifyVersionInfo.
            </para>
            <para>
            In Windows versions earlier than Windows Vista, <c>IsOS</c> was not exported by name or declared in a public header file. To use
            it in those cases, you must use GetProcAddress and request ordinal 437 from Shlwapi.dll to obtain a function pointer. Under
            Windows Vista, <c>IsOS</c> is included in Shlwapi.h and this is not necessary.
            </para>
            <para>
            When referring to server products, "Windows Server" refers only to the Standard Edition server. If all server products are
            covered by a particular flag, it is called out explicitly in the table.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IStream_Copy(System.Runtime.InteropServices.ComTypes.IStream,System.Runtime.InteropServices.ComTypes.IStream,System.UInt32)">
            <summary>
            <para>Copies a stream to another stream.</para>
            </summary>
            <param name="pstmFrom">
            <para>Type: <c>IStream*</c></para>
            <para>A pointer to the source stream.</para>
            </param>
            <param name="pstmTo">
            <para>Type: <c>IStream*</c></para>
            <para>A pointer to the destination stream.</para>
            </param>
            <param name="cb">
            <para>Type: <c>DWORD</c></para>
            <para>The number of bytes to copy from the source stream.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IStream_Read(System.Runtime.InteropServices.ComTypes.IStream,System.IntPtr,System.UInt32)">
            <summary>
            Reads bytes from a specified stream and returns a value that indicates whether all bytes were successfully read.
            </summary>
            <param name="pstm"><para>Type: <c>IStream*</c></para>
            <para>A pointer to the IStream interface of the stream from which to read.</para></param>
            <param name="pv"><para>Type: <c>VOID*</c></para>
            <para>A pointer to a buffer to receive the stream data from pstm. This buffer must be at least cb bytes in size.</para></param>
            <param name="cb"><para>Type: <c>ULONG</c></para>
            <para>The number of bytes of data that the function should attempt to read from the input stream.</para></param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            Returns <c>S_OK</c> if the function successfully reads the specified number of bytes from the stream, or a COM failure code
            otherwise. In particular, if the read attempt was successful but fewer than cb bytes were read, the function returns <c>E_FAIL</c>.
            </para>
            </returns>
            <remarks>
            This function calls the ISequentialStream::Read method to read data from the specified stream into the buffer. If the function
            fails for any reason, the contents of the output buffer and the position of the read pointer in the input stream are undefined.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IStream_Read(System.Runtime.InteropServices.ComTypes.IStream,Vanara.InteropServices.SafeAllocatedMemoryHandle,System.UInt32)">
            <summary>
            Reads bytes from a specified stream and returns a value that indicates whether all bytes were successfully read.
            </summary>
            <param name="pstm"><para>Type: <c>IStream*</c></para>
            <para>A pointer to the IStream interface of the stream from which to read.</para></param>
            <param name="pv"><para>Type: <c>VOID*</c></para>
            <para>A pointer to a buffer to receive the stream data from pstm. This buffer must be at least cb bytes in size.</para></param>
            <param name="cb"><para>Type: <c>ULONG</c></para>
            <para>The number of bytes of data that the function should attempt to read from the input stream.</para></param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            Returns <c>S_OK</c> if the function successfully reads the specified number of bytes from the stream, or a COM failure code
            otherwise. In particular, if the read attempt was successful but fewer than cb bytes were read, the function returns <c>E_FAIL</c>.
            </para>
            </returns>
            <remarks>
            This function calls the ISequentialStream::Read method to read data from the specified stream into the buffer. If the function
            fails for any reason, the contents of the output buffer and the position of the read pointer in the input stream are undefined.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IStream_ReadPidl(System.Runtime.InteropServices.ComTypes.IStream,System.IntPtr@)">
            <summary>
            <para>Reads a pointer to an item identifier list (PIDL) from an IStream object into a PIDLIST_RELATIVE object.</para>
            </summary>
            <param name="pstm">
            <para>Type: <c>IStream*</c></para>
            <para>A pointer to the IStream from which the PIDL is read.</para>
            </param>
            <param name="ppidlOut">
            <para>Type: <c>PIDLIST_RELATIVE*</c></para>
            <para>A pointer to the resulting PIDL.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IStream_ReadStr(System.Runtime.InteropServices.ComTypes.IStream,System.Text.StringBuilder@)">
            <summary>
            <para>Reads from a stream and writes into a string.</para>
            </summary>
            <param name="pstm">
            <para>Type: <c>IStream*</c></para>
            <para>A pointer to the stream from which to read.</para>
            </param>
            <param name="ppsz">
            <para>Type: <c>PWSTR*</c></para>
            <para>A pointer to the null-terminated, Unicode string into which the stream is written.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IStream_Reset(System.Runtime.InteropServices.ComTypes.IStream)">
            <summary>
            <para>Moves the seek position in a specified stream to the beginning of the stream.</para>
            </summary>
            <param name="pstm">
            <para>Type: <c>IStream*</c></para>
            <para>A pointer to the IStream interface of the stream whose position is to be reset.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            Returns <c>S_OK</c> on success or a COM failure code otherwise. See IStream::Seek for further discussion of possible error codes.
            </para>
            </returns>
            <remarks>
            <para>This function calls IStream::Seek to move the stream's seek position to the beginning of the stream.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IStream_Size(System.Runtime.InteropServices.ComTypes.IStream,System.UInt64@)">
            <summary>
            <para>Retrieves the size, in bytes, of a specified stream.</para>
            </summary>
            <param name="pstm">
            <para>Type: <c>IStream*</c></para>
            <para>A pointer to the IStream interface of the stream whose size is to be determined.</para>
            </param>
            <param name="pui">
            <para>Type: <c>ULARGE_INTEGER*</c></para>
            <para>A pointer to a ULARGE_INTEGER structure to receive the size of the stream.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            Returns <c>S_OK</c> on success or a COM failure code otherwise. See IStream::Stat for further discussion of possible error codes.
            </para>
            </returns>
            <remarks>
            <para>
            This function gets the size of the stream by calling the specified stream object's IStream::Stat method. It then copies the value
            of the <c>cbSize</c> member of the STATSTG structure returned by <c>IStream::Stat</c> to the ULARGE_INTEGER structure pointed to
            by pui. If the function fails, the contents of the <c>ULARGE_INTEGER</c> structure are undefined.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IStream_Write(System.Runtime.InteropServices.ComTypes.IStream,System.IntPtr,System.UInt32)">
            <summary>
            <para>Writes data of unknown format from a buffer to a specified stream.</para>
            </summary>
            <param name="pstm">
            <para>Type: <c>IStream*</c></para>
            <para>An IStream pointer that specifies the target stream.</para>
            </param>
            <param name="pv">
            <para>Type: <c>const void*</c></para>
            <para>Pointer to a buffer that holds the data to send to the target stream. This buffer must be at least cb bytes in size.</para>
            </param>
            <param name="cb">
            <para>Type: <c>ULONG</c></para>
            <para>The number of bytes of data to write to the target stream.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            Returns S_OK if the function successfully wrote the specified number of bytes to the stream, or an error value otherwise. In
            particular, if less than cb bytes was written to the target stream, even if some data was successfully written, the function
            returns E_FAIL.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IStream_Write(System.Runtime.InteropServices.ComTypes.IStream,Vanara.InteropServices.SafeAllocatedMemoryHandle,System.UInt32)">
            <summary>
            <para>Writes data of unknown format from a buffer to a specified stream.</para>
            </summary>
            <param name="pstm">
            <para>Type: <c>IStream*</c></para>
            <para>An IStream pointer that specifies the target stream.</para>
            </param>
            <param name="pv">
            <para>Type: <c>const void*</c></para>
            <para>Pointer to a buffer that holds the data to send to the target stream. This buffer must be at least cb bytes in size.</para>
            </param>
            <param name="cb">
            <para>Type: <c>ULONG</c></para>
            <para>The number of bytes of data to write to the target stream.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            Returns S_OK if the function successfully wrote the specified number of bytes to the stream, or an error value otherwise. In
            particular, if less than cb bytes was written to the target stream, even if some data was successfully written, the function
            returns E_FAIL.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IStream_WritePidl(System.Runtime.InteropServices.ComTypes.IStream,System.IntPtr)">
            <summary>
            <para>Writes a pointer to an item identifier list (PIDL) from a PCUIDLIST_RELATIVE object into an IStream object.</para>
            </summary>
            <param name="pstm">
            <para>Type: <c>IStream*</c></para>
            <para>A pointer to the IStream object in which to write.</para>
            </param>
            <param name="pidlWrite">
            <para>Type: <c>PCUIDLIST_RELATIVE</c></para>
            <para>The source PIDL.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IStream_WriteStr(System.Runtime.InteropServices.ComTypes.IStream,System.String)">
            <summary>
            <para>Reads from a string and writes into a stream.</para>
            </summary>
            <param name="pstm">
            <para>Type: <c>IStream*</c></para>
            <para>A pointer to the stream in which to write.</para>
            </param>
            <param name="psz">
            <para>Type: <c>PCWSTR</c></para>
            <para>A pointer to a null-terminated, Unicode string from which to read.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IUnknown_AtomicRelease(System.Object@)">
            <summary>
            <para>Releases a Component Object Model (COM) pointer and sets it to <c>NULL</c>.</para>
            </summary>
            <param name="ppunk">
            <para>Type: <c>void**</c></para>
            <para>The address of a pointer to a COM interface.</para>
            </param>
            <returns>
            <para>This function does not return a value.</para>
            </returns>
            <remarks>
            <para>
            If ppunk points to a <c>NULL</c> pointer, no operation is performed. Otherwise, ppunk is assumed to be the address of a COM
            interface pointer, derived from IUnknown. The function calls the interface's IUnknown::Release method then sets the interface
            pointer to <c>NULL</c>.
            </para>
            <para>Examples</para>
            <para>The following example uses <c>IUnknown_AtomicRelease</c> to release the stream, if it exists. If not, it does nothing.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IUnknown_GetSite(System.Object,System.Guid@,System.Object@)">
            <summary>
            <para>Calls the specified object's IObjectWithSite::GetSite method.</para>
            </summary>
            <param name="punk">
            <para>Type: <c>IUnknown*</c></para>
            <para>A pointer to the COM object whose IObjectWithSite::GetSite method is to be called.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>The IID of the interface pointer that should be returned in ppvSite.</para>
            </param>
            <param name="ppv">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns <c>S_OK</c> if the site was successfully retrieved or a COM error code otherwise.</para>
            </returns>
            <remarks>
            <para>
            This function calls the specified object's QueryInterface method to obtain the IObjectWithSite interface. If successful, the
            function calls the interface's IObjectWithSite::GetSite method to obtain the site.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IUnknown_GetWindow(System.Object,Vanara.PInvoke.HWND@)">
            <summary>
            <para>
            Attempts to retrieve a window handle from a Component Object Model (COM) object by querying for various interfaces that have a
            <c>GetWindow</c> method.
            </para>
            </summary>
            <param name="punk">
            <para>Type: <c>IUnknown*</c></para>
            <para>A pointer to the COM object from which this function will attempt to obtain a window handle.</para>
            </param>
            <param name="phwnd">
            <para>Type: <c>HWND*</c></para>
            <para>
            A pointer to a HWND that, when this function returns successfully, receives the window handle. If a window handle was not
            obtained, this parameter is set to <c>NULL</c>.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            Returns S_OK if a window handle was successfully returned, or a COM error code otherwise. If no suitable interface was found, the
            function returns E_NOINTERFACE. Otherwise, the function returns the <c>HRESULT</c> returned by the corresponding interface's
            <c>GetWindow</c> method.
            </para>
            </returns>
            <remarks>
            <para>
            This function attempts to retrieve the window handle by calling IOleWindow::GetWindow, IInternetSecurityMgrSite::GetWindow, and
            IShellView::GetWindow. It is possible that future versions of <c>IUnknown_GetWindow</c> may attempt additional interfaces.
            </para>
            <para>
            <c>Note</c> The query for IShellView is theoretically unnecessary because <c>IShellView</c> derives from IOleWindow. The function
            explicitly queries for this interface because some objects implement QueryInterface incorrectly and fail to respond to a query
            for the base interface.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IUnknown_QueryService(System.Object,System.Guid@,System.Guid@,System.Object@)">
            <summary>
            <para>Retrieves an interface for a service from a specified object.</para>
            </summary>
            <param name="punk">
            <para>Type: <c>IUnknown*</c></para>
            <para>A pointer to the IUnknown instance of the COM object that supports the service.</para>
            </param>
            <param name="guidService">
            <para>Type: <c>REFGUID</c></para>
            <para>The service's unique identifier (SID).</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>The IID of the desired service interface.</para>
            </param>
            <param name="ppvOut">
            <para>Type: <c>void**</c></para>
            <para>
            When this method returns, contains the interface pointer requested riid. If successful, the calling application is responsible
            for calling IUnknown::Release using this value when the service is no longer needed. In the case of failure, this value is <c>NULL</c>.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            Returns <c>S_OK</c> if successful. Returns <c>E_FAIL</c> if the object does not support IServiceProvider. Otherwise, the function
            returns the <c>HRESULT</c> returned by the object's QueryService method.
            </para>
            </returns>
            <remarks>
            <para>
            If the object passed in the punk parameter supports the IServiceProvider interface, then its QueryService method is invoked,
            passing the guidService, riid, and ppvOut parameters and propagating the return value. Otherwise, the function returns E_FAIL.
            </para>
            <para>
            For those versions of Windows that do not include <c>IUnknown_QueryService</c> in Shlwapi.h, this function must be called
            directly from Shlwapi.dll using ordinal 176.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IUnknown_QueryService``1(System.Object,System.Guid@,System.Nullable{System.Guid}@)">
            <summary>Retrieves an interface for a service from a specified object.</summary>
            <typeparam name="TOut">The type of the desired service interface.</typeparam>
            <param name="punk"><para>Type: <c>IUnknown*</c></para>
            <para>A pointer to the IUnknown instance of the COM object that supports the service.</para></param>
            <param name="guidService"><para>Type: <c>REFGUID</c></para>
            <para>The service's unique identifier (SID).</para></param>
            <param name="riid"><para>Type: <c>Guid?</c></para>
            <para>The IID of the desired service interface. If <see langword="null" />, the Guid of the <typeparamref name="TOut" /> type is used.</para></param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            When this method returns, contains the interface pointer requested riid. If successful, the calling application is responsible
            for calling IUnknown::Release using this value when the service is no longer needed. In the case of failure, this value is <c>NULL</c>.
            </para>
            </returns>
            <remarks>
            <para>
            If the object passed in the punk parameter supports the IServiceProvider interface, then its QueryService method is invoked,
            passing the guidService, riid, and ppvOut parameters and propagating the return value. Otherwise, the function returns E_FAIL.
            </para>
            <para>
            For those versions of Windows that do not include <c>IUnknown_QueryService</c> in Shlwapi.h, this function must be called
            directly from Shlwapi.dll using ordinal 176.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IUnknown_Set(System.Object@,System.Object)">
            <summary>
            <para>Changes the value of a Component Object Model (COM) interface pointer and releases the previous interface.</para>
            </summary>
            <param name="ppunk">
            <para>Type: <c>IUnknown**</c></para>
            <para>
            The address of a COM interface pointer to receive the pointer assigned to punk. If the previous value of the pointer is non-
            <c>NULL</c>, the function releases that interface by calling its IUnkown::Release method.
            </para>
            </param>
            <param name="punk">
            <para>Type: <c>IUnknown*</c></para>
            <para>
            The interface pointer to be copied to ppunk. If the value is non- <c>NULL</c>, the function increments the interface's reference count.
            </para>
            </param>
            <returns>
            <para>This function does not return a value.</para>
            </returns>
            <remarks>
            <para>This function mimics the behavior of a smart pointer. Conceptually, the function does the following:</para>
            <list type="bullet">
            <item>
            <term>Releases the original interface, if ppunk is non- <c>NULL</c></term>
            </item>
            <item>
            <term>Assigns punk to ppunk</term>
            </item>
            <item>
            <term>Calls IUnknown::AddRef on the interface pointed to by punk, if punk is non- <c>NULL</c>.</term>
            </item>
            </list>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IUnknown_SetSite(System.Object,System.Object)">
            <summary>
            <para>Sets the specified object's site by calling its IObjectWithSite::SetSite method.</para>
            </summary>
            <param name="punk">
            <para>Type: <c>IUnknown*</c></para>
            <para>A pointer to the IUnknown interface of the object whose site is to be changed.</para>
            </param>
            <param name="punkSite">
            <para>Type: <c>IUnknown*</c></para>
            <para>A pointer to the IUnknown interface of the new site.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns S_OK if the site was successfully set, or a COM error code otherwise.</para>
            </returns>
            <remarks>
            <para>
            This function calls the specified object's IUnknown::QueryInterface method to obtain a pointer to the object's IObjectWithSite
            interface. If successful, the function calls IObjectWithSite::SetSite to set or change the site.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.MLLoadLibrary(System.String,Vanara.PInvoke.HINSTANCE,System.UInt32)">
            <summary>
            <para>[This function is not available for use as of Windows 7.]</para>
            <para>Maps an appropriate resource DLL into the address space of the calling function, based on the user's default UI language.</para>
            </summary>
            <param name="lpszLibFileName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A <c>null</c>-terminated string with the file name of the resource DLL to be loaded. Do not include any path information.
            <c>MLLoadLibrary</c> derives that information as described in the Remarks below.
            </para>
            </param>
            <param name="hModule">
            <para>Type: <c>HMODULE</c></para>
            <para>
            A handle to an already-loaded DLL that represents the code library for which the multilingual resource library is being requested.
            </para>
            </param>
            <param name="dwCrossCodePage">
            <para>Type: <c>DWORD</c></para>
            <para>Reserved. This parameter must be set to zero.</para>
            </param>
            <returns>
            <para>Type: <c>HINSTANCE</c></para>
            <para>Returns the module's handle if successful, or <c>NULL</c> otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.QISearch(System.IntPtr,Vanara.PInvoke.ShlwApi.QITAB[],System.Guid@,System.Object@)">
            <summary>
            <para>A table-driven implementation of the IUnknown::QueryInterface method.</para>
            </summary>
            <param name="that">
            <para>Type: <c>void*</c></para>
            <para>A pointer to the base of a COM object.</para>
            </param>
            <param name="pqit">
            <para>Type: <c>LPCQITAB</c></para>
            <para>
            An array of QITAB structures. The last structure in the array must have its <c>piid</c> member set to <c>NULL</c> and its
            <c>dwOffset</c> member set to 0.
            </para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>A reference to the IID of the interface to retrieve through ppv.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this method returns successfully, contains the interface pointer requested in riid.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            Returns S_OK if the requested interface was found in the table or if the requested interface was IUnknown. Returns E_NOINTERFACE
            if the requested interface was not found.
            </para>
            </returns>
            <remarks>
            <para>
            <c>Note</c> Prior to Windows Vista, <c>QISearch</c> was not exported by name or declared in a public header file. To use it in
            those cases, you must use GetProcAddress and request ordinal 219 from Shlwapi.dll to obtain a function pointer. Under Windows
            Vista, <c>QISearch</c> is included in Shlwapi.h and this is not necessary.
            </para>
            <para>
            If the requested interface is IUnknown, then <c>QISearch</c> uses the first entry of the specified array of QITAB structures.
            Otherwise, <c>QISearch</c> searches the table until it either finds a matching IID or reaches the end of the table. If a matching
            IID is found, the function advances the associated interface pointer by the number of bytes specified by the <c>dwOffset</c>
            member of the interface's <c>QITAB</c> structure and reinterpreted as a COM pointer. That pointer is assigned to the
            <c>QISearch</c> function's ppv parameter. The method also calls IUnknown::AddRef to increment the interface's reference count.
            </para>
            <para>
            If <c>QISearch</c> reaches the end of the table without finding the interface, it returns E_NOINTERFACE and sets ppv to <c>NULL</c>.
            </para>
            <para>
            It is important to include all applicable interfaces in the table. For example, if the object implements a derived interface, you
            should also include the base interface in the table.
            </para>
            <para>
            We recommend that you use the IID_PPV_ARGS macro, defined in Objbase.h, to package the riid and ppv parameters. This macro
            provides the correct IID based on the interface pointed to by the value in ppv, which eliminates the possibility of a coding
            error in riid that could lead to unexpected results.
            </para>
            <para>
            <c>Note</c> Active Template Library (ATL) provides a significantly better version of a table-driven implementation of QueryInterface.
            </para>
            <para>Examples</para>
            <para>
            The following example illustrates how to use <c>QISearch</c> to implement QueryInterface. It uses the offsetofclass macro from
            ATL to compute the offset from the base of the CSample object to a specified interface.
            </para>
            <para>
            This object supports two interfaces aside from IUnknown, so there are two non- <c>NULL</c> entries in the QITAB table. The entry
            for each interface specifies a pointer to the associated IID (IID_IPersist or IID_IPersistFolder) and the offset of the interface
            pointer relative to the class's base pointer. The sample uses the <c>offsetofclass</c> macro from ATL to determine that offset.
            </para>
            <para>
            <c>Note</c> Forgetting to include all base classes, including indirect ones, is a common error. Notice that there is an entry for
            the IPersist interface. This interface is an indirect base class for CSample, inherited through IPersistFolder.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHAllocShared(System.IntPtr,System.UInt32,System.UInt32)">
            <summary>
            <para>
            [ <c>SHAllocShared</c> is available for use in the operating systems specified in the Requirements section. It may be altered or
            unavailable in subsequent versions.]
            </para>
            <para>Allocates a handle in a specified process to a copy of a specified memory block in the calling process.</para>
            </summary>
            <param name="pvData">
            <para>Type: <c>const void*</c></para>
            <para>
            A pointer to the memory block in the calling process that is to be copied. You can set this parameter to <c>NULL</c> if you want
            to share a block of memory without copying any data to it.
            </para>
            </param>
            <param name="dwSize">
            <para>Type: <c>DWORD</c></para>
            <para>The size, in bytes, of the memory block pointed to by pvData.</para>
            </param>
            <param name="dwProcessId">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>HANDLE</c></para>
            <para>Returns a handle to the shared memory for the process specified by dwDestinationProcessId. Returns <c>NULL</c> if unsuccessful.</para>
            </returns>
            <remarks>
            <para>Use SHFreeShared to free the handle when you are finished.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHAnsiToAnsi(System.String,System.Text.StringBuilder,System.Int32)">
            <summary>
            <para>
            [This function is available through Windows XP and Windows Server 2003. It might be altered or unavailable in subsequent versions
            of Windows.]
            </para>
            <para>Copies an ANSI string.</para>
            </summary>
            <param name="pszSrc">
            <para>Type: <c>LPCSTR</c></para>
            <para>A pointer to a null-terminated ANSI string to be converted to Unicode.</para>
            </param>
            <param name="pszDst">
            <para>Type: <c>LPWSTR</c></para>
            <para>
            A pointer to a buffer that, when this function returns successfully, receives the characters copied from pszSrc. The buffer must
            be large enough to contain the number of characters specified by the cchBuf parameter, including a room for a terminating null character.
            </para>
            </param>
            <param name="cchBuf">
            <para>Type: <c>int</c></para>
            <para>
            The number of characters that can be contained by the buffer pointed to by pszDst. This parameter must be greater than zero.
            </para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>Returns the number of characters written to pszDst, including the terminating null character. Returns 0 if unsuccessful.</para>
            </returns>
            <remarks>
            <para>
            <c>Security Warning:</c> Using this function incorrectly can compromise the security of your application. For example, if pszDst
            buffer is not large enough to contain the number of characters specified by cchBuf, a buffer overrun can occur. Buffer overruns
            can cause a denial of service attack against an application if an access violation occurs. In the worst case, a buffer overrun
            might allow an attacker to inject executable code into your process, especially if pszDst is a stack-based buffer. Note that the
            output string is silently truncated if the buffer is not large enough. This can result in canonicalization or other security vulnerabilities.
            </para>
            <para>
            If the pszDst buffer is not large enough to contain the entire converted output string, the string is truncated to fit the
            buffer. There is no way to detect that the return string has been truncated. The string will always be null-terminated, even if
            it has been truncated. This function takes care to not truncate between the lead and trail bytes of a DBCS character pair. In
            that case, only cchBuf-1 characters are returned.
            </para>
            <para>If the pszSrc and pszDst buffers overlap, the function's behavior is undefined.</para>
            <para>
            <c>Note</c> Do not assume that the function has not changed any of the characters in the output buffer that follow the string's
            terminating null character. The contents of the output buffer following the string's terminating null character are undefined, up
            to and including the last character in the buffer.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHAnsiToUnicode(System.String,System.Text.StringBuilder,System.Int32)">
            <summary>
            <para>
            [This function is available through Windows XP and Windows Server 2003. It might be altered or unavailable in subsequent versions
            of Windows.]
            </para>
            <para>Converts a string from the ANSI code page to the Unicode code page.</para>
            </summary>
            <param name="pszSrc">
            <para>Type: <c>PCSTR</c></para>
            <para>A pointer to a null-terminated ANSI string to be converted to Unicode.</para>
            </param>
            <param name="pwszDst">
            <para>Type: <c>PWSTR</c></para>
            <para>
            A pointer to a buffer that, when this function returns successfully, receives the string specified by pszSrc, after the ANSI
            characters have been converted to Unicode (WCHAR). The buffer must be large enough to contain the number of Unicode characters
            specified by the cwchBuf parameter, including a terminating null character.
            </para>
            </param>
            <param name="cwchBuf">
            <para>Type: <c>int</c></para>
            <para>
            The number of Unicode characters that can be contained by the buffer pointed to by pwszDst. This parameter must be greater than zero.
            </para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>Returns the number of Unicode characters written to pwszDst, including the terminating null character. Returns 0 if unsuccessful.</para>
            </returns>
            <remarks>
            <para>
            <c>Security Warning:</c> Using this function incorrectly can compromise the security of your application. For example, if pwszDst
            buffer is not large enough to contain the number of characters specified by cwchBuf, a buffer overrun can occur. Buffer overruns
            can cause a denial of service attack against an application if an access violation occurs. In the worst case, a buffer overrun
            might allow an attacker to inject executable code into your process, especially if pwszDst is a stack-based buffer. When copying
            an entire string, note that sizeof returns the number of bytes, which is not the correct value to use for the cwchBuf parameter.
            Instead, use sizeof(pwszDst)/sizeof(WCHAR). Note that this technique assumes that pwszDst is an array, not a pointer.
            </para>
            <para>
            If the pwszDst buffer is not large enough to contain the entire converted output string, the string is truncated to fit the
            buffer. There is no way to detect that the return string has been truncated. The string is always null-terminated, even if it has
            been truncated. This ensures that no more than cwchBuf characters are copied to pwszDst. No attempt is made to avoid truncating
            the string in the middle of a Unicode surrogate pair.
            </para>
            <para>If the pszSrc and pwszDst buffers overlap, the function's behavior is undefined.</para>
            <para>
            <c>Note</c> Do not assume that the function has not changed any of the characters in the output buffer that follow the string's
            terminating null character. The contents of the output buffer following the string's terminating null character are undefined, up
            to and including the last character in the buffer.
            </para>
            <para><c>SHAnsiToTChar</c> is defined to be the same as <c>SHAnsiToUnicode</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHAutoComplete(Vanara.PInvoke.HWND,Vanara.PInvoke.ShlwApi.SHACF)">
            <summary>
            <para>Instructs system edit controls to use AutoComplete to help complete URLs or file system paths.</para>
            </summary>
            <param name="hwndEdit">
            <para>Type: <c>HWND</c></para>
            <para>
            The window handle of a system edit control. Typically, this parameter is the handle of an edit control or the edit control
            embedded in a ComboBoxEx control.
            </para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>
            The flags to control the operation of <c>SHAutoComplete</c>. The first four flags are used to override the Internet Explorer
            registry settings. The user can change these settings manually by launching the <c>Internet Options</c> property sheet from the
            <c>Tools</c> menu and clicking the <c>Advanced</c> tab.
            </para>
            <para>SHACF_AUTOAPPEND_FORCE_OFF (0x80000000)</para>
            <para>
            Ignore the registry default and force the AutoAppend feature off. This flag must be used in combination with one or more of the
            SHACF_FILESYS* or SHACF_URL* flags.
            </para>
            <para>SHACF_AUTOAPPEND_FORCE_ON (0x40000000)</para>
            <para>
            Ignore the registry value and force the AutoAppend feature on. The completed string will be displayed in the edit box with the
            added characters highlighted. This flag must be used in combination with one or more of the SHACF_FILESYS* or SHACF_URL* flags.
            </para>
            <para>SHACF_AUTOSUGGEST_FORCE_OFF (0x20000000)</para>
            <para>
            Ignore the registry default and force the AutoSuggest feature off. This flag must be used in combination with one or more of the
            SHACF_FILESYS* or SHACF_URL* flags.
            </para>
            <para>SHACF_AUTOSUGGEST_FORCE_ON (0x10000000)</para>
            <para>
            Ignore the registry value and force the AutoSuggest feature on. A selection of possible completed strings will be displayed as a
            drop-down list, below the edit box. This flag must be used in combination with one or more of the SHACF_FILESYS* or SHACF_URL* flags.
            </para>
            <para>SHACF_DEFAULT (0x00000000)</para>
            <para>
            The default setting, equivalent to <c>SHACF_FILESYSTEM</c> | <c>SHACF_URLALL</c>. <c>SHACF_DEFAULT</c> cannot be combined with
            any other flags.
            </para>
            <para>SHACF_FILESYS_ONLY (0x00000010)</para>
            <para>Include the file system only.</para>
            <para>SHACF_FILESYS_DIRS (0x00000020)</para>
            <para>Include the file system and directories, UNC servers, and UNC server shares.</para>
            <para>SHACF_FILESYSTEM (0x00000001)</para>
            <para>Include the file system and the rest of the Shell (Desktop, Computer, and Control Panel, for example).</para>
            <para>SHACF_URLALL (SHACF_URLHISTORY | SHACF_URLMRU)</para>
            <para>Include the URLs in the users <c>History</c> and <c>Recently Used</c> lists. Equivalent to <c>SHACF_URLHISTORY</c> | <c>SHACF_URLMRU</c>.</para>
            <para>SHACF_URLHISTORY (0x00000002)</para>
            <para>Include the URLs in the user's <c>History</c> list.</para>
            <para>SHACF_URLMRU (0x00000004)</para>
            <para>Include the URLs in the user's <c>Recently Used</c> list.</para>
            <para>SHACF_USETAB (0x00000008)</para>
            <para>
            Allow the user to select from the autosuggest list by pressing the TAB key. If this flag is not set, pressing the TAB key will
            shift focus to the next control and close the autosuggest list. If <c>SHACF_USETAB</c> is set, pressing the TAB key will select
            the first item in the list. Pressing TAB again will select the next item in the list, and so on. When the user reaches the end of
            the list, the next TAB key press will cycle the focus back to the edit control. This flag must be used in combination with one or
            more of the SHACF_FILESYS* or SHACF_URL* flags listed on this page.
            </para>
            <para>SHACF_VIRTUAL_NAMESPACE (0x00000040)</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            <c>SHAutoComplete</c> works on any system edit control, including the edit control and controls that contain edit controls such
            as ComboBoxEx controls. To retrieve a handle to an edit control embedded in a ComboBoxEx control, send the ComboBoxEx control a
            CBEM_GETEDITCONTROL message.
            </para>
            <para>
            An application must have invoked either CoInitialize or OleInitialize prior to calling this function. CoUninitialize or
            OleUninitialize cannot be called until the edit box has finished processing the WM_DESTROY message for hwndEdit.
            </para>
            <para>The maximum number of items that can be displayed in an autosuggest drop-down list box is 1000.</para>
            <para>
            On versions of Windows prior to Windows Vista and server versions prior to Windows Server 2008, <c>SHAutoComplete</c> should not
            be called more than once with the same <c>HWND</c>. Doing so results in a memory leak. It prevents the original resources from
            being released, including the previous instance of the AutoComplete object, enumerator objects that the previous AutoComplete
            object has referenced, and Windows Graphics Device Interface (GDI) resources. Rather than call <c>SHAutoComplete</c> again with a
            different set of flags to change the AutoComplete list, call CoCreateInstance with CLSID_AutoComplete to obtain the AutoComplete
            object. Then pass the <c>HWND</c> to the object to initialize it and provide your own custom enumerator. You can use
            CLSID_ACLMulti if you want AutoComplete to use multiple lists.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHCopyKey(Vanara.PInvoke.HKEY,System.String,Vanara.PInvoke.HKEY,System.UInt32)">
            <summary>
            <para>
            Recursively copies the subkeys and values of the source subkey to the destination key. <c>SHCopyKey</c> does not copy the
            security attributes of the keys.
            </para>
            </summary>
            <param name="hkeySrc">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to the source key (for example, <c>HKEY_CURRENT_USER</c>).</para>
            </param>
            <param name="pszSrcSubKey">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The subkey whose subkeys and values are to be copied.</para>
            </param>
            <param name="hkeyDest">
            <para>Type: <c>HKEY</c></para>
            <para>The destination key.</para>
            </param>
            <param name="fReserved">
            <para>Type: <c>DWORD</c></para>
            <para>Reserved. Must be 0.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or one of the nonzero error codes defined in Winerror.h otherwise. Use FormatMessage with
            the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
            <remarks>
            <para>
            <c>Important</c> This function does not duplicate the security attributes of the keys and values that it copies. Rather, all
            security attributes in the destination key are the default attributes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHCreateMemStream(System.IntPtr,System.UInt32)">
            <summary>
            <para>Creates a memory stream using a similar process to CreateStreamOnHGlobal.</para>
            </summary>
            <param name="pInit">
            <para>Type: <c>const BYTE*</c></para>
            <para>
            A pointer to a buffer of size cbInit. The contents of this buffer are used to set the initial contents of the memory stream. If
            this parameter is <c>NULL</c>, the returned memory stream does not have any initial content.
            </para>
            </param>
            <param name="cbInit">
            <para>Type: <c>UINT</c></para>
            <para>The number of bytes in the buffer pointed to by pInit. If pInit is set to <c>NULL</c>, cbInit must be zero.</para>
            </param>
            <returns>
            <para>Type: <c>IStream*</c></para>
            <para>On success, returns a pointer to the created memory stream. Returns <c>NULL</c> if the stream object could not be allocated.</para>
            </returns>
            <remarks>
            <para>
            Prior to Windows Vista, this function was not included in the public Shlwapi.h file, nor was it exported by name from
            Shlwapi.dll. To use it on earlier systems, you must call it directly from the Shlwapi.dll file as ordinal 12.
            </para>
            <para>
            This function creates a memory stream. This is an implementation of the IStream interface that stores its contents in memory.
            <c>SHCreateMemStream</c> differs from CreateStreamOnHGlobal in the following ways.
            </para>
            <list type="bullet">
            <item>
            <term>
            Thread safety. The stream created by <c>SHCreateMemStream</c> is thread-safe as of Windows 8. On earlier systems, the stream is
            not thread-safe. The stream created by CreateStreamOnHGlobal is thread-safe.
            </term>
            </item>
            <item>
            <term>
            Initial contents. <c>SHCreateMemStream</c> accepts the initial contents in the form of a buffer. CreateStreamOnHGlobal accepts
            the initial contents in the form of an HGLOBAL.
            </term>
            </item>
            <item>
            <term>
            Access to contents. <c>SHCreateMemStream</c> does not allow direct access to the stream contents. CreateStreamOnHGlobal permits
            access through GetHGlobalFromStream.
            </term>
            </item>
            <item>
            <term>
            Failure information. If <c>SHCreateMemStream</c> returns <c>NULL</c>, it was unable to allocate the neccessary memory. Callers
            should assume the cause is E_OUTOFMEMORY.
            </term>
            </item>
            <item>
            <term>
            Support for IStream::Clone. Prior to Windows 8, the stream created by <c>SHCreateMemStream</c> does not support
            <c>IStream::Clone</c>. The stream created by CreateStreamOnHGlobal does. As of Windows 8, the stream created by
            <c>SHCreateMemStream</c> does support <c>IStream::Clone</c>.
            </term>
            </item>
            <item>
            <term>
            The stream returned by <c>SHCreateMemStream</c> returns S_FALSE from IStream::Read if you attempt to read past the end of the
            buffer. The stream returned by CreateStreamOnHGlobal returns S_OK and sets *pcbRead to 0 if you attempt to read past the end of
            the buffer.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHCreateShellPalette(Vanara.PInvoke.HDC)">
            <summary>
            <para>Creates a halftone palette for the specified device context.</para>
            </summary>
            <param name="hdc">
            <para>Type: <c>HDC</c></para>
            <para>The device context.</para>
            </param>
            <returns>
            <para>Type: <c>HPALETTE</c></para>
            <para>Returns the palette if successful; otherwise 0.</para>
            </returns>
            <remarks>
            <para>
            This function behaves the same as CreateHalftonePalette. The palette that is returned depends on the device context in the
            following way:
            </para>
            <list type="bullet">
            <item>
            <term>If hdc is set to <c>NULL</c>, a full palette is returned.</term>
            </item>
            <item>
            <term>If the device context is indexed, a full palette is returned.</term>
            </item>
            <item>
            <term>If the device context is not indexed, a default palette (VGA colors) is returned.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHCreateStreamOnFile(System.String,Vanara.PInvoke.STGM,System.Runtime.InteropServices.ComTypes.IStream@)">
            <summary>
            <para>
            [ <c>SHCreateStreamOnFile</c> is available for use in the operating systems specified in the Requirements section. It may be
            altered or unavailable in subsequent versions. Instead, use SHCreateStreamOnFileEx.]
            </para>
            <para>Opens or creates a file and retrieves a stream to read or write to that file.</para>
            </summary>
            <param name="pszFile">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string that specifies the file name.</para>
            </param>
            <param name="grfMode">
            <para>Type: <c>DWORD</c></para>
            <para>
            One or more STGM values that are used to specify the file access mode and how the object that exposes the stream is created and deleted.
            </para>
            </param>
            <param name="ppstm">
            <para>Type: <c>IStream**</c></para>
            <para>Receives an IStream interface pointer for the stream associated with the file.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            SHCreateStreamOnFileEx fully supports all STGM modes and allows the caller to specify file attributes if creating a new file.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHCreateStreamOnFileEx(System.String,Vanara.PInvoke.STGM,Vanara.PInvoke.FileFlagsAndAttributes,System.Boolean,System.Runtime.InteropServices.ComTypes.IStream,System.Runtime.InteropServices.ComTypes.IStream@)">
            <summary>
            <para>Opens or creates a file and retrieves a stream to read or write to that file.</para>
            </summary>
            <param name="pszFile">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A pointer to a null-terminated string that specifies the file name.</para>
            </param>
            <param name="grfMode">
            <para>Type: <c>DWORD</c></para>
            <para>
            One or more STGM values that are used to specify the file access mode and how the object that exposes the stream is created and deleted.
            </para>
            </param>
            <param name="dwAttributes">
            <para>Type: <c>DWORD</c></para>
            <para>
            One or more flag values that specify file attributes in the case that a new file is created. For a complete list of possible
            values, see the dwFlagsAndAttributes parameter of the CreateFile function.
            </para>
            </param>
            <param name="fCreate">
            <para>Type: <c>BOOL</c></para>
            <para>
            A <c>BOOL</c> value that helps specify, in conjunction with grfMode, how existing files should be treated when creating the
            stream. See Remarks for details.
            </para>
            </param>
            <param name="pstmTemplate">
            <para>Type: <c>IStream*</c></para>
            <para>Reserved.</para>
            </param>
            <param name="ppstm">
            <para>Type: <c>IStream**</c></para>
            <para>Receives an IStream interface pointer for the stream associated with the file.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The <c>SHCreateStreamOnFileEx</c> function extends the semantics of the STGM flags and produces the same effect as calling the
            CreateFile function.
            </para>
            <para>The grfMode and fCreate parameters work together to specify how the function should behave with respect to existing files.</para>
            <list type="table">
            <listheader>
            <term>grfMode</term>
            <term>fCreate</term>
            <term>File exists?</term>
            <term>Behavior</term>
            </listheader>
            <item>
            <term>STGM_CREATE</term>
            <term>Ignored</term>
            <term>Yes</term>
            <term>The file is recreated.</term>
            </item>
            <item>
            <term>STGM_CREATE</term>
            <term>Ignored</term>
            <term>No</term>
            <term>The file is created.</term>
            </item>
            <item>
            <term>STGM_FAILIFTHERE</term>
            <term>FALSE</term>
            <term>Yes</term>
            <term>The file is opened.</term>
            </item>
            <item>
            <term>STGM_FAILIFTHERE</term>
            <term>FALSE</term>
            <term>No</term>
            <term>The call fails.</term>
            </item>
            <item>
            <term>STGM_FAILIFTHERE</term>
            <term>TRUE</term>
            <term>Yes</term>
            <term>The call fails.</term>
            </item>
            <item>
            <term>STGM_FAILIFTHERE</term>
            <term>TRUE</term>
            <term>No</term>
            <term>The file is created.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHCreateThread(Vanara.PInvoke.Kernel32.ThreadProc,System.IntPtr,Vanara.PInvoke.ShlwApi.SHCT_FLAGS,Vanara.PInvoke.Kernel32.ThreadProc)">
            <summary>
            <para>Creates a thread.</para>
            </summary>
            <param name="pfnThreadProc">
            <para>Type: <c>LPTHREAD_START_ROUTINE</c></para>
            <para>
            A pointer to an application-defined function of the LPTHREAD_START_ROUTINE type. If a new thread was successfully created, this
            application-defined function is called in the context of that thread. <c>SHCreateThread</c> does not wait for the function
            pointed to by this parameter to complete before returning to its caller. The application-defined function's return value is the
            exit code of the thread.
            </para>
            </param>
            <param name="pData">
            <para>Type: <c>void*</c></para>
            <para>
            A pointer to an optional application-defined data structure that contains initialization data. It is passed to the function
            pointed to by pfnThreadProc and, optionally, pfnCallback. This value can be <c>NULL</c>.
            </para>
            </param>
            <param name="flags">
            <para>TBD</para>
            </param>
            <param name="pfnCallback">
            <para>Type: <c>LPTHREAD_START_ROUTINE</c></para>
            <para>
            A pointer to an optional application-defined function of the LPTHREAD_START_ROUTINE type. This function is called in the context
            of the created thread before the function pointed to by pfnThreadProc is called. It will also receive pData as its argument.
            <c>SHCreateThread</c> will wait for the function pointed to by pfnCallback to return before returning to its caller. The return
            value of the function pointed to by pfnCallback is ignored.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            Returns <c>TRUE</c> if the thread is successfully created, or <c>FALSE</c> otherwise. On failure, use GetLastError to retrieve
            the specific error value as shown here.
            </para>
            </returns>
            <remarks>
            <para>The function pointed to by pfnThreadProc and pfnCallback must take the following form.</para>
            <para>
            The function name is arbitrary. The pData parameter points to an application-defined data structure with initialization information.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHCreateThreadRef(System.Int32@,System.Object@)">
            <summary>
            <para>Creates a per-thread reference to a Component Object Model (COM) object.</para>
            </summary>
            <param name="pcRef">
            <para>Type: <c>LONG*</c></para>
            <para>
            A pointer to a value, usually a local variable in the thread's ThreadProc, that is used by the interface in ppunk as a reference counter.
            </para>
            </param>
            <param name="ppunk">
            <para>Type: <c>IUnknown**</c></para>
            <para>
            The address of a pointer to an IUnknown interface. If successful, this parameter holds the thread's <c>IUnknown</c> pointer on
            return. Your application is responsible for freeing the pointer when it is finished.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>See Managing Thread References for more details on using the Shlwapi thread APIs.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHCreateThreadWithHandle(Vanara.PInvoke.Kernel32.ThreadProc,System.IntPtr,Vanara.PInvoke.ShlwApi.SHCT_FLAGS,Vanara.PInvoke.Kernel32.ThreadProc,Vanara.PInvoke.Kernel32.SafeHFILE@)">
            <summary>
            <para>Creates a new thread and retrieves its handle.</para>
            </summary>
            <param name="pfnThreadProc">
            <para>Type: <c>LPTHREAD_START_ROUTINE</c></para>
            <para>
            A pointer to an application-defined function of type LPTHREAD_START_ROUTINE. If a new thread was successfully created, this
            application-defined function is called in the context of that thread. <c>SHCreateThreadWithHandle</c> does not wait for the
            function pointed to by pfnThreadProc to complete before returning to its caller. The return value for the function specified by
            pfnThreadProc is the exit code of the thread.
            </para>
            </param>
            <param name="pData">
            <para>Type: <c>void*</c></para>
            <para>
            A pointer to an optional application-defined data structure that contains initialization data. It is passed to the function
            pointed to by pfnThreadProc and, optionally, the function pointed to by pfnCallback.
            </para>
            </param>
            <param name="flags">
            <para>Type: <c>SHCT_FLAGS</c></para>
            <para>Flags that control the behavior of the function; one or more of the CTF constants.</para>
            </param>
            <param name="pfnCallback">
            <para>Type: <c>LPTHREAD_START_ROUTINE</c></para>
            <para>
            A pointer to an optional application-defined function of type LPTHREAD_START_ROUTINE. This function is called in the context of
            the created thread before the function pointed to by pfnThreadProc is called. It will also receive pData as its argument.
            <c>SHCreateThreadWithHandle</c> waits for the function pointed to by pfnCallback to complete before returning to its caller. The
            return value for the function specified by pfnCallback is ignored.
            </para>
            </param>
            <param name="pHandle">
            <para>Type: <c>HANDLE*</c></para>
            <para>
            A pointer to the <c>HANDLE</c> of the created thread. When it is no longer needed, this handle should be closed by calling the
            CloseHandle function. This value can be <c>NULL</c>.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para><c>TRUE</c> if the thread is successfully created; otherwise, <c>FALSE</c></para>
            </returns>
            <remarks>
            <para>
            Prior to Windows 7, this function did not have an associated header or library file. To use this function under those earlier
            operating systems, call LoadLibrary with the DLL name (Shlwapi.dll) to obtain a module handle. Then call GetProcAddress with that
            module handle and a function ordinal of 615 to get the address of this function.
            </para>
            <para>The function pointed to by pfnThreadProc and pfnCallback must take the following form.</para>
            <para>
            The function name is arbitrary. The pData parameter points to an application-defined data structure with initialization information.
            </para>
            <para>Examples</para>
            <para>
            The following code example provides a function pointer prototype typedef for calling <c>SHCreateThreadWithHandle</c> by ordinal
            and shows how to accomplish such a call.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHDeleteEmptyKey(Vanara.PInvoke.HKEY,System.String)">
            <summary>
            <para>Deletes an empty key.</para>
            </summary>
            <param name="hkey">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to an open registry key, or one of the following predefined keys:</para>
            <para>HKEY_CLASSES_ROOT</para>
            <para>HKEY_CURRENT_CONFIG</para>
            <para>HKEY_CURRENT_USER</para>
            <para>HKEY_LOCAL_MACHINE</para>
            <para>HKEY_PERFORMANCE_DATA</para>
            <para>HKEY_USERS</para>
            </param>
            <param name="pszSubKey">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The address of a null-terminated string specifying the name of the key to delete.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns <c>ERROR_SUCCESS</c> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the
            FormatMessage function with the <c>FORMAT_MESSAGE_FROM_SYSTEM</c> flag to retrieve a generic description of the error.
            </para>
            </returns>
            <remarks>
            <para><c>SHDeleteEmptyKey</c> does not delete a key if it contains any subkeys or values. Use SHDeleteKey instead.</para>
            <para>Alternatively, use the RegDeleteKey or RegDeleteTree function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHDeleteKey(Vanara.PInvoke.HKEY,System.String)">
            <summary>
            <para>Deletes a subkey and all its descendants. This function removes the key and all the key's values from the registry.</para>
            </summary>
            <param name="hkey">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to an open registry key, or one of the following predefined keys:</para>
            <para>HKEY_CLASSES_ROOT</para>
            <para>HKEY_CURRENT_CONFIG</para>
            <para>HKEY_CURRENT_USER</para>
            <para>HKEY_LOCAL_MACHINE</para>
            <para>HKEY_PERFORMANCE_DATA</para>
            <para>HKEY_USERS</para>
            </param>
            <param name="pszSubKey">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The address of a null-terminated string specifying the name of the key to delete.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns <c>ERROR_SUCCESS</c> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the
            FormatMessage function with the <c>FORMAT_MESSAGE_FROM_SYSTEM</c> flag to retrieve a generic description of the error.
            </para>
            </returns>
            <remarks>
            <para>Alternatively, use the RegDeleteKey or RegDeleteTree function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHDeleteValue(Vanara.PInvoke.HKEY,System.String,System.String)">
            <summary>
            <para>Deletes a named value from the specified registry key.</para>
            </summary>
            <param name="hkey">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to the currently open key, or any of the following predefined values.</para>
            <para>HKEY_CLASSES_ROOT</para>
            <para>HKEY_CURRENT_CONFIG</para>
            <para>HKEY_CURRENT_USER</para>
            <para>HKEY_LOCAL_MACHINE</para>
            <para>HKEY_PERFORMANCE_DATA</para>
            <para>HKEY_USERS</para>
            </param>
            <param name="pszSubKey">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The address of a null-terminated string specifying the name of the subkey for which to change the value.</para>
            </param>
            <param name="pszValue">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The address of the value to be deleted.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHEnumKeyEx(Vanara.PInvoke.HKEY,System.UInt32,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            <para>Enumerates the subkeys of the specified open registry key.</para>
            </summary>
            <param name="hkey">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to the currently open key, or any of the following predefined values.</para>
            <para>HKEY_CLASSES_ROOT</para>
            <para>HKEY_CURRENT_CONFIG</para>
            <para>HKEY_CURRENT_USER</para>
            <para>HKEY_LOCAL_MACHINE</para>
            <para>HKEY_PERFORMANCE_DATA</para>
            <para>HKEY_USERS</para>
            </param>
            <param name="dwIndex">
            <para>Type: <c>DWORD</c></para>
            <para>The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
            </param>
            <param name="pszName">
            <para>Type: <c>LPTSTR</c></para>
            <para>The address of a character buffer that receives the enumerated key name.</para>
            </param>
            <param name="pcchName">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            The address of a <c>DWORD</c> that, on entry, contains the size of the buffer at pszName, in characters. On exit, this contains
            the number of characters that were copied to pszName.
            </para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHEnumValue(Vanara.PInvoke.HKEY,System.UInt32,System.Text.StringBuilder,System.UInt32@,Vanara.PInvoke.REG_VALUE_TYPE@,System.IntPtr,System.UInt32@)">
            <summary>
            <para>Enumerates the values of the specified open registry key.</para>
            </summary>
            <param name="hkey">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to the currently open key, or any of the following predefined values.</para>
            <para>HKEY_CLASSES_ROOT</para>
            <para>HKEY_CURRENT_CONFIG</para>
            <para>HKEY_CURRENT_USER</para>
            <para>HKEY_LOCAL_MACHINE</para>
            <para>HKEY_PERFORMANCE_DATA</para>
            <para>HKEY_USERS</para>
            </param>
            <param name="dwIndex">
            <para>Type: <c>DWORD</c></para>
            <para>The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
            </param>
            <param name="pszValueName">
            <para>Type: <c>LPTSTR</c></para>
            <para>The address of a character buffer that receives the enumerated value name. The size of this buffer is specified in pcchValueName.</para>
            </param>
            <param name="pcchValueName">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            The address of a <c>DWORD</c> that, on entry, contains the size of the buffer at pszValueName, in characters. On exit, this
            contains the number of characters that were copied to pszValueName.
            </para>
            </param>
            <param name="pdwType">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            The address of a <c>DWORD</c> that receives the data type of the value. These are the same values as those described under the
            lpType parameter of RegEnumValue.
            </para>
            </param>
            <param name="pvData">
            <para>Type: <c>LPVOID</c></para>
            <para>
            The address of a buffer that receives the data for the value entry. The size of this buffer is specified in pcbData. This
            parameter can be <c>NULL</c> if the data is not required.
            </para>
            </param>
            <param name="pcbData">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            The address of a <c>DWORD</c> that, on entry, contains the size of the buffer at pvData, in bytes. On exit, this contains the
            number of bytes that were copied to pvData.
            </para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHEnumValue(Vanara.PInvoke.HKEY,System.UInt32,System.Text.StringBuilder,System.UInt32@,Vanara.PInvoke.REG_VALUE_TYPE@,Vanara.InteropServices.SafeAllocatedMemoryHandle,System.UInt32@)">
            <summary>
            <para>Enumerates the values of the specified open registry key.</para>
            </summary>
            <param name="hkey">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to the currently open key, or any of the following predefined values.</para>
            <para>HKEY_CLASSES_ROOT</para>
            <para>HKEY_CURRENT_CONFIG</para>
            <para>HKEY_CURRENT_USER</para>
            <para>HKEY_LOCAL_MACHINE</para>
            <para>HKEY_PERFORMANCE_DATA</para>
            <para>HKEY_USERS</para>
            </param>
            <param name="dwIndex">
            <para>Type: <c>DWORD</c></para>
            <para>The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
            </param>
            <param name="pszValueName">
            <para>Type: <c>LPTSTR</c></para>
            <para>The address of a character buffer that receives the enumerated value name. The size of this buffer is specified in pcchValueName.</para>
            </param>
            <param name="pcchValueName">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            The address of a <c>DWORD</c> that, on entry, contains the size of the buffer at pszValueName, in characters. On exit, this
            contains the number of characters that were copied to pszValueName.
            </para>
            </param>
            <param name="pdwType">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            The address of a <c>DWORD</c> that receives the data type of the value. These are the same values as those described under the
            lpType parameter of RegEnumValue.
            </para>
            </param>
            <param name="pvData">
            <para>Type: <c>LPVOID</c></para>
            <para>
            The address of a buffer that receives the data for the value entry. The size of this buffer is specified in pcbData. This
            parameter can be <c>NULL</c> if the data is not required.
            </para>
            </param>
            <param name="pcbData">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            The address of a <c>DWORD</c> that, on entry, contains the size of the buffer at pvData, in bytes. On exit, this contains the
            number of bytes that were copied to pvData.
            </para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHFormatDateTime(System.Runtime.InteropServices.ComTypes.FILETIME@,Vanara.PInvoke.ShlwApi.FDTF@,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>
            [ <c>SHFormatDateTime</c> is available for use in the operating systems specified in the Requirements section. It may be altered
            or unavailable in subsequent versions.]
            </para>
            <para>Produces a string representation of a time specified as a FILETIME structure.</para>
            </summary>
            <param name="pft">
            <para>Type: <c>const FILETIME UNALIGNED*</c></para>
            <para>A pointer to the FILETIME structure whose time is to be converted to a string.</para>
            </param>
            <param name="pdwFlags">
            <para>Type: <c>DWORD*</c></para>
            <para>A pointer to a <c>DWORD</c> value that contains bitwise flags that specify the date and time format.</para>
            <para>
            When you call the function, you can combine zero or more of the following flags, with exceptions as noted. You can also set this
            parameter to <c>NULL</c>, in which case the function assumes that the FDTF_DEFAULT flag is set.
            </para>
            <para>FDTF_SHORTTIME (0x00000001)</para>
            <para>
            0x00000001. Formats the time of day as specified by the <c>Regional and Language Options</c> application in Control Panel, but
            without seconds. This flag cannot be combined with FDTF_LONGTIME.
            </para>
            <para>The short time was successfully formatted.</para>
            <para>FDTF_SHORTDATE (0x00000002)</para>
            <para>
            0x00000002. Formats the date as specified by the short date format in the <c>Regional and Language Options</c> application in
            Control Panel. This flag cannot be combined with FDTF_LONGDATE.
            </para>
            <para>The short date was successfully formatted.</para>
            <para>FDTF_DEFAULT</para>
            <para>Equivalent to FDTF_SHORTDATE | FDTF_SHORTTIME.</para>
            <para>FDTF_LONGDATE (0x00000004)</para>
            <para>
            0x00000004. Formats the date as specified by the long date format in the <c>Regional and Language Options</c> application in
            Control Panel. This flag cannot be combined with FDTF_SHORTDATE.
            </para>
            <para>The long date was successfully formatted.</para>
            <para>FDTF_LONGTIME (0x00000008)</para>
            <para>
            0x00000008. Formats the time of day as specified by the <c>Regional and Language Options</c> application in Control Panel,
            including seconds. This flag cannot be combined with FDTF_SHORTTIME.
            </para>
            <para>The long time was successfully formatted.</para>
            <para>FDTF_RELATIVE (0x00000010)</para>
            <para>
            0x00000010. If the FDTF_LONGDATE flag is set and the date in the FILETIME structure is the same date that <c>SHFormatDateTime</c>
            is called, then the day of the week (if present) is changed to "Today". If the date in the structure is the previous day, then
            the day of the week (if present) is changed to "Yesterday".
            </para>
            <para>Relative notation was used for the date.</para>
            <para>FDTF_LTRDATE (0x00000100)</para>
            <para>0x00000100. Adds marks for left-to-right reading layout. This flag cannot be combined with FDTF_RTLDATE.</para>
            <para>FDTF_RTLDATE (0x00000200)</para>
            <para>0x00000200. Adds marks for right-to-left reading layout. This flag cannot be combined with FDTF_LTRDATE.</para>
            <para>FDTF_NOAUTOREADINGORDER (0x00000400)</para>
            <para>
            0x00000400. No reading order marks are inserted. Normally, in the absence of the FDTF_LTRDATE or FDTF_RTLDATE flag,
            <c>SHFormatDateTime</c> determines the reading order from the user's default locale, inserts reading order marks, and updates the
            pdwFlags output value appropriately. This flag prevents that process from occurring. It is used most commonly by legacy callers
            of <c>SHFormatDateTime</c>. This flag cannot be combined with FDTF_RTLDATE or FDTF_LTRDATE.
            </para>
            <para><c>Windows Server 2003 and Windows XP:</c> This value is not available.</para>
            <para>
            When the function returns, the <c>DWORD</c> value pointed to by this parameter can contain zero or more of the following flags.
            </para>
            <para>FDTF_SHORTTIME (0x00000001)</para>
            <para>
            0x00000001. Formats the time of day as specified by the <c>Regional and Language Options</c> application in Control Panel, but
            without seconds. This flag cannot be combined with FDTF_LONGTIME.
            </para>
            <para>The short time was successfully formatted.</para>
            <para>FDTF_SHORTDATE (0x00000002)</para>
            <para>
            0x00000002. Formats the date as specified by the short date format in the <c>Regional and Language Options</c> application in
            Control Panel. This flag cannot be combined with FDTF_LONGDATE.
            </para>
            <para>The short date was successfully formatted.</para>
            <para>FDTF_LONGDATE (0x00000004)</para>
            <para>
            0x00000004. Formats the date as specified by the long date format in the <c>Regional and Language Options</c> application in
            Control Panel. This flag cannot be combined with FDTF_SHORTDATE.
            </para>
            <para>The long date was successfully formatted.</para>
            <para>FDTF_LONGTIME (0x00000008)</para>
            <para>
            0x00000008. Formats the time of day as specified by the <c>Regional and Language Options</c> application in Control Panel,
            including seconds. This flag cannot be combined with FDTF_SHORTTIME.
            </para>
            <para>The long time was successfully formatted.</para>
            <para>FDTF_RELATIVE (0x00000010)</para>
            <para>
            0x00000010. If the FDTF_LONGDATE flag is set and the date in the FILETIME structure is the same date that <c>SHFormatDateTime</c>
            is called, then the day of the week (if present) is changed to "Today". If the date in the structure is the previous day, then
            the day of the week (if present) is changed to "Yesterday".
            </para>
            <para>Relative notation was used for the date.</para>
            </param>
            <param name="pszBuf">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer to a buffer that receives the formatted date and time. The buffer must be large enough to contain the number of TCHAR
            characters specified by the cchBuf parameter, including a terminating null character.
            </para>
            </param>
            <param name="cchBuf">
            <para>Type: <c>UINT</c></para>
            <para>The number of TCHARs that can be contained by the buffer pointed to by pszBuf.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            Returns the number of TCHARs written to the buffer, including the terminating null character. On failure, this value is 0.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHFreeShared(System.IntPtr,System.UInt32)">
            <summary>
            <para>
            [ <c>SHFreeShared</c> is available for use in the operating systems specified in the Requirements section. It may be altered or
            unavailable in subsequent versions.]
            </para>
            <para>Frees shared memory, regardless of which process allocated it.</para>
            </summary>
            <param name="hData">
            <para>Type: <c>HANDLE</c></para>
            <para>A handle to the mapped memory.</para>
            </param>
            <param name="dwProcessId">
            <para>Type: <c>DWORD</c></para>
            <para>The process ID of the process from which the memory was allocated.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if successful; otherwise, <c>FALSE</c>. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHGetInverseCMAP(System.IntPtr,System.UInt32)">
            <summary>
            <para>
            [This function is available through Windows XP and Windows Server 2003. It might be altered or unavailable in subsequent versions
            of Windows.]
            </para>
            <para>Retrieves the inverse color table mapping for the halftone palette.</para>
            </summary>
            <param name="pbMap">
            <para>Type: <c>BYTE*</c></para>
            <para>
            A pointer to an array of <c>BYTE</c><c>s</c> that receives the inverse color table mapping, or a pointer to an <c>LPBYTE</c>
            which receives a pointer to a cached copy of the inverse color table mapping, depending on the value of the cbMap parameter.
            </para>
            </param>
            <param name="cbMap">
            <para>Type: <c>ULONG</c></para>
            <para>The size of the buffer pointed to by pbMap, which also defines its contents. Two values are recognized.</para>
            <para>(sizeof(BYTE*))</para>
            <para>The buffer pointed to by pbMap receives a pointer to a cached copy of the inverse color map table.</para>
            <para>(32768)</para>
            <para>
            The buffer pointed to by pbMap receives a copy of the inverse color map table. The buffer must be exactly 32,768 bytes in size.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The inverse color mapping table is a table of 32,768 bytes. It contains the indexes of colors in the halftone palette. Each index
            is stored at a position in the buffer that corresponds to a particular RGB value expressed in 555 format. These pairings allow
            you to find a color in the halftone palette which is a close approximation of the original color.
            </para>
            <para>
            For example, the method for determining a color in the halftone palette that is a close approximation for the color #306040 is as follows:
            </para>
            <list type="number">
            <item>
            <term>
            Decompose the color into its red, green, and blue components. In this case, the red component is 0x30, the green component is
            0x60 and the blue component is 0x40.
            </term>
            </item>
            <item>
            <term>
            Reassemble the color into 555 format. The formula for reducing a 24-bit RGB color into 555 format is shown here. In this example,
            the value in 555 format is ((0x30 / 8) &lt;&lt; 10) + ((0x60 / 8) &lt;&lt; 5) + (0x40 / 8) = 6536.
            </term>
            </item>
            <item>
            <term>
            The index value stored in position 6536 in the inverse color map table is the index of the color in the halftone palette that is
            a reasonable approximation to the color #306040.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHGetThreadRef(System.Object@)">
            <summary>
            <para>Retrieves the per-thread object reference set by SHSetThreadRef.</para>
            </summary>
            <param name="ppunk">
            <para>Type: <c>IUnknown**</c></para>
            <para>
            The address of a pointer that, when this function returns successfully, points to the object whose reference is stored. Your
            application is responsible for freeing this resource when it is no longer needed.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns S_OK if the object reference exists, or <c>E_NOINTERFACE</c> otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHGetValue(Vanara.PInvoke.HKEY,System.String,System.String,Vanara.PInvoke.REG_VALUE_TYPE@,System.IntPtr,System.UInt32@)">
            <summary>
            <para>Retrieves a registry value.</para>
            </summary>
            <param name="hkey">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to the currently open key, or any of the following predefined values.</para>
            <para>HKEY_CLASSES_ROOT</para>
            <para>HKEY_CURRENT_CONFIG</para>
            <para>HKEY_CURRENT_USER</para>
            <para>HKEY_LOCAL_MACHINE</para>
            <para>HKEY_PERFORMANCE_DATA</para>
            <para>HKEY_USERS</para>
            </param>
            <param name="pszSubKey">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The address of a null-terminated string that specifies the name of the subkey from which to retrieve the value.</para>
            </param>
            <param name="pszValue">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The address of the value.</para>
            </param>
            <param name="pdwType">
            <para>Type: <c>LPDWORD</c></para>
            <para>The type of value. For more information, see Registry Data Types.</para>
            </param>
            <param name="pvData">
            <para>Type: <c>LPVOID</c></para>
            <para>The address of the destination data buffer.</para>
            </param>
            <param name="pcbData">
            <para>Type: <c>LPDWORD</c></para>
            <para>The size of the destination data buffer.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
            <remarks>
            <para>
            If your application must set/retrieve a series of values in the same key, it is better to open the key once and set/retrieve the
            values with the regular Microsoft Win32 registry functions rather than use this function repeatedly.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHGetValue(Vanara.PInvoke.HKEY,System.String,System.String,Vanara.PInvoke.REG_VALUE_TYPE@,Vanara.InteropServices.SafeAllocatedMemoryHandle,System.UInt32@)">
            <summary>
            <para>Retrieves a registry value.</para>
            </summary>
            <param name="hkey">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to the currently open key, or any of the following predefined values.</para>
            <para>HKEY_CLASSES_ROOT</para>
            <para>HKEY_CURRENT_CONFIG</para>
            <para>HKEY_CURRENT_USER</para>
            <para>HKEY_LOCAL_MACHINE</para>
            <para>HKEY_PERFORMANCE_DATA</para>
            <para>HKEY_USERS</para>
            </param>
            <param name="pszSubKey">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The address of a null-terminated string that specifies the name of the subkey from which to retrieve the value.</para>
            </param>
            <param name="pszValue">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The address of the value.</para>
            </param>
            <param name="pdwType">
            <para>Type: <c>LPDWORD</c></para>
            <para>The type of value. For more information, see Registry Data Types.</para>
            </param>
            <param name="pvData">
            <para>Type: <c>LPVOID</c></para>
            <para>The address of the destination data buffer.</para>
            </param>
            <param name="pcbData">
            <para>Type: <c>LPDWORD</c></para>
            <para>The size of the destination data buffer.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
            <remarks>
            <para>
            If your application must set/retrieve a series of values in the same key, it is better to open the key once and set/retrieve the
            values with the regular Microsoft Win32 registry functions rather than use this function repeatedly.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHGetViewStatePropertyBag(System.IntPtr,System.String,Vanara.PInvoke.ShlwApi.SHGVSPB,System.Guid@,System.Object@)">
            <summary>
            <para>
            [ <c>SHGetViewStatePropertyBag</c> is available for use in the operating systems specified in the Requirements section. It may be
            altered or unavailable in subsequent versions.]
            </para>
            <para>
            Retrieves a property bag in which the view state information for a folder can be stored and subsequently retrieved. The user's
            settings are kept for the next time the user visits the folder.
            </para>
            </summary>
            <param name="pidl">
            <para>Type: <c>PCIDLIST_ABSOLUTE</c></para>
            <para>
            A PIDL of the folder for which you are requesting properties. This parameter must be <c>NULL</c> if the SHGVSPB_ALLFOLDERS flag
            is passed.
            </para>
            </param>
            <param name="pszBagName">
            <para>Type: <c>PCWSTR</c></para>
            <para>A pointer to a string that contains the name of the requested property bag.</para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>A value that specifies a combination of the following flags.</para>
            <para>One value from the following set of flags is required.</para>
            <para>SHGVSPB_PERUSER</para>
            <para>Returns the per-user properties for the specified pidl.</para>
            <para>SHGVSPB_ALLUSERS</para>
            <para>Returns the All User properties for the specified pidl.</para>
            <para>One value from the following set of flags is required.</para>
            <para>SHGVSPB_PERFOLDER</para>
            <para>Returns the property bag for the folder specified by the pidl parameter.</para>
            <para>SHGVSPB_ALLFOLDERS</para>
            <para>Returns the property bag that applies to all folders.</para>
            <para>SHGVSPB_INHERIT</para>
            <para>Returns the property bag used to provide defaults for subfolders that do not have their property bag.</para>
            <para>The following flags are optional.</para>
            <para>SHGVSPB_ROAM</para>
            <para>Allows the property bag to roam. See Roaming User Profiles. This flag cannot be combined with SHGVSPB_ALLFOLDERS.</para>
            <para>SHGVSPB_NOAUTODEFAULTS</para>
            <para>
            Suppresses the search for a suitable default when the property bag cannot be found for the specified folder. By default, if
            SHGVSPB_INHERIT is not specified and a property bag cannot be found for the specified folder, the system searches for identically
            named property bags in other locations that may be able to provide default values. For example, the system searches in the
            ancestors of the folder to see if any of them provide a SHGVSPB_INHERIT property bag. Other places the system searches are in the
            user defaults and the global defaults.
            </para>
            <para>The following set of flags consists of values that combine some flags listed above, and are used for brevity and convenience.</para>
            <para>SHGVSPB_FOLDER</para>
            <para>Combines SHGVSPB_PERUSER and SHGVSPB_PERFOLDER.</para>
            <para>SHGVSPB_FOLDERNODEFAULTS</para>
            <para>Combines SHGVSPB_PERUSER, SHGVSPB_PERFOLDER, and SHGVSPB_NOAUTODEFAULTS.</para>
            <para>SHGVSPB_USERDEFAULTS</para>
            <para>Combines SHGVSPB_PERUSER and SHGVSPB_ALLFOLDERS.</para>
            <para>SHGVSPB_GLOBALDEFAULTS</para>
            <para>Combines SHGVSPB_ALLUSERS and SHGVSPB_ALLFOLDERS.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</c> This flag is named SHGVSPB_GLOBALDEAFAULTS.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>A reference to the IID of the interface to retrieve through ppv.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this method returns successfully, contains the interface pointer requested in riid.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            Critical information should not be stored in the view state property bag because the system keeps only a limited number of view
            states. If a folder is not visited for a long time, its view state is eventually deleted.
            </para>
            <para>
            We recommend that you use the IID_PPV_ARGS macro, defined in Objbase.h, to package the riid and ppv parameters. This macro
            provides the correct IID based on the interface pointed to by the value in ppv, which eliminates the possibility of a coding
            error in riid that could lead to unexpected results.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHIsChildOrSelf(Vanara.PInvoke.HWND,Vanara.PInvoke.HWND)">
            <summary>
            <para>
            [This function is available through Windows XP and Windows Server 2003. It might be altered or unavailable in subsequent versions
            of Windows.]
            </para>
            <para>Compares whether a window is equal to, a child of, or a descendant of, a second window.</para>
            </summary>
            <param name="hwndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the first window.</para>
            </param>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to a window to be tested against hwndParent.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            Returns <c>S_OK</c> if the window specified by hwnd is equal to, a child of, or a descendent of the window specified by
            hwndParent. Returns <c>S_FALSE</c> if the window specified by hwnd is not equal to, not a child of, and not a descendent of the
            window specified by hwndParent. The return value is undefined if either window handle is invalid.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHIsLowMemoryMachine(System.UInt32)">
            <summary>
            <para>Not supported.</para>
            </summary>
            <param name="dwType">
            <para>Type: <c>DWORD</c></para>
            <para>The type of machine being examined. The following is the only recognized value.</para>
            <para>ILMM_IE4</para>
            <para>
            An older (circa 1997), low-end machine. Since system resources in general were lower on these older machines, the low-memory
            threshold is accordingly lower.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para><c>TRUE</c> if the machine is considered low on resources, <c>FALSE</c> otherwise.</para>
            <para><c>Note</c> Always returns <c>FALSE</c> under Windows XP.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHLoadIndirectString(System.String,System.Text.StringBuilder,System.UInt32,System.IntPtr)">
            <summary>
            Extracts a specified text resource when given that resource in the form of an indirect string (a string that begins with the '@' symbol).
            </summary>
            <param name="pszSource">
            <para>Type: <c>PCWSTR</c></para>
            <para>
            A pointer to a buffer that contains the indirect string from which the resource will be retrieved. This string should begin with
            the '@' symbol and use one of the forms discussed in the Remarks section. This function will successfully accept a string that
            does not begin with an '@' symbol, but the string will be simply passed unchanged to pszOutBuf.
            </para>
            </param>
            <param name="pszOutBuf">
            <para>Type: <c>PWSTR</c></para>
            <para>
            A pointer to a buffer that, when this function returns successfully, receives the text resource. Both pszOutBuf and pszSource
            can point to the same buffer, in which case the original string will be overwritten.
            </para>
            </param>
            <param name="cchOutBuf">
            <para>Type: <c>UINT</c></para>
            <para>The size of the buffer pointed to by pszOutBuf, in characters.</para>
            </param>
            <param name="ppvReserved">
            <para>Type: <c>void**</c></para>
            <para>Not used; set to <c>NULL</c>.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>An indirect string can be provided in several forms, each of which has its own interpretation:</para>
            <list type="bullet">
            <item>
            <term>
            <c>File name and resource ID</c> The string is extracted from the file named, using the resource value as a locator. If the
            resource value is zero or greater, the number becomes the index of the string in the binary file. If the number is negative, it
            becomes a resource ID. The retrieved string is copied to the output buffer and the function returns S_OK.
            </term>
            </item>
            <item>
            <term>
            <c>File name and resource ID with a version modifier</c> This form can be used when a resource is changed but still uses the
            same index or ID as the old resource. Without a version modifier, the Multilingual User Interface (MUI) cache will not recognize
            that the resource has changed and will not refresh. By appending the version modifier, the value is seen as a new resource and
            is added to the cache. Note that it is recommended that you use a new ID or index for a new resource, and use a version modifier
            only when that is not possible.
            </term>
            </item>
            <item>
            <term>
            <c>PRI file path and resource ID</c> The Package Resource Index (PRI) is a binary format introduced in Windows 8 that contains
            indexed resources or references to resources. The .pri file is bundled as part of an app's package. For more information on .pri
            files, see Creating and retrieving resources in Windows Store apps.
            </term>
            </item>
            <item>
            <term>
            <c>Package name and resource ID</c> The string is extracted from the Resources.pri file stored in the app's root directory of
            the package identified by PackageFullName, using the resource as a locator. The retrieved string is copied to the output buffer
            and the function returns S_OK. The string is extracted based on the app's environment or ResourceContext. An example of this
            type of indirect string is shown here. In this example, the reference name is fully-qualified, but it contains no namespace (for
            example, "resources"). The deployment stack expands the name to look for it in all namespaces.
            </term>
            </item>
            </list>
            <para>
            If the string is not an indirect string, then the string is directly copied without change to pszOutBuf and the function returns S_OK.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHLoadIndirectString(System.String,System.IntPtr,System.UInt32,System.IntPtr)">
            <summary>
            Extracts a specified text resource when given that resource in the form of an indirect string (a string that begins with the '@' symbol).
            </summary>
            <param name="pszSource">
            <para>Type: <c>PCWSTR</c></para>
            <para>
            A pointer to a buffer that contains the indirect string from which the resource will be retrieved. This string should begin with
            the '@' symbol and use one of the forms discussed in the Remarks section. This function will successfully accept a string that
            does not begin with an '@' symbol, but the string will be simply passed unchanged to pszOutBuf.
            </para>
            </param>
            <param name="pszOutBuf">
            <para>Type: <c>PWSTR</c></para>
            <para>
            A pointer to a buffer that, when this function returns successfully, receives the text resource. Both pszOutBuf and pszSource
            can point to the same buffer, in which case the original string will be overwritten.
            </para>
            </param>
            <param name="cchOutBuf">
            <para>Type: <c>UINT</c></para>
            <para>The size of the buffer pointed to by pszOutBuf, in characters.</para>
            </param>
            <param name="ppvReserved">
            <para>Type: <c>void**</c></para>
            <para>Not used; set to <c>NULL</c>.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>An indirect string can be provided in several forms, each of which has its own interpretation:</para>
            <list type="bullet">
            <item>
            <term>
            <c>File name and resource ID</c> The string is extracted from the file named, using the resource value as a locator. If the
            resource value is zero or greater, the number becomes the index of the string in the binary file. If the number is negative, it
            becomes a resource ID. The retrieved string is copied to the output buffer and the function returns S_OK.
            </term>
            </item>
            <item>
            <term>
            <c>File name and resource ID with a version modifier</c> This form can be used when a resource is changed but still uses the
            same index or ID as the old resource. Without a version modifier, the Multilingual User Interface (MUI) cache will not recognize
            that the resource has changed and will not refresh. By appending the version modifier, the value is seen as a new resource and
            is added to the cache. Note that it is recommended that you use a new ID or index for a new resource, and use a version modifier
            only when that is not possible.
            </term>
            </item>
            <item>
            <term>
            <c>PRI file path and resource ID</c> The Package Resource Index (PRI) is a binary format introduced in Windows 8 that contains
            indexed resources or references to resources. The .pri file is bundled as part of an app's package. For more information on .pri
            files, see Creating and retrieving resources in Windows Store apps.
            </term>
            </item>
            <item>
            <term>
            <c>Package name and resource ID</c> The string is extracted from the Resources.pri file stored in the app's root directory of
            the package identified by PackageFullName, using the resource as a locator. The retrieved string is copied to the output buffer
            and the function returns S_OK. The string is extracted based on the app's environment or ResourceContext. An example of this
            type of indirect string is shown here. In this example, the reference name is fully-qualified, but it contains no namespace (for
            example, "resources"). The deployment stack expands the name to look for it in all namespaces.
            </term>
            </item>
            </list>
            <para>
            If the string is not an indirect string, then the string is directly copied without change to pszOutBuf and the function returns S_OK.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHLockShared(System.IntPtr,System.UInt32)">
            <summary>
            <para>
            [ <c>SHLockShared</c> is available for use in the operating systems specified in the Requirements section. It may be altered or
            unavailable in subsequent versions.]
            </para>
            <para>Maps a block of memory from a specified process into the calling process.</para>
            </summary>
            <param name="hData">
            <para>Type: <c>HANDLE</c></para>
            <para>A handle to the memory you want to map into the calling process.</para>
            </param>
            <param name="dwProcessId">
            <para>Type: <c>DWORD</c></para>
            <para>The process ID of the process from which you want to map the block of memory.</para>
            </param>
            <returns>
            <para>Returns a void pointer to the shared memory. Returns <c>NULL</c> if unsuccessful.</para>
            </returns>
            <remarks>
            <para>Call SHUnlockShared to unlock the memory that this function maps. Call SHFreeShared to release the memory.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHMessageBoxCheck(Vanara.PInvoke.HWND,System.String,System.String,System.UInt32,System.Int32,System.String)">
            <summary>
            <para>
            [ <c>SHMessageBoxCheck</c> is available for use in the operating systems specified in the Requirements section. It may be altered
            or unavailable in subsequent versions.]
            </para>
            <para>
            Displays a message box that gives the user the option of suppressing further occurrences. If the user has already opted to
            suppress the message box, the function does not display a dialog box and instead simply returns the default value.
            </para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>The window handle to the message box's owner. This value can be <c>NULL</c>.</para>
            </param>
            <param name="pszText">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string that contains the message to be displayed.</para>
            </param>
            <param name="pszCaption">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a null-terminated string that contains the title of the message box. If this parameter is set to <c>NULL</c>, the
            title is set to <c>Error!</c>.
            </para>
            </param>
            <param name="uType">
            <para>Type: <c>UINT</c></para>
            <para>
            The flags that specify the contents and behavior of the message box. This function supports only a subset of the flags supported
            by MessageBox. If you use any flags that are not listed below, the function's behavior is undefined.
            </para>
            <para>You must specify the buttons to be displayed by setting one and only one of the following flags.</para>
            <para>MB_OKCANCEL</para>
            <para>Display a message box with <c>OK</c> and <c>Cancel</c> buttons.</para>
            <para>MB_YESNO</para>
            <para>Display a message box with <c>Yes</c> and <c>No</c> buttons.</para>
            <para>MB_OK</para>
            <para>Display a message box with an <c>OK</c> button.</para>
            <para>You can display an optional icon by setting one and only one of the following flags.</para>
            <para>MB_ICONHAND</para>
            <para>Display a stop-sign icon.</para>
            <para>MB_ICONQUESTION</para>
            <para>Display a question-mark icon.</para>
            <para>MB_ICONEXCLAMATION</para>
            <para>Display an exclamation-point icon.</para>
            <para>MB_ICONINFORMATION</para>
            <para>Display an icon with a lowercase "i" in a circle.</para>
            </param>
            <param name="iDefault">
            <para>Type: <c>int</c></para>
            <para>
            The value that the function returns when the user has opted not to have the message box displayed again. If the user has not
            opted to suppress the message box, the message box is displayed and the function ignores iDefault.
            </para>
            </param>
            <param name="pszRegVal">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a null-terminated string that contains a unique string value to associate with this message. To avoid collisions
            with values used by Microsoft, this string should include a GUID. This string must not exceed REGSTR_MAX_VALUE_LENGTH characters
            in length, including the terminating null character.
            </para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>If the user has already chosen to suppress the message box, the function immediately returns the value assigned to iDefault.</para>
            <para>
            If the user clicks the <c>OK</c>, <c>Cancel</c>, <c>Yes</c>, or <c>No</c> button, the function returns IDOK, IDCANCEL, IDYES, or
            IDNO, respectively.
            </para>
            <para>
            If the user closes the message box by clicking the <c>X</c> button in the caption, the function returns IDCANCEL. This value is
            returned in this case even if the MB_OKCANCEL flag has not been set.
            </para>
            <para>
            If an error occurs, the return value is normally –1. However, under certain low-memory conditions, the function might return iDefault.
            </para>
            </returns>
            <remarks>
            <para>
            <c>Security Warning:</c> Do not take any dangerous actions if the function returns either –1 or iDefault. If an error occurs when
            attempting to display the message box, <c>SHMessageBoxCheck</c> returns –1 or, in some cases, iDefault. Such errors can be caused
            by insufficient memory or resources. If you get one of these return values, you should be aware that the user did not necessarily
            see the dialog box and consequently did not positively agree to any action.
            </para>
            <para>
            Do not confuse "Do not show this dialog box" with "Remember this answer". <c>SHMessageBoxCheck</c> does not provide "Remember
            this answer" functionality. If the user chooses to suppress the message box again, the function does not preserve which button
            they clicked. Instead, subsequent invocations of <c>SHMessageBoxCheck</c> simply return the value specified by iDefault. Consider
            the following example.
            </para>
            <para>
            If the user selects <c>In the future, do not show me this</c> dialog box and clicks the <c>Yes</c> button,
            <c>SHMessageBoxCheck</c> returns IDYES. However, the next time this code is executed, <c>SHMessageBoxCheck</c> does not return
            IDYES, even though the user selected <c>Yes</c> originally. Instead, it returns IDNO, because that is the value specified by iDefault.
            </para>
            <para>
            The default button displayed by the message box should agree with your iDefault value. The lack of support for the MB_DEFBUTTON2
            flag means that iDefault should be set to IDOK if you have specified the MB_OK or MB_OKCANCEL flag. The iDefault value should be
            set to IDYES if you have set the MB_YESNO flag.
            </para>
            <para><c>SHMessageBoxCheck</c> records the message boxes that the user has chosen to suppress under the following registry key.</para>
            <para><c>Software</c><c>Microsoft</c><c>Windows</c><c>CurrentVersion</c><c>Explorer</c><c>LowRegistry</c><c>DontShowMeThisDialogAgain</c></para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHOpenRegStream2(Vanara.PInvoke.HKEY,System.String,System.String,Vanara.PInvoke.STGM)">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHQueryInfoKey(Vanara.PInvoke.HKEY,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
            <para>Retrieves information about a specified registry key.</para>
            </summary>
            <param name="hkey">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to the currently open key, or any of the following predefined values.</para>
            <para>HKEY_CLASSES_ROOT</para>
            <para>HKEY_CURRENT_CONFIG</para>
            <para>HKEY_CURRENT_USER</para>
            <para>HKEY_LOCAL_MACHINE</para>
            <para>HKEY_PERFORMANCE_DATA</para>
            <para>HKEY_USERS</para>
            </param>
            <param name="pcSubKeys">
            <para>Type: <c>LPDWORD</c></para>
            <para>The address of a <c>DWORD</c> that receives the number of subkeys under the specified key.</para>
            </param>
            <param name="pcchMaxSubKeyLen">
            <para>Type: <c>LPDWORD</c></para>
            <para>The address of a <c>DWORD</c> that receives the number of characters in the name of the subkey with the largest name.</para>
            </param>
            <param name="pcValues">
            <para>Type: <c>LPDWORD</c></para>
            <para>The address of a <c>DWORD</c> that receives the number of values under the specified key.</para>
            </param>
            <param name="pcchMaxValueNameLen">
            <para>Type: <c>LPDWORD</c></para>
            <para>The address of a <c>DWORD</c> that receives the number of characters in the name of the value with the largest name.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHQueryValueEx(Vanara.PInvoke.HKEY,System.String,System.IntPtr,Vanara.PInvoke.REG_VALUE_TYPE@,System.IntPtr,System.UInt32@)">
            <summary>
            <para>Opens a registry key and queries it for a specific value.</para>
            </summary>
            <param name="hkey">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to the currently open key, or any of the following predefined values.</para>
            <para>HKEY_CLASSES_ROOT</para>
            <para>HKEY_CURRENT_CONFIG</para>
            <para>HKEY_CURRENT_USER</para>
            <para>HKEY_LOCAL_MACHINE</para>
            <para>HKEY_PERFORMANCE_DATA</para>
            <para>HKEY_USERS</para>
            </param>
            <param name="pszValue">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The address of the <c>null</c>-terminated string that contains the name of the value to be queried.</para>
            </param>
            <param name="pdwReserved">
            <para>Type: <c>LPDWORD</c></para>
            <para>Reserved. Must be <c>NULL</c>.</para>
            </param>
            <param name="pdwType">
            <para>Type: <c>LPDWORD</c></para>
            <para>The address of the variable that receives the key's value type. For more information, see Registry Data Types.</para>
            </param>
            <param name="pvData">
            <para>Type: <c>LPVOID</c></para>
            <para>The address of the buffer that receives the value's data. This parameter can be <c>NULL</c> if the data is not required.</para>
            </param>
            <param name="pcbData">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            The address of the variable that specifies the size, in bytes, of the buffer pointed to by the pvData parameter. When the
            function returns, this variable contains the size of the data copied to pvData.
            </para>
            </param>
            <returns>
            <para>Type: <c>DWORD</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegCloseUSKey(Vanara.PInvoke.ShlwApi.HUSKEY)">
            <summary>
            <para>Closes a handle to a user-specific registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
            </summary>
            <param name="hUSKey">
            <para>Type: <c>HUSKEY</c></para>
            <para>
            A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more
            information, see Registry Key Security and Access Rights.
            </para>
            <para>This handle can be obtained through the SHRegOpenUSKey function.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. Use FormatMessage with the
            FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegCreateUSKey(System.String,System.UInt32,Vanara.PInvoke.ShlwApi.HUSKEY,Vanara.PInvoke.ShlwApi.SafeHUSKEY@,Vanara.PInvoke.ShlwApi.SHREGSET)">
            <summary>
            <para>Creates or opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a null-terminated string that contains the subkey to be created or opened. If a value with this name is already
            present in the subkey, it will be opened.
            </para>
            </param>
            <param name="samDesired">
            <para>Type: <c>REGSAM</c></para>
            <para>The desired security access. For more information on security access, see REGSAM.</para>
            </param>
            <param name="hRelativeUSKey">
            <para>Type: <c>HUSKEY</c></para>
            <para>
            The key to be used as a base for relative paths. If pszPath is a relative path, the key it specifies will be relative to
            hRelativeUSKey. If pszPath is an absolute path, set hRelativeUSKey to <c>NULL</c>. The key will then be created under
            <c>HKEY_LOCAL_MACHINE</c> or <c>HKEY_CURRENT_USER</c>, depending the value of dwFlags.
            </para>
            </param>
            <param name="phNewUSKey">
            <para>Type: <c>PHUSKEY</c></para>
            <para>A pointer to an <c>HUSKEY</c> that will receive the handle to the new key.</para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>The base key under which the key should be opened. This can be one or more of the following values.</para>
            <para>SHREGSET_HKCU</para>
            <para>Create/open the key under <c>HKEY_CURRENT_USER</c>. Only creates a key if it is empty.</para>
            <para>SHREGSET_FORCE_HKCU</para>
            <para>Create/open the key under <c>HKEY_CURRENT_USER</c>. Creates a key even if it is not empty.</para>
            <para>SHREGSET_HKLM</para>
            <para>Create/open the key under <c>HKEY_LOCAL_MACHINE</c>. Only creates a key if it is empty.</para>
            <para>SHREGSET_FORCE_HKLM</para>
            <para>Create/open the key under <c>HKEY_LOCAL_MACHINE</c>. Creates a key even if it is not empty.</para>
            <para>SHREGSET_DEFAULT</para>
            <para>
            Create/open the key under both <c>HKEY_CURRENT_USER</c> (forced) and <c>HKEY_LOCAL_MACHINE</c> (only if empty). This flag is the
            equivalent of ( <c>SHREGSET_FORCE_HKCU</c> | <c>SHREGSET_HKLM</c>).
            </para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
            <remarks>
            <para>
            If you want to write values to the new key, use SHRegWriteUSValue to write each value, passing the <c>HUSKEY</c> handle that is
            returned through phNewUSKey. When you have finished, close the user-specific registry key with SHRegCloseUSKey.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegDeleteEmptyUSKey(Vanara.PInvoke.ShlwApi.HUSKEY,System.String,Vanara.PInvoke.ShlwApi.SHREGDEL_FLAGS)">
            <summary>
            <para>Deletes an empty registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
            </summary>
            <param name="hUSKey">
            <para>Type: <c>HUSKEY</c></para>
            <para>
            A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more
            information, see Registry Key Security and Access Rights.
            </para>
            <para>This handle can be obtained through the SHRegOpenUSKey function.</para>
            </param>
            <param name="pszSubKey">
            <para>TBD</para>
            </param>
            <param name="delRegFlags">
            <para>Type: <c>SHREGDEL_FLAGS</c></para>
            <para>One of the SHREGDEL_FLAGS that specifies from which base key the subkey will be deleted.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegDeleteUSValue(Vanara.PInvoke.ShlwApi.HUSKEY,System.String,Vanara.PInvoke.ShlwApi.SHREGDEL_FLAGS)">
            <summary>
            <para>Deletes a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
            </summary>
            <param name="hUSKey">
            <para>Type: <c>HUSKEY</c></para>
            <para>
            A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more
            information, see Registry Key Security and Access Rights.
            </para>
            <para>This handle can be obtained through the SHRegOpenUSKey function.</para>
            </param>
            <param name="pszValue">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to the null-terminated string that names the value to remove.</para>
            </param>
            <param name="delRegFlags">
            <para>Type: <c>SHREGDEL_FLAGS</c></para>
            <para>One of the SHREGDEL_FLAGS that specifies from which base key the value will be deleted.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegDuplicateHKey(Vanara.PInvoke.HKEY)">
            <summary>
            <para>Duplicates a registry key's HKEY handle.</para>
            </summary>
            <param name="hkey">
            <para>Type: <c>HKEY</c></para>
            <para>The HKEY handle to be duplicated.</para>
            </param>
            <returns>
            <para>Type: <c>HKEY</c></para>
            <para>Returns a duplicate of the handle specified in hkey.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegEnumUSKey(Vanara.PInvoke.ShlwApi.HUSKEY,System.UInt32,System.Text.StringBuilder,System.UInt32@,Vanara.PInvoke.ShlwApi.SHREGENUM_FLAGS)">
            <summary>
            <para>Enumerates the subkeys of a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
            </summary>
            <param name="hUSKey">
            <para>Type: <c>HUSKEY</c></para>
            <para>
            A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more
            information, see Registry Key Security and Access Rights.
            </para>
            <para>This handle can be obtained through the SHRegOpenUSKey function.</para>
            </param>
            <param name="dwIndex">
            <para>Type: <c>DWORD</c></para>
            <para>The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
            </param>
            <param name="pszName">
            <para>Type: <c>LPTSTR</c></para>
            <para>A pointer to a character buffer that receives the enumerated key name.</para>
            </param>
            <param name="pcchName">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            A pointer to a DWORD that, on entry, contains the size of the buffer at pszName, in characters. On exit, this contains the number
            of characters that were copied to pszName.
            </para>
            </param>
            <param name="enumRegFlags">
            <para>Type: <c>SHREGENUM_FLAGS</c></para>
            <para>A SHREGENUM_FLAGS that specifies the base key in which the enumeration should take place.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegEnumUSValue(Vanara.PInvoke.ShlwApi.HUSKEY,System.UInt32,System.Text.StringBuilder,System.UInt32@,Vanara.PInvoke.REG_VALUE_TYPE@,System.IntPtr,System.UInt32@,Vanara.PInvoke.ShlwApi.SHREGENUM_FLAGS)">
            <summary>Enumerates the values of the specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</summary>
            <param name="hUSKey">
            <para>Type: <c>HUSKEY</c></para>
            <para>
            A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more
            information, see Registry Key Security and Access Rights.
            </para>
            <para>This handle can be obtained through the <c>SHRegOpenUSKey</c> function.</para>
            </param>
            <param name="dwIndex">
            <para>Type: <c>DWORD</c></para>
            <para>The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
            </param>
            <param name="pszValueName">
            <para>Type: <c>LPTSTR</c></para>
            <para>A pointer to a character buffer that receives the enumerated value name. The size of this buffer is specified in pcchValueNameLen.</para>
            </param>
            <param name="pcchValueNameLen">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            A pointer to a <c>DWORD</c> that, on entry, contains the size of the buffer at pszValueName, in characters. On exit, this
            contains the number of characters that were copied to pszValueName.
            </para>
            </param>
            <param name="pdwType">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            A pointer to a <c>DWORD</c> that receives the data type of the value. These are the same values as those described under the
            lpType parameter of <c>RegEnumValue</c>.
            </para>
            </param>
            <param name="pvData">
            <para>Type: <c>void*</c></para>
            <para>
            A pointer to a buffer that receives the data for the value entry. The size of this buffer is specified in pcbData. This parameter
            can be <c>NULL</c> if the data is not required.
            </para>
            </param>
            <param name="pcbData">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            A pointer to a <c>DWORD</c> that, on entry, contains the size of the buffer at pvData. On exit, this contains the number of bytes
            that were copied to pvData.
            </para>
            </param>
            <param name="enumRegFlags">
            <para>Type: <c><c>SHREGENUM_FLAGS</c></c></para>
            <para>One of the <c>SHREGENUM_FLAGS</c> that specifies the base key in which the enumeration should take place.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns <c>ERROR_SUCCESS</c> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the
            <c>FormatMessage</c> function with the <c>FORMAT_MESSAGE_FROM_SYSTEM</c> flag to retrieve a textual description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegGetBoolUSValue(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            <para>Retrieves a Boolean value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
            </summary>
            <param name="pszSubKey">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a null-terminated string with the name of the subkey relative to <c>HKEY_LOCAL_MACHINE</c> and
            <c>HKEY_CURRENT_USER</c>. For example, "Software\MyCompany\MyProduct".
            </para>
            </param>
            <param name="pszValue">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string that specifies the name of the value. This value can be <c>NULL</c>.</para>
            </param>
            <param name="fIgnoreHKCU">
            <para>Type: <c>BOOL</c></para>
            <para>
            A variable that specifies which key to look under. When set to <c>TRUE</c>, SHRegGetUSValue ignores <c>HKEY_CURRENT_USER</c> and
            returns a value from <c>HKEY_LOCAL_MACHINE</c>.
            </para>
            </param>
            <param name="fDefault">
            <para>Type: <c>BOOL</c></para>
            <para>A value that is returned if there is no registry value.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns either the value from the registry, or fDefault if none is found.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegGetBoolValueFromHKCUHKLM(System.String,System.String,System.Boolean)">
            <summary>
            <para>[This function is no longer supported.]</para>
            <para>
            Evaluates a registry key value and returns a boolean value that reflects whether the value exists and the expected state matches
            the actual state. This function will first check HKEY_CURRENT_USER for the requested information in the specified subkey. If the
            information does not exist under the HKEY_CURRENT_USER subtree it will check the HKEY_LOCAL_MACHINE subtree for the same information.
            </para>
            </summary>
            <param name="pszKey">
            <para>Type: <c>PCWSTR</c></para>
            <para>A pointer to a null-terminated Unicode string that specifies the path to the key to be checked.</para>
            </param>
            <param name="pszValue">
            <para>Type: <c>PCWSTR</c></para>
            <para>A pointer to a null-terminated Unicode string that specifies the value to be evaluated.</para>
            </param>
            <param name="fDefault">
            <para>Type: <c>BOOL</c></para>
            <para>The expected state of the evaluation, as defined by the calling function.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para><c>TRUE</c> if the evaluation matches the fDefault value; otherwise, <c>FALSE</c>.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegGetIntW(System.IntPtr,System.String,System.Int32)">
            <summary>
            <para>Reads a numeric string value from the registry and converts it to an integer.</para>
            </summary>
            <param name="hk">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to the registry key that specifies the value to be read.</para>
            </param>
            <param name="pwzKey">
            <para>TBD</para>
            </param>
            <param name="iDefault">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>Returns the converted string as an <c>int</c>, or the default value specified by nDefault.</para>
            </returns>
            <remarks>
            <para>
            Prior to Windows 2000 Service Pack 3 (SP3), Windows Server 2003 Service Pack 1 (SP1), and Windows XP, <c>SHRegGetIntW</c> was not
            exported by name. On those systems you must load it directly from Shlwapi.dll as ordinal 280.
            </para>
            <para>This function is only available in a Unicode version. ANSI is not supported.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegGetPath(Vanara.PInvoke.HKEY,System.String,System.String,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>Retrieves a file path from the registry, expanding environment variables as needed.</para>
            </summary>
            <param name="hKey">
            <para>TBD</para>
            </param>
            <param name="pcszSubKey">
            <para>TBD</para>
            </param>
            <param name="pcszValue">
            <para>TBD</para>
            </param>
            <param name="pszPath">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A buffer to hold the expanded path. You should set the size of this buffer to <c>MAX_PATH</c> to ensure that it is large enough
            to hold the returned string.
            </para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>Reserved.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>Returns <c>ERROR_SUCCESS</c> if successful, or a Windows error code otherwise.</para>
            </returns>
            <remarks>
            <para>
            The data type of the specified registry value must be either <c>REG_EXPAND_SZ</c> or <c>REG_SZ</c>. If it has the
            <c>REG_EXPAND_SZ</c> type, any environment variables in the registry string will be expanded with ExpandEnvironmentStrings. If it
            has the <c>REG_SZ</c> data type, environment variables will not be expanded and the string pointed to by pszPath will be
            identical to the string in the registry.
            </para>
            <para>The following environment strings will be replaced by their equivalent path.</para>
            <list type="table">
            <listheader>
            <term>Environment string</term>
            <term>Folder</term>
            </listheader>
            <item>
            <term>%USERPROFILE%</term>
            <term>The current user's profile folder</term>
            </item>
            <item>
            <term>%ALLUSERSPROFILE%</term>
            <term>The All Users profile folder</term>
            </item>
            <item>
            <term>%ProgramFiles%</term>
            <term>The Program Files folder</term>
            </item>
            <item>
            <term>%SystemRoot%</term>
            <term>The system root folder</term>
            </item>
            <item>
            <term>%SystemDrive%</term>
            <term>The system drive letter</term>
            </item>
            </list>
            <para>
            <c>Note</c> %USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated
            from a service.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegGetUSValue(System.String,System.String,Vanara.PInvoke.REG_VALUE_TYPE@,System.IntPtr,System.UInt32@,System.Boolean,System.IntPtr,System.UInt32)">
            <summary>
            <para>Retrieves a value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
            </summary>
            <param name="pszSubKey">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a null-terminated string with the name of the subkey relative to <c>HKEY_LOCAL_MACHINE</c> and
            <c>HKEY_CURRENT_USER</c>. For example: "Software\MyCompany\MyProduct".
            </para>
            </param>
            <param name="pszValue">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string with the name of the value. This value can be <c>NULL</c>.</para>
            </param>
            <param name="pdwType">
            <para>Type: <c>DWORD*</c></para>
            <para>
            A pointer to a <c>DWORD</c> that receives the type of data stored in the retrieved value. When using default values, the input
            pdwType is the type of the default value. For possible values, see Registry Data Types. If type information is not required, this
            parameter can be <c>NULL</c>.
            </para>
            </param>
            <param name="pvData">
            <para>Type: <c>void*</c></para>
            <para>A pointer to a buffer that receives the value's data.</para>
            </param>
            <param name="pcbData">
            <para>Type: <c>DWORD*</c></para>
            <para>
            A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by pvData. When <c>SHRegGetUSValue</c>
            returns, pcbData contains the size of the data copied to pvData.
            </para>
            </param>
            <param name="fIgnoreHKCU">
            <para>Type: <c>BOOL</c></para>
            <para>
            A variable that specifies which key to look under. When set to <c>TRUE</c>, <c>SHRegGetUSValue</c> ignores
            <c>HKEY_CURRENT_USER</c> and returns the value from the key under <c>HKEY_LOCAL_MACHINE</c>.
            </para>
            </param>
            <param name="pvDefaultData">
            <para>Type: <c>void*</c></para>
            <para>A pointer to a buffer that receives the value's default data.</para>
            </param>
            <param name="dwDefaultDataSize">
            <para>Type: <c>DWORD</c></para>
            <para>The length, in bytes, of the buffer pointed to by pvDefaultData.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
            <remarks>
            <para>
            When fIgnoreHKCU is set to <c>TRUE</c>, <c>SHRegGetUSValue</c> returns the value from the key under <c>HKEY_LOCAL_MACHINE</c>.
            When set to <c>FALSE</c>, <c>SHRegGetUSValue</c> first tries to return the value from the key under <c>HKEY_CURRENT_USER</c>.
            However, if the key is not found under <c>HKEY_CURRENT_USER</c>, the value is returned from the key under
            <c>HKEY_LOCAL_MACHINE</c>. If neither key is present, or if an error occurred and dwDefaultDataSize is nonzero, then the default
            data is copied to pvData and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no
            way of distinguishing which value copies to pvData. To prevent the use of default data, set pvDefaultData to <c>NULL</c> and
            dwDefaultDataSize to zero.
            </para>
            <para>
            This function opens the key each time it is used. If your code involves getting a series of values from the same key, it is more
            efficient to open the key once with SHRegOpenUSKey and then use SHRegQueryUSValue to retrieve the data.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegGetUSValue(System.String,System.String,Vanara.PInvoke.REG_VALUE_TYPE@,Vanara.InteropServices.SafeAllocatedMemoryHandle,System.UInt32@,System.Boolean,Vanara.InteropServices.SafeAllocatedMemoryHandle,System.UInt32)">
            <summary>
            <para>Retrieves a value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
            </summary>
            <param name="pszSubKey">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a null-terminated string with the name of the subkey relative to <c>HKEY_LOCAL_MACHINE</c> and
            <c>HKEY_CURRENT_USER</c>. For example: "Software\MyCompany\MyProduct".
            </para>
            </param>
            <param name="pszValue">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string with the name of the value. This value can be <c>NULL</c>.</para>
            </param>
            <param name="pdwType">
            <para>Type: <c>DWORD*</c></para>
            <para>
            A pointer to a <c>DWORD</c> that receives the type of data stored in the retrieved value. When using default values, the input
            pdwType is the type of the default value. For possible values, see Registry Data Types. If type information is not required, this
            parameter can be <c>NULL</c>.
            </para>
            </param>
            <param name="pvData">
            <para>Type: <c>void*</c></para>
            <para>A pointer to a buffer that receives the value's data.</para>
            </param>
            <param name="pcbData">
            <para>Type: <c>DWORD*</c></para>
            <para>
            A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by pvData. When <c>SHRegGetUSValue</c>
            returns, pcbData contains the size of the data copied to pvData.
            </para>
            </param>
            <param name="fIgnoreHKCU">
            <para>Type: <c>BOOL</c></para>
            <para>
            A variable that specifies which key to look under. When set to <c>TRUE</c>, <c>SHRegGetUSValue</c> ignores
            <c>HKEY_CURRENT_USER</c> and returns the value from the key under <c>HKEY_LOCAL_MACHINE</c>.
            </para>
            </param>
            <param name="pvDefaultData">
            <para>Type: <c>void*</c></para>
            <para>A pointer to a buffer that receives the value's default data.</para>
            </param>
            <param name="dwDefaultDataSize">
            <para>Type: <c>DWORD</c></para>
            <para>The length, in bytes, of the buffer pointed to by pvDefaultData.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
            <remarks>
            <para>
            When fIgnoreHKCU is set to <c>TRUE</c>, <c>SHRegGetUSValue</c> returns the value from the key under <c>HKEY_LOCAL_MACHINE</c>.
            When set to <c>FALSE</c>, <c>SHRegGetUSValue</c> first tries to return the value from the key under <c>HKEY_CURRENT_USER</c>.
            However, if the key is not found under <c>HKEY_CURRENT_USER</c>, the value is returned from the key under
            <c>HKEY_LOCAL_MACHINE</c>. If neither key is present, or if an error occurred and dwDefaultDataSize is nonzero, then the default
            data is copied to pvData and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no
            way of distinguishing which value copies to pvData. To prevent the use of default data, set pvDefaultData to <c>NULL</c> and
            dwDefaultDataSize to zero.
            </para>
            <para>
            This function opens the key each time it is used. If your code involves getting a series of values from the same key, it is more
            efficient to open the key once with SHRegOpenUSKey and then use SHRegQueryUSValue to retrieve the data.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegGetValue(Vanara.PInvoke.HKEY,System.String,System.String,Vanara.PInvoke.ShlwApi.SRRF,Vanara.PInvoke.REG_VALUE_TYPE@,System.IntPtr,System.UInt32@)">
            <summary>
            <para>
            [ <c>SHRegGetValue</c> may be altered or unavailable in subsequent versions of the operating system or product. Use RegGetValue
            in its place.]
            </para>
            <para>Retrieves a registry value.</para>
            </summary>
            <param name="hkey">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to the currently open key, or any of the following predefined values.</para>
            <para>HKEY_CLASSES_ROOT</para>
            <para>HKEY_CURRENT_CONFIG</para>
            <para>HKEY_CURRENT_USER</para>
            <para>HKEY_LOCAL_MACHINE</para>
            <para>HKEY_PERFORMANCE_DATA</para>
            <para>HKEY_USERS</para>
            </param>
            <param name="pszSubKey">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a <c>null</c>-terminated string that specifies the relative path from hkey to the subkey to retrieve the value from.
            This parameter can be <c>NULL</c> or an empty string, in which case the data is retrieved from the hkey location.
            </para>
            </param>
            <param name="pszValue">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a <c>null</c>-terminated string that contains the name of the value. This parameter can be <c>NULL</c> or an empty
            string, in which case the data is retrieved from the Default value.
            </para>
            </param>
            <param name="srrfFlags">
            <para>Type: <c>SRRF</c></para>
            <para>
            One or more of the SRRF flags that restricts the data to be retrieved. At least one type restriction (SRRF_RT) value must be specified.
            </para>
            </param>
            <param name="pdwType">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            A pointer to a <c>DWORD</c> that receives the type of data stored in the retrieved value. When using default values, the input
            pdwType is the type of the default value. For possible values, see Registry Data Types. If the SRRF_NOEXPAND flag is not set,
            REG_EXPAND_SZ types are automatically expanded and returned as REG_SZ. If type information is not required, this parameter can be <c>NULL</c>.
            </para>
            </param>
            <param name="pvData">
            <para>Type: <c>LPVOID</c></para>
            <para>
            A pointer to a buffer that receives the value's data. This parameter can be <c>NULL</c> if the data is not needed. For example,
            if you were testing only for a value's existence, the specific value data would be superfluous.
            </para>
            </param>
            <param name="pcbData">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            A pointer to a <c>DWORD</c> that, on entry, contains the size of the destination data buffer pvData, in bytes. This value can be
            <c>NULL</c> only if pvData is <c>NULL</c>. On exit, pcbData points to one of these values.
            </para>
            <list type="table">
            <listheader>
            <term>pvData</term>
            <term>Return Value</term>
            <term>pcbData</term>
            </listheader>
            <item>
            <term>NULL</term>
            <term>ERROR_SUCCESS</term>
            <term>
            Size in bytes sufficient to hold the registry data. Note that this is not guaranteed to be the precise size, but only a
            sufficient size.
            </term>
            </item>
            <item>
            <term>Non-NULL</term>
            <term>ERROR_SUCCESS</term>
            <term>Exact number of bytes written to pvData.</term>
            </item>
            <item>
            <term>Non-NULL</term>
            <term>ERROR_MORE_DATA</term>
            <term>
            Size in bytes needed to hold the entire data. Note that this is not guaranteed to be the precise size, but only a sufficient size.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns <c>ERROR_SUCCESS</c> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the
            FormatMessage function with the <c>FORMAT_MESSAGE_FROM_SYSTEM</c> flag to retrieve a generic description of the error.
            </para>
            </returns>
            <remarks>
            <para>
            <c>SHRegGetValue</c> provides data type checking, boot mode checking, auto-expansion of REG_EXPAND_SZ data, and guaranteed
            <c>null</c>-termination of REG_SZ, REG_EXPAND_SZ, and REG_MULTI_SZ data.
            </para>
            <para>
            The key identified by hkey must have been opened with KEY_QUERY_VALUE security access. If pszSubKey is not <c>NULL</c> or an
            empty string, that key also must be able to be opened with <c>KEY_QUERY_VALUE</c> security access in the current calling context.
            </para>
            <para>
            If the data's type is REG_SZ, REG_EXPAND_SZ or REG_MULTI_SZ, then any returned data includes or takes into account the string's
            <c>null</c>-termination. For example, if pvData is not <c>NULL</c>, the data returned in that buffer is <c>null</c>-terminated.
            If pcbData is not <c>NULL</c>, the buffer size that it points to includes the bytes required to hold the terminating <c>null</c> character.
            </para>
            <para>
            Unless the SRRF_NOEXPAND flag is set, string data of type REG_EXPAND_SZ is automatically expanded before being returned. The
            expanded string's type is reported in pdwType as REG_SZ, the pcbData parameter points to the number of bytes written for the
            expanded string, and the buffer pointed to by pvData holds the expanded version of the string.
            </para>
            <para>Performance Notes</para>
            <para>
            If pszSubKey is not <c>NULL</c> or an empty string, that key is opened and closed by this function each time it is accessed. If
            your application must retrieve a series of values from the same subkey, you will see better performance by opening the key using
            RegOpenKeyEx before calling <c>SHRegGetValue</c>. Use the key returned in the phkResult parameter of <c>RegOpenKeyEx</c> as the
            hkey parameter in this function, with pszSubKey set to <c>NULL</c>.
            </para>
            <para>
            The potential for an additional call to the registry to read or re-read the data exists when the data type is REG_EXPAND_SZ and
            the SRRF_NOEXPAND flag has not been set. The following conditions result in that additional call.
            </para>
            <list type="bullet">
            <item>
            <term>
            pvData is <c>NULL</c>, pcbData is not <c>NULL</c>. Though the data is not retrieved, the registry must be read to get the string
            and that string expanded to determine the required size of the data buffer.
            </term>
            </item>
            <item>
            <term>
            pvData is not <c>NULL</c>, but is too small to hold the data. The data is re-read to get the full string, the string is expanded,
            and the total required size is determined.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegGetValue(Vanara.PInvoke.HKEY,System.String,System.String,Vanara.PInvoke.ShlwApi.SRRF,Vanara.PInvoke.REG_VALUE_TYPE@,Vanara.InteropServices.SafeAllocatedMemoryHandle,System.UInt32@)">
            <summary>
            <para>
            [ <c>SHRegGetValue</c> may be altered or unavailable in subsequent versions of the operating system or product. Use RegGetValue
            in its place.]
            </para>
            <para>Retrieves a registry value.</para>
            </summary>
            <param name="hkey">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to the currently open key, or any of the following predefined values.</para>
            <para>HKEY_CLASSES_ROOT</para>
            <para>HKEY_CURRENT_CONFIG</para>
            <para>HKEY_CURRENT_USER</para>
            <para>HKEY_LOCAL_MACHINE</para>
            <para>HKEY_PERFORMANCE_DATA</para>
            <para>HKEY_USERS</para>
            </param>
            <param name="pszSubKey">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a <c>null</c>-terminated string that specifies the relative path from hkey to the subkey to retrieve the value from.
            This parameter can be <c>NULL</c> or an empty string, in which case the data is retrieved from the hkey location.
            </para>
            </param>
            <param name="pszValue">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a <c>null</c>-terminated string that contains the name of the value. This parameter can be <c>NULL</c> or an empty
            string, in which case the data is retrieved from the Default value.
            </para>
            </param>
            <param name="srrfFlags">
            <para>Type: <c>SRRF</c></para>
            <para>
            One or more of the SRRF flags that restricts the data to be retrieved. At least one type restriction (SRRF_RT) value must be specified.
            </para>
            </param>
            <param name="pdwType">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            A pointer to a <c>DWORD</c> that receives the type of data stored in the retrieved value. When using default values, the input
            pdwType is the type of the default value. For possible values, see Registry Data Types. If the SRRF_NOEXPAND flag is not set,
            REG_EXPAND_SZ types are automatically expanded and returned as REG_SZ. If type information is not required, this parameter can be <c>NULL</c>.
            </para>
            </param>
            <param name="pvData">
            <para>Type: <c>LPVOID</c></para>
            <para>
            A pointer to a buffer that receives the value's data. This parameter can be <c>NULL</c> if the data is not needed. For example,
            if you were testing only for a value's existence, the specific value data would be superfluous.
            </para>
            </param>
            <param name="pcbData">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            A pointer to a <c>DWORD</c> that, on entry, contains the size of the destination data buffer pvData, in bytes. This value can be
            <c>NULL</c> only if pvData is <c>NULL</c>. On exit, pcbData points to one of these values.
            </para>
            <list type="table">
            <listheader>
            <term>pvData</term>
            <term>Return Value</term>
            <term>pcbData</term>
            </listheader>
            <item>
            <term>NULL</term>
            <term>ERROR_SUCCESS</term>
            <term>
            Size in bytes sufficient to hold the registry data. Note that this is not guaranteed to be the precise size, but only a
            sufficient size.
            </term>
            </item>
            <item>
            <term>Non-NULL</term>
            <term>ERROR_SUCCESS</term>
            <term>Exact number of bytes written to pvData.</term>
            </item>
            <item>
            <term>Non-NULL</term>
            <term>ERROR_MORE_DATA</term>
            <term>
            Size in bytes needed to hold the entire data. Note that this is not guaranteed to be the precise size, but only a sufficient size.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns <c>ERROR_SUCCESS</c> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the
            FormatMessage function with the <c>FORMAT_MESSAGE_FROM_SYSTEM</c> flag to retrieve a generic description of the error.
            </para>
            </returns>
            <remarks>
            <para>
            <c>SHRegGetValue</c> provides data type checking, boot mode checking, auto-expansion of REG_EXPAND_SZ data, and guaranteed
            <c>null</c>-termination of REG_SZ, REG_EXPAND_SZ, and REG_MULTI_SZ data.
            </para>
            <para>
            The key identified by hkey must have been opened with KEY_QUERY_VALUE security access. If pszSubKey is not <c>NULL</c> or an
            empty string, that key also must be able to be opened with <c>KEY_QUERY_VALUE</c> security access in the current calling context.
            </para>
            <para>
            If the data's type is REG_SZ, REG_EXPAND_SZ or REG_MULTI_SZ, then any returned data includes or takes into account the string's
            <c>null</c>-termination. For example, if pvData is not <c>NULL</c>, the data returned in that buffer is <c>null</c>-terminated.
            If pcbData is not <c>NULL</c>, the buffer size that it points to includes the bytes required to hold the terminating <c>null</c> character.
            </para>
            <para>
            Unless the SRRF_NOEXPAND flag is set, string data of type REG_EXPAND_SZ is automatically expanded before being returned. The
            expanded string's type is reported in pdwType as REG_SZ, the pcbData parameter points to the number of bytes written for the
            expanded string, and the buffer pointed to by pvData holds the expanded version of the string.
            </para>
            <para>Performance Notes</para>
            <para>
            If pszSubKey is not <c>NULL</c> or an empty string, that key is opened and closed by this function each time it is accessed. If
            your application must retrieve a series of values from the same subkey, you will see better performance by opening the key using
            RegOpenKeyEx before calling <c>SHRegGetValue</c>. Use the key returned in the phkResult parameter of <c>RegOpenKeyEx</c> as the
            hkey parameter in this function, with pszSubKey set to <c>NULL</c>.
            </para>
            <para>
            The potential for an additional call to the registry to read or re-read the data exists when the data type is REG_EXPAND_SZ and
            the SRRF_NOEXPAND flag has not been set. The following conditions result in that additional call.
            </para>
            <list type="bullet">
            <item>
            <term>
            pvData is <c>NULL</c>, pcbData is not <c>NULL</c>. Though the data is not retrieved, the registry must be read to get the string
            and that string expanded to determine the required size of the data buffer.
            </term>
            </item>
            <item>
            <term>
            pvData is not <c>NULL</c>, but is too small to hold the data. The data is re-read to get the full string, the string is expanded,
            and the total required size is determined.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegGetValueFromHKCUHKLM(System.String,System.String,Vanara.PInvoke.ShlwApi.SRRF,Vanara.PInvoke.REG_VALUE_TYPE@,System.IntPtr,System.UInt32@)">
            <summary>
            <para>[This function is no longer supported.]</para>
            <para>
            Obtains specified information from the registry. This function will check HKEY_CURRENT_USER for the requested information in the
            specified subkey. If the information does not exist under the HKEY_CURRENT_USER subtree, the function checks the
            HKEY_LOCAL_MACHINE subtree for the same information.
            </para>
            </summary>
            <param name="pwszKey">
            <para>Type: <c>PCWSTR</c></para>
            <para>A pointer to a <c>null</c>-terminated Unicode string that specifies the path to the registry key.</para>
            </param>
            <param name="pwszValue">
            <para>Type: <c>PCWSTR</c></para>
            <para>
            A pointer to a <c>null</c>-terminated Unicode string that specifies the key value. This value can be <c>NULL</c>, in which case
            data is retrieved from the Default value.
            </para>
            </param>
            <param name="srrfFlags">
            <para>Type: <c>SRRF</c></para>
            <para>
            The SRRF flag constants. If more than one flag is used they can be combined using a bitwise OR. These flags are used to restrict
            the type of data returned. This value cannot be 0.
            </para>
            </param>
            <param name="pdwType">
            <para>Type: <c>DWORD*</c></para>
            <para>
            When this function returns, contains a pointer to a <c>DWORD</c> which receives a code that indicates the type of data stored in
            the specified value. This can be set to <c>NULL</c> if no type information is wanted. If this value is not <c>NULL</c>, and the
            SRRF_NOEXPAND flag has not been set, data types of REG_EXPAND_SZ will be returned as REG_SZ since they are automatically expanded
            in this method.
            </para>
            </param>
            <param name="pvData">
            <para>Type: <c>LPCVOID</c></para>
            <para>
            A pointer to a buffer that contains the value's data. This parameter can be <c>NULL</c> if the data is not needed. This value
            must contain the size of the pvData buffer on entry. If pvData is <c>NULL</c> (or if pvData is not <c>NULL</c>, but too small of
            a buffer to hold the registry data), then on exit it will contain the size required to hold the registry data.
            </para>
            </param>
            <param name="pcbData">
            <para>Type: <c>DWORD*</c></para>
            <para>When this function returns, contains a pointer to the size of the data, in bytes.</para>
            </param>
            <returns>
            <para>Type: <c>LONG</c></para>
            <para>
            If successful, this function returns ERROR_SUCCESS and all out parameters requested. Returns ERROR_MORE_DATA if the function
            fails due to insufficient space in a provided non- <c>NULL</c> pvData. In this case only pdwType and pcbData may contain valid
            data, pvData will be undefined. Otherwise, returns a nonzero error code defined in Winerror.h . You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegGetValueFromHKCUHKLM(System.String,System.String,Vanara.PInvoke.ShlwApi.SRRF,Vanara.PInvoke.REG_VALUE_TYPE@,Vanara.InteropServices.SafeAllocatedMemoryHandle,System.UInt32@)">
            <summary>
            <para>[This function is no longer supported.]</para>
            <para>
            Obtains specified information from the registry. This function will check HKEY_CURRENT_USER for the requested information in the
            specified subkey. If the information does not exist under the HKEY_CURRENT_USER subtree, the function checks the
            HKEY_LOCAL_MACHINE subtree for the same information.
            </para>
            </summary>
            <param name="pwszKey">
            <para>Type: <c>PCWSTR</c></para>
            <para>A pointer to a <c>null</c>-terminated Unicode string that specifies the path to the registry key.</para>
            </param>
            <param name="pwszValue">
            <para>Type: <c>PCWSTR</c></para>
            <para>
            A pointer to a <c>null</c>-terminated Unicode string that specifies the key value. This value can be <c>NULL</c>, in which case
            data is retrieved from the Default value.
            </para>
            </param>
            <param name="srrfFlags">
            <para>Type: <c>SRRF</c></para>
            <para>
            The SRRF flag constants. If more than one flag is used they can be combined using a bitwise OR. These flags are used to restrict
            the type of data returned. This value cannot be 0.
            </para>
            </param>
            <param name="pdwType">
            <para>Type: <c>DWORD*</c></para>
            <para>
            When this function returns, contains a pointer to a <c>DWORD</c> which receives a code that indicates the type of data stored in
            the specified value. This can be set to <c>NULL</c> if no type information is wanted. If this value is not <c>NULL</c>, and the
            SRRF_NOEXPAND flag has not been set, data types of REG_EXPAND_SZ will be returned as REG_SZ since they are automatically expanded
            in this method.
            </para>
            </param>
            <param name="pvData">
            <para>Type: <c>LPCVOID</c></para>
            <para>
            A pointer to a buffer that contains the value's data. This parameter can be <c>NULL</c> if the data is not needed. This value
            must contain the size of the pvData buffer on entry. If pvData is <c>NULL</c> (or if pvData is not <c>NULL</c>, but too small of
            a buffer to hold the registry data), then on exit it will contain the size required to hold the registry data.
            </para>
            </param>
            <param name="pcbData">
            <para>Type: <c>DWORD*</c></para>
            <para>When this function returns, contains a pointer to the size of the data, in bytes.</para>
            </param>
            <returns>
            <para>Type: <c>LONG</c></para>
            <para>
            If successful, this function returns ERROR_SUCCESS and all out parameters requested. Returns ERROR_MORE_DATA if the function
            fails due to insufficient space in a provided non- <c>NULL</c> pvData. In this case only pdwType and pcbData may contain valid
            data, pvData will be undefined. Otherwise, returns a nonzero error code defined in Winerror.h . You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegOpenUSKey(System.String,System.UInt32,Vanara.PInvoke.ShlwApi.HUSKEY,Vanara.PInvoke.ShlwApi.SafeHUSKEY@,System.Boolean)">
            <summary>
            <para>Opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
            </summary>
            <param name="pszPath">
            <para>TBD</para>
            </param>
            <param name="samDesired">
            <para>Type: <c>REGSAM</c></para>
            <para>The desired security access. For more information on security access, see REGSAM.</para>
            </param>
            <param name="hRelativeUSKey">
            <para>Type: <c>HUSKEY</c></para>
            <para>
            The key to be used as a base for relative paths. If pszPath is a relative path, the key it specifies will be relative to
            hRelativeUSKey. If pszPath is an absolute path, set hRelativeUSKey to <c>NULL</c>.
            </para>
            </param>
            <param name="phNewUSKey">
            <para>Type: <c>PHUSKEY</c></para>
            <para>A pointer to the handle of the opened key.</para>
            </param>
            <param name="fIgnoreHKCU">
            <para>Type: <c>BOOL</c></para>
            <para>
            The variable that specifies which key to look under. When set to <c>TRUE</c>, <c>SHRegOpenUSKey</c> ignores
            <c>HKEY_CURRENT_USER</c> and returns a value from <c>HKEY_LOCAL_MACHINE</c>.
            </para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegQueryInfoUSKey(Vanara.PInvoke.ShlwApi.HUSKEY,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,Vanara.PInvoke.ShlwApi.SHREGENUM_FLAGS)">
            <summary>
            <para>Retrieves information about a specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
            </summary>
            <param name="hUSKey">
            <para>Type: <c>HUSKEY</c></para>
            <para>
            A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more
            information, see Registry Key Security and Access Rights.
            </para>
            <para>This handle can be obtained through the SHRegOpenUSKey function.</para>
            </param>
            <param name="pcSubKeys">
            <para>Type: <c>LPDWORD</c></para>
            <para>A pointer to a <c>DWORD</c> that receives the number of subkeys under the specified key.</para>
            </param>
            <param name="pcchMaxSubKeyLen">
            <para>Type: <c>LPDWORD</c></para>
            <para>A pointer to a <c>DWORD</c> that receives the number of characters in the largest subkey name.</para>
            </param>
            <param name="pcValues">
            <para>Type: <c>LPDWORD</c></para>
            <para>A pointer to a <c>DWORD</c> that receives the number of values under the specified key.</para>
            </param>
            <param name="pcchMaxValueNameLen">
            <para>Type: <c>LPDWORD</c></para>
            <para>A pointer to a <c>DWORD</c> that receives the number of characters in the largest value name.</para>
            </param>
            <param name="enumRegFlags">
            <para>Type: <c>SHREGENUM_FLAGS</c></para>
            <para>One of the SHREGENUM_FLAGS that specifies the base key in which the query should take place.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegQueryUSValue(Vanara.PInvoke.ShlwApi.HUSKEY,System.String,Vanara.PInvoke.REG_VALUE_TYPE@,System.IntPtr,System.UInt32@,System.Boolean,System.IntPtr,System.UInt32)">
            <summary>
            <para>
            Retrieves the type and data for a specified name associated with an open registry subkey in a user-specific subtree
            (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
            </para>
            </summary>
            <param name="hUSKey">
            <para>Type: <c>HUSKEY</c></para>
            <para>
            A handle to a currently open registry subkey, or one of the following predefined values. The subkey must have been opened with
            the KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights.
            </para>
            <para>This handle can be obtained through the SHRegOpenUSKey function.</para>
            <para>HKEY_CLASSES_ROOT</para>
            <para>HKEY_CURRENT_CONFIG</para>
            <para>HKEY_CURRENT_USER</para>
            <para>HKEY_LOCAL_MACHINE</para>
            <para>HKEY_PERFORMANCE_DATA</para>
            <para>HKEY_USERS</para>
            </param>
            <param name="pszValue">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to the <c>null</c>-terminated string that contains the name of the value to be queried.</para>
            </param>
            <param name="pdwType">
            <para>Type: <c>LPDWORD*</c></para>
            <para>
            A pointer to the variable that sets or receives the key's value type. For more information, see Registry Data Types. This
            parameter can be <c>NULL</c>.
            </para>
            </param>
            <param name="pvData">
            <para>Type: <c>LPVOID*</c></para>
            <para>A pointer to the buffer that receives the value's data. This parameter can be <c>NULL</c> if the data is not required.</para>
            </param>
            <param name="pcbData">
            <para>Type: <c>LPDWORD*</c></para>
            <para>
            A pointer to the variable that specifies the size, in bytes, of the buffer pointed to by the pvData parameter. When the function
            returns, this variable contains the size of the data copied to pvData.
            </para>
            </param>
            <param name="fIgnoreHKCU">
            <para>Type: <c>BOOL</c></para>
            <para>
            The variable that specifies which key to look under. When set to <c>TRUE</c>, <c>SHRegQueryUSValue</c> ignores
            <c>HKEY_CURRENT_USER</c> and returns the value from the key under <c>HKEY_LOCAL_MACHINE</c>.
            </para>
            </param>
            <param name="pvDefaultData">
            <para>Type: <c>LPVOID*</c></para>
            <para>A pointer to the default data.</para>
            </param>
            <param name="dwDefaultDataSize">
            <para>Type: <c>DWORD</c></para>
            <para>The length, in bytes, of the default data.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
            <remarks>
            <para>
            When fIgnoreHKCU is set to <c>TRUE</c>, <c>SHRegQueryUSValue</c> returns the value from the key under <c>HKEY_LOCAL_MACHINE</c>.
            When set to <c>FALSE</c>, <c>SHRegQueryUSValue</c> first tries to return the value from the key under <c>HKEY_CURRENT_USER</c>.
            However, if the key is not found under <c>HKEY_CURRENT_USER</c>, the value returns from the key under <c>HKEY_LOCAL_MACHINE</c>.
            If neither key is present, or if an error occurs and dwDefaultDataSize is nonzero, then the default data is copied to pvData and
            ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which
            value copies to pvData. To prevent the use of default data, set pvDefaultData to <c>NULL</c> and dwDefaultDataSize to zero.
            </para>
            <para>
            If you only need to read a single value, SHRegGetUSValue will both open the key and return the value. To use
            <c>SHRegQueryUSValue</c>, you must first open the key with SHRegOpenUSKey. However, once the key is opened, you can use
            <c>SHRegQueryUSValue</c> as many times as necessary. If you need to retrieve more than one value from the same key, using
            multiple calls to <c>SHRegQueryUSValue</c> is usually more efficient than <c>SHRegGetUSValue</c>, as the key is only opened once.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegSetPath(Vanara.PInvoke.HKEY,System.String,System.String,System.String,System.UInt32)">
            <summary>
            <para>Takes a file path, replaces folder names with environment strings, and places the resulting string in the registry.</para>
            </summary>
            <param name="hKey">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to a key that is currently open, or a registry root key.</para>
            </param>
            <param name="pcszSubKey">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a null-terminated string containing the name of an existing subkey. If the subkey does not exist,
            <c>SHRegSetPath</c> will fail.
            </para>
            </param>
            <param name="pcszValue">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string with the name of the value to hold the path string.</para>
            </param>
            <param name="pcszPath">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string with a fully qualified file path.</para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>Reserved.</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>Returns ERROR_SUCCESS if successful, or a Windows error code otherwise.</para>
            </returns>
            <remarks>
            <para>
            For Windows 2000, <c>SHRegSetPath</c> uses PathUnExpandEnvStrings to convert folder names to their corresponding environment
            string. If any environment variables were substituted, the registry value will be set with the <c>REG_EXPAND_SZ</c> data type.
            Otherwise, it will be set with the <c>REG_SZ</c> data type.
            </para>
            <para>The following folder paths will be replaced by their equivalent environment string.</para>
            <list type="table">
            <listheader>
            <term>Folder</term>
            <term>Environment string</term>
            </listheader>
            <item>
            <term>The current user's profile folder</term>
            <term>%USERPROFILE%</term>
            </item>
            <item>
            <term>The All Users profile folder</term>
            <term>%ALLUSERSPROFILE%</term>
            </item>
            <item>
            <term>The Program Files folder</term>
            <term>%ProgramFiles%</term>
            </item>
            <item>
            <term>The system root folder</term>
            <term>%SystemRoot%</term>
            </item>
            <item>
            <term>The system drive letter</term>
            <term>%SystemDrive%</term>
            </item>
            </list>
            <para>
            <c>Note</c> %USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated
            from a service.
            </para>
            <para>
            The environment variables listed in the above table might not all be set on any particular system. If an environment variable is
            not set, it will not be unexpanded. In particular, none of these variables are set for the default environment of Windows 95 or
            Windows 98. The %ProgramFiles% variable is new for Windows 2000, and will typically not be set on Microsoft Windows NT 4.0 systems.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegSetUSValue(System.String,System.String,Vanara.PInvoke.REG_VALUE_TYPE,System.IntPtr,System.UInt32,Vanara.PInvoke.ShlwApi.SHREGSET)">
            <summary>
            <para>Sets a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
            </summary>
            <param name="pszSubKey">
            <para>TBD</para>
            </param>
            <param name="pszValue">
            <para>TBD</para>
            </param>
            <param name="dwType">
            <para>Type: <c>DWORD</c></para>
            <para>Type of data to be stored. This parameter must be the <c>REG_SZ</c> type. For more information, see Registry Data Types.</para>
            </param>
            <param name="pvData">
            <para>Type: <c>LPVOID*</c></para>
            <para>Apointer to a null-terminated string that contains the value to be set for the specified key.</para>
            </param>
            <param name="cbData">
            <para>Type: <c>DWORD</c></para>
            <para>Length, in bytes, of the string pointed to by the pvData parameter, not including the terminating null character.</para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>Flags indicating where the data should be written.</para>
            <para>SHREGSET_HKCU</para>
            <para>Write to <c>HKEY_CURRENT_USER</c> if empty.</para>
            <para>SHREGSET_FORCE_HKCU</para>
            <para>Write to <c>HKEY_CURRENT_USER</c>.</para>
            <para>SHREGSET_HKLM</para>
            <para>Write to <c>HKEY_LOCAL_MACHINE</c> if empty.</para>
            <para>SHREGSET_FORCE_HKLM</para>
            <para>Write to <c>HKEY_LOCAL_MACHINE</c>.</para>
            <para>SHREGSET_DEFAULT</para>
            <para>Equivalent to ( <c>SHREGSET_FORCE_HKCU</c> | <c>SHREGSET_HKLM</c>).</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
            <remarks>
            <para>
            This function opens the key each time it is used. If your code involves setting a series of values in the same key, it is more
            efficient to open the key once with SHRegOpenUSKey and then use SHRegWriteUSValue to write the data.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHRegWriteUSValue(Vanara.PInvoke.ShlwApi.HUSKEY,System.String,Vanara.PInvoke.REG_VALUE_TYPE,System.IntPtr,System.UInt32,Vanara.PInvoke.ShlwApi.SHREGSET)">
            <summary>
            <para>Writes a value to a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
            </summary>
            <param name="hUSKey">
            <para>Type: <c>HUSKEY</c></para>
            <para>
            A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more
            information, see Registry Key Security and Access Rights.
            </para>
            <para>This handle can be obtained through the SHRegOpenUSKey function.</para>
            </param>
            <param name="pszValue">
            <para>TBD</para>
            </param>
            <param name="dwType">
            <para>Type: <c>DWORD</c></para>
            <para>
            The type of the data to be stored in the value specified by pszValue. One of the following registry value types defined in
            Winnt.h and Wdm.h.
            </para>
            <para>REG_NONE (0x00000000)</para>
            <para>REG_SZ (0x00000001)</para>
            <para>REG_EXPAND_SZ (0x00000002)</para>
            <para>REG_BINARY (0x00000003)</para>
            <para>REG_DWORD (0x00000004)</para>
            <para>REG_DWORD_LITTLE_ENDIAN (0x00000004)</para>
            <para>REG_DWORD_BIG_ENDIAN (0x00000005)</para>
            <para>REG_LINK (0x00000006)</para>
            <para>REG_MULTI_SZ (0x00000007)</para>
            <para>REG_RESOURCE_LIST (0x00000008)</para>
            <para>REG_FULL_RESOURCE_DESCRIPTOR (0x00000009)</para>
            <para>REG_RESOURCE_REQUIREMENTS_LIST (0x0000000A)</para>
            <para>REG_QWORD (0x0000000B)</para>
            <para>REG_QWORD_LITTLE_ENDIAN (0x0000000B)</para>
            </param>
            <param name="pvData">
            <para>Type: <c>const void*</c></para>
            <para>
            A pointer to the data to be set for the value specified by pszValue. For string-based types, such as REG_SZ, the string must be
            null-terminated. With the REG_MULTI_SZ data type, the string must be terminated with two null characters. A backslash in a path
            must be preceded by another backslash as an escape character. For example, specify "C:\mydir\myfile" to store the string "C:\mydir\myfile".
            </para>
            </param>
            <param name="cbData">
            <para>Type: <c>DWORD</c></para>
            <para>
            The size, in bytes, of the data pointed to by the pvData parameter. If the data is of type REG_SZ, REG_EXPAND_SZ, or
            REG_MULTI_SZ, cbData must include the size of the terminating null character or characters.
            </para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>Flags that indicate the subtree to which the data should be written. One or more of the following values:</para>
            <para>SHREGSET_HKCU (0x00000001)</para>
            <para>
            Write to <c>HKEY_CURRENT_USER</c> only if a value of the name specified in pszValue does not currently exist under the specified subkey.
            </para>
            <para>SHREGSET_FORCE_HKCU (0x00000002)</para>
            <para>Write to <c>HKEY_CURRENT_USER</c>. If a value of the name specified in pszValue already exists, it will be overwritten.</para>
            <para>SHREGSET_HKLM (0x00000004)</para>
            <para>
            Write to <c>HKEY_LOCAL_MACHINE</c> only if a value of the name specified in pszValue does not currently exist under the specified subkey..
            </para>
            <para>SHREGSET_FORCE_HKLM (0x00000008)</para>
            <para>Write to <c>HKEY_LOCAL_MACHINE</c>. If a value of the name specified in pszValue already exists, it will be overwritten.</para>
            <para>SHREGSET_DEFAULT (0x00000006)</para>
            <para>Equivalent to ( <c>SHREGSET_FORCE_HKCU</c> | <c>SHREGSET_HKLM</c>).</para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
            <remarks>
            <para>
            To use <c>SHRegWriteUSValue</c>, you must first open the key with SHRegOpenUSKey. Once the key is opened, you can use
            <c>SHRegWriteUSValue</c> as many times as necessary.
            </para>
            <para>If you only need to write a single value, you should use SHRegSetUSValue, which both opens the key and writes the value.</para>
            <para>
            If you need to write more than one value on the same key, multiple calls to <c>SHRegWriteUSValue</c> are usually more efficient
            than SHRegSetUSValue, because the key is only opened once.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHReleaseThreadRef">
            <summary>
            <para>Releases a thread reference before the thread procedure returns.</para>
            </summary>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHSendMessageBroadcast(System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            [This function is available through Windows XP and Windows Server 2003. It might be altered or unavailable in subsequent versions
            of Windows.]
            </para>
            <para>Sends a message to all top-level windows in the system.</para>
            </summary>
            <param name="uMsg">
            <para>Type: <c>UINT</c></para>
            <para>The message to send.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value is not meaningful.</para>
            </returns>
            <remarks>
            <para>
            <c>SHSendMessageBroadcast</c> is equivalent to SendMessage with <c>HWND_BROADCAST</c>. To avoid causing the Shell to become
            unresponsive in the case where there could be a window in the system that is not responding to messages, use <c>SHSendMessageBroadcast</c>.
            </para>
            <para>
            <c>SHSendMessageBroadcast</c> is not exported by name. <c>SHSendMessageBroadcastA</c> is exported from Shlwapi.dll as ordinal
            432. <c>SHSendMessageBroadcastW</c> is exported from Shlwapi.dll as ordinal 433.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHSetThreadRef(System.Object)">
            <summary>
            <para>
            Stores a per-thread reference to a Component Object Model (COM) object. This allows the caller to control the thread's lifetime
            so that it can ensure that Windows won't shut down the thread before the caller is ready.
            </para>
            </summary>
            <param name="punk">
            <para>Type: <c>IUnknown*</c></para>
            <para>A pointer to the IUnknown of the object for which you want to store a reference. This value can be <c>NULL</c>.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>Use SHGetThreadRef to retrieve the IUnknown pointer.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHSetValue(Vanara.PInvoke.HKEY,System.String,System.String,Vanara.PInvoke.REG_VALUE_TYPE,System.IntPtr,System.UInt32)">
            <summary>
            <para>Sets the value of a registry key.</para>
            </summary>
            <param name="hkey">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to the currently open key, or any of the following predefined values.</para>
            <para>HKEY_CLASSES_ROOT</para>
            <para>HKEY_CURRENT_CONFIG</para>
            <para>HKEY_CURRENT_USER</para>
            <para>HKEY_LOCAL_MACHINE</para>
            <para>HKEY_PERFORMANCE_DATA</para>
            <para>HKEY_USERS</para>
            </param>
            <param name="pszSubKey">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The address of a null-terminated string that specifies the name of the subkey with which a value is associated. This can be
            <c>NULL</c> or a pointer to an empty string. In this case, the value is added to the key identified by the hkey parameter.
            </para>
            </param>
            <param name="pszValue">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The address of a null-terminated string that specifies the value. This value can be <c>NULL</c>.</para>
            </param>
            <param name="dwType">
            <para>Type: <c>DWORD</c></para>
            <para>Type of data to be stored. This parameter must be the <c>REG_SZ</c> type. For more information, see Registry Data Types.</para>
            </param>
            <param name="pvData">
            <para>Type: <c>LPCVOID</c></para>
            <para>Pointer to a buffer that contains the data to set for the specified value. This value can be <c>NULL</c>.</para>
            </param>
            <param name="cbData">
            <para>Type: <c>DWORD</c></para>
            <para>
            Length, in bytes, of the buffer pointed to by the pvData parameter. If the data is a null-terminated string, this length includes
            the terminating null character.
            </para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHSetValue(Vanara.PInvoke.HKEY,System.String,System.String,Vanara.PInvoke.REG_VALUE_TYPE,Vanara.InteropServices.SafeAllocatedMemoryHandle,System.UInt32)">
            <summary>
            <para>Sets the value of a registry key.</para>
            </summary>
            <param name="hkey">
            <para>Type: <c>HKEY</c></para>
            <para>A handle to the currently open key, or any of the following predefined values.</para>
            <para>HKEY_CLASSES_ROOT</para>
            <para>HKEY_CURRENT_CONFIG</para>
            <para>HKEY_CURRENT_USER</para>
            <para>HKEY_LOCAL_MACHINE</para>
            <para>HKEY_PERFORMANCE_DATA</para>
            <para>HKEY_USERS</para>
            </param>
            <param name="pszSubKey">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The address of a null-terminated string that specifies the name of the subkey with which a value is associated. This can be
            <c>NULL</c> or a pointer to an empty string. In this case, the value is added to the key identified by the hkey parameter.
            </para>
            </param>
            <param name="pszValue">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The address of a null-terminated string that specifies the value. This value can be <c>NULL</c>.</para>
            </param>
            <param name="dwType">
            <para>Type: <c>DWORD</c></para>
            <para>Type of data to be stored. This parameter must be the <c>REG_SZ</c> type. For more information, see Registry Data Types.</para>
            </param>
            <param name="pvData">
            <para>Type: <c>LPCVOID</c></para>
            <para>Pointer to a buffer that contains the data to set for the specified value. This value can be <c>NULL</c>.</para>
            </param>
            <param name="cbData">
            <para>Type: <c>DWORD</c></para>
            <para>
            Length, in bytes, of the buffer pointed to by the pvData parameter. If the data is a null-terminated string, this length includes
            the terminating null character.
            </para>
            </param>
            <returns>
            <para>Type: <c>LSTATUS</c></para>
            <para>
            Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the FormatMessage
            function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHSkipJunction(System.Runtime.InteropServices.ComTypes.IBindCtx,System.Guid@)">
            <summary>
            <para>Checks a bind context to see if it is safe to bind to a particular component object.</para>
            </summary>
            <param name="pbc">
            <para>Type: <c>IBindCtx*</c></para>
            <para>A pointer to an IBindCtx interface that specifies the bind context you want to check. This value can be <c>NULL</c>.</para>
            </param>
            <param name="pclsid">
            <para>Type: <c>const CLSID*</c></para>
            <para>
            A pointer to a variable that specifies the <c>CLSID</c> of the object being tested to see if it must be skipped. Typically, this
            is the CLSID of the object that IShellFolder::BindToObject is about to create.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if the object specified by pclsid must be skipped, or <c>FALSE</c> otherwise.</para>
            </returns>
            <remarks>
            <para>
            This function can be used to avoid infinite cycles in namespace binding. For example, a folder shortcut that refers to a folder
            above it in the namespace tree can produce an infinitely recursive loop.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHStrDup(System.String,System.String@)">
            <summary>
            <para>Makes a copy of a string in newly allocated memory.</para>
            </summary>
            <param name="psz">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to the null-terminated string to be copied.</para>
            </param>
            <param name="ppwsz">
            <para>Type: <c>LPTSTR*</c></para>
            <para>
            A pointer to an allocated Unicode string that contains the result. <c>SHStrDup</c> allocates memory for this string with
            CoTaskMemAlloc. You should free the string with CoTaskMemFree when it is no longer needed.
            </para>
            <para>In the case of failure, this value is NULL.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns S_OK if successful, or a COM error value otherwise.</para>
            </returns>
            <remarks>
            <para>This function will take either Unicode or ANSI strings as input, but the copied string is always Unicode.</para>
            <para>
            This function uses CoTaskMemAlloc to allocate memory for the copied string. You must free this memory with CoTaskMemFree when it
            is no longer needed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHStripMneumonic(System.Text.StringBuilder)">
            <summary>
            <para>
            [This function is available through Windows XP and Windows Server 2003. It might be altered or unavailable in subsequent versions
            of Windows.]
            </para>
            <para>Removes the mnemonic marker from a string.</para>
            </summary>
            <param name="pszMenu">
            <para>Type: <c>LPTSTR*</c></para>
            <para>A pointer to the null-terminated string that contains the mnemonic marker.</para>
            </param>
            <returns>
            <para>Type: <c>TCHAR</c></para>
            <para>Returns the mnemonic character, if one was found. Otherwise, returns 0.</para>
            </returns>
            <remarks>
            <para>The term "mnemonic" is misspelled in the function name.</para>
            <para>The function supports the following mnemonic formats.</para>
            <list type="table">
            <listheader>
            <term>Input String</term>
            <term>Output String</term>
            <term>Mnemonic Character</term>
            <term>Remarks</term>
            </listheader>
            <item>
            <term>"Str&amp;ing"</term>
            <term>"String"</term>
            <term>'i'</term>
            <term>None.</term>
            </item>
            <item>
            <term>"String (&amp;S)"</term>
            <term>"String"</term>
            <term>'S'</term>
            <term>Supported only by the Unicode version of this function. Requires Windows XP or later.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHUnicodeToAnsi(System.String,System.Text.StringBuilder,System.Int32)">
            <summary>
            <para>
            [This function is available through Windows XP and Windows Server 2003. It might be altered or unavailable in subsequent versions
            of Windows.]
            </para>
            <para>Converts a string from the Unicode code page to the ANSI code page.</para>
            </summary>
            <param name="pwszSrc">
            <para>Type: <c>PCWSTR</c></para>
            <para>A pointer to the null-terminated Unicode string to be converted to ANSI.</para>
            </param>
            <param name="pszDst">
            <para>Type: <c>PSTR</c></para>
            <para>
            A pointer to a buffer that, when this function returns successfully, receives the converted characters. The buffer must be large
            enough to contain the number of <c>CHAR</c> characters specified by the cchBuf parameter, including room for a terminating null character.
            </para>
            </param>
            <param name="cchBuf">
            <para>Type: <c>int</c></para>
            <para>
            The number of <c>CHAR</c> values that can be contained by the buffer pointed to by pszDst. The value assigned to parameter must
            be greater than zero.
            </para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            Returns the number of <c>CHAR</c> values written to the output buffer, including the terminating null character. Returns 0 if unsuccessful.
            </para>
            </returns>
            <remarks>
            <para>
            <c>Security Warning:</c> Using this function incorrectly can compromise the security of your application. For example, if pszDst
            buffer is not large enough to contain the number of characters specified by cchBuf, a buffer overrun can occur. Buffer overruns
            can cause a denial of service attack against an application if an access violation occurs. In the worst case, a buffer overrun
            might allow an attacker to inject executable code into your process, especially if pszDst is a stack-based buffer. In addition,
            the output string is silently truncated if it is too large for the buffer. This can cause canonicalization or other security vulnerabilities.
            </para>
            <para>
            If the pszDst buffer is not large enough to contain the entire converted output string, the string is truncated to fit the
            buffer. There is no way to detect that the return string has been truncated. The string will always be null-terminated, even if
            it has been truncated. This function takes care to not truncate between the lead and trail bytes of a DBCS character pair. In
            that case, only cchBuf-1 characters are returned.
            </para>
            <para>If the pwszSrc and pszDst buffers overlap, the function's behavior is undefined.</para>
            <para>
            <c>Note</c> Do not assume that the function has not changed any of the characters in the output buffer that follow the string's
            terminating null character. The contents of the output buffer following the string's terminating null character are undefined, up
            to and including the last character in the buffer.
            </para>
            <para><c>SHTCharToAnsi</c> is defined to be the same as <c>SHUnicodeToAnsi</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHUnicodeToUnicode(System.String,System.Text.StringBuilder,System.Int32)">
            <summary>
            <para>
            [This function is available through Windows XP and Windows Server 2003. It might be altered or unavailable in subsequent versions
            of Windows.]
            </para>
            <para>Copies a Unicode string.</para>
            </summary>
            <param name="pwzSrc">
            <para>Type: <c>PCWSTR</c></para>
            <para>A pointer to a null-terminated Unicode string to be copied to the output buffer.</para>
            </param>
            <param name="pwzDst">
            <para>Type: <c>PWSTR</c></para>
            <para>
            A pointer to an output buffer to receive the copied characters. The buffer must be large enough to contain the number of
            <c>WCHAR</c> characters specified by cwchBuf, including room for a terminating null character.
            </para>
            </param>
            <param name="cwchBuf">
            <para>Type: <c>int</c></para>
            <para>
            The number of <c>WCHAR</c> characters that can be contained by the buffer pointed to by pwzDst parameter. This parameter must be
            greater than zero.
            </para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            Returns the number of <c>WCHAR</c> characters written to the output buffer, including the terminating null character. Returns 0
            if unsuccessful.
            </para>
            </returns>
            <remarks>
            <para>
            <c>Security Warning:</c> Using this function incorrectly can compromise the security of your application. For example, if pwzDst
            buffer is not large enough to contain the number of characters specified by cwchBuf, a buffer overrun can occur. Buffer overruns
            can cause a denial of service attack against an application if an access violation occurs. In the worst case, a buffer overrun
            might allow an attacker to inject executable code into your process, especially if pwzDst is a stack-based buffer. When copying
            an entire string, note that sizeof returns the number of bytes, which is not the correct value to use for the cwchBuf parameter.
            Instead, use sizeof(pwzDst)/sizeof(WCHAR). Note that this technique assumes that pwzDst is an array, not a pointer. Note also
            that the function silently truncates the output string if the buffer is not large enough. This can result in canonicalization or
            other security vulnerabilities.
            </para>
            <para>
            If the pwzDst buffer is not large enough to contain the entire converted output string, the string is truncated to fit the
            buffer. There is no way to detect that the return string has been truncated. The string will always be null-terminated, even if
            it has been truncated. This ensures that no more than cwchBuf characters are copied to pwzDst. No attempt is made to avoid
            truncating the string in the middle of a Unicode surrogate pair.
            </para>
            <para>If the pwzSrc and pwzDst buffers overlap, the function's behavior is undefined.</para>
            <para>
            <c>Note</c> Do not assume that the function has not changed any of the characters in the output buffer that follow the string's
            terminating null character. The contents of the output buffer following the string's terminating null character are undefined, up
            to and including the last character in the buffer.
            </para>
            <para><c>SHTCharToUnicode</c> is defined to be the same as <c>SHUnicodeToUnicode</c>.</para>
            <para><c>SHUnicodeToTChar</c> is defined to be the same as <c>SHUnicodeToUnicode</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SHUnlockShared(System.IntPtr)">
            <summary>
            <para>
            [ <c>SHUnlockShared</c> is available for use in the operating systems specified in the Requirements section. It may be altered or
            unavailable in subsequent versions.]
            </para>
            <para>Unlocks memory locked by SHLockShared.</para>
            </summary>
            <param name="pvData">
            <para>Type: <c>void*</c></para>
            <para>A pointer to the shared memory block returned by SHLockShared.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            If the function succeeds, the return value is <c>TRUE</c> and all modified pages within the specified range are written to the
            disk with low priority. If the function fails, the return value is <c>FALSE</c>. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>Call SHFreeShared to free the memory block.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.WhichPlatform">
            <summary>
            <para>
            [ <c>WhichPlatform</c> is available for use in the operating systems specified in the Requirements section. It may be altered or
            unavailable in subsequent versions.]
            </para>
            <para>Retrieves a value that indicates the type of Shell32.dll that the platform contains.</para>
            </summary>
            <returns>
            <para>Type: <c>UINT</c></para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>PLATFORM_UNKNOWN</term>
            <term>The function was unable to determine the Shell32.dll version.</term>
            </item>
            <item>
            <term>PLATFORM_IE3</term>
            <term>Obsolete: Use PLATFORM_BROWSERONLY.</term>
            </item>
            <item>
            <term>PLATFORM_BROWSERONLY</term>
            <term>The Shell32.dll version is browser-only, with no new shell.</term>
            </item>
            <item>
            <term>PLATFORM_INTEGRATED</term>
            <term>The platform contains an integrated shell.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>This function always returns PLATFORM_INTEGRATED because Windows XP comes with an integrated shell.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.HUSKEY">
            <summary>Provides a handle to a user specific registry key.</summary>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.HUSKEY.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.ShlwApi.HUSKEY"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.ShlwApi.HUSKEY.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.ShlwApi.HUSKEY"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.ShlwApi.HUSKEY.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.HUSKEY.op_Explicit(Vanara.PInvoke.ShlwApi.HUSKEY)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.ShlwApi.HUSKEY"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.HUSKEY.op_Implicit(System.IntPtr)~Vanara.PInvoke.ShlwApi.HUSKEY">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.ShlwApi.HUSKEY"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.HUSKEY.op_Inequality(Vanara.PInvoke.ShlwApi.HUSKEY,Vanara.PInvoke.ShlwApi.HUSKEY)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.HUSKEY.op_Equality(Vanara.PInvoke.ShlwApi.HUSKEY,Vanara.PInvoke.ShlwApi.HUSKEY)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.HUSKEY.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.HUSKEY.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.HUSKEY.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.QITAB">
            <summary>
            <para>Used by the QISearch function to describe a single interface.</para>
            </summary>
            <remarks>
            <para>
            <c>Note</c> Prior to Windows Vista, <c>QITAB</c> was not declared in a public header file. To use it in those cases, you must use
            define it yourself as it is given here. Under Windows Vista, <c>QITAB</c> is included in Shlwapi.h and this is not necessary.
            </para>
            <para>
            To mark the end of a <c>QITAB</c> table, set the <c>piid</c> member to <c>NULL</c> and the <c>dwOffset</c> member to 0. See the
            QISearch function for an example of how to use this structure.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.QITAB.piid">
            <summary>
            <para>Type: <c>const IID*</c></para>
            <para>A pointer to the IID of the interface represented by this structure.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.QITAB.dwOffset">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The offset, in bytes, from the base of the object to the start of the interface.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.SafeHUSKEY">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <see cref="T:Vanara.PInvoke.ShlwApi.HUSKEY"/> that is disposed using <see cref="M:Vanara.PInvoke.ShlwApi.SHRegCloseUSKey(Vanara.PInvoke.ShlwApi.HUSKEY)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SafeHUSKEY.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.ShlwApi.SafeHUSKEY"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SafeHUSKEY.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.ShlwApi.SafeHUSKEY"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SafeHUSKEY.op_Implicit(Vanara.PInvoke.ShlwApi.SafeHUSKEY)~Vanara.PInvoke.ShlwApi.HUSKEY">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.ShlwApi.SafeHUSKEY"/> to <see cref="T:Vanara.PInvoke.ShlwApi.HUSKEY"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.SafeHUSKEY.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.CLSID_QueryAssociations">
            <summary>CLSID_QueryAssociations</summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.ASSOCF">
            <summary>Provides information to the <c>IQueryAssociations</c> interface methods.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCF.ASSOCF_NONE">
            <summary>None of the following options are set.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCF.ASSOCF_INIT_NOREMAPCLSID">
            <summary>Instructs <c>IQueryAssociations</c> interface methods not to map CLSID values to ProgID values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCF.ASSOCF_INIT_BYEXENAME">
            <summary>
            Identifies the value of the pwszAssoc parameter of <c>IQueryAssociations::Init</c> as an executable file name. If this flag
            is not set, the root key will be set to the ProgID associated with the <c>.exe</c> key instead of the executable file's ProgID.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCF.ASSOCF_OPEN_BYEXENAME">
            <summary>Identical to <c><c>ASSOCF_INIT_BYEXENAME</c></c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCF.ASSOCF_INIT_DEFAULTTOSTAR">
            <summary>
            Specifies that when an <c>IQueryAssociations</c> method does not find the requested value under the root key, it should
            attempt to retrieve the comparable value from the <c>*</c> subkey.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCF.ASSOCF_INIT_DEFAULTTOFOLDER">
            <summary>
            Specifies that when a <c>IQueryAssociations</c> method does not find the requested value under the root key, it should
            attempt to retrieve the comparable value from the <c>Folder</c> subkey.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCF.ASSOCF_NOUSERSETTINGS">
            <summary>
            Specifies that only <c>HKEY_CLASSES_ROOT</c> should be searched, and that <c>HKEY_CURRENT_USER</c> should be ignored.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCF.ASSOCF_NOTRUNCATE">
            <summary>
            Specifies that the return string should not be truncated. Instead, return an error value and the required size for the
            complete string.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCF.ASSOCF_VERIFY">
            <summary>
            Specifies that the return string should not be truncated. Instead, return an error value and the required size for the
            complete string.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCF.ASSOCF_REMAPRUNDLL">
            <summary>
            Instructs <c>IQueryAssociations</c> methods to ignore Rundll.exe and return information about its target. Typically
            <c>IQueryAssociations</c> methods return information about the first .exe or .dll in a command string. If a command uses
            Rundll.exe, setting this flag tells the method to ignore Rundll.exe and return information about its target.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCF.ASSOCF_NOFIXUPS">
            <summary>
            Instructs <c>IQueryAssociations</c> methods not to fix errors in the registry, such as the friendly name of a function not
            matching the one found in the .exe file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCF.ASSOCF_IGNOREBASECLASS">
            <summary>Specifies that the BaseClass value should be ignored.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCF.ASSOCF_INIT_IGNOREUNKNOWN">
            <summary><c>Introduced in Windows 7</c>. Specifies that the "Unknown" ProgID should be ignored; instead, fail.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCF.ASSOCF_INIT_FIXED_PROGID">
            <summary>
            <c>Introduced in Windows 8</c>. Specifies that the supplied ProgID should be mapped using the system defaults, rather than
            the current user defaults.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCF.ASSOCF_IS_PROTOCOL">
            <summary>
            <c>Introduced in Windows 8</c>. Specifies that the value is a protocol, and should be mapped using the current user defaults.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCF.ASSOCF_INIT_FOR_FILE">
            <summary>
            <c>Introduced in Windows 8.1</c>. Specifies that the ProgID corresponds with a file extension based association. Use together
            with <c>ASSOCF_INIT_FIXED_PROGID</c>.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.ASSOCKEY">
            <summary>
            <para>Specifies the type of key to be returned by IQueryAssociations::GetKey.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCKEY.ASSOCKEY_SHELLEXECCLASS">
            <summary>A key that is passed to ShellExecuteEx through a SHELLEXECUTEINFO structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCKEY.ASSOCKEY_APP">
            <summary>An Application key for the file type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCKEY.ASSOCKEY_CLASS">
            <summary>A ProgID or class key.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCKEY.ASSOCKEY_BASECLASS">
            <summary>A BaseClass value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCKEY.ASSOCKEY_MAX">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.ASSOCSTR">
            <summary>
            <para>Used by IQueryAssociations::GetString to define the type of string that is to be returned.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_COMMAND">
            <summary>A command string associated with a Shell verb.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_EXECUTABLE">
            <summary>
            An executable from a Shell verb command string. For example, this string is found as the (Default) value for a subkey such as
            HKEY_CLASSES_ROOT\\shell\Open\command. If the command uses Rundll.exe, set the ASSOCF_REMAPRUNDLL flag in the parameter of
            IQueryAssociations::GetString to retrieve the target executable. This type of string will identify the code that will be
            invoked in the implementation of the verb.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_FRIENDLYDOCNAME">
            <summary>The friendly name of a document type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_FRIENDLYAPPNAME">
            <summary>The friendly name of an executable file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_NOOPEN">
            <summary>Ignore the information associated with the open subkey.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_SHELLNEWVALUE">
            <summary>Look under the ShellNew subkey.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_DDECOMMAND">
            <summary>A template for DDE commands.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_DDEIFEXEC">
            <summary>The DDE command to use to create a process.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_DDEAPPLICATION">
            <summary>The application name in a DDE broadcast.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_DDETOPIC">
            <summary>The topic name in a DDE broadcast.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_INFOTIP">
            <summary>
            Corresponds to the InfoTip registry value. Returns an info tip for an item, or list of properties in the form of an
            IPropertyDescriptionList from which to create an info tip, such as when hovering the cursor over a file name. The list of
            properties can be parsed with PSGetPropertyDescriptionListFromString.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_QUICKTIP">
            <summary>
            Introduced in Internet Explorer 6. Corresponds to the QuickTip registry value. Same as ASSOCSTR_INFOTIP, except that it
            always returns a list of property names in the form of an IPropertyDescriptionList. The difference between this value and
            ASSOCSTR_INFOTIP is that this returns properties that are safe for any scenario that causes slow property retrieval, such as
            offline or slow networks. Some of the properties returned from ASSOCSTR_INFOTIP might not be appropriate for slow property
            retrieval scenarios. The list of properties can be parsed with PSGetPropertyDescriptionListFromString.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_TILEINFO">
            <summary>
            Introduced in Internet Explorer 6. Corresponds to the TileInfo registry value. Contains a list of properties to be displayed
            for a particular file type in a Windows Explorer window that is in tile view. This is the same as ASSOCSTR_INFOTIP, but, like
            ASSOCSTR_QUICKTIP, it also returns a list of property names in the form of an IPropertyDescriptionList. The list of
            properties can be parsed with PSGetPropertyDescriptionListFromString.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_CONTENTTYPE">
            <summary>
            Introduced in Internet Explorer 6. Describes a general type of MIME file association, such as image and bmp, so that
            applications can make general assumptions about a specific file type.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_DEFAULTICON">
            <summary>
            Introduced in Internet Explorer 6. Returns the path to the icon resources to use by default for this association. Positive
            numbers indicate an index into the dll's resource table, while negative numbers indicate a resource ID. An example of the
            syntax for the resource is "c:\myfolder\myfile.dll,-1".
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_SHELLEXTENSION">
            <summary>
            Introduced in Internet Explorer 6. For an object that has a Shell extension associated with it, you can use this to retrieve
            the CLSID of that Shell extension object by passing a string representation of the IID of the interface you want to retrieve
            as the parameter of IQueryAssociations::GetString. For example, if you want to retrieve a handler that implements the
            IExtractImage interface, you would specify "{BB2E617C-0920-11d1-9A0B-00C04FC2D6C1}", which is the IID of IExtractImage.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_DROPTARGET">
            <summary>
            Introduced in Internet Explorer 8.. For a verb invoked through COM and the IDropTarget interface, you can use this flag to
            retrieve the IDropTarget object's CLSID. This CLSID is registered in the DropTarget subkey. The verb is specified in the
            parameter in the call to IQueryAssociations::GetString. This type of string will identify the code that will be invoked in
            the implementation of the verb.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_DELEGATEEXECUTE">
            <summary>
            Introduced in Internet Explorer 8.. For a verb invoked through COM and the IExecuteCommand interface, you can use this flag
            to retrieve the IExecuteCommand object's CLSID. This CLSID is registered in the verb's command subkey as the DelegateExecute
            entry. The verb is specified in the parameter in the call to IQueryAssociations::GetString. This type of string will identify
            the code that will be invoked in the implementation of the verb.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_SUPPORTED_URI_PROTOCOLS">
            <summary>Introduced in Windows 8.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_PROGID">
            <summary>
            The ProgID provided by the app associated with the file type or URI scheme. This if configured by users in their default
            program settings.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_APPID">
            <summary>
            The AppUserModelID of the app associated with the file type or URI scheme. This is configured by users in their default
            program settings.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_APPPUBLISHER">
            <summary>
            The publisher of the app associated with the file type or URI scheme. This is configured by users in their default program settings.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_APPICONREFERENCE">
            <summary>
            The icon reference of the app associated with the file type or URI scheme. This is configured by users in their default
            program settings.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.ASSOCSTR.ASSOCSTR_MAX">
            <summary>The maximum defined ASSOCSTR value, used for validation purposes.</summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.PERCEIVED">
            <summary>
            <para>Specifies a file's perceived type. This set of constants is used in the AssocGetPerceivedType function.</para>
            </summary>
            <remarks>
            <para>Prior to Windows Vista, this enumeration was declared in Shlwapi.h.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVED.PERCEIVED_TYPE_CUSTOM">
            <summary>The file's perceived type as defined in the registry is not a known type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVED.PERCEIVED_TYPE_UNSPECIFIED">
            <summary>The file does not have a perceived type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVED.PERCEIVED_TYPE_FOLDER">
            <summary>Not used.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVED.PERCEIVED_TYPE_UNKNOWN">
            <summary>
            The file's perceived type hasn't yet been requested. This is the cached type of the object when it is created. This value is
            never returned by AssocGetPerceivedType.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVED.PERCEIVED_TYPE_TEXT">
            <summary>The file's perceived type is "text".</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVED.PERCEIVED_TYPE_IMAGE">
            <summary>The file's perceived type is "image".</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVED.PERCEIVED_TYPE_AUDIO">
            <summary>The file's perceived type is "audio".</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVED.PERCEIVED_TYPE_VIDEO">
            <summary>The file's perceived type is "video".</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVED.PERCEIVED_TYPE_COMPRESSED">
            <summary>The file's perceived type is "compressed".</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVED.PERCEIVED_TYPE_DOCUMENT">
            <summary>The file's perceived type is "document".</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVED.PERCEIVED_TYPE_SYSTEM">
            <summary>The file's perceived type is "system".</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVED.PERCEIVED_TYPE_APPLICATION">
            <summary>The file's perceived type is "application".</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVED.PERCEIVED_TYPE_GAMEMEDIA">
            <summary>Windows Vista and later. The file's perceived type is "gamemedia".</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVED.PERCEIVED_TYPE_CONTACTS">
            <summary>Windows Vista and later. The file's perceived type is "contacts"</summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.PERCEIVEDFLAG">
            <summary>Indicates the source of the perceived type information.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVEDFLAG.PERCEIVEDFLAG_UNDEFINED">
            <summary>No perceived type was found (PERCEIVED_TYPE_UNSPECIFIED).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVEDFLAG.PERCEIVEDFLAG_SOFTCODED">
            <summary>The perceived type was determined through an association in the registry.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVEDFLAG.PERCEIVEDFLAG_HARDCODED">
            <summary>The perceived type is inherently known to Windows.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVEDFLAG.PERCEIVEDFLAG_NATIVESUPPORT">
            <summary>The perceived type was determined through a codec provided with Windows.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVEDFLAG.PERCEIVEDFLAG_GDIPLUS">
            <summary>The perceived type is supported by the GDI+ library.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVEDFLAG.PERCEIVEDFLAG_WMSDK">
            <summary>The perceived type is supported by the Windows Media SDK.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PERCEIVEDFLAG.PERCEIVEDFLAG_ZIPFOLDER">
            <summary>The perceived type is supported by Windows compressed folders.</summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.IQueryAssociations">
            <summary>
            Exposes methods that simplify the process of retrieving information stored in the registry in association with defining a file
            type or protocol and associating it with an application.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IQueryAssociations.Init(Vanara.PInvoke.ShlwApi.ASSOCF,System.String,Vanara.PInvoke.HKEY,Vanara.PInvoke.HWND)">
            <summary>Initializes the IQueryAssociations interface and sets the root key to the appropriate ProgID.</summary>
            <param name="flags">
            A flag that specifies how the search is to be initialized. It is typically set to zero, but it can also take one of the
            following ASSOCF values.
            </param>
            <param name="pszAssoc">
            A Unicode string that is used to determine the root key. If a value is specified for hkProgid, set this parameter to NULL.
            Four types of string can be used:
            <list type="bullet">
            <item>
            <term>File name extension</term>
            <description>A file name extension, such as .txt.</description>
            </item>
            <item>
            <term>CLSID</term>
            <description>A CLSID GUID in the standard "{GUID}" format.</description>
            </item>
            <item>
            <term>ProgID</term>
            <description>An application's ProgID, such as Word.Document.8.</description>
            </item>
            <item>
            <term>Executable name</term>
            <description>The name of an application's .exe file. The ASSOCF_OPEN_BYEXENAME flag must be set in flags.</description>
            </item>
            </list>
            </param>
            <param name="hkProgid">
            The HKEY value of the subkey that is used as a root key. The search looks only below this key. If a value is specified for
            pwszAssoc, set this parameter to NULL.
            </param>
            <param name="hwnd">The HWND.</param>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IQueryAssociations.GetString(Vanara.PInvoke.ShlwApi.ASSOCF,Vanara.PInvoke.ShlwApi.ASSOCSTR,System.String,System.Text.StringBuilder,System.UInt32@)">
            <summary>Searches for and retrieves a file or protocol association-related string from the registry.</summary>
            <param name="flags">A flag that can be used to control the search. It can be any combination of the following ASSOCF values.</param>
            <param name="str">An ASSOCSTR value that specifies the type of string that is to be returned.</param>
            <param name="pszExtra">
            A pointer to an optional, null-terminated Unicode string with information about the location of the string. It is typically
            set to a Shell verb such as open. Set this parameter to NULL if it is not used.
            </param>
            <param name="pszOut">
            A pointer to a null-terminated Unicode string used to return the requested string. Set this parameter to NULL to retrieve the
            required buffer size.
            </param>
            <param name="pcchOut">
            A pointer to a value that, on entry, is set to the number of characters in the pwszOut buffer. When the function returns
            successfully, it points to the number of characters placed in the buffer.
            <para>
            If the ASSOCF_NOTRUNCATE flag is set in flags and the buffer specified in pwszOut is too small, the function returns
            E_POINTER and pcchOut points to the required size of the buffer.
            </para>
            <para>If pwszOut is NULL, the function returns S_FALSE and pcchOut points to the required size of the buffer.</para>
            </param>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IQueryAssociations.GetKey(Vanara.PInvoke.ShlwApi.ASSOCF,Vanara.PInvoke.ShlwApi.ASSOCKEY,System.String,Vanara.PInvoke.HKEY@)">
            <summary>Searches for and retrieves a file or protocol association-related key from the registry.</summary>
            <param name="flags">The ASSOCF value that can be used to control the search.</param>
            <param name="data">The ASSOCKEY value that specifies the type of key that is to be returned.</param>
            <param name="pszExtra">
            A pointer to an optional, null-terminated Unicode string with information about the location of the key. It is normally set
            to a Shell verb such as open. Set this parameter to NULL if it is not used.
            </param>
            <param name="phkeyOut">A pointer to the key's HKEY value.</param>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IQueryAssociations.GetData(Vanara.PInvoke.ShlwApi.ASSOCF,Vanara.PInvoke.ShlwApi.ASSOCDATA,System.String,System.IntPtr,System.UInt32@)">
            <summary>Searches for and retrieves file or protocol association-related binary data from the registry.</summary>
            <param name="flags">The ASSOCF value that can be used to control the search.</param>
            <param name="data">The ASSOCDATA value that specifies the type of data that is to be returned.</param>
            <param name="pszExtra">
            A pointer to an optional, null-terminated Unicode string with information about the location of the data. It is normally set
            to a Shell verb such as open. Set this parameter to NULL if it is not used.
            </param>
            <param name="pvOut">A pointer to a value that, when this method returns successfully, receives the requested data value.</param>
            <param name="pcbOut">
            A pointer to a value that, when this method is called, holds the size of pvOut, in bytes. When this method returns
            successfully, the value contains the size of the data actually retrieved.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.IQueryAssociations.GetEnum(Vanara.PInvoke.ShlwApi.ASSOCF,Vanara.PInvoke.ShlwApi.ASSOCENUM,System.String,System.Guid@,System.IntPtr@)">
            <summary>This method is not implemented.</summary>
            <param name="flags">Undocumented.</param>
            <param name="assocenum">Undocumented.</param>
            <param name="pszExtra">Undocumented.</param>
            <param name="riid">Undocumented.</param>
            <param name="ppvOut">Undocumented.</param>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.AssocCreate(System.Guid,System.Guid@,Vanara.PInvoke.ShlwApi.IQueryAssociations@)">
            <summary>Returns a pointer to an IQueryAssociations object.</summary>
            <param name="clsid">
            <para>Type: <c>CLSID</c></para>
            <para>
            The CLSID of the object that exposes the interface. This parameter must be set to CLSID_QueryAssociations, which is defined in Shlguid.h.
            </para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>Reference to the IID IID_IQueryAssociations, which is defined in Shlguid.h.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void*</c></para>
            <para>When this method returns, contains the IQueryAssociations interface pointer requested in riid.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>As of Windows Vista, AssocCreateForClasses is preferred to <c>AssocCreate</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.AssocCreate">
            <summary>Returns a pointer to an IQueryAssociations object.</summary>
            <returns>The requested IQueryAssociations interface pointer.</returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.AssocGetPerceivedType(System.String,Vanara.PInvoke.ShlwApi.PERCEIVED@,Vanara.PInvoke.ShlwApi.PERCEIVEDFLAG@,System.Text.StringBuilder@)">
            <summary>
            <para>Retrieves a file's perceived type based on its extension.</para>
            </summary>
            <param name="pszExt">
            <para>Type: <c>PCWSTR</c></para>
            <para>A pointer to a buffer that contains the file's extension. This should include the leading period, for example ".txt".</para>
            </param>
            <param name="ptype">
            <para>Type: <c>PERCEIVED*</c></para>
            <para>A pointer to a PERCEIVED value that indicates the perceived type.</para>
            </param>
            <param name="pflag">
            <para>Type: <c>PERCEIVEDFLAG*</c></para>
            <para>A pointer to a value that indicates the source of the perceived type information. One or more of the following values.</para>
            <para>PERCEIVEDFLAG_UNDEFINED (0x0000)</para>
            <para>No perceived type was found (PERCEIVED_TYPE_UNSPECIFIED).</para>
            <para>PERCEIVEDFLAG_SOFTCODED (0x0001)</para>
            <para>The perceived type was determined through an association in the registry.</para>
            <para>PERCEIVEDFLAG_HARDCODED (0x0002)</para>
            <para>The perceived type is inherently known to Windows.</para>
            <para>PERCEIVEDFLAG_NATIVESUPPORT (0x0004)</para>
            <para>The perceived type was determined through a codec provided with Windows.</para>
            <para>PERCEIVEDFLAG_GDIPLUS (0x0010)</para>
            <para>The perceived type is supported by the GDI+ library.</para>
            <para>PERCEIVEDFLAG_WMSDK (0x0020)</para>
            <para>The perceived type is supported by the Windows Media SDK.</para>
            <para>PERCEIVEDFLAG_ZIPFOLDER (0x0040)</para>
            <para>The perceived type is supported by Windows compressed folders.</para>
            </param>
            <param name="ppszType">
            <para>Type: <c>PWSTR*</c></para>
            <para>
            If the function returns a success code, this contains the address of a pointer to a buffer that receives the perceived type
            string, for instance "text" or "video". This value can be <c>NULL</c>.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            This function first compares the extension against a hard-coded set of extensions known to Windows. If that search fails to
            reveal a match, the registered associations under HKEY_CLASSES_ROOT are searched for a key that matches the extension and
            contains a PerceivedType value. If that value is found, the extension set is again searched for a match. If again no match is
            found, the perceived type is determined to be PERCEIVED_TYPE_CUSTOM. If either a key that matches the extension or a
            PerceivedType value is not found, the perceived type is reported as PERCEIVED_TYPE_UNSPECIFIED.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.AssocIsDangerous(System.String)">
            <summary>
            <para>Determines whether a file type is considered a potential security risk.</para>
            </summary>
            <param name="pszAssoc">
            <para>Type: <c>PCWSTR</c></para>
            <para>
            A pointer to a string that contains the type of file in question. This may be either an extension such as ".exe" or a progid such
            as "exefile".
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if the file type is considered dangerous; otherwise, <c>FALSE</c>.</para>
            </returns>
            <remarks>
            <para>
            Files that are determined to be potentially dangerous, such as .exe files, should be handled with more care than other files. For
            example, Windows Internet Explorer version 6.01 or later uses <c>AssocIsDangerous</c> to determine whether it should issue
            stronger warning language in its download dialog box. ShellExecuteEx uses <c>AssocIsDangerous</c> to trigger zone checking using
            the methods of the IInternetSecurityManager interface in conjunction with the URLACTION_SHELL_SHELLEXECUTE flag.
            </para>
            <para>
            The determination of a file's potential risk is made by checking its type against several sources, including a list of known
            dangerous types and the presence of the FTA_AlwaysUnsafe flag in the registry. On systems running Windows XPService Pack 1 (SP1)
            or later or Windows Server 2003, it also uses the SaferiIsExecutableFileType function to determine whether a file type is executable.
            </para>
            <para>
            Applications that can take advantage of <c>AssocIsDangerous</c> include email programs, browsers, chat clients capable of
            downloading files, and any application that moves files or data from one zone of trust to another.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.AssocQueryKey(Vanara.PInvoke.ShlwApi.ASSOCF,Vanara.PInvoke.ShlwApi.ASSOCKEY,System.String,System.String,Vanara.PInvoke.HKEY@)">
            <summary>
            <para>Searches for and retrieves a key related to a file or protocol association from the registry.</para>
            </summary>
            <param name="flags">
            <para>Type: <c>ASSOCF</c></para>
            <para>
            The flags that can be used to control the search. It can be any combination of ASSOCF values, except that only one ASSOCF_INIT
            value can be included.
            </para>
            </param>
            <param name="key">
            <para>Type: <c>ASSOCKEY</c></para>
            <para>The ASSOCKEY value that specifies the type of key that is to be returned.</para>
            </param>
            <param name="pszAssoc">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string that is used to determine the root key. Four types of strings can be used.</para>
            <para>File name extension</para>
            <para>A file name extension, such as .txt.</para>
            <para>CLSID</para>
            <para>A CLSID GUID in the standard "{GUID}" format.</para>
            <para>ProgID</para>
            <para>An application's ProgID, such as <c>Word.Document.8</c>.</para>
            <para>Executable name</para>
            <para>The name of an application's .exe file. The ASSOCF_OPEN_BYEXENAME flag must be set in flags.</para>
            </param>
            <param name="pszExtra">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set
            to a Shell verb such as <c>open</c>. Set this parameter to <c>NULL</c> if it is not used.
            </para>
            </param>
            <param name="phkeyOut">
            <para>Type: <c>HKEY*</c></para>
            <para>A pointer to the key's HKEY value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns S_OK if successful, or a COM error value otherwise.</para>
            </returns>
            <remarks>
            <para>
            This function is a wrapper for the IQueryAssociations interface. It is intended to simplify the process of using the interface.
            For further discussion of how the file and protocol association functions work, see <c>IQueryAssociations</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.AssocQueryString(Vanara.PInvoke.ShlwApi.ASSOCF,Vanara.PInvoke.ShlwApi.ASSOCSTR,System.String,System.String,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            <para>Searches for and retrieves a file or protocol association-related string from the registry.</para>
            </summary>
            <param name="flags">
            <para>Type: <c>ASSOCF</c></para>
            <para>
            The flags that can be used to control the search. It can be any combination of ASSOCF values, except that only one ASSOCF_INIT
            value can be included.
            </para>
            </param>
            <param name="str">
            <para>Type: <c>ASSOCSTR</c></para>
            <para>The ASSOCSTR value that specifies the type of string that is to be returned.</para>
            </param>
            <param name="pszAssoc">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a null-terminated string that is used to determine the root key. The following four types of strings can be used.
            </para>
            <para>File name extension</para>
            <para>A file name extension, such as .txt.</para>
            <para>CLSID</para>
            <para>A CLSID GUID in the standard "{GUID}" format.</para>
            <para>ProgID</para>
            <para>An application's ProgID, such as <c>Word.Document.8</c>.</para>
            <para>Executable name</para>
            <para>The name of an application's .exe file. The ASSOCF_OPEN_BYEXENAME flag must be set in flags.</para>
            </param>
            <param name="pszExtra">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            An optional null-terminated string with additional information about the location of the string. It is typically set to a Shell
            verb such as <c>open</c>. Set this parameter to <c>NULL</c> if it is not used.
            </para>
            </param>
            <param name="pszOut">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            Pointer to a null-terminated string that, when this function returns successfully, receives the requested string. Set this
            parameter to <c>NULL</c> to retrieve the required buffer size.
            </para>
            </param>
            <param name="pcchOut">
            <para>Type: <c>DWORD*</c></para>
            <para>
            A pointer to a value that, when calling the function, is set to the number of characters in the pszOut buffer. When the function
            returns successfully, the value is set to the number of characters actually placed in the buffer.
            </para>
            <para>
            If the ASSOCF_NOTRUNCATE flag is set in flags and the buffer specified in pszOut is too small, the function returns E_POINTER and
            the value is set to the required size of the buffer.
            </para>
            <para>
            If pszOut is <c>NULL</c>, the function returns S_FALSE and pcchOut points to the required size, in characters, of the buffer.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns a standard COM error value, including the following:</para>
            <list type="table">
            <listheader>
            <term>Error</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_POINTER</term>
            <term>The pszOut buffer is too small to hold the entire string.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>pszOut is NULL. pcchOut contains the required buffer size.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function is a wrapper for the IQueryAssociations interface. The <c>AssocQueryString</c> function is intended to simplify the
            process of using <c>IQueryAssociations</c> interface.
            </para>
            <para>
            Once an item is selected, the host must decide which (if any) preview handler is available for that item. Preview handlers are
            typically registered on file name extensions or ProgID, but some preview handlers are only instantiated for items within
            particular shell folders (the MAPI preview handler is associated with any items that came from the MAPI Shell folder, for
            example). Thus, the host must use IQueryAssociations to determine which preview handler to use. For further discussion of how the
            file and protocol association functions work, see IQueryAssociations.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.PMSF">
            <summary>Flags used by <see cref="M:Vanara.PInvoke.ShlwApi.PathMatchSpecEx(System.String,System.String,Vanara.PInvoke.ShlwApi.PMSF)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PMSF.PMSF_NORMAL">
            <summary>The pszSpec parameter points to a single file name pattern to be matched.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PMSF.PMSF_MULTIPLE">
            <summary>The pszSpec parameter points to a semicolon-delimited list of file name patterns to be matched.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PMSF.PMSF_DONT_STRIP_SPACES">
            <summary>
            If <c>PMSF_NORMAL</c> is used, ignore leading spaces in the string pointed to by pszSpec. If <c>PMSF_MULTIPLE</c> is used,
            ignore leading spaces in each file type contained in the string pointed to by pszSpec. This flag can be combined with
            <c>PMSF_NORMAL</c> and <c>PMSF_MULTIPLE</c>.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathAddBackslash(System.Text.StringBuilder)">
            <summary>
            <para>
            Adds a backslash to the end of a string to create the correct syntax for a path. If the source path already has a trailing
            backslash, no backslash will be added.
            </para>
            <para>
            <c>Note</c> Misuse of this function can lead to a buffer overrun. We recommend the use of the safer PathCchAddBackslash or
            PathCchAddBackslashEx function in its place.
            </para>
            </summary>
            <param name="pszPath">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer that, when this function returns successfully, points to the new string's terminating null character. If the backslash
            could not be appended due to inadequate buffer size, this value is <c>NULL</c>.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathAddExtension(System.Text.StringBuilder,System.String)">
            <summary>
            <para>Adds a file name extension to a path string.</para>
            <para>
            <c>Note</c> Misuse of this function can lead to a buffer overrun. We recommend the use of the safer PathCchAddExtension function
            in its place.
            </para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer to a buffer with the null-terminated string to which the file name extension will be appended. You must set the size of
            this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
            </para>
            </param>
            <param name="pszExt">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if an extension was added, or <c>FALSE</c> otherwise.</para>
            </returns>
            <remarks>
            <para>
            If there is already a file name extension present, no extension will be added. If the pszPath points to a <c>NULL</c> string, the
            result will be the file name extension only. If pszExtension points to a <c>NULL</c> string, an ".exe" extension will be added.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathAppend(System.Text.StringBuilder,System.String)">
            <summary>
            <para>Appends one path to the end of another.</para>
            <para>
            <c>Note</c> Misuse of this function can lead to a buffer overrun. We recommend the use of the safer PathCchAppend or
            PathCchAppendEx function in its place.
            </para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer to a null-terminated string to which the path specified in pszMore is appended. You must set the size of this buffer to
            MAX_PATH to ensure that it is large enough to hold the returned string.
            </para>
            </param>
            <param name="pszMore">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be appended.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if successful, or <c>FALSE</c> otherwise.</para>
            </returns>
            <remarks>
            <para>This function automatically inserts a backslash between the two strings, if one is not already present.</para>
            <para>
            The path supplied in pszPath cannot begin with "..\" or ".\" to produce a relative path string. If present, those periods are
            stripped from the output string. For example, appending "path3" to "..\path1\path2" results in an output of "\path1\path2\path3"
            rather than "..\path1\path2\path3".
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathBuildRoot(System.Text.StringBuilder,System.Int32)">
            <summary>
            <para>Creates a root path from a given drive number.</para>
            </summary>
            <param name="pszRoot">
            <para>TBD</para>
            </param>
            <param name="iDrive">
            <para>Type: <c>int</c></para>
            <para>A variable of type <c>int</c> that indicates the desired drive number. It should be between 0 and 25.</para>
            </param>
            <returns>
            <para>Type: <c>LPTSTR</c></para>
            <para>
            Returns the address of the constructed root path. If the call fails for any reason (for example, an invalid drive number), szRoot
            is returned unchanged.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathCanonicalize(System.Text.StringBuilder,System.String)">
            <summary>
            <para>Simplifies a path by removing navigation elements such as "." and ".." to produce a direct, well-formed path.</para>
            <para>
            <c>Note</c> Misuse of this function can lead to a buffer overrun. We recommend the use of the safer PathCchCanonicalize or
            PathCchCanonicalizeEx function in its place.
            </para>
            </summary>
            <param name="pszBuf">
            <para>TBD</para>
            </param>
            <param name="pszPath">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            Returns <c>TRUE</c> if a result has been computed and the content of the lpszDst output buffer is valid. Returns <c>FALSE</c>
            otherwise, and the contents of the buffer pointed to by lpszDst are invalid. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            This function allows the user to specify what to remove from a path by inserting special character sequences into the path. The
            ".." sequence indicates to remove a path segment from the current position to the previous path segment. The "." sequence
            indicates to skip over the next path segment to the following path segment. The root segment of the path cannot be removed.
            </para>
            <para>
            If there are more ".." sequences than there are path segments, the function returns <c>TRUE</c> and contents of the buffer
            pointed to by lpszDst contains just the root, "".
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathCombine(System.Text.StringBuilder,System.String,System.String)">
            <summary>
            <para>Concatenates two strings that represent properly formed paths into one path; also concatenates any relative path elements.</para>
            <para>
            <c>Note</c> Misuse of this function can lead to a buffer overrun. We recommend the use of the safer PathCchCombine or
            PathCchCombineEx function in its place.
            </para>
            </summary>
            <param name="pszDest">
            <para>TBD</para>
            </param>
            <param name="pszDir">
            <para>TBD</para>
            </param>
            <param name="pszFile">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer to a buffer that, when this function returns successfully, receives the concatenated path string. This is the same
            string pointed to by pszPathOut. If this function does not return successfully, this value is <c>NULL</c>.
            </para>
            </returns>
            <remarks>
            <para>
            The directory path should be in the form of A:,B:, ..., Z:. The file path should be in a correct form that represents the file
            name part of the path. If the directory path ends with a backslash, the backslash will be maintained. Note that while lpszDir and
            lpszFile are both optional parameters, they cannot both be <c>NULL</c>.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathCommonPrefix(System.String,System.String,System.Text.StringBuilder)">
            <summary>
            <para>Compares two paths to determine if they share a common prefix. A prefix is one of these types: "C:\", ".", "..", "..\".</para>
            </summary>
            <param name="pszFile1">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of length MAX_PATH that contains the first path name.</para>
            </param>
            <param name="pszFile2">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of length MAX_PATH that contains the second path name.</para>
            </param>
            <param name="achPath">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            Returns the count of common prefix characters in the path. If the output buffer pointer is not <c>NULL</c>, then these characters
            are copied to the output buffer.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathCompactPath(Vanara.PInvoke.HDC,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>Truncates a file path to fit within a given pixel width by replacing path components with ellipses.</para>
            </summary>
            <param name="hDC">
            <para>Type: <c>HDC</c></para>
            <para>A handle to the device context used for font metrics. This value can be <c>NULL</c>.</para>
            </param>
            <param name="pszPath">
            <para>TBD</para>
            </param>
            <param name="dx">
            <para>Type: <c>UINT</c></para>
            <para>The width, in pixels, in which the string must fit.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            Returns <c>TRUE</c> if the path was successfully compacted to the specified width. Returns <c>FALSE</c> on failure, or if the
            base portion of the path would not fit the specified width.
            </para>
            </returns>
            <remarks>
            <para>
            This function uses the font currently selected in hDC to calculate the width of the text. This function will not compact the path
            beyond the base file name preceded by ellipses.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathCompactPathEx(System.Text.StringBuilder,System.String,System.UInt32,System.UInt32)">
            <summary>
            <para>Truncates a path to fit within a certain number of characters by replacing path components with ellipses.</para>
            </summary>
            <param name="pszOut">
            <para>Type: <c>LPTSTR</c></para>
            <para>The address of the string that has been altered.</para>
            </param>
            <param name="pszSrc">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be altered.</para>
            </param>
            <param name="cchMax">
            <para>Type: <c>UINT</c></para>
            <para>
            The maximum number of characters to be contained in the new string, including the terminating null character. For example, if
            cchMax = 8, the resulting string can contain a maximum of 7 characters plus the terminating null character.
            </para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if successful, or <c>FALSE</c> otherwise.</para>
            </returns>
            <remarks>
            <para>
            The '/' separator will be used instead of '' if the original string used it. If pszSrc points to a file name that is too long,
            instead of a path, the file name will be truncated to cchMax characters, including the ellipsis and the terminating <c>NULL</c>
            character. For example, if the input file name is "My Filename" and cchMax is 10, <c>PathCompactPathEx</c> will return "My Fil...".
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathCreateFromUrl(System.String,System.Text.StringBuilder,System.UInt32@,System.UInt32)">
            <summary>
            <para>Converts a file URL to a Microsoft MS-DOS path.</para>
            </summary>
            <param name="pszUrl">
            <para>Type: <c>PCTSTR</c></para>
            <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
            </param>
            <param name="pszPath">
            <para>Type: <c>PTSTR</c></para>
            <para>
            A pointer to a buffer that, when this function returns successfully, receives the MS-DOS path. You must set the size of this
            buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
            </para>
            </param>
            <param name="pcchPath">
            <para>Type: <c>DWORD*</c></para>
            <para>The number of characters in the pszPath buffer.</para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>Reserved. Set this parameter to <c>NULL</c>.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathCreateFromUrlAlloc(System.String,System.Text.StringBuilder@,System.UInt32)">
            <summary>
            <para>Creates a path from a file URL.</para>
            </summary>
            <param name="pszIn">
            <para>Type: <c>PCWSTR</c></para>
            <para>A pointer to the URL of a file, represented as a null-terminated, Unicode string.</para>
            </param>
            <param name="ppszOut">
            <para>Type: <c>PWSTR*</c></para>
            <para>
            The address of a pointer to a buffer of length MAX_PATH that, when this function returns successfully, receives the file path.
            </para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>Reserved, must be 0.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathFileExists(System.String)">
            <summary>
            <para>Determines whether a path to a file system object such as a file or folder is valid.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the full path of the object to verify.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para><c>TRUE</c> if the file exists; otherwise, <c>FALSE</c>. Call GetLastError for extended error information.</para>
            </returns>
            <remarks>
            <para>This function tests the validity of the path.</para>
            <para>
            A path specified by Universal Naming Convention (UNC) is limited to a file only; that is, \server\share\file is permitted. A UNC
            path to a server or server share is not permitted; that is, \server or \server\share. This function returns <c>FALSE</c> if a
            mounted remote drive is out of service.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathFindExtension(System.String)">
            <summary>
            <para>Searches a path for an extension.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>PTSTR</c></para>
            <para>
            A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search, including the extension being
            searched for.
            </para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>
            Returns the address of the "." that precedes the extension within pszPath if an extension is found, or the address of the
            terminating null character otherwise.
            </para>
            </returns>
            <remarks>
            <para>
            Note that a valid file name extension cannot contain a space. For more information on valid file name extensions, see File Type Handlers.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathFindFileName(System.String)">
            <summary>
            <para>Searches a path for a file name.</para>
            </summary>
            <param name="pszPath">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns a pointer to the address of the string if successful, or a pointer to the beginning of the path otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathFindNextComponent(System.String)">
            <summary>
            <para>Parses a path and returns the portion of that path that follows the first backslash.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>PTSTR</c></para>
            <para>
            A pointer to a null-terminated string that contains the path to parse. This string must not be longer than MAX_PATH characters,
            plus the terminating null character. Path components are delimited by backslashes. For instance, the path
            "c:\path1\path2\file.txt" has four components: c:, path1, path2, and file.txt.
            </para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns a pointer to a null-terminated string that contains the truncated path.</para>
            <para>If pszPath points to the last component in the path, this function returns a pointer to the terminating null character.</para>
            <para>If pszPath points to the terminating null character or if the call fails, this function returns <c>NULL</c>.</para>
            </returns>
            <remarks>
            <para>
            <c>PathFindNextComponent</c> walks a path string until it encounters a backslash ("\"), ignores everything up to that point
            including the backslash, and returns the rest of the path. Therefore, if a path begins with a backslash (such as \path1\path2),
            the function simply removes the initial backslash and returns the rest (path1\path2).
            </para>
            <para>Examples</para>
            <para>
            The following simple console application passes various strings to <c>PathFindNextComponent</c> to demonstrate what the function
            recognizes as a path component and to show what is returned. To run this code in Visual Studio, you must link to Shlwapi.lib and
            define UNICODE in the preprocessor commands in the project settings.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathFindOnPath(System.Text.StringBuilder,System.String[])">
            <summary>
            <para>Searches for a file.</para>
            </summary>
            <param name="pszPath">
            <para>TBD</para>
            </param>
            <param name="ppszOtherDirs">
            <para>Type: <c>LPCTSTR*</c></para>
            <para>An optional, null-terminated array of directories to be searched first. This value can be <c>NULL</c>.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if successful, or <c>FALSE</c> otherwise.</para>
            </returns>
            <remarks>
            <para>
            <c>PathFindOnPath</c> searches for the file specified by pszFile. If no directories are specified in ppszOtherDirs, it attempts
            to find the file by searching standard directories such as System32 and the directories specified in the PATH environment
            variable. To expedite the process or enable <c>PathFindOnPath</c> to search a wider range of directories, use the ppszOtherDirs
            parameter to specify one or more directories to be searched first. If more than one file has the name specified by pszFile,
            <c>PathFindOnPath</c> returns the first instance it finds.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathFindSuffixArray(System.String,System.String[],System.Int32)">
            <summary>
            <para>Determines whether a given file name has one of a list of suffixes.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested. A full path can be used.
            </para>
            </param>
            <param name="apszSuffix">
            <para>Type: <c>const LPCTSTR*</c></para>
            <para>
            An array of iArraySize string pointers. Each string pointed to is null-terminated and contains one suffix. The strings can be of
            variable lengths.
            </para>
            </param>
            <param name="iArraySize">
            <para>Type: <c>int</c></para>
            <para>The number of elements in the array pointed to by apszSuffix.</para>
            </param>
            <returns>
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            Returns a pointer to a string with the matching suffix if successful, or <c>NULL</c> if pszPath does not end with one of the
            specified suffixes.
            </para>
            </returns>
            <remarks>
            <para>This function uses a case-sensitive comparison. The suffix must match exactly.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathGetArgs(System.String)">
            <summary>
            <para>Finds the command line arguments within a given path.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>PTSTR</c></para>
            <para>Pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns a pointer to a null-terminated string that contains the arguments portion of the path if successful.</para>
            <para>If there are no arguments in the path, the function returns a pointer to the end of the input string.</para>
            <para>If the function is given a <c>NULL</c> argument it returns <c>NULL</c>.</para>
            </returns>
            <remarks>
            <para>
            This function should not be used on generic command path templates (from users or the registry), but rather should be used only
            on templates that the application knows to be well formed.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathGetCharType(System.Char)">
            <summary>
            <para>Determines the type of character in relation to a path.</para>
            </summary>
            <param name="ch">
            <para>Type: <c>TUCHAR</c></para>
            <para>The character for which to determine the type.</para>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>Returns one or more of the following values that define the type of character.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GCT_INVALID</term>
            <term>The character is not valid in a path.</term>
            </item>
            <item>
            <term>GCT_LFNCHAR</term>
            <term>The character is valid in a long file name.</term>
            </item>
            <item>
            <term>GCT_SEPARATOR</term>
            <term>The character is a path separator.</term>
            </item>
            <item>
            <term>GCT_SHORTCHAR</term>
            <term>The character is valid in a short (8.3) file name.</term>
            </item>
            <item>
            <term>GCT_WILD</term>
            <term>The character is a wildcard character.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathGetDriveNumber(System.String)">
            <summary>
            <para>Searches a path for a drive letter within the range of 'A' to 'Z' and returns the corresponding drive number.</para>
            </summary>
            <param name="pszPath">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has a drive letter, or -1 otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathIsContentType(System.String,System.String)">
            <summary>
            <para>
            Determines if a file's registered content type matches the specified content type. This function obtains the content type for the
            specified file type and compares that string with the pszContentType. The comparison is not case-sensitive.
            </para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file whose content type will be compared.</para>
            </param>
            <param name="pszContentType">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The address of a character buffer that contains the null-terminated content type string to which the file's registered content
            type will be compared.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns nonzero if the file's registered content type matches pszContentType, or zero otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathIsDirectory(System.String)">
            <summary>
            <para>Verifies that a path is a valid directory.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to verify.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns (BOOL)FILE_ATTRIBUTE_DIRECTORY if the path is a valid directory; otherwise, <c>FALSE</c>.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathIsDirectoryEmpty(System.String)">
            <summary>
            <para>Determines whether a specified path is an empty directory.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be tested.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            Returns <c>TRUE</c> if pszPath is an empty directory. Returns <c>FALSE</c> if pszPath is not a directory, or if it contains at
            least one file other than "." or "..".
            </para>
            </returns>
            <remarks>
            <para>"C:" is considered a directory.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathIsFileSpec(System.String)">
            <summary>
            <para>
            Searches a path for any path-delimiting characters (for example, ':' or '' ). If there are no path-delimiting characters present,
            the path is considered to be a File Spec path.
            </para>
            </summary>
            <param name="pszPath">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            Returns <c>TRUE</c> if there are no path-delimiting characters within the path, or <c>FALSE</c> if there are path-delimiting characters.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathIsLFNFileSpec(System.String)">
            <summary>
            <para>Determines whether a file name is in long format.</para>
            </summary>
            <param name="pszName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if pszName exceeds the number of characters allowed by the 8.3 format, or <c>FALSE</c> otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathIsNetworkPath(System.String)">
            <summary>
            <para>Determines whether a path string represents a network resource.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if the string represents a network resource, or <c>FALSE</c> otherwise.</para>
            </returns>
            <remarks>
            <para><c>PathIsNetworkPath</c> interprets the following two types of paths as network paths.</para>
            <list type="bullet">
            <item>
            <term>Paths that begin with two backslash characters (\\) are interpreted as Universal Naming Convention (UNC) paths.</term>
            </item>
            <item>
            <term>
            Paths that begin with a letter followed by a colon (:) are interpreted as a mounted network drive. However,
            <c>PathIsNetworkPath</c> cannot recognize a network drive mapped to a drive letter through the Microsoft MS-DOS SUBST command or
            the DefineDosDevice function.
            </term>
            </item>
            </list>
            <para>
            <c>Note</c> The function does not verify that the specified network resource exists, is currently accessible, or that the user
            has sufficient permissions to access it.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathIsPrefix(System.String,System.String)">
            <summary>
            <para>
            Searches a path to determine if it contains a valid prefix of the type passed by pszPrefix. A prefix is one of these types:
            "C:\", ".", "..", "..\".
            </para>
            </summary>
            <param name="pszPrefix">
            <para>Type: <c>IN LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the prefix for which to search.</para>
            </param>
            <param name="pszPath">
            <para>Type: <c>IN LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if the compared path is the full prefix for the path, or <c>FALSE</c> otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathIsRelative(System.String)">
            <summary>
            <para>Searches a path and determines if it is relative.</para>
            </summary>
            <param name="pszPath">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if the path is relative, or <c>FALSE</c> if it is absolute.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathIsRoot(System.String)">
            <summary>
            <para>Determines whether a path string refers to the root of a volume.</para>
            </summary>
            <param name="pszPath">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if the specified path is a root, or <c>FALSE</c> otherwise.</para>
            </returns>
            <remarks>
            <para>
            Returns <c>TRUE</c> for paths such as "", "X:" or "\server&lt;i&gt;share". Paths such as "..\path2" or "\server" return <c>FALSE</c>.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathIsSameRoot(System.String,System.String)">
            <summary>
            <para>Compares two paths to determine if they have a common root component.</para>
            </summary>
            <param name="pszPath1">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path to be compared.</para>
            </param>
            <param name="pszPath2">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path to be compared.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            Returns <c>TRUE</c> if both strings have the same root component, or <c>FALSE</c> otherwise. If pszPath1 contains only the server
            and share, this function also returns <c>FALSE</c>.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathIsSystemFolder(System.String,Vanara.PInvoke.FileFlagsAndAttributes)">
            <summary>
            <para>
            Determines if an existing folder contains the attributes that make it a system folder. Alternately, this function indicates if
            certain attributes qualify a folder to be a system folder.
            </para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder. The attributes for
            this folder will be retrieved and compared with those that define a system folder. If this folder contains the attributes to make
            it a system folder, the function returns nonzero. If this value is <c>NULL</c>, this function determines if the attributes passed
            in dwAttrb qualify it to be a system folder.
            </para>
            </param>
            <param name="dwAttrb">
            <para>Type: <c>DWORD</c></para>
            <para>
            The file attributes to be compared. Used only if pszPath is <c>NULL</c>. In that case, the attributes passed in this value are
            compared with those that qualify a folder as a system folder. If the attributes are sufficient to make this a system folder, this
            function returns nonzero. These attributes are the attributes that are returned from GetFileAttributes.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns nonzero if the pszPath or dwAttrb represent a system folder, or zero otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathIsUNC(System.String)">
            <summary>
            <para>Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to a path based on a drive letter.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if the string is a valid UNC path; otherwise, <c>FALSE</c>.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathIsUNCServer(System.String)">
            <summary>
            <para>Determines if a string is a valid Universal Naming Convention (UNC) for a server path only.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if the string is a valid UNC path for a server only (no share name), or <c>FALSE</c> otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathIsUNCServerShare(System.String)">
            <summary>
            <para>Determines if a string is a valid Universal Naming Convention (UNC) share path, \server&lt;i&gt;share.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if the string is in the form \server&lt;i&gt;share, or <c>FALSE</c> otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathIsURL(System.String)">
            <summary>
            <para>Tests a given string to determine if it conforms to a valid URL format.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the URL path to validate.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if pszPath has a valid URL format, or <c>FALSE</c> otherwise.</para>
            </returns>
            <remarks>
            <para>This function does not verify that the path points to an existing site—only that it has a valid URL format.</para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathMakePretty(System.Text.StringBuilder)">
            <summary>
            <para>Converts an all-uppercase path to all lowercase characters to give the path a consistent appearance.</para>
            </summary>
            <param name="pszPath">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if the path has been converted, or <c>FALSE</c> otherwise.</para>
            </returns>
            <remarks>
            <para>
            This function only operates on paths that are entirely uppercase. For example: C:\WINDOWS will be converted to c:\windows, but
            c:\Windows will not be changed.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathMakeSystemFolder(System.String)">
            <summary>
            <para>Gives an existing folder the proper attributes to become a system folder.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer to a null-terminated string of length MAX_PATH that contains the name of an existing folder that will be made into a
            system folder.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns nonzero if successful, or zero otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathMatchSpec(System.String,System.String)">
            <summary>
            <para>Searches a string using a Microsoft MS-DOS wildcard match type.</para>
            </summary>
            <param name="pszFile">
            <para>Type: <c>LPCSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
            </param>
            <param name="pszSpec">
            <para>Type: <c>LPCSTR</c></para>
            <para>
            A pointer to a null-terminated string of maximum length MAX_PATH that contains the file type for which to search. For example, to
            test whether pszFile is a .doc file, pszSpec should be set to "*.doc".
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if the string matches, or <c>FALSE</c> otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathMatchSpecEx(System.String,System.String,Vanara.PInvoke.ShlwApi.PMSF)">
            <summary>
            <para>Matches a file name from a path against one or more file name patterns.</para>
            </summary>
            <param name="pszFile">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a null-terminated string of maximum length MAX_PATH that contains the path from which the file name to be matched is taken.
            </para>
            </param>
            <param name="pszSpec">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name pattern for which to search. This
            can be the exact name, or it can contain wildcard characters. If exactly one pattern is specified, set the <c>PMSF_NORMAL</c>
            flag in dwFlags. If more than one pattern is specified, separate them with semicolons and set the <c>PMSF_MULTIPLE</c> flag.
            </para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>Modifies the search condition. The following are valid flags.</para>
            <para>PMSF_NORMAL (0x00000000)</para>
            <para>The pszSpec parameter points to a single file name pattern to be matched.</para>
            <para>PMSF_MULTIPLE (0x00000001)</para>
            <para>The pszSpec parameter points to a semicolon-delimited list of file name patterns to be matched.</para>
            <para>PMSF_DONT_STRIP_SPACES (0x00010000)</para>
            <para>
            If <c>PMSF_NORMAL</c> is used, ignore leading spaces in the string pointed to by pszSpec. If <c>PMSF_MULTIPLE</c> is used, ignore
            leading spaces in each file type contained in the string pointed to by pszSpec. This flag can be combined with <c>PMSF_NORMAL</c>
            and <c>PMSF_MULTIPLE</c>.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>A file name pattern specified in pszSpec matched the file name found in the string pointed to by pszFile.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>No file name pattern specified in pszSpec matched the file name found in the string pointed to by pszFile.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathParseIconLocation(System.Text.StringBuilder)">
            <summary>
            <para>Parses a file location string that contains a file location and icon index, and returns separate values.</para>
            </summary>
            <param name="pszIconFile">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer to a null-terminated string of length MAX_PATH that contains a file location string. It should be in the form
            "path,iconindex". When the function returns, pszIconFile will point to the file's path.
            </para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>Returns the valid icon index value.</para>
            </returns>
            <remarks>
            <para>
            This function is useful for taking a DefaultIcon value retrieved from the registry by SHGetValue and separating the icon index
            from the path.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathQuoteSpaces(System.Text.StringBuilder)">
            <summary>
            <para>Searches a path for spaces. If spaces are found, the entire path is enclosed in quotation marks.</para>
            </summary>
            <param name="lpsz">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer to a null-terminated string that contains the path to search. The size of this buffer must be set to MAX_PATH to ensure
            that it is large enough to hold the returned string.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para><c>TRUE</c> if spaces were found; otherwise, <c>FALSE</c>.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathRelativePathTo(System.Text.StringBuilder,System.String,Vanara.PInvoke.FileFlagsAndAttributes,System.String,Vanara.PInvoke.FileFlagsAndAttributes)">
            <summary>
            <para>Creates a relative path from one file or folder to another.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPTSTR</c></para>
            <para>A pointer to a string that receives the relative path. This buffer must be at least MAX_PATH characters in size.</para>
            </param>
            <param name="pszFrom">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the start of the relative path.
            </para>
            </param>
            <param name="dwAttrFrom">
            <para>Type: <c>DWORD</c></para>
            <para>
            The file attributes of pszFrom. If this value contains FILE_ATTRIBUTE_DIRECTORY, pszFrom is assumed to be a directory; otherwise,
            pszFrom is assumed to be a file.
            </para>
            </param>
            <param name="pszTo">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the endpoint of the relative path.
            </para>
            </param>
            <param name="dwAttrTo">
            <para>Type: <c>DWORD</c></para>
            <para>
            The file attributes of pszTo. If this value contains FILE_ATTRIBUTE_DIRECTORY, pszTo is assumed to be directory; otherwise, pszTo
            is assumed to be a file.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if successful, or <c>FALSE</c> otherwise.</para>
            </returns>
            <remarks>
            <para>
            This function takes a pair of paths and generates a relative path from one to the other. The paths do not have to be fully
            qualified, but they must have a common prefix, or the function will fail and return <c>FALSE</c>.
            </para>
            <para>
            For example, let the starting point, pszFrom, be "c:\FolderA\FolderB\FolderC", and the ending point, pszTo, be
            "c:\FolderA\FolderD\FolderE". <c>PathRelativePathTo</c> will return the relative path from pszFrom to pszTo as:
            "....\FolderD\FolderE". You will get the same result if you set pszFrom to "\FolderA\FolderB\FolderC" and pszTo to
            "\FolderA\FolderD\FolderE". On the other hand, "c:\FolderA\FolderB" and "a:\FolderA\FolderD do not share a common prefix, and the
            function will fail. Note that "\" is not considered a prefix and is ignored. If you set pszFrom to "\FolderA\FolderB", and pszTo
            to "\FolderC\FolderD", the function will fail.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathRemoveArgs(System.Text.StringBuilder)">
            <summary>
            <para>Removes any arguments from a given path.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPTSTR</c></para>
            <para>Pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove arguments.</para>
            </param>
            <returns>
            <para>This function does not return a value.</para>
            </returns>
            <remarks>
            <para>
            This function should not be used on generic command path templates (from users or the registry), but rather it should be used
            only on templates that the application knows to be well formed.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathRemoveBackslash(System.Text.StringBuilder)">
            <summary>
            <para>Removes the trailing backslash from a given path.</para>
            <para>
            <c>Note</c> This function is deprecated. We recommend the use of the PathCchRemoveBackslash or PathCchRemoveBackslashEx function
            in its place.
            </para>
            </summary>
            <param name="pszPath">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer that, when this function returns successfully and if a backslash has been removed, points to the terminating null
            character that has replaced the backslash at the end of the string. If the path did not include a trailing backslash, this value
            will point to the final character in the string.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathRemoveBlanks(System.Text.StringBuilder)">
            <summary>
            <para>Removes all leading and trailing spaces from a string.</para>
            </summary>
            <param name="pszPath">
            <para>TBD</para>
            </param>
            <returns>
            <para>This function does not return a value.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathRemoveExtension(System.Text.StringBuilder)">
            <summary>
            <para>Removes the file name extension from a path, if one is present.</para>
            <para><c>Note</c> This function is deprecated. We recommend the use of the PathCchRemoveExtension in its place.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPTSTR</c></para>
            <para>A pointer to a null-terminated string of length MAX_PATH from which to remove the extension.</para>
            </param>
            <returns>
            <para>This function does not return a value.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathRemoveFileSpec(System.Text.StringBuilder)">
            <summary>
            <para>Removes the trailing file name and backslash from a path, if they are present.</para>
            <para><c>Note</c> This function is deprecated. We recommend the use of the PathCchRemoveFileSpec function in its place.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPTSTR</c></para>
            <para>A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the file name.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns nonzero if something was removed, or zero otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathRenameExtension(System.Text.StringBuilder,System.String)">
            <summary>
            <para>
            Replaces the extension of a file name with a new extension. If the file name does not contain an extension, the extension will be
            attached to the end of the string.
            </para>
            <para>
            <c>Note</c> Misuse of this function can lead to a buffer overrun. We recommend the use of the safer PathCchRenameExtension
            function in its place.
            </para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPTSTR</c></para>
            <para>Pointer to a null-terminated string of length MAX_PATH in which to replace the extension.</para>
            </param>
            <param name="pszExt">
            <para>Type: <c>LPCTSTR</c></para>
            <para>Pointer to a character buffer that contains a '.' character followed by the new extension.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns nonzero if successful, or zero if the new path and extension would exceed MAX_PATH characters.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathSearchAndQualify(System.String,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>Determines if a given path is correctly formatted and fully qualified.</para>
            </summary>
            <param name="pszPath">
            <para>TBD</para>
            </param>
            <param name="pszBuf">
            <para>TBD</para>
            </param>
            <param name="cchBuf">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if the path is qualified, or <c>FALSE</c> otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathSetDlgItemPath(Vanara.PInvoke.HWND,System.Int32,System.String)">
            <summary>
            <para>Sets the text of a child control in a window or dialog box, using PathCompactPath to ensure the path fits in the control.</para>
            </summary>
            <param name="hDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box or window.</para>
            </param>
            <param name="id">
            <para>Type: <c>int</c></para>
            <para>The identifier of the control.</para>
            </param>
            <param name="pszPath">
            <para>Type: <c>LPCSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to set in the control.</para>
            </param>
            <returns>
            <para>This function does not return a value.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathSkipRoot(System.String)">
            <summary>
            <para>
            Retrieves a pointer to the first character in a path following the drive letter or Universal Naming Convention (UNC) server/share
            path elements.
            </para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>PTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to parse.</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>
            A pointer that, when this function returns successfully, points to the beginning of the subpath that follows the root (drive
            letter or UNC server/share). If the function encounters an error, this value will be <c>NULL</c>.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathStripPath(System.Text.StringBuilder)">
            <summary>
            <para>Removes the path portion of a fully qualified path and file.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer to a null-terminated string of length MAX_PATH that contains the path and file name. When this function returns
            successfully, the string contains only the file name, with the path removed.
            </para>
            </param>
            <returns>
            <para>This function does not return a value.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathStripToRoot(System.Text.StringBuilder)">
            <summary>
            <para>Removes all file and directory elements in a path except for the root information.</para>
            <para>
            <c>Note</c> Misuse of this function can lead to a buffer overrun. We recommend the use of the safer PathCchStripToRoot function
            in its place.
            </para>
            </summary>
            <param name="pszPath">
            <para>TBD</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if a valid drive letter was found in the path, or <c>FALSE</c> otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathUndecorate(System.Text.StringBuilder)">
            <summary>
            <para>Removes the decoration from a path string.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A null-terminated string of length MAX_PATH that contains the path. When the function returns, pszPath points to the undecorated string.
            </para>
            </param>
            <returns>
            <para>This function does not return a value.</para>
            </returns>
            <remarks>
            <para>
            A decoration consists of a pair of square brackets with one or more digits in between, inserted immediately after the base name
            and before the file name extension.
            </para>
            <para>Examples</para>
            <para>The following table illustrates how strings are modified by <c>PathUndecorate</c>.</para>
            <list type="table">
            <listheader>
            <term>Initial String</term>
            <term>Undecorated String</term>
            </listheader>
            <item>
            <term>C:\Path\File[5].txt</term>
            <term>C:\Path\File.txt</term>
            </item>
            <item>
            <term>C:\Path\File[12]</term>
            <term>C:\Path\File</term>
            </item>
            <item>
            <term>C:\Path\File.txt</term>
            <term>C:\Path\File.txt</term>
            </item>
            <item>
            <term>C:\Path\[3].txt</term>
            <term>C:\Path\[3].txt</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathUnExpandEnvStrings(System.String,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>Replaces certain folder names in a fully qualified path with their associated environment string.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be unexpanded.</para>
            </param>
            <param name="pszBuf">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer to a buffer that, when this method returns successfully, receives the unexpanded string. The size of this buffer must
            be set to MAX_PATH to ensure that it is large enough to hold the returned string.
            </para>
            </param>
            <param name="cchBuf">
            <para>Type: <c>UINT</c></para>
            <para>The size, in characters, in the pszBuf buffer.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if successful; otherwise, <c>FALSE</c>.</para>
            </returns>
            <remarks>
            <para>The following folder paths are replaced by their equivalent environment string.</para>
            <list type="table">
            <listheader>
            <term>Folder</term>
            <term>Environment String</term>
            </listheader>
            <item>
            <term>The All Users profile folder</term>
            <term>%ALLUSERSPROFILE%</term>
            </item>
            <item>
            <term>The current user's application data folder (Windows Vista and later only).</term>
            <term>%APPDATA%</term>
            </item>
            <item>
            <term>The system name</term>
            <term>%COMPUTERNAME%</term>
            </item>
            <item>
            <term>The Program Files folder</term>
            <term>%ProgramFiles%</term>
            </item>
            <item>
            <term>The system root folder</term>
            <term>%SystemRoot%</term>
            </item>
            <item>
            <term>The system drive letter</term>
            <term>%SystemDrive%</term>
            </item>
            <item>
            <term>The current user's profile folder</term>
            <term>%USERPROFILE%</term>
            </item>
            </list>
            <para>
            <c>Note</c> %APPDATA% and %USERPROFILE% are relative to the user making the call. This function does not work if the user is
            being impersonated from a service. For further discussion of access control issues, see Access Control.
            </para>
            <para>
            The environment variables listed in the above table might not all be set on all systems. If an environment variable is not set,
            it is not unexpanded.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathUnmakeSystemFolder(System.String)">
            <summary>
            <para>Removes the attributes from a folder that make it a system folder. This folder must actually exist in the file system.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder that will have the
            system folder attributes removed.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns nonzero if successful, or zero otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.PathUnquoteSpaces(System.Text.StringBuilder)">
            <summary>
            <para>Removes quotes from the beginning and end of a path.</para>
            </summary>
            <param name="lpsz">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer to a null-terminated string of length MAX_PATH that contains the path. When the function returns successfully, points
            to the string with beginning and ending quotation marks removed.
            </para>
            </param>
            <returns>
            <para>No return value.</para>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.SFBS_FLAGS">
            <summary>
            <para>Specifies how the StrFormatByteSizeEx function should handle rounding of undisplayed digits.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SFBS_FLAGS.SFBS_FLAGS_ROUND_TO_NEAREST_DISPLAYED_DIGIT">
            <summary>Round to the nearest displayed digit.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.SFBS_FLAGS.SFBS_FLAGS_TRUNCATE_UNDISPLAYED_DECIMAL_DIGITS">
            <summary>Discard undisplayed digits.</summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.STIF_FLAGS">
            <summary>Flags that control the output of string to number conversions.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.STIF_FLAGS.STIF_DEFAULT">
            <summary>The string at pszString contains the representation of a decimal value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.STIF_FLAGS.STIF_SUPPORT_HEX">
            <summary>
            The string at pszString contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal
            representations, the characters A-F are case-insensitive.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrCatBuff(System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            <para>Copies and appends characters from one string to the end of another.</para>
            <para><c>Note</c> Do not use. See Remarks for alternative functions.</para>
            </summary>
            <param name="pszDest">
            <para>Type: <c>PTSTR</c></para>
            <para>
            A pointer to a null-terminated string. When this function returns successfully, this string contains its original content with
            the string pszSrc appended.
            </para>
            </param>
            <param name="pszSrc">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the string to be appended to pszDest.</para>
            </param>
            <param name="cchDestBuffSize">
            <para>Type: <c>int</c></para>
            <para>
            The size of the buffer, in characters, pointed to by pszDest. This value must be at least the length of the combined string plus
            the terminating null character. If the buffer is too small to fit the entire string, the string will be truncated.
            </para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns a pointer to the destination string.</para>
            </returns>
            <remarks>
            <para>
            <c>Security Warning:</c> Using this function incorrectly can compromise the security of your application. The final string is not
            guaranteed to be null-terminated. Consider using one of the following alternatives: StringCbCat, StringCbCatEx, StringCbCatN,
            StringCbCatNEx, StringCchCat, StringCchCatEx, StringCchCatN, or StringCchCatNEx. You should review Security Considerations:
            Microsoft Windows Shell before continuing.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrCatChainW(System.Text.StringBuilder,System.UInt32,System.UInt32,System.String)">
            <summary>
            <para>Concatenates two Unicode strings. Used when repeated concatenations to the same buffer are required.</para>
            </summary>
            <param name="pszDst">
            <para>Type: <c>PWSTR</c></para>
            <para>A pointer to a buffer that, when this function returns successfully, receives the null-terminated, Unicode string.</para>
            </param>
            <param name="cchDst">
            <para>Type: <c>DWORD</c></para>
            <para>
            The size of the destination buffer, in characters. This buffer must be of sufficient size to hold both strings as well as a
            terminating null character. If the buffer is too small, the final string is truncated.
            </para>
            </param>
            <param name="ichAt">
            <para>Type: <c>DWORD</c></para>
            <para>
            The offset into the destination buffer at which to begin the append action. If the string is not empty, set this value to -1 to
            have the current number of filled characters (not including the terminating null character) calculated for you.
            </para>
            </param>
            <param name="pszSrc">
            <para>Type: <c>PCWSTR</c></para>
            <para>A pointer to the null-terminated Unicode source string.</para>
            </param>
            <returns>
            <para>Type: <c>DWORD</c></para>
            <para>Returns the offset of the null character after the last character added to pszDst.</para>
            </returns>
            <remarks>
            <para>
            <c>Security Warning:</c> Using this function incorrectly can compromise the security of your application. The final string is not
            guaranteed to be null-terminated. Consider using one of the following alternatives: StringCbCatEx, StringCbCatNEx,
            StringCchCatEx, or StringCchCatNEx. You should review Security Considerations: Microsoft Windows Shell before continuing.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrCatW(System.Text.StringBuilder,System.String)">
            <summary>
            <para>Appends one string to another.</para>
            <para><c>Note</c> Do not use. See Remarks for alternative functions.</para>
            </summary>
            <param name="psz1">
            <para>Type: <c>PTSTR</c></para>
            <para>
            A pointer to a null-terminated string. When this function returns successfully, this string contains its original content with
            the string psz2 appended. This buffer must be large enough to hold both strings and the terminating null character.
            </para>
            </param>
            <param name="psz2">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to a null-terminated string to be appended to psz1.</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns a pointer to psz1, which holds the combined strings.</para>
            </returns>
            <remarks>
            <para>
            <c>Security Warning:</c> Using this function incorrectly can compromise the security of your application. The first argument,
            psz1, must be large enough to hold psz2 and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a
            denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an
            attacker to inject executable code into your process, especially if psz1 is a stack-based buffer. Consider using one of the
            following alternatives: StringCbCat, StringCbCatEx, StringCbCatN, StringCbCatNEx, StringCchCat, StringCchCatEx, StringCchCatN, or
            StringCchCatNEx. You should review Security Considerations: Microsoft Windows Shell before continuing.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrChr(System.String,System.Char)">
            <summary>
            <para>Searches a string for the first occurrence of a character that matches the specified character. The comparison is case-sensitive.</para>
            </summary>
            <param name="pszStart">
            <para>Type: <c>PTSTR</c></para>
            <para>The address of the string to be searched.</para>
            </param>
            <param name="wMatch">
            <para>Type: <c>TCHAR</c></para>
            <para>The character to be used for comparison.</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns the address of the first occurrence of the character in the string if successful, or <c>NULL</c> otherwise.</para>
            </returns>
            <remarks>
            <para>The comparison assumes pszStart points to the start of a null-terminated string.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrChrI(System.String,System.Char)">
            <summary>
            <para>
            Searches a string for the first occurrence of a character that matches the specified character. The comparison is not case-sensitive.
            </para>
            </summary>
            <param name="pszStart">
            <para>Type: <c>PTSTR</c></para>
            <para>A pointer to the string to be searched.</para>
            </param>
            <param name="wMatch">
            <para>Type: <c>TCHAR</c></para>
            <para>The character to be used for comparison.</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns the address of the first occurrence of the character in the string if successful, or <c>NULL</c> otherwise.</para>
            </returns>
            <remarks>
            <para>The comparison assumes pszStart points to the start of a null-terminated string.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrChrNIW(System.String,System.Char,System.UInt32)">
            <summary>
            <para>Searches a string for the first occurrence of a specified character. The comparison is not case-sensitive.</para>
            </summary>
            <param name="pszStart">
            <para>Type: <c>PCWSTR</c></para>
            <para>A pointer to the string to be searched.</para>
            </param>
            <param name="wMatch">
            <para>Type: <c>WCHAR</c></para>
            <para>The character to be used for comparison.</para>
            </param>
            <param name="cchMax">
            <para>Type: <c>UINT</c></para>
            <para>The maximum number of characters to search.</para>
            </param>
            <returns>
            <para>Type: <c>PWSTR</c></para>
            <para>Returns the address of the first occurrence of the character in the string if successful, or <c>NULL</c> otherwise.</para>
            </returns>
            <remarks>
            <para><c>StrChrNIW</c> searches for wMatch from pszStart to pszStart + cchMax, or until a <c>NULL</c> character is encountered.</para>
            <para>To help ensure optimal performance, pszStart should be word-aligned.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrChrNW(System.String,System.Char,System.UInt32)">
            <summary>
            <para>Searches a string for the first occurrence of a specified character. The comparison is case-sensitive.</para>
            </summary>
            <param name="pszStart">
            <para>Type: <c>PWSTR</c></para>
            <para>A pointer to the string to be searched.</para>
            </param>
            <param name="wMatch">
            <para>Type: <c>WCHAR</c></para>
            <para>The character to be used for comparison.</para>
            </param>
            <param name="cchMax">
            <para>Type: <c>UINT</c></para>
            <para>The maximum number of characters to search.</para>
            </param>
            <returns>
            <para>Type: <c>PWSTR</c></para>
            <para>Returns the address of the first occurrence of the character in the string if successful, or <c>NULL</c> otherwise.</para>
            </returns>
            <remarks>
            <para><c>StrChrNW</c> searches for wMatch from pszStart to pszStart + cchMax, or until a <c>NULL</c> character is encountered.</para>
            <para>To help ensure optimal performance, pszStart should be word-aligned.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrCmpC(System.String,System.String)">
            <summary>
            <para>Compares strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.</para>
            </summary>
            <param name="pszStr1">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to the first null-terminated string to be compared.</para>
            </param>
            <param name="pszStr2">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to the second null-terminated string to be compared.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            Returns zero if the strings are identical. Returns a positive value if the string pointed to by lpStr1 is alphabetically greater
            than that pointed to by lpStr2. Returns a negative value if the string pointed to by lpStr1 is alphabetically less than that
            pointed to by lpStr2.
            </para>
            </returns>
            <remarks>
            <para>
            It is strongly recommended that you use the CompareString function in place of this function. <c>StrCmpC</c> was designed for
            comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it
            will not function correctly with a double-byte character set (DBCS) or other multiple-character data.
            </para>
            <para>
            This function locates the first unequal characters and returns a positive number if the character from the first string is
            greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, if
            lpStr1="abczb" and lpStr2="abcdefg", <c>StrCmpC</c> determines that the first unequal character is at position four ("z" in
            lpStr1 and "d" in lpStr2) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".
            </para>
            <para>
            For those versions of Windows that do not include <c>StrCmpC</c> in Shlwapi.h, this function's individual ANSI or Unicode version
            must be called directly from Shlwapi.dll. <c>StrCmpCA</c> is ordinal 155 and <c>StrCmpCW</c> is ordinal 156.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrCmpIC(System.String,System.String)">
            <summary>
            <para>Compares two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.</para>
            </summary>
            <param name="pszStr1">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to the first null-terminated string to be compared.</para>
            </param>
            <param name="pszStr2">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to the second null-terminated string to be compared.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            Returns zero if the strings are identical. Returns a positive value if the string pointed to by lpStr1 is alphabetically greater
            than that pointed to by lpStr2. Returns a negative value if the string pointed to by lpStr1 is alphabetically less than that
            pointed to by lpStr2
            </para>
            </returns>
            <remarks>
            <para>
            It is strongly recommended that you use CompareString in place of this function. <c>StrCmpIC</c> was designed for comparing
            canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not
            function correctly with double-byte character set (DBCS) data.
            </para>
            <para>
            Uppercase characters are converted to lowercase characters before comparing, and the return value is based on comparing the
            converted values. This function returns the difference in value of the first unequal characters it encounters, or zero if they
            are all equal. For example, if lpStr1="abczb" and lpStr2="abcdefg", <c>StrCmpIC</c> determines that "abczb" is greater than
            "abcdefg" and returns z - d.
            </para>
            <para>
            For those versions of Windows that do not include <c>StrCmpIC</c> in Shlwapi.h, this function's individual ANSI or Unicode
            version must be called directly from Shlwapi.dll. <c>StrCmpICA</c> is ordinal 157 and <c>StrCmpICW</c> is ordinal 158.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrCmpIW(System.String,System.String)">
            <summary>
            <para>Compares two strings to determine if they are the same. The comparison is not case-sensitive.</para>
            </summary>
            <param name="psz1">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the first null-terminated string to be compared.</para>
            </param>
            <param name="psz2">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the second null-terminated string to be compared.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            Returns zero if the strings are identical. Returns a positive value if the string pointed to by psz1 is greater than that pointed
            to by psz2. Returns a negative value if the string pointed to by psz1 is less than that pointed to by psz2.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrCmpLogicalW(System.String,System.String)">
            <summary>
            <para>
            Compares two Unicode strings. Digits in the strings are considered as numerical content rather than text. This test is not case-sensitive.
            </para>
            </summary>
            <param name="psz1">
            <para>Type: <c>PCWSTR</c></para>
            <para>A pointer to the first null-terminated string to be compared.</para>
            </param>
            <param name="psz2">
            <para>Type: <c>PCWSTR</c></para>
            <para>A pointer to the second null-terminated string to be compared.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <list type="bullet">
            <item>
            <term>Returns zero if the strings are identical.</term>
            </item>
            <item>
            <term>Returns 1 if the string pointed to by psz1 has a greater value than that pointed to by psz2.</term>
            </item>
            <item>
            <term>Returns -1 if the string pointed to by psz1 has a lesser value than that pointed to by psz2.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function's ordering schema differs somewhat from StrCmpI, which also compares strings without regard to case sensitivity.
            Considering digits by their numerical value—as <c>StrCmpLogicalW</c> does—strings are ordered as follows:
            </para>
            <para><c>StrCmpI</c> considers digits in the string only as text so that those same strings are ordered as follows:</para>
            <para>
            <c>Note</c> Behavior of this function, and therefore the results it returns, can change from release to release. It should not be
            used for canonical sorting applications.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrCmpN(System.String,System.String,System.Int32)">
            <summary>
            <para>
            Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is
            case-sensitive. The <c>StrNCmp</c> macro differs from this function in name only.
            </para>
            </summary>
            <param name="psz1">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the first null-terminated string to be compared.</para>
            </param>
            <param name="psz2">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the second null-terminated string to be compared.</para>
            </param>
            <param name="nChar">
            <para>Type: <c>int</c></para>
            <para>The number of characters from the beginning of each string to be compared.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            Returns zero if the strings are identical. Returns a positive value if the first nChar characters of the string pointed to by
            psz1 are greater than those from the string pointed to by psz2. It returns a negative value if the first nChar characters of the
            string pointed to by psz1 are less than those from the string pointed to by psz2.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrCmpNC(System.String,System.String,System.Int32)">
            <summary>
            <para>
            Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The
            comparison is case-sensitive.
            </para>
            </summary>
            <param name="pszStr1">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to the first null-terminated string to be compared.</para>
            </param>
            <param name="pszStr2">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to the second null-terminated string to be compared.</para>
            </param>
            <param name="nChar">
            <para>Type: <c>int</c></para>
            <para>The number of characters from the beginning of each string to be compared.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by pszStr1 is
            alphabetically greater than the string taken from that pointed to by pszStr2. Returns a negative value if the string taken from
            that pointed to by pszStr1 is alphabetically less than the string taken from that pointed to by pszStr2.
            </para>
            </returns>
            <remarks>
            <para>
            Note that <c>StrCmpNC</c> was designed for comparing canonical strings. These strings are not localized and consist only of
            characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other
            multiple-character data.
            </para>
            <para>
            This function locates the first unequal characters and returns a positive number if the character from the first string is
            greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that
            pszStr1="abczb", pszStr2="abcdefg", and you are comparing the first four characters from each. <c>StrCmpNC</c> determines that
            the first unequal character is at position four ("z" in pszStr1 and "d" in pszStr2) and returns a positive value since the ASCII
            code for "z" is greater than the ASCII code for "d".
            </para>
            <para>
            For those versions of Windows that do not include <c>StrCmpNC</c> in Shlwapi.h, this function's individual ANSI or Unicode
            version must be called directly from Shlwapi.dll. <c>StrCmpNCA</c> is ordinal 151 and <c>StrCmpNCW</c> is ordinal 152.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrCmpNI(System.String,System.String,System.Int32)">
            <summary>
            <para>
            Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is
            not case-sensitive. The <c>StrNCmpI</c> macro differs from this function in name only.
            </para>
            </summary>
            <param name="psz1">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the first null-terminated string to be compared.</para>
            </param>
            <param name="psz2">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the second null-terminated string to be compared.</para>
            </param>
            <param name="nChar">
            <para>Type: <c>int</c></para>
            <para>The number of characters from the beginning of each string to be compared.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            Returns zero if the strings are identical. Returns a positive value if the first nChar characters of the string pointed to by
            psz1 are greater than those from the string pointed to by psz2. It returns a negative value if the first nChar characters of the
            string pointed to by psz1 are less than those from the string pointed to by psz2.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrCmpNIC(System.String,System.String,System.Int32)">
            <summary>
            <para>
            Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The
            comparison is not case-sensitive.
            </para>
            </summary>
            <param name="pszStr1">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to the first null-terminated string to be compared.</para>
            </param>
            <param name="pszStr2">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to the second null-terminated string to be compared.</para>
            </param>
            <param name="nChar">
            <para>Type: <c>int</c></para>
            <para>The number of characters from the beginning of each string to be compared.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by pszStr1 is
            alphabetically greater the string taken from that pointed to by pszStr2. Returns a negative value if the string taken from that
            pointed to by pszStr1 is alphabetically less than the string taken from that pointed to by pszStr2.
            </para>
            </returns>
            <remarks>
            <para>
            Note that <c>StrCmpNIC</c> was designed for comparing canonical strings. These strings are not localized and consist only of
            characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other
            multiple-character data.
            </para>
            <para>
            This function locates the first unequal characters and returns a positive number if the character from the first string is
            greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that
            pszStr1="abczb", pszStr2="abcdefg", and you are comparing the first four characters from each. <c>StrCmpNIC</c> determines that
            the first unequal character is at position four ("z" in pszStr1 and "d" in pszStr2) and returns a positive value since the ASCII
            code for "z" is greater than the ASCII code for "d".
            </para>
            <para>
            For those versions of Windows that do not include <c>StrCmpNIC</c> in Shlwapi.h, this function's individual ANSI or Unicode
            version must be called directly from Shlwapi.dll. <c>StrCmpNICA</c> is ordinal 153 and <c>StrCmpNICW</c> is ordinal 154.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrCmpW(System.String,System.String)">
            <summary>
            <para>Compares two strings to determine if they are the same. The comparison is case-sensitive.</para>
            </summary>
            <param name="psz1">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the first null-terminated string to be compared.</para>
            </param>
            <param name="psz2">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the second null-terminated string to be compared.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            Returns zero if the strings are identical. Returns a positive value if the string pointed to by psz1 is greater than that pointed
            to by psz2. Returns a negative value if the string pointed to by psz1 is less than that pointed to by psz2.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrCpyNW(System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            <para>Copies a specified number of characters from the beginning of one string to another.</para>
            <para><c>Note</c> Do not use this function or the <c>StrNCpy</c> macro. See Remarks for alternative functions.</para>
            </summary>
            <param name="pszDst">
            <para>Type: <c>PTSTR</c></para>
            <para>
            A pointer to a buffer that, when this function returns successfully, receives the copied string. This buffer must be of
            sufficient size to hold the copied characters. This string is not guaranteed to be null-terminated.
            </para>
            </param>
            <param name="pszSrc">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the null-terminated source string.</para>
            </param>
            <param name="cchMax">
            <para>Type: <c>int</c></para>
            <para>The number of characters to be copied, including the terminating null character.</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns a pointer to pszDst.</para>
            </returns>
            <remarks>
            <para>
            <c>Security Warning:</c> Using this function incorrectly can compromise the security of your application. The copied string is
            not guaranteed to be null-terminated. Consider using one of the following alternatives. StringCbCopy, StringCbCopyEx,
            StringCbCopyN, StringCbCopyNEx, StringCchCopy, StringCchCopyEx, StringCchCopyN, StringCchCopyNEx. You should review Security
            Considerations: Microsoft Windows Shell before continuing.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrCpyW(System.Text.StringBuilder,System.String)">
            <summary>
            <para>Copies one string to another.</para>
            <para><c>Note</c> Do not use. See Remarks for alternative functions.</para>
            </summary>
            <param name="psz1">
            <para>Type: <c>PTSTR</c></para>
            <para>
            A pointer to a buffer that, when this function returns successfully, receives the copied string. This string is not guaranteed to
            be null-terminated.
            </para>
            </param>
            <param name="psz2">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the null-terminated source string.</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns a pointer to psz1.</para>
            </returns>
            <remarks>
            <para>
            <c>Security Warning:</c> Using this function incorrectly can compromise the security of your application. The first argument,
            psz1, must be large enough to hold psz2 and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a
            denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an
            attacker to inject executable code into your process, especially if psz1 is a stack-based buffer. Consider using one of the
            following alternatives: StringCbCopy, StringCbCopyEx, StringCbCopyN, StringCbCopyNEx, StringCchCopy, StringCchCopyEx,
            StringCchCopyN, or StringCchCopyNEx. You should review Security Considerations: Microsoft Windows Shell before continuing.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrCSpn(System.String,System.String)">
            <summary>
            <para>
            Searches a string for the first occurrence of any of a group of characters. The search method is case-sensitive, and the
            terminating <c>NULL</c> character is included within the search pattern match.
            </para>
            </summary>
            <param name="pszStr">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the null-terminated string to be searched.</para>
            </param>
            <param name="pszSet">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to a null-terminated string that contains the characters to search for.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            Returns the index of the first occurrence in pszStr of any character from pszSet, or the length of pszStr if no match is found.
            </para>
            </returns>
            <remarks>
            <para>
            The return value of this function is equal to the length of the initial substring in pszStr that does not include any characters
            from pszSet.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrCSpnI(System.String,System.String)">
            <summary>
            <para>
            Searches a string for the first occurrence of any of a group of characters. The search method is not case-sensitive, and the
            terminating <c>NULL</c> character is included within the search pattern match.
            </para>
            </summary>
            <param name="pszStr">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the null-terminated string to be searched.</para>
            </param>
            <param name="pszSet">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to a null-terminated string containing the characters to search for.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            Returns the index of the first occurrence in pszStr of any character from pszSet, or the length of pszStr if no match is found.
            </para>
            </returns>
            <remarks>
            <para>
            The return value of this function is equal to the length of the initial substring in pszStr that does not include any characters
            from pszSet.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrDup(System.String)">
            <summary>
            <para>Duplicates a string.</para>
            </summary>
            <param name="pszSrch">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to a constant <c>null</c>-terminated character string.</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns the address of the string that was copied, or <c>NULL</c> if the string cannot be copied.</para>
            </returns>
            <remarks>
            <para>
            <c>StrDup</c> will allocate storage the size of the original string. If storage allocation is successful, the original string is
            copied to the duplicate string.
            </para>
            <para>
            This function uses LocalAlloc to allocate storage space for the copy of the string. The calling application must free this memory
            by calling the LocalFree function on the pointer returned by the call to <c>StrDup</c>.
            </para>
            <para>Examples</para>
            <para>This simple console application illustrates the use of <c>StrDup</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrFormatByteSize64A(System.Int64,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>
            Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or
            gigabytes, depending on the size.
            </para>
            </summary>
            <param name="qdw">
            <para>Type: <c>LONGLONG</c></para>
            <para>The numeric value to be converted.</para>
            </param>
            <param name="pszBuf">
            <para>Type: <c>PSTR</c></para>
            <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
            </param>
            <param name="cchBuf">
            <para>Type: <c>UINT</c></para>
            <para>The size of the buffer pointed to by pszBuf, in characters.</para>
            </param>
            <returns>
            <para>Type: <c>PSTR</c></para>
            <para>Returns a pointer to the converted string, or <c>NULL</c> if the conversion fails.</para>
            </returns>
            <remarks>
            <para>
            <c>StrFormatByteSize64</c> can be used for either ANSI or Unicode characters. However, while <c>StrFormatByteSize64A</c> can be
            called directly, <c>StrFormatByteSize64W</c> is not defined. When <c>StrFormatByteSize64</c> is called with a Unicode value,
            StrFormatByteSizeW is used.
            </para>
            <para>In Windows 10, size is reported in base 10 rather than base 2. For example, 1 KB is 1000 bytes rather than 1024.</para>
            <para>The following table illustrates how this function converts a numeric value into a text string.</para>
            <list type="table">
            <listheader>
            <term>Numeric value</term>
            <term>Text string</term>
            </listheader>
            <item>
            <term>532</term>
            <term>532 bytes</term>
            </item>
            <item>
            <term>1340</term>
            <term>1.30 KB</term>
            </item>
            <item>
            <term>23506</term>
            <term>23.5 KB</term>
            </item>
            <item>
            <term>2400016</term>
            <term>2.40 MB</term>
            </item>
            <item>
            <term>2400000000</term>
            <term>2.4 GB</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrFormatByteSizeA(System.UInt32,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>
            Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or
            gigabytes, depending on the size. Differs from StrFormatByteSizeW in one parameter type.
            </para>
            </summary>
            <param name="dw">
            <para>Type: <c>DWORD</c></para>
            <para>The numeric value to be converted.</para>
            </param>
            <param name="pszBuf">
            <para>Type: <c>PSTR</c></para>
            <para>A pointer to a buffer that receives the converted string.</para>
            </param>
            <param name="cchBuf">
            <para>Type: <c>UINT</c></para>
            <para>The size of the buffer pointed to by pszBuf, in characters.</para>
            </param>
            <returns>
            <para>Type: <c>PSTR</c></para>
            <para>Returns a pointer to the converted string, or <c>NULL</c> if the conversion fails.</para>
            </returns>
            <remarks>
            <para>
            The first parameter of this function has a different type for the ANSI and Unicode versions. If your numeric value is a
            <c>DWORD</c>, you can use <c>StrFormatByteSize</c> with text macros for both cases. The compiler will cast the numerical value to
            a <c>LONGLONG</c> for the Unicode case. If your numerical value is a <c>LONGLONG</c>, you should use StrFormatByteSizeW explicitly.
            </para>
            <para>In Windows 10, size is reported in base 10 rather than base 2. For example, 1 KB is 1000 bytes rather than 1024.</para>
            <para>The following table illustrates how this function converts a numeric value into a text string.</para>
            <list type="table">
            <listheader>
            <term>Numeric value</term>
            <term>Text string</term>
            </listheader>
            <item>
            <term>532</term>
            <term>532 bytes</term>
            </item>
            <item>
            <term>1340</term>
            <term>1.30 KB</term>
            </item>
            <item>
            <term>23506</term>
            <term>22.9 KB</term>
            </item>
            <item>
            <term>2400016</term>
            <term>2.28 MB</term>
            </item>
            <item>
            <term>2400000000</term>
            <term>2.23 GB</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrFormatByteSizeEx(System.UInt64,Vanara.PInvoke.ShlwApi.SFBS_FLAGS,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>
            Converts a numeric value into a string that represents the number in bytes, kilobytes, megabytes, or gigabytes, depending on the
            size. Extends StrFormatByteSizeW by offering the option to round to the nearest displayed digit or to discard undisplayed digits.
            </para>
            </summary>
            <param name="ull">
            <para>Type: <c>ULONGLONG</c></para>
            <para>The numeric value to be converted.</para>
            </param>
            <param name="flags">
            <para>Type: <c>SFBS_FLAGS</c></para>
            <para>
            One of the SFBS_FLAGS enumeration values that specifies whether to round or truncate undisplayed digits. This value cannot be NULL.
            </para>
            </param>
            <param name="pszBuf">
            <para>Type: <c>PWSTR</c></para>
            <para>A pointer to a buffer that receives the converted string.</para>
            </param>
            <param name="cchBuf">
            <para>Type: <c>UINT</c></para>
            <para>The size of the buffer pointed to by pszBuf, in characters.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The following table illustrates how this function converts a numeric value into a text string in relation to the passed flag.
            </para>
            <list type="table">
            <listheader>
            <term>Numeric value</term>
            <term>Flag</term>
            <term>Text string</term>
            </listheader>
            <item>
            <term>2147483647</term>
            <term>SFBS_FLAGS_ROUND_TO_NEAREST_DISPLAYED_DIGIT</term>
            <term>2.00 GB</term>
            </item>
            <item>
            <term>2147483647</term>
            <term>SFBS_FLAGS_TRUNCATE_UNDISPLAYED_DECIMAL_DIGITS</term>
            <term>1.99 GB</term>
            </item>
            </list>
            <para>In Windows 10, size is reported in base 10 rather than base 2. For example, 1 KB is 1000 bytes rather than 1024.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrFormatByteSizeW(System.Int64,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>
            Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or
            gigabytes, depending on the size. Differs from StrFormatByteSizeW in one parameter type.
            </para>
            </summary>
            <param name="dw">
            <para>Type: <c>DWORD</c></para>
            <para>The numeric value to be converted.</para>
            </param>
            <param name="pszBuf">
            <para>Type: <c>PSTR</c></para>
            <para>A pointer to a buffer that receives the converted string.</para>
            </param>
            <param name="cchBuf">
            <para>Type: <c>UINT</c></para>
            <para>The size of the buffer pointed to by pszBuf, in characters.</para>
            </param>
            <returns>
            <para>Type: <c>PSTR</c></para>
            <para>Returns a pointer to the converted string, or <c>NULL</c> if the conversion fails.</para>
            </returns>
            <remarks>
            <para>
            The first parameter of this function has a different type for the ANSI and Unicode versions. If your numeric value is a
            <c>DWORD</c>, you can use <c>StrFormatByteSize</c> with text macros for both cases. The compiler will cast the numerical value to
            a <c>LONGLONG</c> for the Unicode case. If your numerical value is a <c>LONGLONG</c>, you should use StrFormatByteSizeW explicitly.
            </para>
            <para>In Windows 10, size is reported in base 10 rather than base 2. For example, 1 KB is 1000 bytes rather than 1024.</para>
            <para>The following table illustrates how this function converts a numeric value into a text string.</para>
            <list type="table">
            <listheader>
            <term>Numeric value</term>
            <term>Text string</term>
            </listheader>
            <item>
            <term>532</term>
            <term>532 bytes</term>
            </item>
            <item>
            <term>1340</term>
            <term>1.30 KB</term>
            </item>
            <item>
            <term>23506</term>
            <term>22.9 KB</term>
            </item>
            <item>
            <term>2400016</term>
            <term>2.28 MB</term>
            </item>
            <item>
            <term>2400000000</term>
            <term>2.23 GB</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrFormatKBSize(System.Int64,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>Converts a numeric value into a string that represents the number expressed as a size value in kilobytes.</para>
            </summary>
            <param name="qdw">
            <para>Type: <c>LONGLONG</c></para>
            <para>The numeric value to be converted.</para>
            </param>
            <param name="pszBuf">
            <para>Type: <c>PTSTR</c></para>
            <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
            </param>
            <param name="cchBuf">
            <para>Type: <c>UINT</c></para>
            <para>The size of pszBuf, in characters.</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns a pointer to the converted string, or <c>NULL</c> if the conversion fails.</para>
            </returns>
            <remarks>
            <para>In Windows 10, size is reported in base 10 rather than base 2. For example, 1 KB is 1000 bytes rather than 1024.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrFromTimeInterval(System.Text.StringBuilder,System.UInt32,System.UInt32,System.Int32)">
            <summary>
            <para>Converts a time interval, specified in milliseconds, to a string.</para>
            </summary>
            <param name="pszOut">
            <para>Type: <c>PTSTR</c></para>
            <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
            </param>
            <param name="cchMax">
            <para>Type: <c>UINT</c></para>
            <para>
            The size of pszOut, in characters. If cchMax is set to zero, <c>StrFromTimeInterval</c> will return the minimum size of the
            character buffer needed to hold the converted string. In this case, pszOut will not contain the converted string.
            </para>
            </param>
            <param name="dwTimeMS">
            <para>Type: <c>DWORD</c></para>
            <para>The time interval, in milliseconds.</para>
            </param>
            <param name="digits">
            <para>Type: <c>int</c></para>
            <para>The maximum number of significant digits to be represented in pszOut. Some examples are:</para>
            <list type="table">
            <listheader>
            <term>dwTimeMS</term>
            <term>digits</term>
            <term>pszOut</term>
            </listheader>
            <item>
            <term>34000</term>
            <term>3</term>
            <term>34 sec</term>
            </item>
            <item>
            <term>34000</term>
            <term>2</term>
            <term>34 sec</term>
            </item>
            <item>
            <term>34000</term>
            <term>1</term>
            <term>30 sec</term>
            </item>
            <item>
            <term>74000</term>
            <term>3</term>
            <term>1 min 14 sec</term>
            </item>
            <item>
            <term>74000</term>
            <term>2</term>
            <term>1 min 10 sec</term>
            </item>
            <item>
            <term>74000</term>
            <term>1</term>
            <term>1 min</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>Returns the number of characters in pszOut, excluding the terminating <c>NULL</c> character.</para>
            </returns>
            <remarks>
            <para>
            The time value returned in pszOut will always be in the form hh hours mm minutes ss seconds. Times that exceed twenty four hours
            are not converted to days or months. Fractions of seconds are ignored.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrIsIntlEqual(System.Boolean,System.String,System.String,System.Int32)">
            <summary>
            <para>Compares a specified number of characters from the beginning of two strings to determine if they are equal.</para>
            </summary>
            <param name="fCaseSens">
            <para>Type: <c>BOOL</c></para>
            <para>
            The case sensitivity of the comparison. If this value is nonzero, the comparison is case-sensitive. If this value is zero, the
            comparison is not case-sensitive.
            </para>
            </param>
            <param name="pszString1">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the first null-terminated string to be compared.</para>
            </param>
            <param name="pszString2">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the second null-terminated string to be compared.</para>
            </param>
            <param name="nChar">
            <para>Type: <c>int</c></para>
            <para>The number of characters from the beginning of each string to be compared.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para><c>TRUE</c> if the first nChar characters from the two strings are equal; otherwise, <c>FALSE</c>.</para>
            </returns>
            <remarks>
            <para>
            You can set case sensitivity with the <c>StrIntlEqN</c> and <c>StrIntlEqNI</c> macros. <c>StrIntlEqN</c> performs a
            case-sensitive comparison, and <c>StrIntlEqNI</c> performs a case-insensitive comparison.
            </para>
            <para>The syntax of the two macros is:</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrNCat(System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            <para>Appends a specified number of characters from the beginning of one string to the end of another.</para>
            <para><c>Note</c> Do not use this function or the <c>StrCatN</c> macro. See Remarks for alternative functions.</para>
            </summary>
            <param name="psz1">
            <para>Type: <c>PTSTR</c></para>
            <para>
            A pointer to a null-terminated string to which the function appends the characters from psz2. It must be large enough to hold the
            combined strings plus the terminating null character.
            </para>
            </param>
            <param name="psz2">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the null-terminated string to be appended.</para>
            </param>
            <param name="cchMax">
            <para>Type: <c>int</c></para>
            <para>The number of characters to be appended to psz1 from the beginning of psz2.</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns a pointer to psz1, which holds the combined string.</para>
            </returns>
            <remarks>
            <para>
            <c>Security Warning:</c> Using this function incorrectly can compromise the security of your application. The first argument,
            psz1, must be large enough to hold psz2 and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a
            denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an
            attacker to inject executable code into your process, especially if psz1 is a stack-based buffer. Be aware that the last
            argument, cchMax, is the number of characters to copy into psz1, not necessarily the size of the psz1 in bytes. Consider using
            one of the following alternatives. StringCbCat, StringCbCatEx, StringCbCatN, StringCbCatNEx, StringCchCat, StringCchCatEx,
            StringCchCatN, or StringCchCatNEx. You should review Security Considerations: Microsoft Windows Shell before continuing.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrPBrk(System.String,System.String)">
            <summary>
            <para>
            Searches a string for the first occurrence of a character contained in a specified buffer. This search does not include the
            terminating null character.
            </para>
            </summary>
            <param name="psz">
            <para>Type: <c>PTSTR</c></para>
            <para>A pointer to the null-terminated string to be searched.</para>
            </param>
            <param name="pszSet">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to a null-terminated character buffer that contains the characters for which to search.</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>
            Returns the address in psz of the first occurrence of a character contained in the buffer at pszSet, or <c>NULL</c> if no match
            is found.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrRChr(System.String,System.String,System.Char)">
            <summary>
            <para>Searches a string for the last occurrence of a specified character. The comparison is case-sensitive.</para>
            </summary>
            <param name="pszStart">
            <para>Type: <c>PTSTR</c></para>
            <para>A pointer to the null-terminated string to be searched.</para>
            </param>
            <param name="pszEnd">
            <para>Type: <c>PCTSTR</c></para>
            <para>
            A pointer into the source string that defines the range of the search. Set pszEnd to point to a character in the string and the
            search will stop with the preceding character. Set pszEnd to <c>NULL</c> to search the entire string.
            </para>
            </param>
            <param name="wMatch">
            <para>Type: <c>TCHAR</c></para>
            <para>The character to search for.</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns a pointer to the last occurrence of the character in the string, if successful, or <c>NULL</c> if not.</para>
            </returns>
            <remarks>
            <para>The comparison assumes that pszEnd points to the end of the string.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrRChrI(System.String,System.String,System.Char)">
            <summary>
            <para>Searches a string for the last occurrence of a specified character. The comparison is not case-sensitive.</para>
            </summary>
            <param name="pszStart">
            <para>Type: <c>PTSTR</c></para>
            <para>A pointer to the null-terminated string to be searched.</para>
            </param>
            <param name="pszEnd">
            <para>Type: <c>PCTSTR</c></para>
            <para>
            A pointer into the source string that defines the range of the search. Set pszEnd to point to a character in the string and the
            search will stop with the preceding character. Set pszEnd to <c>NULL</c> to search the entire string.
            </para>
            </param>
            <param name="wMatch">
            <para>Type: <c>TCHAR</c></para>
            <para>The character to search for.</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns a pointer to the last occurrence of the character in the string, if successful, or <c>NULL</c> if not.</para>
            </returns>
            <remarks>
            <para>The comparison assumes that pszEnd points to the end of the string.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrRetToBSTR(System.IntPtr,System.IntPtr,System.String@)">
            <summary>
            Accepts a STRRET structure returned by IShellFolder::GetDisplayNameOf that contains or points to a string, and returns that
            string as a BSTR.
            </summary>
            <param name="pstr">
            <para>Type: <c>STRRET*</c></para>
            <para>A pointer to a STRRET structure. When the function returns, this pointer is longer valid.</para>
            </param>
            <param name="pidl">
            <para>Type: <c>PCUITEMID_CHILD</c></para>
            <para>
            A pointer to an ITEMIDLIST that uniquely identifies a file object or subfolder relative to the parent folder. This value can be <c>NULL</c>.
            </para>
            </param>
            <param name="pbstr">
            <para>Type: <c>BSTR*</c></para>
            <para>A pointer to a variable of type BSTR that receives the converted string.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            If the uType member of the STRRET structure pointed to by pstr is set to <c>STRRET_WSTR</c>, the pOleStr member of that
            structure is freed on return.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrRetToBuf(System.IntPtr,System.IntPtr,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>Converts an STRRET structure returned by IShellFolder::GetDisplayNameOf to a string, and places the result in a buffer.</para>
            </summary>
            <param name="pstr">
            <para>Type: <c>STRRET*</c></para>
            <para>A pointer to the STRRET structure. When the function returns, this pointer will no longer be valid.</para>
            </param>
            <param name="pidl">
            <para>Type: <c>PCUITEMID_CHILD</c></para>
            <para>A pointer to the item's ITEMIDLIST structure.</para>
            </param>
            <param name="pszBuf">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A buffer to hold the display name. It will be returned as a null-terminated string. If cchBuf is too small, the name will be
            truncated to fit.
            </para>
            </param>
            <param name="cchBuf">
            <para>Type: <c>UINT</c></para>
            <para>The size of pszBuf, in characters. If cchBuf is too small, the string will be truncated to fit.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            If the <c>uType</c> member of the structure pointed to by pstr is set to <c>STRRET_WSTR</c>, the <c>pOleStr</c> member of that
            structure will be freed on return.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrRetToStr(System.IntPtr,System.IntPtr,System.String@)">
            <summary>
            <para>
            Takes an STRRET structure returned by IShellFolder::GetDisplayNameOf and returns a pointer to an allocated string containing the
            display name.
            </para>
            </summary>
            <param name="pstr">
            <para>Type: <c>STRRET*</c></para>
            <para>A pointer to the STRRET structure. When the function returns, this pointer will no longer be valid.</para>
            </param>
            <param name="pidl">
            <para>Type: <c>PCUITEMID_CHILD</c></para>
            <para>A pointer to the item's ITEMIDLIST structure. This value can be <c>NULL</c>.</para>
            </param>
            <param name="ppsz">
            <para>Type: <c>LPTSTR*</c></para>
            <para>
            A pointer to an allocated string containing the result. <c>StrRetToStr</c> allocates memory for this string with CoTaskMemAlloc.
            You should free the string with CoTaskMemFree when it is no longer needed.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrRStrI(System.String,System.String,System.String)">
            <summary>
            <para>Searches for the last occurrence of a specified substring within a string. The comparison is not case-sensitive.</para>
            </summary>
            <param name="pszSource">
            <para>Type: <c>PTSTR</c></para>
            <para>A pointer to a <c>null</c>-terminated source string.</para>
            </param>
            <param name="pszLast">
            <para>Type: <c>PCTSTR</c></para>
            <para>
            A pointer into the source string that defines the range of the search. Set pszLast to point to a character in the source string,
            and the search will stop with the preceding character. Set pszLast to <c>NULL</c> to search the entire source string.
            </para>
            </param>
            <param name="pszSrch">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the substring to search for.</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns the address of the last occurrence of the substring if successful, or <c>NULL</c> otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrSpn(System.String,System.String)">
            <summary>
            <para>Obtains the length of a substring within a string that consists entirely of characters contained in a specified buffer.</para>
            </summary>
            <param name="psz">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the null-terminated string that is to be searched.</para>
            </param>
            <param name="pszSet">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to a null-terminated character buffer that contains the set of characters for which to search.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>Returns the length, in characters, of the matching string or zero if no match is found.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrStr(System.String,System.String)">
            <summary>
            <para>Finds the first occurrence of a substring within a string. The comparison is case-sensitive.</para>
            </summary>
            <param name="pszFirst">
            <para>Type: <c>PTSTR</c></para>
            <para>A pointer to the null-terminated string to search.</para>
            </param>
            <param name="pszSrch">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the substring to search for.</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns the address of the first occurrence of the matching substring if successful, or <c>NULL</c> otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrStrI(System.String,System.String)">
            <summary>
            <para>Finds the first occurrence of a substring within a string. The comparison is not case-sensitive.</para>
            </summary>
            <param name="pszFirst">
            <para>Type: <c>PTSTR</c></para>
            <para>A pointer to the null-terminated string being searched.</para>
            </param>
            <param name="pszSrch">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to the substring to search for.</para>
            </param>
            <returns>
            <para>Type: <c>PTSTR</c></para>
            <para>Returns the address of the first occurrence of the matching substring if successful, or <c>NULL</c> otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrStrNIW(System.String,System.String,System.UInt32)">
            <summary>
            <para>Finds the first occurrence of a substring within a string. The comparison is case-insensitive.</para>
            </summary>
            <param name="pszFirst">
            <para>Type: <c>PWSTR</c></para>
            <para>A pointer to the null-terminated, Unicode string that is being searched.</para>
            </param>
            <param name="pszSrch">
            <para>Type: <c>PCWSTR</c></para>
            <para>A pointer to the null-terminated, Unicode substring that is being searched for.</para>
            </param>
            <param name="cchMax">
            <para>Type: <c>UINT</c></para>
            <para>The maximum number of characters from the beginning of the searched string in which to search for the substring.</para>
            </param>
            <returns>
            <para>Type: <c>PWSTR</c></para>
            <para>Returns the address of the first occurrence of the matching substring if successful, or <c>NULL</c> otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrStrNW(System.String,System.String,System.UInt32)">
            <summary>
            <para>Finds the first occurrence of a substring within a string. The comparison is case-sensitive.</para>
            </summary>
            <param name="pszFirst">
            <para>Type: <c>PWSTR</c></para>
            <para>A pointer to the null-terminated, Unicode string that is being searched.</para>
            </param>
            <param name="pszSrch">
            <para>Type: <c>PCWSTR</c></para>
            <para>A pointer to the null-terminated, Unicode substring that is being searched for.</para>
            </param>
            <param name="cchMax">
            <para>Type: <c>UINT</c></para>
            <para>The maximum number of characters from the beginning of the searched string in which to search for the substring.</para>
            </param>
            <returns>
            <para>Type: <c>PWSTR</c></para>
            <para>Returns the address of the first occurrence of the matching substring if successful, or <c>NULL</c> otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrToInt(System.String)">
            <summary>
            <para>Converts a string that represents a decimal value to an integer. The <c>StrToLong</c> macro is identical to this function.</para>
            </summary>
            <param name="pszSrc">
            <para>Type: <c>PCTSTR</c></para>
            <para>
            A pointer to the null-terminated string to be converted. A valid string representing a decimal value contains only the characters
            0-9 and must have the following form to be parsed successfully.
            </para>
            <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>Returns the <c>int</c> value represented by pszSrc. For instance, the string "123" returns the integer value 123.</para>
            </returns>
            <remarks>
            <para>
            If the string pointed to by pszSrc contains an invalid character, that character is considered the end of the string to be
            converted and the remainder is ignored. For instance, given the invalid decimal string "12b34", <c>StrToInt</c> only recognizes
            "12" and returns that integer value.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrToInt64Ex(System.String,Vanara.PInvoke.ShlwApi.STIF_FLAGS,System.Int64@)">
            <summary>
            <para>Converts a string representing a decimal or hexadecimal value to a 64-bit integer.</para>
            </summary>
            <param name="pszString">
            <para>Type: <c>PCTSTR</c></para>
            <para>
            A pointer to the <c>null</c>-terminated string to be converted. For further details concerning the valid forms of the string, see
            the Remarks section.
            </para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>STIF_FLAGS</c></para>
            <para>One of the following values that specify how pszString should be parsed for its conversion to a 64-bit integer.</para>
            <para>STIF_DEFAULT</para>
            <para>The string at pszString contains the representation of a decimal value.</para>
            <para>STIF_SUPPORT_HEX</para>
            <para>
            The string at pszString contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal
            representations, the characters A-F are case-insensitive.
            </para>
            </param>
            <param name="pllRet">
            <para>Type: <c>LONGLONG*</c></para>
            <para>
            A pointer to a variable of type <c>LONGLONG</c> that receives the 64-bit integer value of the converted string. For instance, in
            the case of the string "123", the integer pointed to by this value receives the value 123.
            </para>
            <para>If this function returns <c>FALSE</c>, this value is undefined.</para>
            <para>
            If the value returned is too large to be contained in a variable of type <c>LONGLONG</c>, this parameter contains the 64
            low-order bits of the value. Any high-order bits beyond that are lost.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if the string is converted; otherwise <c>FALSE</c>.</para>
            </returns>
            <remarks>
            <para>The string pointed to by the pszString parameter must have one of the following forms to be parsed successfully.</para>
            <list type="bullet">
            <item>
            <term>This form is accepted as a decimal value under either flag.</term>
            </item>
            <item>
            <term>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.</term>
            </item>
            </list>
            <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
            <para>
            <c>Note</c> If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the
            string "-0x1" is parsed as 1 instead of -1.
            </para>
            <para>
            If the string pointed to by pszString contains an invalid character, that character is considered the end of the string to be
            converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <c>StrToInt64Ex</c> only
            recognizes "0x00a", converts it to the integer value 10, and returns <c>TRUE</c>.
            </para>
            <para>
            If pllRet is <c>NULL</c>, the function returns <c>TRUE</c> if the string can be converted, even though it does not perform the conversion.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrToIntEx(System.String,Vanara.PInvoke.ShlwApi.STIF_FLAGS,System.Int32@)">
            <summary>
            <para>Converts a string representing a decimal or hexadecimal number to an integer.</para>
            </summary>
            <param name="pszString">
            <para>Type: <c>PCTSTR</c></para>
            <para>
            A pointer to the null-terminated string to be converted. For further details concerning the valid forms of the string, see the
            Remarks section.
            </para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>STIF_FLAGS</c></para>
            <para>One of the following values that specify how pszString should be parsed for its conversion to an integer.</para>
            <para>STIF_DEFAULT</para>
            <para>The string at pszString contains the representation of a decimal value.</para>
            <para>STIF_SUPPORT_HEX</para>
            <para>
            The string at pszString contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal
            representations, the characters A-F are case-insensitive.
            </para>
            </param>
            <param name="piRet">
            <para>Type: <c>int*</c></para>
            <para>
            A pointer to an <c>int</c> that receives the converted string. For instance, in the case of the string "123", the integer pointed
            to by this value receives the integer value 123.
            </para>
            <para>If this function returns <c>FALSE</c>, this value is undefined.</para>
            <para>
            If the value returned is too large to be contained in a variable of type <c>int</c>, this parameter contains the 32 low-order
            bits of the value. Any high-order bits beyond that are lost.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if the string is converted; otherwise <c>FALSE</c>.</para>
            </returns>
            <remarks>
            <para>The string pointed to by the pszString parameter must have one of the following forms to be parsed successfully.</para>
            <list type="bullet">
            <item>
            <term>This form is accepted as a decimal value under either flag.</term>
            </item>
            <item>
            <term>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.</term>
            </item>
            </list>
            <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
            <para>
            <c>Note</c> If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the
            string "-0x1" is parsed as 1 instead of -1.
            </para>
            <para>
            If the string pointed to by pszString contains an invalid character, that character is considered the end of the string to be
            converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <c>StrToIntEx</c> only
            recognizes "0x00a", converts it to the integer value 10, and returns <c>TRUE</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.StrTrim(System.Text.StringBuilder,System.String)">
            <summary>
            <para>Removes specified leading and trailing characters from a string.</para>
            </summary>
            <param name="psz">
            <para>Type: <c>PTSTR</c></para>
            <para>
            A pointer to the null-terminated string to be trimmed. When this function returns successfully, psz receives the trimmed string.
            </para>
            </param>
            <param name="pszTrimChars">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to a null-terminated string that contains the characters to trim from psz.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para><c>TRUE</c> if any characters were removed; otherwise, <c>FALSE</c>.</para>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.URL_APPLY">
            <summary>The flags that specify how to determine the scheme.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_APPLY.URL_APPLY_DEFAULT">
            <summary>
            Apply the default scheme if <c>UrlApplyScheme</c> can't determine one. The default prefix is stored in the registry but is
            typically "http".
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_APPLY.URL_APPLY_GUESSSCHEME">
            <summary>Attempt to determine the scheme by examining pszIn.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_APPLY.URL_APPLY_GUESSFILE">
            <summary>Attempt to determine a file URL from pszIn.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_APPLY.URL_APPLY_FORCEAPPLY">
            <summary>Force <c>UrlApplyScheme</c> to determine a scheme for pszIn.</summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.URL_SCHEME">
            <summary>
            <para>Used to specify URL schemes.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_INVALID">
            <summary>An invalid scheme.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_UNKNOWN">
            <summary>An unknown scheme.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_FTP">
            <summary>FTP (ftp:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_HTTP">
            <summary>HTTP (http:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_GOPHER">
            <summary>Gopher (gopher:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_MAILTO">
            <summary>Mail-to (mailto:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_NEWS">
            <summary>Usenet news (news:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_NNTP">
            <summary>Usenet news with NNTP (nntp:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_TELNET">
            <summary>Telnet (telnet:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_WAIS">
            <summary>Wide Area Information Server (wais:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_FILE">
            <summary>File (file:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_MK">
            <summary>URL moniker (mk:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_HTTPS">
            <summary>URL HTTPS (https:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_SHELL">
            <summary>Shell (shell:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_SNEWS">
            <summary>NNTP news postings with SSL (snews:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_LOCAL">
            <summary>Local (local:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_JAVASCRIPT">
            <summary>JavaScript (javascript:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_VBSCRIPT">
            <summary>VBScript (vbscript:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_ABOUT">
            <summary>About (about:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_RES">
            <summary>Res (res:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_MSSHELLROOTED">
            <summary>Internet Explorer 6 and later only. Shell-rooted (ms-shell-rooted:)</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_MSSHELLIDLIST">
            <summary>Internet Explorer 6 and later only. Shell ID-list (ms-shell-idlist:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_MSHELP">
            <summary>Internet Explorer 6 and later only. MSHelp (hcp:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_MSSHELLDEVICE">
            <summary>Not supported.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_WILDCARD">
            <summary>Internet Explorer 7 and later only. Wildcard (*:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_SEARCH_MS">
            <summary>Windows Vista and later only. Search-MS (search-ms:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_SEARCH">
            <summary>Windows Vista with SP1 and later only. Search (search:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_KNOWNFOLDER">
            <summary>Windows 7 and later. Known folder (knownfolder:).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URL_SCHEME.URL_SCHEME_MAXVALUE">
            <summary>The highest legitimate value in the enumeration, used for validation purposes.</summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.URLFLAGS">
            <summary>The flags that specify how the URL is converted to canonical form.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_UNESCAPE">
            <summary>
            Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for "?" and "#" are not
            un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_ESCAPE_UNSAFE">
            <summary>
            Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered
            during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, [, ], and ') characters. This flag applies
            to all URLs, including opaque URLs.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_PLUGGABLE_PROTOCOL">
            <summary>
            Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to
            standard protocols such as ftp, http, gopher, and so on. If this flag is set, UrlCombine does not simplify URLs, so there is
            no need to also set URL_DONT_SIMPLIFY.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_WININET_COMPATIBILITY">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_DONT_ESCAPE_EXTRA_INFO">
            <summary>
            Used only in conjunction with URL_ESCAPE_SPACES_ONLY to prevent the conversion of characters in the query (the portion of the
            URL following the first # or ? character encountered in the string). This flag should not be used alone, nor combined with URL_ESCAPE_SEGMENT_ONLY.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_DONT_UNESCAPE_EXTRA_INFO">
            <summary>Defined to be the same as URL_DONT_ESCAPE_EXTRA_INFO.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_BROWSER_MODE">
            <summary>Defined to be the same as URL_DONT_ESCAPE_EXTRA_INFO.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_ESCAPE_SPACES_ONLY">
            <summary>
            Convert only space characters to their escape sequences, including those space characters in the query portion of the URL.
            Other unsafe characters are not converted to their escape sequences. This flag assumes that pszURL does not contain a full
            URL. It expects only the portions following the server specification.
            <para>
            Combine this flag with URL_DONT_ESCAPE_EXTRA_INFO to prevent the conversion of space characters in the query portion of the URL.
            </para>
            <para>This flag cannot be combined with URL_ESCAPE_PERCENT or URL_ESCAPE_SEGMENT_ONLY.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_DONT_SIMPLIFY">
            <summary>
            Treat "/./" and "/../" in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_NO_META">
            <summary>Defined to be the same as URL_DONT_SIMPLIFY.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_UNESCAPE_INPLACE">
            <summary>Converts escape sequences back into ordinary characters and overwrites the original string.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_CONVERT_IF_DOSPATH">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_UNESCAPE_HIGH_ANSI_ONLY">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_INTERNAL_PATH">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_FILE_USE_PATHURL">
            <summary>Use DOS path compatibility mode to create "file" URIs.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_DONT_UNESCAPE">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_ESCAPE_AS_UTF8">
            <summary>Windows 7 and later. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_UNESCAPE_AS_UTF8">
            <summary>Windows 7 and later. Percent-unencode all non-ASCII characters as their UTF-8 equivalents.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_ESCAPE_ASCII_URI_COMPONENT">
            <summary>Windows 8 and later. Percent-encode all ASCII characters outside of the unreserved set from URI RFC 3986 (a-zA-Z0-9-.~_).</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_ESCAPE_URI_COMPONENT">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_UNESCAPE_URI_COMPONENT">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_ESCAPE_PERCENT">
            <summary>
            Convert any % character found in the segment section of the URL (that section falling between the server specification and
            the first # or ? character). By default, the % character is not converted to its escape sequence. Other unsafe characters in
            the segment are also converted normally.
            <para>
            Combining this flag with URL_ESCAPE_SEGMENT_ONLY includes those % characters in the query portion of the URL. However, as the
            URL_ESCAPE_SEGMENT_ONLY flag causes the entire string to be considered the segment, any # or ? characters are also converted.
            </para>
            <para>This flag cannot be combined with URL_ESCAPE_SPACES_ONLY.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLFLAGS.URL_ESCAPE_SEGMENT_ONLY">
            <summary>
            Indicates that pszURL contains only that section of the URL following the server component but preceding the query. All
            unsafe characters in the string are converted. If a full URL is provided when this flag is set, all unsafe characters in the
            entire string are converted, including # and ? characters.
            <para>Combine this flag with URL_ESCAPE_PERCENT to include that character in the conversion.</para>
            <para>This flag cannot be combined with URL_ESCAPE_SPACES_ONLY or URL_DONT_ESCAPE_EXTRA_INFO.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.URLIS">
            <summary>The type of URL to be tested for. This parameter can take one of the following values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLIS.URLIS_URL">
            <summary>Is the URL valid?</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLIS.URLIS_OPAQUE">
            <summary>Is the URL opaque?</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLIS.URLIS_NOHISTORY">
            <summary>Is the URL a URL that is not typically tracked in navigation history?</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLIS.URLIS_FILEURL">
            <summary>Is the URL a file URL?</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLIS.URLIS_APPLIABLE">
            <summary>Attempt to determine a valid scheme for the URL.</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLIS.URLIS_DIRECTORY">
            <summary>Does the URL string end with a directory?</summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.URLIS.URLIS_HASQUERY">
            <summary>Does the URL have an appended query string?</summary>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.ParseURL(System.String,Vanara.PInvoke.ShlwApi.PARSEDURL@)">
            <summary>
            <para>Performs rudimentary parsing of a URL.</para>
            </summary>
            <param name="pcszURL">
            <para>TBD</para>
            </param>
            <param name="ppu">
            <para>Type: <c>PARSEDURL*</c></para>
            <para>
            A pointer to a PARSEDURL structure that receives the parsed results. The calling application must set the structure's cbSize
            member to the size of the structure before calling <c>ParseURL</c>.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            Returns <c>S_OK</c> on success, or a COM error code otherwise. The function returns <c>URL_E_INVALID_SYNTAX</c> (defined in
            Intshcut.h) if the string could not be parsed as a URL.
            </para>
            </returns>
            <remarks>
            <para>The parsing performed by <c>ParseURL</c> is fairly rudimentary. For more sophisticated URL parsing, use InternetCrackUrl.</para>
            <para>Examples</para>
            <para>This sample console application uses <c>ParseURL</c> to parse several simple URLs.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.UrlApplyScheme(System.String,System.Text.StringBuilder,System.UInt32@,Vanara.PInvoke.ShlwApi.URL_APPLY)">
            <summary>
            <para>Determines a scheme for a specified URL string, and returns a string with an appropriate prefix.</para>
            </summary>
            <param name="pszIn">
            <para>Type: <c>PCTSTR</c></para>
            <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL.</para>
            </param>
            <param name="pszOut">
            <para>Type: <c>PTSTR</c></para>
            <para>
            A pointer to a buffer that, when this function returns successfully, receives a null-terminated string set to the URL specified
            by pszIn and converted to the standard scheme://URL_string format.
            </para>
            </param>
            <param name="pcchOut">
            <para>Type: <c>DWORD*</c></para>
            <para>
            The address of a value set to the number of characters in the pszOut buffer. When the function returns, the value depends on
            whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.
            </para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>The flags that specify how to determine the scheme. The following flags can be combined.</para>
            <para>URL_APPLY_DEFAULT</para>
            <para>
            Apply the default scheme if <c>UrlApplyScheme</c> can't determine one. The default prefix is stored in the registry but is
            typically "http".
            </para>
            <para>URL_APPLY_GUESSSCHEME</para>
            <para>Attempt to determine the scheme by examining pszIn.</para>
            <para>URL_APPLY_GUESSFILE</para>
            <para>Attempt to determine a file URL from pszIn.</para>
            <para>URL_APPLY_FORCEAPPLY</para>
            <para>Force <c>UrlApplyScheme</c> to determine a scheme for pszIn.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns a standard COM return value, including the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>
            A scheme was determined. pszOut points to a string containing the URL with the scheme's prefix. The value of pcchOut is set to
            the number of characters in the string, not counting the terminating NULL character.
            </term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>There were no errors, but no prefix was prepended.</term>
            </item>
            <item>
            <term>E_POINTER</term>
            <term>
            The buffer was too small. The value of pcchOut is set to the minimum number of characters that the buffer must be able to
            contain, including the terminating NULL character.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If the URL has a valid scheme, the string will not be modified. However, almost any combination of two or more characters
            followed by a colon will be parsed as a scheme. Valid characters include some common punctuation marks, such as ".". If your
            input string fits this description, <c>UrlApplyScheme</c> may treat it as valid and not apply a scheme. To force the function to
            apply a scheme to a URL, set the <c>URL_APPLY_FORCEAPPLY</c> and <c>URL_APPLY_DEFAULT</c> flags in dwFlags. This combination of
            flags forces the function to apply a scheme to the URL. Typically, the function will not be able to determine a valid scheme. The
            second flag guarantees that, if no valid scheme can be determined, the function will apply the default scheme to the URL.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.UrlCanonicalize(System.String,System.Text.StringBuilder,System.UInt32@,Vanara.PInvoke.ShlwApi.URLFLAGS)">
            <summary>
            <para>Converts a URL string into canonical form.</para>
            </summary>
            <param name="pszUrl">
            <para>Type: <c>PCTSTR</c></para>
            <para>
            A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL string. If the string does
            not refer to a file, it must include a valid scheme such as "http://".
            </para>
            </param>
            <param name="pszCanonicalized">
            <para>Type: <c>PTSTR</c></para>
            <para>A pointer to a buffer that, when this function returns successfully, receives the converted URL as a null-terminated string.</para>
            </param>
            <param name="pcchCanonicalized">
            <para>Type: <c>DWORD*</c></para>
            <para>A pointer to a value that, on entry, is set to the number of characters in the pszCanonicalized buffer.</para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>The flags that specify how the URL is converted to canonical form. The following flags can be combined.</para>
            <para>URL_UNESCAPE (0x10000000)</para>
            <para>
            Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for "?" and "#" are not
            un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.
            </para>
            <para>URL_ESCAPE_UNSAFE (0x20000000)</para>
            <para>
            Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during
            transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, [, ], and ') characters. This flag applies to all
            URLs, including opaque URLs.
            </para>
            <para>URL_PLUGGABLE_PROTOCOL (0x40000000)</para>
            <para>
            Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard
            protocols such as ftp, http, gopher, and so on. If this flag is set, UrlCombine does not simplify URLs, so there is no need to
            also set <c>URL_DONT_SIMPLIFY</c>.
            </para>
            <para>URL_ESCAPE_SPACES_ONLY (0x04000000)</para>
            <para>
            Replace only spaces with escape sequences. This flag takes precedence over <c>URL_ESCAPE_UNSAFE</c>, but does not apply to opaque URLs.
            </para>
            <para>URL_DONT_SIMPLIFY (0x08000000)</para>
            <para>
            Treat "/./" and "/../" in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.
            </para>
            <para>URL_NO_META (0x08000000)</para>
            <para>Defined to be the same as <c>URL_DONT_SIMPLIFY</c>.</para>
            <para>URL_ESCAPE_PERCENT (0x00001000)</para>
            <para>Convert any occurrence of "%" to its escape sequence.</para>
            <para>URL_ESCAPE_AS_UTF8 (0x00040000)</para>
            <para><c>Windows 7 and later</c>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            This function performs such tasks as replacing unsafe characters with their escape sequences and collapsing sequences like ".....".
            </para>
            <para>
            If a URL string contains "/../" or "/./", <c>UrlCanonicalize</c> treats the characters as indicating navigation in the URL
            hierarchy. The function simplifies the URLs before combining them. For instance "/hello/cruel/../world" is simplified to
            "/hello/world". Exceptions to this default behavior occur in these cases:
            </para>
            <list type="bullet">
            <item>
            <term>
            If the <c>URL_DONT_SIMPLIFY</c> flag is set in dwFlags, the function does not simplify URLs. In this case,
            "/hello/cruel/../world" is left as it is.
            </term>
            </item>
            <item>
            <term>
            If "/../" or "/./" is the first segment in the path (for example, "http://domain/../path1/path2/file.htm"),
            <c>UrlCanonicalize</c> outputs the path exactly as it was input.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.UrlCombine(System.String,System.String,System.Text.StringBuilder,System.UInt32@,Vanara.PInvoke.ShlwApi.URLFLAGS)">
            <summary>
            <para>When provided with a relative URL and its base, returns a URL in canonical form.</para>
            </summary>
            <param name="pszBase">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the base URL.</para>
            </param>
            <param name="pszRelative">
            <para>Type: <c>PCTSTR</c></para>
            <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the relative URL.</para>
            </param>
            <param name="pszCombined">
            <para>Type: <c>PTSTR</c></para>
            <para>
            A pointer to a buffer that, when this function returns successfully, receives a null-terminated string that contains the combined URL.
            </para>
            </param>
            <param name="pcchCombined">
            <para>Type: <c>DWORD*</c></para>
            <para>
            A pointer to a value that, on entry, is set to the number of characters in the pszCombined buffer. When the function returns
            successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of
            this parameter is meaningless.
            </para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>Flags that specify how the URL is converted to canonical form. The following flags can be combined.</para>
            <para>URL_DONT_SIMPLIFY (0x08000000)</para>
            <para>
            Treat '/./' and '/../' in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.
            </para>
            <para>URL_ESCAPE_PERCENT (0x00001000)</para>
            <para>Convert any occurrence of '%' to its escape sequence.</para>
            <para>URL_ESCAPE_SPACES_ONLY (0x04000000)</para>
            <para>
            Replace only spaces with escape sequences. This flag takes precedence over <c>URL_ESCAPE_UNSAFE</c>, but does not apply to opaque URLs.
            </para>
            <para>URL_ESCAPE_UNSAFE (0x20000000)</para>
            <para>
            Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during
            transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, ~, [, ], and ') characters. This flag applies to
            all URLs, including opaque URLs.
            </para>
            <para>URL_NO_META</para>
            <para>Defined to be the same as <c>URL_DONT_SIMPLIFY</c>.</para>
            <para>URL_PLUGGABLE_PROTOCOL (0x40000000)</para>
            <para>
            Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard
            protocols such as ftp, http, gopher, and so on. If this flag is set, <c>UrlCombine</c> does not simplify URLs, so there is no
            need to also set <c>URL_DONT_SIMPLIFY</c>.
            </para>
            <para>URL_UNESCAPE (0x10000000)</para>
            <para>
            Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for '?' and '#' are not
            un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.
            </para>
            <para>URL_ESCAPE_AS_UTF8 (0x00040000)</para>
            <para><c>Windows 7 and later</c>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns standard COM error codes, including the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>
            pszCombined points to a string that contains the combined URLs. The value of pcchCombined is set to the number of characters in
            the string, not counting the terminating NULL character.
            </term>
            </item>
            <item>
            <term>E_POINTER</term>
            <term>
            The buffer was too small. The value of pcchCombined is set to the minimum number of characters that the buffer must be able to
            contain, including the terminating NULL character.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Items between slashes are treated as hierarchical identifiers; the last item specifies the document itself. You must enter a
            slash (/) after the document name to append more items; otherwise, <c>UrlCombine</c> exchanges one document for another. For example:
            </para>
            <para>
            The preceding code returns the URL http://xyz/test/bar. If you want the combined URL to be http://xyz/test/abc/bar, use the
            following call to <c>UrlCombine</c>.
            </para>
            <para>
            If a URL string contains '/../' or '/./', <c>UrlCombine</c> usually treats the characters as if they indicated navigation in the
            URL hierarchy. The function simplifies the URLs before combining them. For instance, "/hello/cruel/../world" is simplified to
            "/hello/world". If the <c>URL_DONT_SIMPLIFY</c> flag is set in dwFlags, the function does not simplify URLs. In this case,
            "/hello/cruel/../world" is left as it is.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.UrlCompare(System.String,System.String,System.Boolean)">
            <summary>
            <para>Makes a case-sensitive comparison of two URL strings.</para>
            </summary>
            <param name="psz1">
            <para>Type: <c>PCTSTR</c></para>
            <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the first URL.</para>
            </param>
            <param name="psz2">
            <para>Type: <c>PCTSTR</c></para>
            <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the second URL.</para>
            </param>
            <param name="fIgnoreSlash">
            <para>Type: <c>BOOL</c></para>
            <para>A value that is set to <c>TRUE</c> to have <c>UrlCompare</c> ignore a trailing '/' character on either or both URLs.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            Returns zero if the two strings are equal. The function will also return zero if fIgnoreSlash is set to <c>TRUE</c> and one of
            the strings has a trailing '' character. The function returns a negative integer if the string pointed to by psz1 is less than
            the string pointed to by psz2. Otherwise, it returns a positive integer.
            </para>
            </returns>
            <remarks>
            <para>
            For best results, you should first canonicalize the URLs with UrlCanonicalize. Then, compare the canonicalized URLs with <c>UrlCompare</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.UrlCreateFromPath(System.String,System.Text.StringBuilder,System.UInt32@,System.UInt32)">
            <summary>
            <para>Converts a Microsoft MS-DOS path to a canonicalized URL.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>PCTSTR</c></para>
            <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the MS-DOS path.</para>
            </param>
            <param name="pszUrl">
            <para>Type: <c>PTSTR</c></para>
            <para>A pointer to a buffer that, when this function returns successfully, receives the URL.</para>
            </param>
            <param name="pcchUrl">
            <para>Type: <c>DWORD*</c></para>
            <para>The number of characters in pszUrl.</para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>Reserved. Set this parameter to <c>NULL</c>.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            Returns S_FALSE if pszPath is already in URL format. In this case, pszPath will simply be copied to pszUrl. Otherwise, it returns
            S_OK if successful or a standard COM error value if not.
            </para>
            </returns>
            <remarks>
            <para>
            <c>Note</c><c>UrlCreateFromPath</c> does not support extended paths. These are paths that include the extended-length path prefix "\\?\".
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.UrlEscape(System.String,System.Text.StringBuilder,System.UInt32@,Vanara.PInvoke.ShlwApi.URLFLAGS)">
            <summary>
            <para>
            Converts characters or surrogate pairs in a URL that might be altered during transport across the Internet ("unsafe" characters)
            into their corresponding escape sequences. Surrogate pairs are characters between U+10000 to U+10FFFF (in UTF-32) or between DC00
            to DFFF (in UTF-16).
            </para>
            </summary>
            <param name="pszUrl">
            <para>Type: <c>PCTSTR</c></para>
            <para>
            A null-terminated string of maximum length <c>INTERNET_MAX_URL_LENGTH</c> that contains a full or partial URL, as appropriate for
            the value in dwFlags.
            </para>
            </param>
            <param name="pszEscaped">
            <para>Type: <c>PTSTR</c></para>
            <para>The buffer that receives the converted string, with the unsafe characters converted to their escape sequences.</para>
            </param>
            <param name="pcchEscaped">
            <para>Type: <c>DWORD*</c></para>
            <para>
            A pointer to a <c>DWORD</c> value that, on entry, contains the number of characters in the pszEscaped buffer. Before calling
            <c>UrlEscape</c>, the calling application must set the value referenced by pcchEscaped to the size of the buffer. When this
            function returns successfully, the value receives the number of characters written to the buffer, not including the terminating
            <c>NULL</c> character.
            </para>
            <para>
            If an E_POINTER error code is returned, the buffer was too small to hold the result, and the value referenced by pcchEscaped is
            set to the required number of characters in the buffer. If any other errors are returned, the value referenced by pcchEscaped is undefined.
            </para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>
            The flags that indicate which portion of the URL is being provided in pszURL and which characters in that string should be
            converted to their escape sequences. The following flags are defined.
            </para>
            <para>URL_DONT_ESCAPE_EXTRA_INFO (0x02000000)</para>
            <para>
            Used only in conjunction with <c>URL_ESCAPE_SPACES_ONLY</c> to prevent the conversion of characters in the query (the portion of
            the URL following the first # or ? character encountered in the string). This flag should not be used alone, nor combined with <c>URL_ESCAPE_SEGMENT_ONLY</c>.
            </para>
            <para>URL_BROWSER_MODE</para>
            <para>Defined to be the same as <c>URL_DONT_ESCAPE_EXTRA_INFO</c>.</para>
            <para>URL_ESCAPE_SPACES_ONLY (0x04000000)</para>
            <para>
            Convert only space characters to their escape sequences, including those space characters in the query portion of the URL. Other
            unsafe characters are not converted to their escape sequences. This flag assumes that pszURL does not contain a full URL. It
            expects only the portions following the server specification.
            </para>
            <para>
            Combine this flag with <c>URL_DONT_ESCAPE_EXTRA_INFO</c> to prevent the conversion of space characters in the query portion of
            the URL.
            </para>
            <para>This flag cannot be combined with <c>URL_ESCAPE_PERCENT</c> or <c>URL_ESCAPE_SEGMENT_ONLY</c>.</para>
            <para>URL_ESCAPE_PERCENT (0x00001000)</para>
            <para>
            Convert any % character found in the segment section of the URL (that section falling between the server specification and the
            first # or ? character). By default, the % character is not converted to its escape sequence. Other unsafe characters in the
            segment are also converted normally.
            </para>
            <para>
            Combining this flag with <c>URL_ESCAPE_SEGMENT_ONLY</c> includes those % characters in the query portion of the URL. However, as
            the <c>URL_ESCAPE_SEGMENT_ONLY</c> flag causes the entire string to be considered the segment, any # or ? characters are also converted.
            </para>
            <para>This flag cannot be combined with <c>URL_ESCAPE_SPACES_ONLY</c>.</para>
            <para>URL_ESCAPE_SEGMENT_ONLY (0x00002000)</para>
            <para>
            Indicates that pszURL contains only that section of the URL following the server component but preceding the query. All unsafe
            characters in the string are converted. If a full URL is provided when this flag is set, all unsafe characters in the entire
            string are converted, including # and ? characters.
            </para>
            <para>Combine this flag with <c>URL_ESCAPE_PERCENT</c> to include that character in the conversion.</para>
            <para>This flag cannot be combined with <c>URL_ESCAPE_SPACES_ONLY</c> or <c>URL_DONT_ESCAPE_EXTRA_INFO</c>.</para>
            <para>URL_ESCAPE_AS_UTF8 (0x00040000)</para>
            <para><c>Windows 7 and later</c>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
            <para>URL_ESCAPE_ASCII_URI_COMPONENT (0x00080000)</para>
            <para><c>Windows 8 and later</c>. Percent-encode all ASCII characters outside of the unreserved set from URI RFC 3986 (a-zA-Z0-9-.~_).</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            Returns S_OK if successful. If the pcchEscaped buffer was too small to contain the result, E_POINTER is returned, and the value
            pointed to by pcchEscaped is set to the required buffer size. Otherwise, a standard error value is returned.
            </para>
            </returns>
            <remarks>
            <para>
            For the purposes of this document, a typical URL is divided into three sections: the server, the segment, and the query. For example:
            </para>
            <para>The server portion is "http://microsoft.com/". The trailing forward slash is considered part of the server portion.</para>
            <para>
            The segment portion is any part of the path found following the server portion, but before the first # or ? character, in this
            case simply "test.asp".
            </para>
            <para>
            The query portion is the remainder of the path from the first # or ? character (inclusive) to the end. In the example, it is "?url=/example/abc.asp?frame=true#fragment".
            </para>
            <para>
            Unsafe characters are those characters that might be altered during transport across the Internet. This function converts unsafe
            characters into their equivalent "%xy" escape sequences. The following table shows unsafe characters and their escape sequences.
            </para>
            <list type="table">
            <listheader>
            <term>Character</term>
            <term>Escape Sequence</term>
            </listheader>
            <item>
            <term>^</term>
            <term>%5E</term>
            </item>
            <item>
            <term>&amp;</term>
            <term>%26</term>
            </item>
            <item>
            <term>`</term>
            <term>%60</term>
            </item>
            <item>
            <term>{</term>
            <term>%7B</term>
            </item>
            <item>
            <term>}</term>
            <term>%7D</term>
            </item>
            <item>
            <term>|</term>
            <term>%7C</term>
            </item>
            <item>
            <term>]</term>
            <term>%5D</term>
            </item>
            <item>
            <term>[</term>
            <term>%5B</term>
            </item>
            <item>
            <term>"</term>
            <term>%22</term>
            </item>
            <item>
            <term>&lt;</term>
            <term>%3C</term>
            </item>
            <item>
            <term>&gt;</term>
            <term>%3E</term>
            </item>
            <item>
            <term>\</term>
            <term>%5C</term>
            </item>
            </list>
            <para>Use of the <c>URL_ESCAPE_SEGMENT_ONLY</c> flag also causes the conversion of the # (%23), ? (%3F), and / (%2F) characters.</para>
            <para>
            By default, <c>UrlEscape</c> ignores any text following a # or ? character. The <c>URL_ESCAPE_SEGMENT_ONLY</c> flag overrides
            this behavior by regarding the entire string as the segment. The <c>URL_ESCAPE_SPACES_ONLY</c> flag overrides this behavior, but
            only for space characters.
            </para>
            <para>Examples</para>
            <para>
            The following examples show the effect of the various flags on a URL. The example URL is not valid but is exaggerated for
            demonstration purposes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.UrlFixupW(System.String,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>
            [ <c>UrlFixupW</c> is available for use in the operating systems specified in the Requirements section. It may be altered or
            unavailable in subsequent versions.]
            </para>
            <para>Attempts to correct a URL whose protocol identifier is incorrect. For example, will be changed to .</para>
            </summary>
            <param name="pcszUrl">
            <para>Type: <c>PCWSTR</c></para>
            <para>
            A pointer to a <c>null</c>-terminated string that contains the URL to be corrected. This string must not exceed
            INTERNET_MAX_PATH_LENGTH characters in length, including the terminating <c>NULL</c> character.
            </para>
            </param>
            <param name="pszTranslatedUrl">
            <para>Type: <c>PWSTR</c></para>
            <para>
            A pointer to a buffer that, when this function returns successfully, receives the copied characters. The buffer must be large
            enough to contain the number of WCHAR characters specified by the cchMax parameter, including the terminating <c>NULL</c>
            character. This parameter can be equal to the pcszUrl parameter to correct a URL in place. If pszTranslatedUrl is not equal to
            pcszUrl, the buffer pointed to by pszTranslatedUrl must not overlap the buffer pointed to by pcszUrl.
            </para>
            </param>
            <param name="cchMax">
            <para>Type: <c>DWORD</c></para>
            <para>
            The number of <c>WCHAR</c> characters that can be contained in the buffer pointed to by pszTranslatedUrl. This parameter must be
            greater than zero.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            Returns S_OK if the proposed URL was already acceptable or was successfully corrected. The pszTranslatedUrl buffer contains the
            corrected URL, or the original URL if no correction was needed. Returns S_FALSE if the proposed URL could not be recognized
            sufficiently to be corrected. Otherwise, returns a standard COM error code.
            </para>
            </returns>
            <remarks>
            <para>The UrlFixup function recognizes the schemes specified by the URL_SCHEME enumeration.</para>
            <para>Priority is given to the first character in the protocol identifier section so will be converted to instead of .</para>
            <para>
            <c>Note</c> Do not use this function for deterministic data transformation. The heuristics used by <c>UrlFixupW</c> can change
            from one release to the next. The function should only be used to correct possibly invalid user input.
            </para>
            <para>This function is available only in a Unicode version.</para>
            <para>Examples</para>
            <para>
            This example shows how to use <c>UrlFixupW</c>. Notice that the last four autocorrections were probably not what the user
            intended and demonstrate limitations of the heuristic used by the function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.UrlGetLocation(System.String)">
            <summary>
            <para>Retrieves the location from a URL.</para>
            </summary>
            <param name="pszURL">
            <para>Type: <c>PCTSTR</c></para>
            <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the location.</para>
            </param>
            <returns>
            <para>Type: <c>LPCTSTR</c></para>
            <para>Returns a pointer to a null-terminated string with the location, or <c>NULL</c> otherwise.</para>
            </returns>
            <remarks>
            <para>
            The location is the segment of the URL starting with a ? or # character. If a file URL has a query string, the returned string
            includes the query string.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.UrlGetPart(System.String,System.Text.StringBuilder,System.UInt32@,System.UInt32,System.UInt32)">
            <summary>
            <para>Accepts a URL string and returns a specified part of that URL.</para>
            </summary>
            <param name="pszIn">
            <para>Type: <c>PCTSTR</c></para>
            <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
            </param>
            <param name="pszOut">
            <para>Type: <c>PTSTR</c></para>
            <para>
            A pointer to a buffer that, when this function returns successfully, receives a null-terminated string with the specified part of
            the URL.
            </para>
            </param>
            <param name="pcchOut">
            <para>Type: <c>DWORD*</c></para>
            <para>
            A pointer to a value that, on entry, is set to the number of characters in the pszOut buffer. When this function returns
            successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of
            this parameter is meaningless.
            </para>
            </param>
            <param name="dwPart">
            <para>Type: <c>DWORD</c></para>
            <para>The flags that specify which part of the URL to retrieve. It can have one of the following values.</para>
            <para>URL_PART_HOSTNAME</para>
            <para>The host name.</para>
            <para>URL_PART_PASSWORD</para>
            <para>The password.</para>
            <para>URL_PART_PORT</para>
            <para>The port number.</para>
            <para>URL_PART_QUERY</para>
            <para>The query portion of the URL.</para>
            <para>URL_PART_SCHEME</para>
            <para>The URL scheme.</para>
            <para>URL_PART_USERNAME</para>
            <para>The username.</para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>A flag that can be set to keep the URL scheme, in addition to the part that is specified by dwPart.</para>
            <para>URL_PARTFLAG_KEEPSCHEME (0x01)</para>
            <para>Keep the URL scheme.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            Returns S_OK if successful. The value pointed to by pcchOut will be set to the number of characters written to the output buffer,
            excluding the terminating <c>NULL</c>. If the buffer was too small, E_POINTER is returned, and the value pointed to by pcchOut
            will be set to the minimum number of characters that the buffer must be able to contain, including the terminating <c>NULL</c>
            character. Otherwise, a COM error value is returned.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.UrlHash(System.String,System.IntPtr,System.UInt32)">
            <summary>
            <para>Hashes a URL string.</para>
            </summary>
            <param name="pszUrl">
            <para>Type: <c>PCTSTR</c></para>
            <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
            </param>
            <param name="pbHash">
            <para>Type: <c>BYTE*</c></para>
            <para>A pointere to a buffer that, when this function returns successfully, receives the hashed array.</para>
            </param>
            <param name="cbHash">
            <para>Type: <c>DWORD</c></para>
            <para>The number of elements in the array at pbHash. It should be no larger than 256.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            To hash a URL into a single byte, set cbHash = sizeof(BYTE) and pbHash = (LPBYTE)&amp;bHashedValue, where bHashedValue is a
            one-byte buffer. To hash a URL into a <c>DWORD</c>, set cbHash = sizeof(DWORD) and pbHash = (LPBYTE)&amp;dwHashedValue, where
            dwHashedValue is a <c>DWORD</c> buffer.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.UrlIs(System.String,Vanara.PInvoke.ShlwApi.URLIS)">
            <summary>
            <para>Tests whether a URL is a specified type.</para>
            </summary>
            <param name="pszUrl">
            <para>Type: <c>PCTSTR</c></para>
            <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
            </param>
            <param name="UrlIs">
            <para>Type: <c>URLIS</c></para>
            <para>The type of URL to be tested for. This parameter can take one of the following values.</para>
            <para>URLIS_APPLIABLE</para>
            <para>Attempt to determine a valid scheme for the URL.</para>
            <para>URLIS_DIRECTORY</para>
            <para>Does the URL string end with a directory?</para>
            <para>URLIS_FILEURL</para>
            <para>Is the URL a file URL?</para>
            <para>URLIS_HASQUERY</para>
            <para>Does the URL have an appended query string?</para>
            <para>URLIS_NOHISTORY</para>
            <para>Is the URL a URL that is not typically tracked in navigation history?</para>
            <para>URLIS_OPAQUE</para>
            <para>Is the URL opaque?</para>
            <para>URLIS_URL</para>
            <para>Is the URL valid?</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            For all but one of the URL types, <c>UrlIs</c> returns <c>TRUE</c> if the URL is the specified type, or <c>FALSE</c> if not.
            </para>
            <para>
            If UrlIs is set to <c>URLIS_APPLIABLE</c>, <c>UrlIs</c> will attempt to determine the URL scheme. If the function is able to
            determine a scheme, it returns <c>TRUE</c>, or <c>FALSE</c> otherwise.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.UrlIsNoHistory(System.String)">
            <summary>
            <para>Returns whether a URL is a URL that browsers typically do not include in navigation history.</para>
            </summary>
            <param name="pszURL">
            <para>Type: <c>PCTSTR</c></para>
            <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns a nonzero value if the URL is a URL that is not included in navigation history, or zero otherwise.</para>
            </returns>
            <remarks>
            <para>This function is equivalent to the following:</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.UrlIsOpaque(System.String)">
            <summary>
            <para>Returns whether a URL is opaque.</para>
            </summary>
            <param name="pszURL">
            <para>Type: <c>PCTSTR</c></para>
            <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns a nonzero value if the URL is opaque, or zero otherwise.</para>
            </returns>
            <remarks>
            <para>
            A URL that has a scheme that is not followed by two slashes (//) is opaque. For example, xyz@litwareinc.com is an opaque URL.
            Opaque URLs cannot be separated into the standard URL hierarchy. <c>UrlIsOpaque</c> is equivalent to the following:
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.ShlwApi.UrlUnescape(System.Text.StringBuilder,System.Text.StringBuilder,System.UInt32@,Vanara.PInvoke.ShlwApi.URLFLAGS)">
            <summary>
            <para>Converts escape sequences back into ordinary characters.</para>
            </summary>
            <param name="pszUrl">
            <para>Type: <c>PTSTR</c></para>
            <para>
            A pointer to a null-terminated string with the URL. If dwFlags is set to <c>URL_UNESCAPE_INPLACE</c>, the converted string is
            returned through this parameter.
            </para>
            </param>
            <param name="pszUnescaped">
            <para>Type: <c>PTSTR</c></para>
            <para>
            A pointer to a buffer that will receive a null-terminated string that contains the unescaped version of pszURL. If
            <c>URL_UNESCAPE_INPLACE</c> is set in dwFlags, this parameter is ignored.
            </para>
            </param>
            <param name="pcchUnescaped">
            <para>Type: <c>DWORD*</c></para>
            <para>
            The number of characters in the buffer pointed to by pszUnescaped. On entry, the value pcchUnescaped points to is set to the size
            of the buffer. If the function returns a success code, the value that pcchUnescaped points to is set to the number of characters
            written to that buffer, not counting the terminating <c>NULL</c> character. If an E_POINTER error code is returned, the buffer
            was too small, and the value to which pcchUnescaped points is set to the required number of characters that the buffer must be
            able to contain. If any other errors are returned, the value to which pcchUnescaped points is undefined.
            </para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>Flags that control which characters are unescaped. It can be a combination of the following flags.</para>
            <para>URL_DONT_UNESCAPE_EXTRA_INFO</para>
            <para>Do not convert the # or ? character, or any characters following them in the string.</para>
            <para>URL_UNESCAPE_AS_UTF8</para>
            <para><c>Introduced in Windows 8</c>. Decode URLs that were encoded by using the <c>URL_ESCAPE_AS_UTF8</c> flag.</para>
            <para>URL_UNESCAPE_INPLACE</para>
            <para>Use pszURL to return the converted string instead of pszUnescaped.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            Returns S_OK if successful. If the <c>URL_UNESCAPE_INPLACE</c> flag is not set, the value pointed to by pcchUnescaped will be set
            to the number of characters in the output buffer pointed to by pszUnescaped. Returns E_POINTER if the <c>URL_UNESCAPE_INPLACE</c>
            flag is not set and the output buffer is too small. The pcchUnescaped parameter will be set to the required buffer size.
            Otherwise, returns a standard error value.
            </para>
            </returns>
            <remarks>
            <para>An escape sequence has the form "%xy".</para>
            <para>Input strings cannot be longer than INTERNET_MAX_URL_LENGTH.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.ShlwApi.PARSEDURL">
            <summary>
            <para>Used by the ParseURL function to return the parsed URL.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PARSEDURL.cbSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            [in] The size of the structure, in bytes. The calling application must set this member before calling the ParseURL function.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PARSEDURL.pszProtocol">
            <summary>
            <para>Type: <c>LPCTSTR</c></para>
            <para>[out] A pointer to the beginning of the protocol part of the URL.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PARSEDURL.cchProtocol">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The number of characters in the URL's protocol section.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PARSEDURL.pszSuffix">
            <summary>
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            [out] A pointer to the section of the URL that follows the protocol and colon (':'). For file URLs, the function also skips
            the leading "//" characters.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PARSEDURL.cchSuffix">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>[out] The number of characters in the URL's suffix.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.ShlwApi.PARSEDURL.nScheme">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>[out] A value from the URL_SCHEME enumeration that specifies the URL's scheme.</para>
            </summary>
        </member>
    </members>
</doc>
