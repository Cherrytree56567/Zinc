<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Vanara.PInvoke.User32</name>
    </assembly>
    <members>
        <member name="T:Vanara.PInvoke.BasicMessageWindowFilter">
            <summary>A filter method that handles messages sent to a window.</summary>
            <param name="hwnd">A handle to the window.</param>
            <param name="msg">The MSG.</param>
            <param name="wParam">Additional message information. The contents of this parameter depend on the value of the uMsg parameter.</param>
            <param name="lParam">Additional message information. The contents of this parameter depend on the value of the uMsg parameter.</param>
            <param name="lReturn">The return value is the result of the message processing and depends on the message sent.</param>
            <returns>
            <see langword="true"/> if the message is handled and <see cref="M:Vanara.PInvoke.User32.DefWindowProc(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)"/> should not be called; <see
            langword="false"/> otherwise.
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.BasicMessageWindow">
            <summary>Simple window to process messages.</summary>
            <seealso cref="T:System.MarshalByRefObject"/>
            <seealso cref="T:System.IDisposable"/>
            <seealso cref="T:Vanara.PInvoke.IHandle"/>
        </member>
        <member name="M:Vanara.PInvoke.BasicMessageWindow.#ctor(Vanara.PInvoke.BasicMessageWindowFilter)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.BasicMessageWindow"/> class.</summary>
            <param name="callback">Specifies the callback method to use to process messages.</param>
        </member>
        <member name="M:Vanara.PInvoke.BasicMessageWindow.Finalize">
            <summary>Finalizes an instance of the <see cref="T:Vanara.PInvoke.BasicMessageWindow"/> class.</summary>
        </member>
        <member name="P:Vanara.PInvoke.BasicMessageWindow.Handle">
            <summary>Gets the handle.</summary>
            <value>The handle.</value>
        </member>
        <member name="P:Vanara.PInvoke.BasicMessageWindow.MessageFilter">
            <summary>Gets or sets the callback method used to filter window messages.</summary>
            <value>The callback method.</value>
        </member>
        <member name="P:Vanara.PInvoke.BasicMessageWindow.ClassName">
            <summary>Gets the name of the class.</summary>
            <value>The name of the class.</value>
        </member>
        <member name="M:Vanara.PInvoke.BasicMessageWindow.Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        </member>
        <member name="M:Vanara.PInvoke.BasicMessageWindow.Vanara#PInvoke#IHandle#DangerousGetHandle">
            <summary>Returns the value of the handle field.</summary>
            <returns>An IntPtr representing the value of the handle field.</returns>
        </member>
        <member name="M:Vanara.PInvoke.BasicMessageWindow.CreateWindow">
            <summary>
            Method used to create the window. When overriding, the <c>hWnd</c> field must be set to the handle of the created window.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.BasicMessageWindow.Dispose(System.Boolean)">
            <summary>Releases unmanaged and - optionally - managed resources.</summary>
            <param name="disposing">
            <see langword="true"/> to release both managed and unmanaged resources; <see langword="false"/> to release only unmanaged resources.
            </param>
        </member>
        <member name="T:Vanara.PInvoke.User32">
            <summary>User32.dll function with GDI params.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ICONINFO">
            <summary>Contains information about an icon or a cursor.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONINFO.fIcon">
            <summary>
            Specifies whether this structure defines an icon or a cursor. A value of TRUE specifies an icon; FALSE specifies a cursor.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONINFO.xHotspot">
            <summary>
            The x-coordinate of a cursor's hot spot. If this structure defines an icon, the hot spot is always in the center of the icon,
            and this member is ignored.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONINFO.yHotspot">
            <summary>
            The y-coordinate of the cursor's hot spot. If this structure defines an icon, the hot spot is always in the center of the
            icon, and this member is ignored.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONINFO.hbmMask">
            <summary>
            The icon bitmask bitmap. If this structure defines a black and white icon, this bitmask is formatted so that the upper half
            is the icon AND bitmask and the lower half is the icon XOR bitmask. Under this condition, the height should be an even
            multiple of two. If this structure defines a color icon, this mask only defines the AND bitmask of the icon.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONINFO.hbmColor">
            <summary>
            A handle to the icon color bitmap. This member can be optional if this structure defines a black and white icon. The AND
            bitmask of hbmMask is applied with the SRCAND flag to the destination; subsequently, the color bitmap is applied (using XOR)
            to the destination by using the SRCINVERT flag.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.ICONINFO.System#IDisposable#Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.VP_COMMAND">
            <summary>Specifies whether to retrieve or set the values that are indicated by the other members of <see cref="T:Vanara.PInvoke.User32.VIDEOPARAMETERS"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_COMMAND.VP_COMMAND_GET">
            <summary>Gets current video capabilities. If capability is not supported, dwFlags is 0.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_COMMAND.VP_COMMAND_SET">
            <summary>Sets video parameters.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.VP_CP_CMD">
            <summary>The copy protection command.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_CP_CMD.VP_CP_CMD_ACTIVATE">
            <summary>Activate copy protection.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_CP_CMD.VP_CP_CMD_DEACTIVATE">
            <summary>Deactivate copy protection.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_CP_CMD.VP_CP_CMD_CHANGE">
            <summary>Change copy protection.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.VP_CP_TYPE">
            <summary>The copy protection type. This field is valid for both VP_COMMAND_GET and VP_COMMAND_SET.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_CP_TYPE.VP_CP_TYPE_APS_TRIGGER">
            <summary>Only DVD trigger bits available.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_CP_TYPE.VP_CP_TYPE_MACROVISION">
            <summary>Full Macrovision data is available.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.VP_FLAGS">
            <summary>
            Indicates which fields of <see cref="T:Vanara.PInvoke.User32.VIDEOPARAMETERS"/> contain valid data. For VP_COMMAND_GET, this should be zero. For
            VP_COMMAND_SET, these are the fields to set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_FLAGS.VP_FLAGS_TV_MODE">
            <summary>dwMode (for VP_COMMAND_GET and VP_COMMAND_SET) and dwAvailableModes (for VP_COMMAND_GET).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_FLAGS.VP_FLAGS_TV_STANDARD">
            <summary>dwTVStandard (for VP_COMMAND_GET and VP_COMMAND_SET) and dwAvailableTVStandard (for VP_COMMAND_GET).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_FLAGS.VP_FLAGS_FLICKER">
            <summary>dwFlickerFilter (for VP_COMMAND_GET and VP_COMMAND_SET).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_FLAGS.VP_FLAGS_OVERSCAN">
            <summary>dwOverScanX, dwOverScanY (for VP_COMMAND_GET and VP_COMMAND_SET).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_FLAGS.VP_FLAGS_MAX_UNSCALED">
            <summary>dwMaxUnscaledX, dwMaxUnscaledY (for VP_COMMAND_GET).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_FLAGS.VP_FLAGS_POSITION">
            <summary>dwPositionX, dwPositionY (for VP_COMMAND_GET and VP_COMMAND_SET).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_FLAGS.VP_FLAGS_BRIGHTNESS">
            <summary>dwBrightness (for VP_COMMAND_GET and VP_COMMAND_SET).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_FLAGS.VP_FLAGS_CONTRAST">
            <summary>dwContrast (for VP_COMMAND_GET and VP_COMMAND_SET).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_FLAGS.VP_FLAGS_COPYPROTECT">
            <summary>
            dwCPType (for VP_COMMAND_GET and VP_COMMAND_SET), dwCPCommand (for VP_COMMAND_SET), dwCPStandard (for VP_COMMAND_GET),
            dwCPKey (for VP_COMMAND_SET), bCP_APSTriggerBits, bOEMCopyProtection (for VP_COMMAND_GET and VP_COMMAND_SET).
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.VP_MODE">
            <summary>The current playback mode. This member is valid for both VP_COMMAND_GET and VP_COMMAND_SET.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_MODE.VP_MODE_WIN_GRAPHICS">
            <summary>
            Describes a set of display settings that are optimal for Windows display, with the flicker filter on and any overscan display off.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_MODE.VP_MODE_TV_PLAYBACK">
            <summary>
            Describes a set of display settings for video playback, with the flicker filter off and the overscan display on.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.VP_TV">
            <summary>The TV standard. This field is valid for both VP_COMMAND_GET and VP_COMMAND_SET.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_NTSC_M">
            <summary>NTSC m</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_NTSC_M_J">
            <summary>NTSC m j</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_PAL_B">
            <summary>pal b</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_PAL_D">
            <summary>pal d</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_PAL_H">
            <summary>pal h</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_PAL_I">
            <summary>pal i</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_PAL_M">
            <summary>pal m</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_PAL_N">
            <summary>pal n</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_SECAM_B">
            <summary>secam b</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_SECAM_D">
            <summary>secam d</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_SECAM_G">
            <summary>secam g</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_SECAM_H">
            <summary>secam h</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_SECAM_K">
            <summary>secam k</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_SECAM_K1">
            <summary>secam k1</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_SECAM_L">
            <summary>secam l</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_WIN_VGA">
            <summary>win vga</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_NTSC_433">
            <summary>NTSC 433</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_PAL_G">
            <summary>pal g</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_PAL_60">
            <summary>pal 60</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VP_TV.VP_TV_STANDARD_SECAM_L1">
            <summary>secam l1</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.VIDEOPARAMETERS">
            <summary>The <c>VIDEOPARAMETERS</c> structure contains information for a video connection.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.guid">
            <summary>
            The GUID for this structure. {02C62061-1097-11d1-920F-00A024DF156E}. Display drivers should verify the GUID at the start of
            the structure before processing the structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwOffset">
            <summary>Reserved; must be zero.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwCommand">
            <summary>Specifies whether to retrieve or set the values that are indicated by the other members of this structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwFlags">
            <summary>
            Indicates which fields contain valid data. For VP_COMMAND_GET, this should be zero. For VP_COMMAND_SET, these are the fields
            to set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwMode">
            <summary>The current playback mode. This member is valid for both VP_COMMAND_GET and VP_COMMAND_SET.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwTVStandard">
            <summary>The TV standard. This field is valid for both VP_COMMAND_GET and VP_COMMAND_SET.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwAvailableModes">
            <summary>
            Specifies which modes are available. This is valid only for VP_COMMAND_GET. It can be any combination of the values specified
            in dwMode.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwAvailableTVStandard">
            <summary>
            The TV standards that are available. This is valid only for VP_COMMAND_GET. It can be any combination of the values specified
            in dwTVStandard.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwFlickerFilter">
            <summary>
            The flicker reduction provided by the hardware. This is a percentage value in tenths of a percent, from 0 to 1,000, where 0
            is no flicker reduction and 1,000 is maximum flicker reduction. This field is valid for both VP_COMMAND_GET and VP_COMMAND_SET.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwOverScanX">
            <summary>
            The amount of overscan in the horizontal direction. This is a percentage value in tenths of a percent, from 0 to 1,000. A
            value of 0 indicates no overscan, ensuring that the entire display is visible. A value of 1,000 is maximum overscan and
            typically causes some of the image to be off the edge of the screen. This field is valid for both VP_COMMAND_GET and VP_COMMAND_SET.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwOverScanY">
            <summary>
            The amount of overscan in the vertical direction. This is a percentage value in tenths of a percent, from 0 to 1,000. A value
            of 0 indicates no overscan, ensuring that the entire display is visible. A value of 1,000 is maximum overscan and typically
            causes some of the image to be off the edge of the screen. This field is valid for both VP_COMMAND_GET and VP_COMMAND_SET.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwMaxUnscaledX">
            <summary>
            The maximum horizontal resolution, in pixels, that is supported when the video is not scaled. This field is valid for both VP_COMMAND_GET.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwMaxUnscaledY">
            <summary>
            The maximum vertical resolution, in pixels, that is supported when the video is not scaled. This field is valid for both VP_COMMAND_GET.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwPositionX">
            <summary>
            The horizontal adjustment to the center of the image. Units are in pixels. This field is valid for both VP_COMMAND_GET and VP_COMMAND_SET.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwPositionY">
            <summary>
            The vertical adjustment to the center of the image. Units are in scan lines. This field is valid for both VP_COMMAND_GET and VP_COMMAND_SET.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwBrightness">
            <summary>
            Adjustment to the DC offset of the video signal to increase brightness on the television. It is a percentage value, 0 to 100,
            where 0 means no adjustment and 100 means maximum adjustment. This field is valid for both VP_COMMAND_GET and VP_COMMAND_SET.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwContrast">
            <summary>
            Adjustment to the gain of the video signal to increase the intensity of whiteness on the television. It is a percentage
            value, 0 to 100, where 0 means no adjustment and 100 means maximum adjustment. This field is valid for both VP_COMMAND_GET
            and VP_COMMAND_SET.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwCPType">
            <summary>The copy protection type. This field is valid for both VP_COMMAND_GET and VP_COMMAND_SET.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwCPCommand">
            <summary>The copy protection command. This field is only valid for VP_COMMAND_SET.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwCPStandard">
            <summary>Specifies TV standards for which copy protection types are available. This field is valid only for VP_COMMAND_GET.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.dwCPKey">
            <summary>
            The copy protection key returned if dwCPCommand is set to VP_CP_CMD_ACTIVATE. The caller must set this key when the
            dwCPCommand field is either VP_CP_CMD_DEACTIVATE or VP_CP_CMD_CHANGE. If the caller sets an incorrect key, the driver must
            not change the current copy protection settings. This field is valid only for VP_COMMAND_SET.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.bCP_APSTriggerBits">
            <summary>The DVD APS trigger bit flag. This is valid only for VP_COMMAND_SET. Currently, only bits 0 and 1 are valid.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VIDEOPARAMETERS.bOEMCopyProtection">
            <summary>
            The OEM-specific copy protection data. Maximum of 256 characters. This field is valid for both VP_COMMAND_GET and VP_COMMAND_SET.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.NMHDR">
            <summary>Contains information about a notification message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NMHDR.hwndFrom">
            <summary>A window handle to the control sending the message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NMHDR.idFrom">
            <summary>An identifier of the control sending the message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NMHDR.code">
            <summary>
            A notification code. This member can be one of the common notification codes (see Notifications under General Control
            Reference), or it can be a control-specific notification code.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.NMHDR.FromLParam(System.IntPtr)">
            <summary>Creates a <see cref="T:Vanara.PInvoke.User32.NMHDR"/> structure from an LPARAM value.</summary>
            <param name="lParam">The LPARAM value.</param>
            <returns>A <see cref="T:Vanara.PInvoke.User32.NMHDR"/> structure.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.NMHDR.LParamAsRef(System.IntPtr)">
            <summary>Creates a reference to an <see cref="T:Vanara.PInvoke.User32.NMHDR"/> structure from an LPARAM value.</summary>
            <param name="lParam">The LPARAM value.</param>
            <returns>A <see cref="T:Vanara.PInvoke.User32.NMHDR"/> structure reference.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.NMHDR.UpdateLParam(System.IntPtr)">
            <summary>Updates the <see cref="T:Vanara.PInvoke.User32.NMHDR"/> value pointed to by an LPARAM value from this instance.</summary>
            <param name="lParam">The LPARAM value to update.</param>
        </member>
        <member name="T:Vanara.PInvoke.User32.WindowMessage">
            <summary>Windows Messages</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NULL">
            <summary>
            <para>
            Performs no operation. An application sends the <c>WM_NULL</c> message if it wants to post a message that the recipient
            window will ignore.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NULL 0x0000</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>An application returns zero if it processes this message.</para>
            <remarks>
            <para>
            For example, if an application has installed a <c>WH_GETMESSAGE</c> hook and wants to prevent a message from being processed,
            the <c>GetMsgProc</c> callback function can change the message number to <c>WM_NULL</c> so the recipient will ignore it.
            </para>
            <para>
            As another example, an application can check if a window is responding to messages by sending the <c>WM_NULL</c> message with
            the <c>SendMessageTimeout</c> function.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CREATE">
            <summary>
            <para>
            Sent when an application requests that a window be created by calling the <c>CreateWindowEx</c> or <c>CreateWindow</c>
            function. (The message is sent before the function returns.) The window procedure of the new window receives this message
            after the window is created, but before the window becomes visible.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_CREATE 0x0001</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>A pointer to a <c>CREATESTRUCT</c> structure that contains information about the window being created.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>
            If an application processes this message, it should return zero to continue creation of the window. If the application
            returns –1, the window is destroyed and the <c>CreateWindowEx</c> or <c>CreateWindow</c> function returns a <c>NULL</c> handle.
            </para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_DESTROY">
            <summary>
            <para>
            Sent when a window is being destroyed. It is sent to the window procedure of the window being destroyed after the window is
            removed from the screen.
            </para>
            <para>
            This message is sent first to the window being destroyed and then to the child windows (if any) as they are destroyed. During
            the processing of the message, it can be assumed that all child windows still exist.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_DESTROY 0x0002</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            If the window being destroyed is part of the clipboard viewer chain (set by calling the <c>SetClipboardViewer</c> function),
            the window must remove itself from the chain by processing the <c>ChangeClipboardChain</c> function before returning from the
            <c>WM_DESTROY</c> message.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MOVE">
            <summary>
            <para>Sent after a window has been moved.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_MOVE 0x0003</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>
            The x and y coordinates of the upper-left corner of the client area of the window. The low-order word contains the
            x-coordinate while the high-order word contains the y coordinate.
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            The parameters are given in screen coordinates for overlapped and pop-up windows and in parent-client coordinates for child windows.
            </para>
            <para>The following example demonstrates how to obtain the position from the lParam parameter.</para>
            <para>
            <code>xPos = (int)(short) LOWORD(lParam); // horizontal position yPos = (int)(short) HIWORD(lParam); // vertical position</code>
            </para>
            <para>You can also use the <c>MAKEPOINTS</c> macro to convert the lParam parameter to a <c>POINTS</c> structure.</para>
            <para>
            The <c>DefWindowProc</c> function sends the <c>WM_SIZE</c> and <c>WM_MOVE</c> messages when it processes the
            <c>WM_WINDOWPOSCHANGED</c> message. The <c>WM_SIZE</c> and <c>WM_MOVE</c> messages are not sent if an application handles the
            <c>WM_WINDOWPOSCHANGED</c> message without calling <c>DefWindowProc</c>.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SIZE">
            <summary>
            <para>Sent to a window after its size has changed.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_SIZE 0x0005</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The type of resizing requested. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>SIZE_MAXHIDE</c> 4</term>
            <term>Message is sent to all pop-up windows when some other window is maximized.</term>
            </item>
            <item>
            <term><c>SIZE_MAXIMIZED</c> 2</term>
            <term>The window has been maximized.</term>
            </item>
            <item>
            <term><c>SIZE_MAXSHOW</c> 3</term>
            <term>Message is sent to all pop-up windows when some other window has been restored to its former size.</term>
            </item>
            <item>
            <term><c>SIZE_MINIMIZED</c> 1</term>
            <term>The window has been minimized.</term>
            </item>
            <item>
            <term><c>SIZE_RESTORED</c> 0</term>
            <term>The window has been resized, but neither the <c>SIZE_MINIMIZED</c> nor <c>SIZE_MAXIMIZED</c> value applies.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>The low-order word of lParam specifies the new width of the client area.</para>
            <para>The high-order word of lParam specifies the new height of the client area.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            If the <c>SetScrollPos</c> or <c>MoveWindow</c> function is called for a child window as a result of the <c>WM_SIZE</c>
            message, the bRedraw or bRepaint parameter should be nonzero to cause the window to be repainted.
            </para>
            <para>
            Although the width and height of a window are 32-bit values, the lParam parameter contains only the low-order 16 bits of each.
            </para>
            <para>
            The <c>DefWindowProc</c> function sends the <c>WM_SIZE</c> and <c>WM_MOVE</c> messages when it processes the
            <c>WM_WINDOWPOSCHANGED</c> message. The <c>WM_SIZE</c> and <c>WM_MOVE</c> messages are not sent if an application handles the
            <c>WM_WINDOWPOSCHANGED</c> message without calling <c>DefWindowProc</c>.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_ACTIVATE">
            <summary>
            <para>
            Sent to both the window being activated and the window being deactivated. If the windows use the same input queue, the
            message is sent synchronously, first to the window procedure of the top-level window being deactivated, then to the window
            procedure of the top-level window being activated. If the windows use different input queues, the message is sent
            asynchronously, so the window is activated immediately.
            </para>
            <para>
            <code>#define WM_ACTIVATE 0x0006</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The low-order word specifies whether the window is being activated or deactivated. This parameter can be one of the following
            values. The high-order word specifies the minimized state of the window being activated or deactivated. A nonzero value
            indicates the window is minimized.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>WA_ACTIVE</c> 1</term>
            <term>
            Activated by some method other than a mouse click (for example, by a call to the <c>SetActiveWindow</c> function or by use of
            the keyboard interface to select the window).
            </term>
            </item>
            <item>
            <term><c>WA_CLICKACTIVE</c> 2</term>
            <term>Activated by a mouse click.</term>
            </item>
            <item>
            <term><c>WA_INACTIVE</c> 0</term>
            <term>Deactivated.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            A handle to the window being activated or deactivated, depending on the value of the wParam parameter. If the low-order word
            of wParam is <c>WA_INACTIVE</c>, lParam is the handle to the window being activated. If the low-order word of wParam is
            <c>WA_ACTIVE</c> or <c>WA_CLICKACTIVE</c>, lParam is the handle to the window being deactivated. This handle can be <c>NULL</c>.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            If the window is being activated and is not minimized, the <c>DefWindowProc</c> function sets the keyboard focus to the
            window. If the window is activated by a mouse click, it also receives a <c>WM_MOUSEACTIVATE</c> message.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SETFOCUS">
            <summary>
            <para>Sent to a window after it has gained the keyboard focus.</para>
            <para>
            <code>#define WM_SETFOCUS 0x0007</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the window that has lost the keyboard focus. This parameter can be <c>NULL</c>.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            To display a caret, an application should call the appropriate caret functions when it receives the <c>WM_SETFOCUS</c> message.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_KILLFOCUS">
            <summary>
            <para>Sent to a window immediately before it loses the keyboard focus.</para>
            <para>
            <code>#define WM_KILLFOCUS 0x0008</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the window that receives the keyboard focus. This parameter can be <c>NULL</c>.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            <para>If an application is displaying a caret, the caret should be destroyed at this point.</para>
            <para>
            While processing this message, do not make any function calls that display or activate a window. This causes the thread to
            yield control and can cause the application to stop responding to messages. For more information, see Message Deadlocks.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_ENABLE">
            <summary>
            <para>
            Sent when an application changes the enabled state of a window. It is sent to the window whose enabled state is changing.
            This message is sent before the <c>EnableWindow</c> function returns, but after the enabled state ( <c>WS_DISABLED</c> style
            bit) of the window has changed.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_ENABLE 0x000A</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            Indicates whether the window has been enabled or disabled. This parameter is <c>TRUE</c> if the window has been enabled or
            <c>FALSE</c> if the window has been disabled.
            </para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If an application processes this message, it should return zero.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SETREDRAW">
            <summary>
            <para>
            You send the <c>WM_SETREDRAW</c> message to a window to allow changes in that window to be redrawn, or to prevent changes in
            that window from being redrawn.
            </para>
            <para>To send this message, call the <c>SendMessage</c> function with the following parameters.</para>
            <para>
            <code>SendMessage( (HWND) hWnd, WM_SETREDRAW, (WPARAM) wParam, (LPARAM) lParam );</code>
            </para>
            <para><em>wParam</em></para>
            <para>
            The redraw state. If this parameter is <c>TRUE</c>, then the content can be redrawn after a change. If this parameter is
            <c>FALSE</c>, then the content can't be redrawn after a change.
            </para>
            <para><em>lParam</em></para>
            <para>This parameter isn't used.</para>
            <para><strong>Returns</strong></para>
            <para>Your application should return 0 if it processes this message.</para>
            </summary>
            <remarks>
            <para>
            This message can be useful if your application must add several items to a list box. Your application can call this message
            with wParam set to <c>FALSE</c>, add the items, and then call the message again with wParam set to <c>TRUE</c>. Finally, your
            application can call <c>RedrawWindow</c>(hWnd, <c>NULL</c>, <c>NULL</c>, RDW_ERASE | RDW_FRAME | RDW_INVALIDATE |
            RDW_ALLCHILDREN) to cause the list box to be repainted.
            </para>
            <para>
            <para>Note</para>
            <para>
            You should use <c>RedrawWindow</c> with the specified flags, instead of <c>InvalidateRect</c>, because the former is
            necessary for some controls that have nonclient area of their own, or have window styles that cause them to be given a
            nonclient area (such as <c>WS_THICKFRAME</c>, <c>WS_BORDER</c>, or <c>WS_EX_CLIENTEDGE</c>). If the control does not have a
            nonclient area, then <c>RedrawWindow</c> with these flags will do only as much invalidation as <c>InvalidateRect</c> would.
            </para>
            </para>
            <para>
            Passing a <c>WM_SETREDRAW</c> message to the <c>DefWindowProc</c> function removes the <c>WS_VISIBLE</c> style from the
            window when wParam is set to <c>FALSE</c>. Although the window content remains visible on screen, the <c>IsWindowVisible</c>
            function returns <c>FALSE</c> when called on a window in this state.
            </para>
            <para>
            Passing a <c>WM_SETREDRAW</c> message to the <c>DefWindowProc</c> function adds the <c>WS_VISIBLE</c> style to the window, if
            not set, when wParam is set to <c>TRUE</c>. If your application sends the <c>WM_SETREDRAW</c> message with wParam set to
            <c>TRUE</c> to a hidden window, then the window becomes visible.
            </para>
            <para>
            <c>Windows 10 and later; Windows Server 2016 and later</c>. The system sets a property named SysSetRedraw on a window whose
            window procedure passes <c>WM_SETREDRAW</c> messages to <c>DefWindowProc</c>. You can use the <c>GetProp</c> function to get
            the property value when it's available. <c>GetProp</c> returns a non-zero value when redraw is disabled. <c>GetProp</c> will
            return zero when redraw is enabled, or when the window property doesn't exist.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SETTEXT">
            <summary>
            <para>Sets the text of a window.</para>
            <para>
            <code>#define WM_SETTEXT 0x000C</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>A pointer to a null-terminated string that is the window text.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>
            The return value is <c>TRUE</c> if the text is set. It is <c>FALSE</c> (for an edit control), <c>LB_ERRSPACE</c> (for a list
            box), or <c>CB_ERRSPACE</c> (for a combo box) if insufficient space is available to set the text in the edit control. It is
            <c>CB_ERR</c> if this message is sent to a combo box without an edit control.
            </para>
            <remarks>
            <para>
            The <c>DefWindowProc</c> function sets and displays the window text. For an edit control, the text is the contents of the
            edit control. For a combo box, the text is the contents of the edit-control portion of the combo box. For a button, the text
            is the button name. For other windows, the text is the window title.
            </para>
            <para>
            This message does not change the current selection in the list box of a combo box. An application should use the
            <c>CB_SELECTSTRING</c> message to select the item in a list box that matches the text in the edit control.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_GETTEXT">
            <summary>
            <para>Copies the text that corresponds to a window into a buffer provided by the caller.</para>
            <para>
            <code>#define WM_GETTEXT 0x000D</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The maximum number of characters to be copied, including the terminating null character.</para>
            <para>
            ANSI applications may have the string in the buffer reduced in size (to a minimum of half that of the wParam value) due to
            conversion from ANSI to Unicode.
            </para>
            <para><em>lParam</em></para>
            <para>A pointer to the buffer that is to receive the text.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value is the number of characters copied, not including the terminating null character.</para>
            <remarks>
            <para>
            The <c>DefWindowProc</c> function copies the text associated with the window into the specified buffer and returns the number
            of characters copied. Note, for non-text static controls this gives you the text with which the control was originally
            created, that is, the ID number. However, it gives you the ID of the non-text static control as originally created. That is,
            if you subsequently used a <c>STM_SETIMAGE</c> to change it the original ID would still be returned.
            </para>
            <para>
            For an edit control, the text to be copied is the content of the edit control. For a combo box, the text is the content of
            the edit control (or static-text) portion of the combo box. For a button, the text is the button name. For other windows, the
            text is the window title. To copy the text of an item in a list box, an application can use the <c>LB_GETTEXT</c> message.
            </para>
            <para>
            When the <c>WM_GETTEXT</c> message is sent to a static control with the <c>SS_ICON</c> style, a handle to the icon will be
            returned in the first four bytes of the buffer pointed to by lParam. This is true only if the <c>WM_SETTEXT</c> message has
            been used to set the icon.
            </para>
            <para>
            <c>Rich Edit:</c> If the text to be copied exceeds 64K, use either the <c>EM_STREAMOUT</c> or <c>EM_GETSELTEXT</c> message.
            </para>
            <para>
            Sending a <c>WM_GETTEXT</c> message to a non-text static control, such as a static bitmap or static icon control, does not
            return a string value. Instead, it returns zero. In addition, in early versions of Windows, applications could send a
            <c>WM_GETTEXT</c> message to a non-text static control to retrieve the control's ID. To retrieve a control's ID, applications
            can use <c>GetWindowLong</c> passing <c>GWL_ID</c> as the index value or <c>GetWindowLongPtr</c> using <c>GWLP_ID</c>.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_GETTEXTLENGTH">
            <summary>
            <para>Determines the length, in characters, of the text associated with a window.</para>
            <para>
            <code>#define WM_GETTEXTLENGTH 0x000E</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value is the length of the text in characters, not including the terminating null character.</para>
            <remarks>
            <para>
            For an edit control, the text to be copied is the content of the edit control. For a combo box, the text is the content of
            the edit control (or static-text) portion of the combo box. For a button, the text is the button name. For other windows, the
            text is the window title. To determine the length of an item in a list box, an application can use the <c>LB_GETTEXTLEN</c> message.
            </para>
            <para>
            When the <c>WM_GETTEXTLENGTH</c> message is sent, the <c>DefWindowProc</c> function returns the length, in characters, of the
            text. Under certain conditions, the <c>DefWindowProc</c> function returns a value that is larger than the actual length of
            the text. This occurs with certain mixtures of ANSI and Unicode, and is due to the system allowing for the possible existence
            of double-byte character set (DBCS) characters within the text. The return value, however, will always be at least as large
            as the actual length of the text; you can thus always use it to guide buffer allocation. This behavior can occur when an
            application uses both ANSI functions and common dialogs, which use Unicode.
            </para>
            <para>
            To obtain the exact length of the text, use the <c>WM_GETTEXT</c>, <c>LB_GETTEXT</c>, or <c>CB_GETLBTEXT</c> messages, or the
            <c>GetWindowText</c> function.
            </para>
            <para>
            Sending a <c>WM_GETTEXTLENGTH</c> message to a non-text static control, such as a static bitmap or static icon controlc, does
            not return a string value. Instead, it returns zero.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_PAINT">
            <summary>
            <para>
            The <c>WM_PAINT</c> message is sent when the system or another application makes a request to paint a portion of an
            application's window. The message is sent when the <c>UpdateWindow</c> or <c>RedrawWindow</c> function is called, or by the
            <c>DispatchMessage</c> function when the application obtains a <c>WM_PAINT</c> message by using the <c>GetMessage</c> or
            <c>PeekMessage</c> function.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>An application returns zero if it processes this message.</para>
            <remarks>
            <para>
            The <c>WM_PAINT</c> message is generated by the system and should not be sent by an application. To force a window to draw
            into a specific device context, use the <c>WM_PRINT</c> or <c>WM_PRINTCLIENT</c> message. Note that this requires the target
            window to support the <c>WM_PRINTCLIENT</c> message. Most common controls support the <c>WM_PRINTCLIENT</c> message.
            </para>
            <para>
            The <c>DefWindowProc</c> function validates the update region. The function may also send the <c>WM_NCPAINT</c> message to
            the window procedure if the window frame must be painted and send the <c>WM_ERASEBKGND</c> message if the window background
            must be erased.
            </para>
            <para>
            The system sends this message when there are no other messages in the application's message queue. <c>DispatchMessage</c>
            determines where to send the message; <c>GetMessage</c> determines which message to dispatch. <c>GetMessage</c> returns the
            <c>WM_PAINT</c> message when there are no other messages in the application's message queue, and <c>DispatchMessage</c> sends
            the message to the appropriate window procedure.
            </para>
            <para>
            A window may receive internal paint messages as a result of calling <c>RedrawWindow</c> with the RDW_INTERNALPAINT flag set.
            In this case, the window may not have an update region. An application may call the <c>GetUpdateRect</c> function to
            determine whether the window has an update region. If <c>GetUpdateRect</c> returns zero, the application need not call the
            <c>BeginPaint</c> and <c>EndPaint</c> functions.
            </para>
            <para>
            An application must check for any necessary internal painting by looking at its internal data structures for each
            <c>WM_PAINT</c> message, because a <c>WM_PAINT</c> message may have been caused by both a non-NULL update region and a call
            to <c>RedrawWindow</c> with the RDW_INTERNALPAINT flag set.
            </para>
            <para>
            The system sends an internal <c>WM_PAINT</c> message only once. After an internal <c>WM_PAINT</c> message is returned from
            <c>GetMessage</c> or <c>PeekMessage</c> or is sent to a window by <c>UpdateWindow</c>, the system does not post or send
            further <c>WM_PAINT</c> messages until the window is invalidated or until <c>RedrawWindow</c> is called again with the
            RDW_INTERNALPAINT flag set.
            </para>
            <para>
            For some common controls, the default <c>WM_PAINT</c> message processing checks the wParam parameter. If wParam is non-NULL,
            the control assumes that the value is an HDC and paints using that device context.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CLOSE">
            <summary>
            <para>Sent as a signal that a window or an application should terminate.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_CLOSE 0x0010</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            An application can prompt the user for confirmation, prior to destroying a window, by processing the <c>WM_CLOSE</c> message
            and calling the <c>DestroyWindow</c> function only if the user confirms the choice.
            </para>
            <para>By default, the <c>DefWindowProc</c> function calls the <c>DestroyWindow</c> function to destroy the window.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_QUERYENDSESSION">
            <summary>
            <para>
            The <c>WM_QUERYENDSESSION</c> message is sent when the user chooses to end the session or when an application calls one of
            the system shutdown functions. If any application returns zero, the session is not ended. The system stops sending
            <c>WM_QUERYENDSESSION</c> messages as soon as one application returns zero.
            </para>
            <para>
            After processing this message, the system sends the <c>WM_ENDSESSION</c> message with the wParam parameter set to the results
            of the <c>WM_QUERYENDSESSION</c> message.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, // handle to window UINT uMsg, // message identifier WPARAM wParam, // not used LPARAM lParam // logoff option );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hwnd</em></para>
            <para>A handle to the window.</para>
            <para><em>uMsg</em></para>
            <para>The <c>WM_QUERYENDSESSION</c> identifier.</para>
            <para><em>wParam</em></para>
            <para>This parameter is reserved for future use.</para>
            <para><em>lParam</em></para>
            <para>
            This parameter can be one or more of the following values. If this parameter is 0, the system is shutting down or restarting
            (it is not possible to determine which event is occurring).
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>ENDSESSION_CLOSEAPP</c> 0x00000001</term>
            <term>
            The application is using a file that must be replaced, the system is being serviced, or system resources are exhausted. For
            more information, see Guidelines for Applications.
            </term>
            </item>
            <item>
            <term><c>ENDSESSION_CRITICAL</c> 0x40000000</term>
            <term>The application is forced to shut down.</term>
            </item>
            <item>
            <term><c>ENDSESSION_LOGOFF</c> 0x80000000</term>
            <term>The user is logging off. For more information, see Logging Off.</term>
            </item>
            </list>
            <para>Note that this parameter is a bit mask. To test for this value, use a bit-wise operation; do not test for equality.</para>
            <para><strong>Returns</strong></para>
            <para>
            Applications should respect the user's intentions and return <c>TRUE</c>. By default, the <c>DefWindowProc</c> function
            returns <c>TRUE</c> for this message.
            </para>
            <para>
            If shutting down would corrupt the system or media that is being burned, the application can return <c>FALSE</c>. However, it
            is good practice to respect the user's actions.
            </para>
            <remarks>
            <para>
            When an application returns <c>TRUE</c> for this message, it receives the <c>WM_ENDSESSION</c> message, regardless of how the
            other applications respond to the <c>WM_QUERYENDSESSION</c> message. Each application should return <c>TRUE</c> or
            <c>FALSE</c> immediately upon receiving this message, and defer any cleanup operations until it receives the
            <c>WM_ENDSESSION</c> message.
            </para>
            <para>
            Applications can display a user interface prompting the user for information at shutdown, however it is not recommended.
            After five seconds, the system displays information about the applications that are preventing shutdown and allows the user
            to terminate them. For example, Windows XP displays a dialog box, while Windows Vista displays a full screen with additional
            information about the applications blocking shutdown. If your application must block or postpone system shutdown, use the
            <c>ShutdownBlockReasonCreate</c> function. For more information, see Shutdown Changes for Windows Vista.
            </para>
            <para>Console applications can use the <c>SetConsoleCtrlHandler</c> function to receive shutdown notification.</para>
            <para>
            Service applications can use the <c>RegisterServiceCtrlHandlerEx</c> function to receive shutdown notifications in a handler routine.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_QUERYOPEN">
            <summary>
            <para>Sent to an icon when the user requests that the window be restored to its previous size and position.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_QUERYOPEN 0x0013</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>
            If the icon can be opened, an application that processes this message should return <c>TRUE</c>; otherwise, it should return
            <c>FALSE</c> to prevent the icon from being opened.
            </para>
            <remarks>
            <para>By default, the <c>DefWindowProc</c> function returns <c>TRUE</c>.</para>
            <para>
            While processing this message, the application should not perform any action that would cause an activation or focus change
            (for example, creating a dialog box).
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_ENDSESSION">
            <summary>
            <para>
            The <c>WM_ENDSESSION</c> message is sent to an application after the system processes the results of the
            <c>WM_QUERYENDSESSION</c> message. The <c>WM_ENDSESSION</c> message informs the application whether the session is ending.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, // handle to window UINT uMsg, // message identifier WPARAM wParam, // end-session option LPARAM lParam // logoff option );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hwnd</em></para>
            <para>A handle to the window.</para>
            <para><em>uMsg</em></para>
            <para>The <c>WM_ENDSESSION</c> identifier.</para>
            <para><em>wParam</em></para>
            <para>
            If the session is being ended, this parameter is <c>TRUE</c>; the session can end any time after all applications have
            returned from processing this message. Otherwise, it is <c>FALSE</c>.
            </para>
            <para><em>lParam</em></para>
            <para>
            This parameter can be one or more of the following values. If this parameter is 0, the system is shutting down or restarting
            (it is not possible to determine which event is occurring).
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>ENDSESSION_CLOSEAPP</c> 0x1</term>
            <term>
            If <c>wParam</c> is <c>TRUE</c>, the application must shut down. Any data should be saved automatically without prompting the
            user (for more information, see Remarks). The Restart Manager sends this message when the application is using a file that
            needs to be replaced, when it must service the system, or when system resources are exhausted. The application will be
            restarted if it has registered for restart using the <c>RegisterApplicationRestart</c> function. For more information, see
            Guidelines for Applications. If <c>wParam</c> is <c>FALSE</c>, the application should not shut down.
            </term>
            </item>
            <item>
            <term><c>ENDSESSION_CRITICAL</c> 0x40000000</term>
            <term>The application is forced to shut down.</term>
            </item>
            <item>
            <term><c>ENDSESSION_LOGOFF</c> 0x80000000</term>
            <term>The user is logging off. For more information, see Logging Off.</term>
            </item>
            </list>
            <para>Note that this parameter is a bit mask. To test for this value, use a bit-wise operation; do not test for equality.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            Applications that have unsaved data could save the data to a temporary location and restore it the next time the application
            starts. It is recommended that applications save their data and state frequently; for example, automatically save data
            between save operations initiated by the user to reduce the amount of data to be saved at shutdown.
            </para>
            <para>The application need not call the <c>DestroyWindow</c> or <c>PostQuitMessage</c> function when the session is ending.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_QUIT">
            <summary>
            <para>
            Indicates a request to terminate an application, and is generated when the application calls the <c>PostQuitMessage</c>
            function. This message causes the <c>GetMessage</c> function to return zero.
            </para>
            <para>
            <code>#define WM_QUIT 0x0012</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The exit code given in the <c>PostQuitMessage</c> function.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>
            This message does not have a return value because it causes the message loop to terminate before the message is sent to the
            application's window procedure.
            </para>
            <remarks>
            <para>
            The <c>WM_QUIT</c> message is not associated with a window and therefore will never be received through a window's window
            procedure. It is retrieved only by the <c>GetMessage</c> or <c>PeekMessage</c> functions.
            </para>
            <para>Do not post the <c>WM_QUIT</c> message using the <c>PostMessage</c> function; use <c>PostQuitMessage</c>.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_ERASEBKGND">
            <summary>
            <para>
            Sent when the window background must be erased (for example, when a window is resized). The message is sent to prepare an
            invalidated portion of a window for painting.
            </para>
            <para>
            <code>#define WM_ERASEBKGND 0x0014</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the device context.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>An application should return nonzero if it erases the background; otherwise, it should return zero.</para>
            <remarks>
            <para>
            The <c>DefWindowProc</c> function erases the background by using the class background brush specified by the
            <c>hbrBackground</c> member of the <c>WNDCLASS</c> structure. If <c>hbrBackground</c> is <c>NULL</c>, the application should
            process the <c>WM_ERASEBKGND</c> message and erase the background.
            </para>
            <para>
            An application should return nonzero in response to <c>WM_ERASEBKGND</c> if it processes the message and erases the
            background; this indicates that no further erasing is required. If the application returns zero, the window will remain
            marked for erasing. (Typically, this indicates that the <c>fErase</c> member of the <c>PAINTSTRUCT</c> structure will be <c>TRUE</c>.)
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SYSCOLORCHANGE">
            <summary>
            <para>The <c>WM_SYSCOLORCHANGE</c> message is sent to all top-level windows when a change is made to a system color setting.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <remarks>
            <para>The system sends a <c>WM_PAINT</c> message to any window that is affected by a system color change.</para>
            <para>
            Applications that have brushes using the existing system colors should delete those brushes and re-create them using the new
            system colors.
            </para>
            <para>
            Top level windows that use common controls must forward the <c>WM_SYSCOLORCHANGE</c> message to the controls; otherwise, the
            controls will not be notified of the color change. This ensures that the colors used by your common controls are consistent
            with those used by other user interface objects. For example, a toolbar control uses the "3D Objects" color to draw its
            buttons. If the user changes the 3D Objects color but the <c>WM_SYSCOLORCHANGE</c> message is not forwarded to the toolbar,
            the toolbar buttons will remain in their original color while the color of other buttons in the system changes.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SHOWWINDOW">
            <summary>
            <para>Sent to a window when the window is about to be hidden or shown.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_SHOWWINDOW 0x0018</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            Indicates whether a window is being shown. If wParam is <c>TRUE</c>, the window is being shown. If wParam is <c>FALSE</c>,
            the window is being hidden.
            </para>
            <para><em>lParam</em></para>
            <para>
            The status of the window being shown. If lParam is zero, the message was sent because of a call to the <c>ShowWindow</c>
            function; otherwise, lParam is one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>SW_OTHERUNZOOM</c> 4</term>
            <term>The window is being uncovered because a maximize window was restored or minimized.</term>
            </item>
            <item>
            <term><c>SW_OTHERZOOM</c> 2</term>
            <term>The window is being covered by another window that has been maximized.</term>
            </item>
            <item>
            <term><c>SW_PARENTCLOSING</c> 1</term>
            <term>The window's owner window is being minimized.</term>
            </item>
            <item>
            <term><c>SW_PARENTOPENING</c> 3</term>
            <term>The window's owner window is being restored.</term>
            </item>
            </list>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            The <c>DefWindowProc</c> function hides or shows the window, as specified by the message. If a window has the
            <c>WS_VISIBLE</c> style when it is created, the window receives this message after it is created, but before it is displayed.
            A window also receives this message when its visibility state is changed by the <c>ShowWindow</c> or <c>ShowOwnedPopups</c> function.
            </para>
            <para>The <c>WM_SHOWWINDOW</c> message is not sent under the following circumstances:</para>
            <list type="bullet">
            <item>
            <term>When a top-level, overlapped window is created with the <c>WS_MAXIMIZE</c> or <c>WS_MINIMIZE</c> style.</term>
            </item>
            <item>
            <term>When the <c>SW_SHOWNORMAL</c> flag is specified in the call to the <c>ShowWindow</c> function.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_WININICHANGE">
            <summary>
            <para>
            An application sends the <c>WM_WININICHANGE</c> message to all top-level windows after making a change to the WIN.INI file.
            The <c>SystemParametersInfo</c> function sends this message after an application uses the function to change a setting in WIN.INI.
            </para>
            <para>
            <para>Note</para>
            <para>
            The <c>WM_WININICHANGE</c> message is provided only for compatibility with earlier versions of the system. Applications
            should use the <c>WM_SETTINGCHANGE</c> message.
            </para>
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_WININICHANGE 0x001A</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>
            A pointer to a string containing the name of the system parameter that was changed. For example, this string can be the name
            of a registry key or the name of a section in the Win.ini file. This parameter is not particularly useful in determining
            which system parameter changed. For example, when the string is a registry name, it typically indicates only the leaf node in
            the registry, not the whole path. In addition, some applications send this message with lParam set to <c>NULL</c>. In
            general, when you receive this message, you should check and reload any system parameter settings that are used by your application.
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If you process this message, return zero.</para>
            <remarks>
            <para>
            To send the <c>WM_WININICHANGE</c> message to all top-level windows, use the <c>SendMessage</c> function with the hWnd
            parameter set to <c>HWND_BROADCAST</c>.
            </para>
            <para>
            Calls to functions that change WIN.INI may be mapped to the registry instead. This mapping occurs when WIN.INI and the
            section being changed are specified in the registry under the following key:
            </para>
            <para><c>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\IniFileMapping</c></para>
            <para>The change in the storage location has no effect on the behavior of this message.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SETTINGCHANGE">
            <summary>
            <para>
            A message that is sent to all top-level windows when the <c>SystemParametersInfo</c> function changes a system-wide setting
            or when policy settings have changed.
            </para>
            <para>
            Applications should send <c>WM_SETTINGCHANGE</c> to all top-level windows when they make changes to system parameters. (This
            message cannot be sent directly to a window.) To send the <c>WM_SETTINGCHANGE</c> message to all top-level windows, use the
            <c>SendMessageTimeout</c> function with the hwnd parameter set to <c>HWND_BROADCAST</c>.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_WININICHANGE 0x001A #define WM_SETTINGCHANGE WM_WININICHANGE</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            When the system sends this message as a result of a <c>SystemParametersInfo</c> call, the wParam parameter is the value of
            the uiAction parameter passed to the <c>SystemParametersInfo</c> function. For a list of values, see <c>SystemParametersInfo</c>.
            </para>
            <para>
            When the system sends this message as a result of a change in policy settings, this parameter indicates the type of policy
            that was applied. This value is 1 if computer policy was applied or zero if user policy was applied.
            </para>
            <para>When the system sends this message as a result of a change in locale settings, this parameter is zero.</para>
            <para>When an application sends this message, this parameter must be <c>NULL</c>.</para>
            <para><em>lParam</em></para>
            <para>
            When the system sends this message as a result of a <c>SystemParametersInfo</c> call, lParam is a pointer to a string that
            indicates the area containing the system parameter that was changed. This parameter does not usually indicate which specific
            system parameter changed. (Note that some applications send this message with lParam set to <c>NULL</c>.) In general, when
            you receive this message, you should check and reload any system parameter settings that are used by your application.
            </para>
            <para>
            This string can be the name of a registry key or the name of a section in the Win.ini file. When the string is a registry
            name, it typically indicates only the leaf node in the registry, not the full path.
            </para>
            <para>
            When the system sends this message as a result of a change in policy settings, this parameter points to the string "Policy".
            </para>
            <para>
            When the system sends this message as a result of a change in locale settings, this parameter points to the string "intl".
            </para>
            <para>
            To effect a change in the environment variables for the system or the user, broadcast this message with lParam set to the
            string "Environment".
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If you process this message, return zero.</para>
            <remarks>
            The lParam parameter indicates which system metric has changed, for example, "ConvertibleSlateMode" if the
            CONVERTIBLESLATEMODE indicator was toggled or "SystemDockMode" if the DOCKED indicator was toggled.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_DEVMODECHANGE">
            <summary>
            <para>The <c>WM_DEVMODECHANGE</c> message is sent to all top-level windows whenever the user changes device-mode settings.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hwnd</em></para>
            <para>A handle to a window.</para>
            <para><em>uMsg</em></para>
            <para>WM_DEVMODECHANGE</para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>A pointer to a string that specifies the device name.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            This message cannot be sent directly to a window. To send the <c>WM_DEVMODECHANGE</c> message to all top-level windows, use
            the <c>SendMessageTimeout</c> function with the hWnd parameter set to HWND_BROADCAST.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_ACTIVATEAPP">
            <summary>
            <para>
            Sent when a window belonging to a different application than the active window is about to be activated. The message is sent
            to the application whose window is being activated and to the application whose window is being deactivated.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_ACTIVATEAPP 0x001C</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            Indicates whether the window is being activated or deactivated. This parameter is <c>TRUE</c> if the window is being
            activated; it is <c>FALSE</c> if the window is being deactivated.
            </para>
            <para><em>lParam</em></para>
            <para>
            The thread identifier. If the wParam parameter is <c>TRUE</c>, lParam is the identifier of the thread that owns the window
            being deactivated. If wParam is <c>FALSE</c>, lParam is the identifier of the thread that owns the window being activated.
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If an application processes this message, it should return zero.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_FONTCHANGE">
            <summary>
            <para>
            An application sends the <c>WM_FONTCHANGE</c> message to all top-level windows in the system after changing the pool of font resources.
            </para>
            <para>To send this message, call the <c>SendMessage</c> function with the following parameters.</para>
            <para>
            <code>SendMessage( (HWND) hWnd, WM_FONTCHANGE, (WPARAM) wParam, (LPARAM) lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <remarks>
            <para>
            An application that adds or removes fonts from the system (for example, by using the <c>AddFontResource</c> or
            <c>RemoveFontResource</c> function) should send this message to all top-level windows.
            </para>
            <para>
            To send the <c>WM_FONTCHANGE</c> message to all top-level windows, an application can call the <c>SendMessage</c> function
            with the hwnd parameter set to HWND_BROADCAST.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_TIMECHANGE">
            <summary>
            <para>A message that is sent whenever there is a change in the system time.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, // handle to window UINT uMsg, // message identifier WPARAM wParam, // not used; must be zero LPARAM lParam // not used; must be zero );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hwnd</em></para>
            <para>A handle to window.</para>
            <para><em>uMsg</em></para>
            <para><c>WM_TIMECHANGE</c> identifier.</para>
            <para><em>wParam</em></para>
            <para>Not used; must be zero.</para>
            <para><em>lParam</em></para>
            <para>Not used; must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            An application should not broadcast this message, because the system will broadcast this message when the application changes
            the system time.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CANCELMODE">
            <summary>
            <para>
            Sent to cancel certain modes, such as mouse capture. For example, the system sends this message to the active window when a
            dialog box or message box is displayed. Certain functions also send this message explicitly to the specified window
            regardless of whether it is the active window. For example, the <c>EnableWindow</c> function sends this message when
            disabling the specified window.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_CANCELMODE 0x001F</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            When the <c>WM_CANCELMODE</c> message is sent, the <c>DefWindowProc</c> function cancels internal processing of standard
            scroll bar input, cancels internal menu processing, and releases the mouse capture.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SETCURSOR">
            <summary>
            <para>Sent to a window if the mouse causes the cursor to move within a window and mouse input is not captured.</para>
            <para>
            <code>#define WM_SETCURSOR 0x0020</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the window that contains the cursor.</para>
            <para><em>lParam</em></para>
            <para>
            The low-order word of lParam specifies the hit-test result for the cursor position. See the return values for WM_NCHITTEST
            for possible values.
            </para>
            <para>
            The high-order word of lParam specifies the mouse window message which triggered this event, such as WM_MOUSEMOVE. When the
            window enters menu mode, this value is zero.
            </para>
            <para><strong>Returns</strong></para>
            <para>
            If an application processes this message, it should return <c>TRUE</c> to halt further processing or <c>FALSE</c> to continue.
            </para>
            <remarks>
            The <c>DefWindowProc</c> function passes the <c>WM_SETCURSOR</c> message to a parent window before processing. If the parent
            window returns <c>TRUE</c>, further processing is halted. Passing the message to a window's parent window gives the parent
            window control over the cursor's setting in a child window. The <c>DefWindowProc</c> function also uses this message to set
            the cursor to an arrow if it is not in the client area, or to the registered class cursor if it is in the client area. If the
            low-order word of the lParam parameter is <c>HTERROR</c> and the high-order word of lParam specifies that one of the mouse
            buttons is pressed, <c>DefWindowProc</c> calls the <c>MessageBeep</c> function.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MOUSEACTIVATE">
            <summary>
            <para>
            Sent when the cursor is in an inactive window and the user presses a mouse button. The parent window receives this message
            only if the child window passes it to the <c>DefWindowProc</c> function.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_MOUSEACTIVATE 0x0021</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the top-level parent window of the window being activated.</para>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the hit-test value returned by the <c>DefWindowProc</c> function as a result of processing the
            <c>WM_NCHITTEST</c> message. For a list of hit-test values, see <c>WM_NCHITTEST</c>.
            </para>
            <para>
            The high-order word specifies the identifier of the mouse message generated when the user pressed a mouse button. The mouse
            message is either discarded or posted to the window, depending on the return value.
            </para>
            <para><strong>Returns</strong></para>
            <para>
            The return value specifies whether the window should be activated and whether the identifier of the mouse message should be
            discarded. It must be one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code/value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term><c>MA_ACTIVATE</c> 1</term>
            <term>Activates the window, and does not discard the mouse message.</term>
            </item>
            <item>
            <term><c>MA_ACTIVATEANDEAT</c> 2</term>
            <term>Activates the window, and discards the mouse message.</term>
            </item>
            <item>
            <term><c>MA_NOACTIVATE</c> 3</term>
            <term>Does not activate the window, and does not discard the mouse message.</term>
            </item>
            <item>
            <term><c>MA_NOACTIVATEANDEAT</c> 4</term>
            <term>Does not activate the window, but discards the mouse message.</term>
            </item>
            </list>
            <remarks>
            The <c>DefWindowProc</c> function passes the message to a child window's parent window before any processing occurs. The
            parent window determines whether to activate the child window. If it activates the child window, the parent window should
            return <c>MA_NOACTIVATE</c> or <c>MA_NOACTIVATEANDEAT</c> to prevent the system from processing the message further.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CHILDACTIVATE">
            <summary>
            <para>Sent to a child window when the user clicks the window's title bar or when the window is activated, moved, or sized.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_CHILDACTIVATE 0x0022</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If an application processes this message, it should return zero.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_QUEUESYNC">
            <summary>
            <para>
            Sent by a computer-based training (CBT) application to separate user-input messages from other messages sent through the
            <c>WH_JOURNALPLAYBACK</c> procedure.
            </para>
            <para>
            <code>#define WM_QUEUESYNC 0x0023</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>void</c></para>
            <para>A CBT application should return zero if it processes this message.</para>
            <remarks>
            <para>
            Whenever a CBT application uses the <c>WH_JOURNALPLAYBACK</c> procedure, the first and last messages are <c>WM_QUEUESYNC</c>.
            This allows the CBT application to intercept and examine user-initiated messages without doing so for events that it sends.
            </para>
            <para>If an application specifies a <c>NULL</c> window handle, the message is posted to the message queue of the active window.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_GETMINMAXINFO">
            <summary>
            <para>
            Sent to a window when the size or position of the window is about to change. An application can use this message to override
            the window's default maximized size and position, or its default minimum or maximum tracking size.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_GETMINMAXINFO 0x0024</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>
            A pointer to a <c>MINMAXINFO</c> structure that contains the default maximized position and dimensions, and the default
            minimum and maximum tracking sizes. An application can override the defaults by setting the members of this structure.
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            The maximum tracking size is the largest window size that can be produced by using the borders to size the window. The
            minimum tracking size is the smallest window size that can be produced by using the borders to size the window.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_PAINTICON">
            <summary>
            <para>
            The WM_PAINTICON message is sent to a minimized window when the icon is to be painted but only if the application is written
            for Windows 3.x. A window receives this message only if a class icon is defined for the window; otherwise, WM_PAINT is sent instead.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_PAINTICON 0x0026</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            The DefWindowProc function draws the class icon. For compatibility with Windows 3.x, wParam is TRUE. However, this value has
            no significance.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_ICONERASEBKGND">
            <summary>
            <para>
            The WM_ICONERASEBKGND message is sent to a minimized window when the background of the icon must be filled before painting
            the icon. A window receives this message only if a class icon is defined for the window; otherwise, WM_ERASEBKGND is sent.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_ICONERASEBKGND 0x0027</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Type: HDC. Identifies the device context of the icon.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>The DefWindowProc function fills the icon background with the class background brush of the parent window.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NEXTDLGCTL">
            <summary>
            <para>Sent to a dialog box procedure to set the keyboard focus to a different control in the dialog box.</para>
            <para>
            <code>#define WM_NEXTDLGCTL 0x0028</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            If lParam is <c>TRUE</c>, this parameter identifies the control that receives the focus. If lParam is <c>FALSE</c>, this
            parameter indicates whether the next or previous control with the <c>WS_TABSTOP</c> style receives the focus. If wParam is
            zero, the next control receives the focus; otherwise, the previous control with the <c>WS_TABSTOP</c> style receives the focus.
            </para>
            <para><em>lParam</em></para>
            <para>
            The low-order word indicates how the system uses wParam. If the low-order word is <c>TRUE</c>, wParam is a handle associated
            with the control that receives the focus; otherwise, wParam is a flag that indicates whether the next or previous control
            with the <c>WS_TABSTOP</c> style receives the focus.
            </para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            <para>
            This message performs additional dialog box management operations beyond those performed by the <c>SetFocus</c> function
            <c>WM_NEXTDLGCTL</c> updates the default pushbutton border, sets the default control identifier, and automatically selects
            the text of an edit control (if the target window is an edit control).
            </para>
            <para>
            Do not use the <c>SendMessage</c> function to send a <c>WM_NEXTDLGCTL</c> message if your application will concurrently
            process other messages that set the focus. Use the <c>PostMessage</c> function instead.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SPOOLERSTATUS">
            <summary>
            <para>
            The <c>WM_SPOOLERSTATUS</c> message is sent from Print Manager whenever a job is added to or removed from the Print Manager queue.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The PR_JOBSTATUS flag.</para>
            <para><em>lParam</em></para>
            <para>The low-order word specifies the number of jobs remaining in the Print Manager queue.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            <para>
            This message is for informational purposes only. This message is advisory and does not have guaranteed delivery semantics.
            Applications should not assume that they will receive a WM_SPOOLERSTATUS message for every change in spooler status.
            </para>
            <para>
            The WM_SPOOLERSTATUS message is not supported after Windows XP. To be notified of changes to the print queue status, you can
            use <c>FindFirstPrinterChangeNotification</c> and <c>FindNextPrinterChangeNotification</c>.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_DRAWITEM">
            <summary>
            <para>
            Sent to the parent window of an owner-drawn button, combo box, list box, or menu when a visual aspect of the button, combo
            box, list box, or menu has changed.
            </para>
            <para>A window receives this message through its WindowProc function.</para>
            <para>
            <code>WM_DRAWITEM WPARAM wParam; LPARAM lParam;</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            Specifies the identifier of the control that sent the <c>WM_DRAWITEM</c> message. If the message was sent by a menu, this
            parameter is zero.
            </para>
            <para><em>lParam</em></para>
            <para>
            Pointer to a <c>DRAWITEMSTRUCT</c> structure containing information about the item to be drawn and the type of drawing required.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return <c>TRUE</c>.</para>
            <remarks>
            <para>By default, the <c>DefWindowProc</c> function draws the focus rectangle for an owner-drawn list box item.</para>
            <para>
            The itemAction member of the <c>DRAWITEMSTRUCT</c> structure specifies the drawing operation that an application should perform.
            </para>
            <para>
            Before returning from processing this message, an application should ensure that the device context identified by the hDC
            member of the <c>DRAWITEMSTRUCT</c> structure is in the default state.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MEASUREITEM">
            <summary>
            <para>Sent to the owner window of a combo box, list box, list-view control, or menu item when the control or menu is created.</para>
            <para>A window receives this message through its WindowProc function.</para>
            <para>
            <code>WM_MEASUREITEM WPARAM wParam; LPARAM lParam;</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            Contains the value of the <c>CtlID</c> member of the <c>MEASUREITEMSTRUCT</c> structure pointed to by the lParam parameter.
            This value identifies the control that sent the <c>WM_MEASUREITEM</c> message. If the message was sent by a menu, this
            parameter is zero. If the value is nonzero or the value is zero and the value of the <c>CtlType</c> member of the
            <c>MEASUREITEMSTRUCT</c> pointed to by lParam is not <c>ODT_MENU</c>, the message was sent by a combo box or by a list box.
            If the value is nonzero, and the value of the <c>itemID</c> member of the <c>MEASUREITEMSTRUCT</c> pointed to by lParam is
            (UINT) 1, the message was sent by a combo edit field.
            </para>
            <para><em>lParam</em></para>
            <para>Pointer to a <c>MEASUREITEMSTRUCT</c> structure that contains the dimensions of the owner-drawn control or menu item.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return <c>TRUE</c>.</para>
            <remarks>
            <para>
            When the owner window receives the <c>WM_MEASUREITEM</c> message, the owner fills in the <c>MEASUREITEMSTRUCT</c> structure
            pointed to by the lParam parameter of the message and returns; this informs the system of the dimensions of the control. If a
            list box or combo box is created with the <c>LBS_OWNERDRAWVARIABLE</c> or <c>CBS_OWNERDRAWVARIABLE</c> style, this message is
            sent to the owner for each item in the control; otherwise, this message is sent once.
            </para>
            <para>
            The system sends the <c>WM_MEASUREITEM</c> message to the owner window of combo boxes and list boxes created with the
            OWNERDRAWFIXED style before sending the <c>WM_INITDIALOG</c> message. As a result, when the owner receives this message, the
            system has not yet determined the height and width of the font used in the control; function calls and calculations requiring
            these values should occur in the main function of the application or library.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_DELETEITEM">
            <summary>
            <para>
            Sent to the owner of a list box or combo box when the list box or combo box is destroyed or when items are removed by the
            <c>LB_DELETESTRING</c>, <c>LB_RESETCONTENT</c>, <c>CB_DELETESTRING</c>, or <c>CB_RESETCONTENT</c> message. The system sends a
            <c>WM_DELETEITEM</c> message for each deleted item. The system sends the <c>WM_DELETEITEM</c> message for any deleted list
            box or combo box item with nonzero item data.
            </para>
            <para>
            <code>WM_DELETEITEM WPARAM wParam; LPARAM lParam;</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Specifies the identifier of the control that sent the <c>WM_DELETEITEM</c> message.</para>
            <para><em>lParam</em></para>
            <para>Pointer to a <c>DELETEITEMSTRUCT</c> structure that contains information about the item deleted from a list box.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return <c>TRUE</c> if it processes this message.</para>
            <remarks>
            <para>
            Microsoft Windows NT and later: Windows sends a <c>WM_DELETEITEM</c> message only for items deleted from an owner-drawn list
            box (with the <c>LBS_OWNERDRAWFIXED</c> or <c>LBS_OWNERDRAWVARIABLE</c> style) or owner-drawn combo box (with the
            <c>CBS_OWNERDRAWFIXED</c> or <c>CBS_OWNERDRAWVARIABLE</c> style).
            </para>
            <para>
            Windows 95: Windows sends the <c>WM_DELETEITEM</c> message for any deleted list box or combo box item with nonzero item data.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_VKEYTOITEM">
            <summary>
            <para>Sent by a list box with the <c>LBS_WANTKEYBOARDINPUT</c> style to its owner in response to a <c>WM_KEYDOWN</c> message.</para>
            <para>
            <code>WM_VKEYTOITEM WPARAM wParam; LPARAM lParam;</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The <c>LOWORD</c> specifies the virtual-key code of the key the user pressed. The <c>HIWORD</c> specifies the current
            position of the caret.
            </para>
            <para><em>lParam</em></para>
            <para>Handle to the list box.</para>
            <para><strong>Returns</strong></para>
            <para>
            The return value specifies the action that the application performed in response to the message. A return value of -2
            indicates that the application handled all aspects of selecting the item and requires no further action by the list box. (See
            Remarks.) A return value of -1 indicates that the list box should perform the default action in response to the keystroke. A
            return value of 0 or greater specifies the index of an item in the list box and indicates that the list box should perform
            the default action for the keystroke on the specified item.
            </para>
            <remarks>
            <para>
            A return value of -2 is valid only for keys that are not translated into characters by the list box control. If the
            <c>WM_KEYDOWN</c> message translates to a <c>WM_CHAR</c> message and the application processes the <c>WM_VKEYTOITEM</c>
            message generated as a result of the key press, the list box ignores the return value and does the default processing for
            that character). <c>WM_KEYDOWN</c> messages generated by keys such as VK_UP, VK_DOWN, VK_NEXT, and VK_PREVIOUS are not
            translated to <c>WM_CHAR</c> messages. In such cases, trapping the <c>WM_VKEYTOITEM</c> message and returning -2 prevents the
            list box from doing the default processing for that key.
            </para>
            <para>
            To trap keys that generate a char message and do special processing, the application must subclass the list box, trap both
            the <c>WM_KEYDOWN</c> and <c>WM_CHAR</c> messages, and process the messages appropriately in the subclass procedure.
            </para>
            <para>
            The preceding remarks apply to regular list boxes that are created with the <c>LBS_WANTKEYBOARDINPUT</c> style. If the list
            box is owner-drawn, the application must process the <c>WM_CHARTOITEM</c> message.
            </para>
            <para>The <c>DefWindowProc</c> function returns -1.</para>
            <para>
            If a dialog box procedure handles this message, it should cast the desired return value to a <c>BOOL</c> and return the value
            directly. The DWL_MSGRESULT value set by the <c>SetWindowLong</c> function is ignored.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CHARTOITEM">
            <summary>
            <para>Sent by a list box with the <c>LBS_WANTKEYBOARDINPUT</c> style to its owner in response to a <c>WM_CHAR</c> message.</para>
            <para>
            <code>WM_CHARTOITEM WPARAM wParam; LPARAM lParam;</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The <c>LOWORD</c> specifies the character code of the key the user pressed. The <c>HIWORD</c> specifies the current position
            of the caret.
            </para>
            <para><em>lParam</em></para>
            <para>Handle to the list box.</para>
            <para><strong>Returns</strong></para>
            <para>
            The return value specifies the action that the application performed in response to the message. A return value of -1 or -2
            indicates that the application handled all aspects of selecting the item and requires no further action by the list box. A
            return value of 0 or greater specifies the zero-based index of an item in the list box and indicates that the list box should
            perform the default action for the keystroke on the specified item.
            </para>
            <remarks>
            <para>The <c>DefWindowProc</c> function returns -1.</para>
            <para>Only owner-drawn list boxes that do not have the <c>LBS_HASSTRINGS</c> style can receive this message.</para>
            <para>
            If a dialog box procedure handles this message, it should cast the desired return value to a <c>BOOL</c> and return the value
            directly. The DWL_MSGRESULT value set by the <c>SetWindowLong</c> function is ignored.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SETFONT">
            <summary>
            <para>Sets the font that a control is to use when drawing text.</para>
            <para>
            <code>#define WM_SETFONT 0x0030</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            A handle to the font ( <c>HFONT</c>). If this parameter is <c>NULL</c>, the control uses the default system font to draw text.
            </para>
            <para><em>lParam</em></para>
            <para>
            The low-order word of lParam specifies whether the control should be redrawn immediately upon setting the font. If this
            parameter is <c>TRUE</c>, the control redraws itself.
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>This message does not return a value.</para>
            <remarks>
            <para>The <c>WM_SETFONT</c> message applies to all controls, not just those in dialog boxes.</para>
            <para>
            The best time for the owner of a dialog box control to set the font of the control is when it receives the
            <c>WM_INITDIALOG</c> message. The application should call the <c>DeleteObject</c> function to delete the font when it is no
            longer needed; for example, after it destroys the control.
            </para>
            <para>
            The size of the control does not change as a result of receiving this message. To avoid clipping text that does not fit
            within the boundaries of the control, the application should correct the size of the control window before it sets the font.
            </para>
            <para>
            When a dialog box uses the DS_SETFONT style to set the text in its controls, the system sends the <c>WM_SETFONT</c> message
            to the dialog box procedure before it creates the controls. An application can create a dialog box that contains the
            DS_SETFONT style by calling any of the following functions:
            </para>
            <list type="bullet">
            <item>
            <term><c>CreateDialogIndirect</c></term>
            </item>
            <item>
            <term><c>CreateDialogIndirectParam</c></term>
            </item>
            <item>
            <term><c>DialogBoxIndirect</c></term>
            </item>
            <item>
            <term><c>DialogBoxIndirectParam</c></term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_GETFONT">
            <summary>
            <para>Retrieves the font with which the control is currently drawing its text.</para>
            <para>
            <code>#define WM_GETFONT 0x0031</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>HFONT</c></para>
            <para>The return value is a handle to the font used by the control, or <c>NULL</c> if the control is using the system font.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SETHOTKEY">
            <summary>
            <para>
            Sent to a window to associate a hot key with the window. When the user presses the hot key, the system activates the window.
            </para>
            <para>
            <code>#define WM_SETHOTKEY 0x0032</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The low-order word specifies the virtual-key code to associate with the window.</para>
            <para>The high-order word can be one or more of the following values from CommCtrl.h.</para>
            <para>Setting wParam to <c>NULL</c> removes the hot key associated with a window.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>HOTKEYF_ALT</c> 0x04</term>
            <term>ALT key</term>
            </item>
            <item>
            <term><c>HOTKEYF_CONTROL</c> 0x02</term>
            <term>CTRL key</term>
            </item>
            <item>
            <term><c>HOTKEYF_EXT</c> 0x08</term>
            <term>Extended key</term>
            </item>
            <item>
            <term><c>HOTKEYF_SHIFT</c> 0x01</term>
            <term>SHIFT key</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>The return value is one of the following.</para>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>-1</term>
            <term>The function is unsuccessful; the hot key is invalid.</term>
            </item>
            <item>
            <term>0</term>
            <term>The function is unsuccessful; the window is invalid.</term>
            </item>
            <item>
            <term>1</term>
            <term>The function is successful, and no other window has the same hot key.</term>
            </item>
            <item>
            <term>2</term>
            <term>The function is successful, but another window already has the same hot key.</term>
            </item>
            </list>
            <remarks>
            <para>A hot key cannot be associated with a child window.</para>
            <para><c>VK_ESCAPE</c>, <c>VK_SPACE</c>, and <c>VK_TAB</c> are invalid hot keys.</para>
            <para>
            When the user presses the hot key, the system generates a <c>WM_SYSCOMMAND</c> message with wParam equal to <c>SC_HOTKEY</c>
            and lParam equal to the window's handle. If this message is passed on to <c>DefWindowProc</c>, the system will bring the
            window's last active popup (if it exists) or the window itself (if there is no popup window) to the foreground.
            </para>
            <para>
            A window can only have one hot key. If the window already has a hot key associated with it, the new hot key replaces the old
            one. If more than one window has the same hot key, the window that is activated by the hot key is random.
            </para>
            <para>These hot keys are unrelated to the hot keys set by <c>RegisterHotKey</c>.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_GETHOTKEY">
            <summary>
            <para>Sent to determine the hot key associated with a window.</para>
            <para>
            <code>#define WM_GETHOTKEY 0x0033</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Not used; must be zero.</para>
            <para><em>lParam</em></para>
            <para>Not used; must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>
            The return value is the virtual-key code and modifiers for the hot key, or <c>NULL</c> if no hot key is associated with the
            window. The virtual-key code is in the low byte of the return value and the modifiers are in the high byte. The modifiers can
            be a combination of the following flags from CommCtrl.h.
            </para>
            <list type="table">
            <listheader>
            <term>Return code/value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term><c>HOTKEYF_ALT</c> 0x04</term>
            <term>ALT key</term>
            </item>
            <item>
            <term><c>HOTKEYF_CONTROL</c> 0x02</term>
            <term>CTRL key</term>
            </item>
            <item>
            <term><c>HOTKEYF_EXT</c> 0x08</term>
            <term>Extended key</term>
            </item>
            <item>
            <term><c>HOTKEYF_SHIFT</c> 0x01</term>
            <term>SHIFT key</term>
            </item>
            </list>
            <remarks>These hot keys are unrelated to the hot keys set by the <c>RegisterHotKey</c> function.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_QUERYDRAGICON">
            <summary>
            <para>
            Sent to a minimized (iconic) window. The window is about to be dragged by the user but does not have an icon defined for its
            class. An application can return a handle to an icon or cursor. The system displays this cursor or icon while the user drags
            the icon.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_QUERYDRAGICON 0x0037</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>
            An application should return a handle to a cursor or icon that the system is to display while the user drags the icon. The
            cursor or icon must be compatible with the display driver's resolution. If the application returns <c>NULL</c>, the system
            displays the default cursor.
            </para>
            <remarks>
            <para>
            When the user drags the icon of a window without a class icon, the system replaces the icon with a default cursor. If the
            application requires a different cursor to be displayed during dragging, it must return a handle to the cursor or icon
            compatible with the display driver's resolution. If an application returns a handle to a color cursor or icon, the system
            converts the cursor or icon to black and white. The application can call the <c>LoadCursor</c> or <c>LoadIcon</c> function to
            load a cursor or icon from the resources in its executable (.exe) file and to retrieve this handle.
            </para>
            <para>
            If a dialog box procedure handles this message, it should cast the desired return value to a <c>BOOL</c> and return the value
            directly. The <c>DWL_MSGRESULT</c> value set by the <c>SetWindowLong</c> function is ignored.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_COMPAREITEM">
            <summary>
            <para>
            Sent to determine the relative position of a new item in the sorted list of an owner-drawn combo box or list box. Whenever
            the application adds a new item, the system sends this message to the owner of a combo box or list box created with the
            <c>CBS_SORT</c> or <c>LBS_SORT</c> style.
            </para>
            <para>
            <code>WM_COMPAREITEM WPARAM wParam; LPARAM lParam;</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Specifies the identifier of the control that sent the <c>WM_COMPAREITEM</c> message.</para>
            <para><em>lParam</em></para>
            <para>
            Pointer to a <c>COMPAREITEMSTRUCT</c> structure that contains the identifiers and application-supplied data for two items in
            the combo or list box.
            </para>
            <para><strong>Returns</strong></para>
            <para>
            The return value indicates the relative position of the two items. It may be any of the values shown in the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term><c>Value</c></term>
            <term>Meaning</term>
            </item>
            <item>
            <term><c>-1</c></term>
            <term>Item 1 precedes item 2 in the sorted order.</term>
            </item>
            <item>
            <term><c>0</c></term>
            <term>Items 1 and 2 are equivalent in the sorted order.</term>
            </item>
            <item>
            <term><c>1</c></term>
            <term>Item 1 follows item 2 in the sorted order.</term>
            </item>
            </list>
            <remarks>
            <para>
            When the owner of an owner-drawn combo box or list box receives this message, the owner returns a value indicating which of
            the items specified by the <c>COMPAREITEMSTRUCT</c> structure will appear before the other. Typically, the system sends this
            message several times until it determines the exact position for the new item.
            </para>
            <para>
            If a dialog box procedure handles this message, it should cast the desired return value to a <c>BOOL</c> and return the value
            directly. The DWL_MSGRESULT value set by the <c>SetWindowLong</c> function is ignored.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_GETOBJECT">
            <summary>
            <para>
            Sent by both Microsoft Active Accessibility and Microsoft UI Automation to obtain information about an accessible object
            contained in a server application.
            </para>
            <para>
            Applications never send this message directly. Microsoft Active Accessibility sends this message in response to calls to
            <c>AccessibleObjectFromPoint</c>, <c>AccessibleObjectFromEvent</c>, or <c>AccessibleObjectFromWindow</c>. However, server
            applications handle this message. UI Automation sends this message in response to calls to
            <c>IUIAutomation::ElementFromHandle</c>, <c>ElementFromPoint</c>, and <c>GetFocusedElement</c>, and when handling events for
            which a client has registered.
            </para>
            <para>
            <code>dwFlags = (WPARAM)(DWORD) wParam; dwObjId = (LPARAM)(DWORD) lParam;</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>dwFlags</em></para>
            <para>
            Provides additional information about the message and is used only by the system. Servers pass dwFlags as the wParam
            parameter in the call to <c>LresultFromObject</c> when handling the message.
            </para>
            <para><em>dwObjId</em></para>
            <para>
            Object identifier. This value is one of the object identifier constants or a custom object identifier. A server application
            must check this value to identify the type of information being requested. Before comparing this value against the OBJID_
            values, the server must cast it to <c>DWORD</c>; otherwise, on 64-bit Windows, the sign extension of the lParam can interfere
            with the comparison.
            </para>
            <list type="bullet">
            <item>
            <term>
            If dwObjId is one of the OBJID_ values such as <c>OBJID_CLIENT</c>, the request is for a Microsoft Active Accessibility
            object that implements <c>IAccessible</c>.
            </term>
            </item>
            <item>
            <term>
            If dwObjId is equal to <c>UiaRootObjectId</c>, the request is for a UI Automation provider. If the server is implementing UI
            Automation, it should return a provider using the <c>UiaReturnRawElementProvider</c> function.
            </term>
            </item>
            <item>
            <term>
            If dwObjId is <c>OBJID_NATIVEOM</c>, the request is for the control's underlying object model. If the control supports this
            request, it should return an appropriate COM interface by calling the <c>LresultFromObject</c> function.
            </term>
            </item>
            <item>
            <term>
            If dwObjId is <c>OBJID_QUERYCLASSNAMEIDX</c>, the request is for the control to identify itself as a standard Windows control
            or a common control implemented by the common control library (ComCtrl.dll).
            </term>
            </item>
            </list>
            <para><strong>Returns</strong></para>
            <para>
            If the window or control does not need to respond to this message, it should pass the message to the <c>DefWindowProc</c>
            function; otherwise, the window or control should return a value that corresponds to the request specified by dwObjId:
            </para>
            <list type="bullet">
            <item>
            <term>
            If the window or control implements UI Automation, the window or control should return the value obtained by a call to the
            <c>UiaReturnRawElementProvider</c> function.
            </term>
            </item>
            <item>
            <term>
            If dwObjId is <c>OBJID_NATIVEOM</c> and the window exposes a native Object Model, the windows should return the value
            obtained by a call to the <c>LresultFromObject</c> function.
            </term>
            </item>
            <item>
            <term>
            If dwObjId is <c>OBJID_CLIENT</c> and the window implements <c>IAccessible</c>, the window should return the value obtained
            by a call to the <c>LresultFromObject</c> function.
            </term>
            </item>
            </list>
            <remarks>
            <para>
            When a client calls <c>AccessibleObjectFromWindow</c> or any of the other <c>AccessibleObjectFrom</c> X functions that
            retrieve an interface to an object, Microsoft Active Accessibility sends the <c>WM_GETOBJECT</c> message to the appropriate
            window procedure within the appropriate server application. While processing <c>WM_GETOBJECT</c>, server applications call
            <c>LresultFromObject</c> and use the return value of this function as the return value for the message. Microsoft Active
            Accessibility, in conjunction with the COM library, performs the appropriate marshaling and passes the interface pointer from
            the server back to the client.
            </para>
            <para>
            Servers do not respond to <c>WM_GETOBJECT</c> before the object is fully initialized or after it begins to close down. When
            an application creates a new window, the system sends <c>EVENT_OBJECT_CREATE</c> to notify clients before it sends the
            WM_CREATE message to the application's window procedure. Because many applications use WM_CREATE to start their
            initialization process, servers do not respond to the <c>WM_GETOBJECT</c> message until finished processing the
            <c>WM_CREATE</c> message.
            </para>
            <para>A server uses <c>WM_GETOBJECT</c> to perform the following tasks:</para>
            <list type="bullet">
            <item>
            <term>Create New Accessible Objects</term>
            </item>
            <item>
            <term>Reuse Existing Pointers to Objects</term>
            </item>
            <item>
            <term>Create New Interfaces to the Same Object</term>
            </item>
            </list>
            <para>
            For clients, this means that they might receive distinct interface pointers for the same user interface element, depending on
            the server's action. To determine if two interface pointers point to the same user interface element, clients compare
            <c>IAccessible</c> properties of the object. Comparing pointers does not work.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_COMPACTING">
            <summary>
            <para>
            Sent to all top-level windows when the system detects more than 12.5 percent of system time over a 30- to 60-second interval
            is being spent compacting memory. This indicates that system memory is low.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <para>Note</para>
            <para>This message is provided only for compatibility with 16-bit Windows-based applications.</para>
            </para>
            <para>
            <code>#define WM_COMPACTING 0x0041</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The ratio of central processing unit (CPU) time currently spent by the system compacting memory to CPU time currently spent
            by the system performing other operations. For example, 0x8000 represents 50 percent of CPU time spent compacting memory.
            </para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            When an application receives this message, it should free as much memory as possible, taking into account the current level
            of activity of the application and the total number of applications running on the system.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_COMMNOTIFY">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_WINDOWPOSCHANGING">
            <summary>
            Sent to a window whose size, position, or place in the Z order is about to change as a result of a call to the SetWindowPos
            function or another window-management function.
            <para>A window receives this message through its WindowProc function.</para>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>A pointer to a <see cref="T:Vanara.PInvoke.User32.WINDOWPOS"/> structure that contains information about the window's new size and position.</para>
            <para><strong>Return value</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            </summary>
            <remarks>
            For a window with the WS_OVERLAPPED or WS_THICKFRAME style, the DefWindowProc function sends the WM_GETMINMAXINFO message to
            the window. This is done to validate the new size and position of the window and to enforce the CS_BYTEALIGNCLIENT and
            CS_BYTEALIGNWINDOW client styles. By not passing the WM_WINDOWPOSCHANGING message to the DefWindowProc function, an
            application can override these defaults.
            <para>
            While this message is being processed, modifying any of the values in WINDOWPOS affects the window's new size, position, or
            place in the Z order. An application can prevent changes to the window by setting or clearing the appropriate bits in the
            flags member of WINDOWPOS.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_WINDOWPOSCHANGED">
            <summary>
            Sent to a window whose size, position, or place in the Z order has changed as a result of a call to the SetWindowPos function
            or another window-management function.
            <para>A window receives this message through its WindowProc function.</para>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>A pointer to a <see cref="T:Vanara.PInvoke.User32.WINDOWPOS"/> structure that contains information about the window's new size and position.</para>
            <para><strong>Return value</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            </summary>
            <remarks>
            By default, the DefWindowProc function sends the WM_SIZE and WM_MOVE messages to the window. The WM_SIZE and WM_MOVE messages
            are not sent if an application handles the WM_WINDOWPOSCHANGED message without calling DefWindowProc. It is more efficient to
            perform any move or size change processing during the WM_WINDOWPOSCHANGED message without calling DefWindowProc.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_POWER">
            <summary>
            <para>
            Notifies applications that the system, typically a battery-powered personal computer, is about to enter a suspended mode.
            </para>
            <para>
            <para>Note</para>
            <para>
            The <c>WM_POWER</c> message is obsolete. It is provided only for compatibility with 16-bit Windows-based applications.
            Applications should use the <c>WM_POWERBROADCAST</c> message.
            </para>
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc HWND hwnd, // handle to window UINT uMsg, // WM_POWER WPARAM wParam, // power-event notification LPARAM lParam // not used );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hwnd</em></para>
            <para>A handle to window.</para>
            <para><em>uMsg</em></para>
            <para>The <c>WM_POWER</c> message identifier.</para>
            <para><em>wParam</em></para>
            <para>The power-event notification. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>PWR_CRITICALRESUME</c></term>
            <term>
            Indicates that the system is resuming operation after entering suspended mode without first broadcasting a
            <c>PWR_SUSPENDREQUEST</c> notification message to the application. An application should perform any necessary recovery actions.
            </term>
            </item>
            <item>
            <term><c>PWR_SUSPENDREQUEST</c></term>
            <term>Indicates that the system is about to enter suspended mode.</term>
            </item>
            <item>
            <term><c>PWR_SUSPENDRESUME</c></term>
            <term>
            Indicates that the system is resuming operation after having entered suspended mode normally that is, the system broadcast a
            <c>PWR_SUSPENDREQUEST</c> notification message to the application before the system was suspended. An application should
            perform any necessary recovery actions.
            </term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>
            The value an application returns depends on the value of the wParam parameter. If wParam is <c>PWR_SUSPENDREQUEST</c>, the
            return value is <c>PWR_FAIL</c> to prevent the system from entering the suspended state; otherwise, it is <c>PWR_OK</c>. If
            wParam is <c>PWR_SUSPENDRESUME</c> or <c>PWR_CRITICALRESUME</c>, the return value is zero.
            </para>
            <remarks>
            <para>
            This message is broadcast only to an application that is running on a system that conforms to the Advanced Power Management
            (APM) basic input/output system (BIOS) specification. The message is broadcast by the power-management driver to each window
            returned by the <c>EnumWindows</c> function.
            </para>
            <para>
            The suspended mode is the state in which the greatest amount of power savings occurs, but all operational data and parameters
            are preserved. Random-access memory (RAM) contents are preserved, but many devices are likely to be turned off.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_COPYDATA">
            <summary>
            <para>An application sends the <c>WM_COPYDATA</c> message to pass data to another application.</para>
            <para>
            <code>#define WM_COPYDATA 0x004A</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the window passing the data.</para>
            <para><em>lParam</em></para>
            <para>A pointer to a <c>COPYDATASTRUCT</c> structure that contains the data to be passed.</para>
            <para><strong>Returns</strong></para>
            <para>If the receiving application processes this message, it should return <c>TRUE</c>; otherwise, it should return <c>FALSE</c>.</para>
            <remarks>
            <para>
            The data being passed must not contain pointers or other references to objects not accessible to the application receiving
            the data.
            </para>
            <para>While this message is being sent, the referenced data must not be changed by another thread of the sending process.</para>
            <para>
            The receiving application should consider the data read-only. The lParam parameter is valid only during the processing of the
            message. The receiving application should not free the memory referenced by lParam. If the receiving application must access
            the data after <c>SendMessage</c> returns, it must copy the data into a local buffer.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CANCELJOURNAL">
            <summary>
            <para>
            Posted to an application when a user cancels the application's journaling activities. The message is posted with a
            <c>NULL</c> window handle.
            </para>
            <para>
            <code>#define WM_CANCELJOURNAL 0x004B</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>void</c></para>
            <para>
            This message does not return a value. It is meant to be processed from within an application's main loop or a
            <c>GetMessage</c> hook procedure, not from a window procedure.
            </para>
            <remarks>
            <para>
            Journal record and playback modes are modes imposed on the system that let an application sequentially record or play back
            user input. The system enters these modes when an application installs a JournalRecordProc or JournalPlaybackProc hook
            procedure. When the system is in either of these journaling modes, applications must take turns reading input from the input
            queue. If any one application stops reading input while the system is in a journaling mode, other applications are forced to wait.
            </para>
            <para>
            To ensure a robust system, one that cannot be made unresponsive by any one application, the system automatically cancels any
            journaling activities when a user presses CTRL+ESC or CTRL+ALT+DEL. The system then unhooks any journaling hook procedures,
            and posts a <c>WM_CANCELJOURNAL</c> message, with a <c>NULL</c> window handle, to the application that set the journaling hook.
            </para>
            <para>
            The <c>WM_CANCELJOURNAL</c> message has a <c>NULL</c> window handle, therefore it cannot be dispatched to a window procedure.
            There are two ways for an application to see a <c>WM_CANCELJOURNAL</c> message: If the application is running in its own main
            loop, it must catch the message between its call to <c>GetMessage</c> or <c>PeekMessage</c> and its call to
            <c>DispatchMessage</c>. If the application is not running in its own main loop, it must set a GetMsgProc hook procedure
            (through a call to <c>SetWindowsHookEx</c> specifying the <c>WH_GETMESSAGE</c> hook type) that watches for the message.
            </para>
            <para>
            When an application sees a <c>WM_CANCELJOURNAL</c> message, it can assume two things: the user has intentionally canceled the
            journal record or playback mode, and the system has already unhooked any journal record or playback hook procedures.
            </para>
            <para>
            Note that the key combinations mentioned above (CTRL+ESC or CTRL+ALT+DEL) cause the system to cancel journaling. If any one
            application is made unresponsive, they give the user a means of recovery. The <c>VK_CANCEL</c> virtual key code (usually
            implemented as the CTRL+BREAK key combination) is what an application that is in journal record mode should watch for as a
            signal that the user wishes to cancel the journaling activity. The difference is that watching for <c>VK_CANCEL</c> is a
            suggested behavior for journaling applications, whereas CTRL+ESC or CTRL+ALT+DEL cause the system to cancel journaling
            regardless of a journaling application's behavior.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NOTIFY">
            <summary>Sent by a common control to its parent window when an event has occurred or the control requires some information.</summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The identifier of the common control sending the message. This identifier is not guaranteed to be unique. An application
            should use the <c>hwndFrom</c> or <c>idFrom</c> member of the <c>NMHDR</c> structure (passed as the lParam parameter) to
            identify the control.
            </para>
            <para><em>lParam</em></para>
            <para>
            A pointer to an <c>NMHDR</c> structure that contains the notification code and additional information. For some notification
            messages, this parameter points to a larger structure that has the <c>NMHDR</c> structure as its first member.
            </para>
            <para><strong>Returns</strong></para>
            <para>The return value is ignored except for notification messages that specify otherwise.</para>
            <remarks>
            <para>
            The destination of the message must be the <c>HWND</c> of the parent of the control. This value can be obtained by using
            <c>GetParent</c>, as shown in the following example, where m_controlHwnd is the <c>HWND</c> of the control itself.
            </para>
            <para>
            <code>NMHDR nmh; nmh.code = CUSTOM_SELCHANGE; // Message type defined by control. nmh.idFrom = GetDlgCtrlID(m_controlHwnd); nmh.hwndFrom = m_controlHwnd; SendMessage(GetParent(m_controlHwnd), WM_NOTIFY, nmh.idFrom, (LPARAM)&amp;nmh);</code>
            </para>
            <para>
            Applications handle the message in the window procedure of the parent window, as shown in the following example, which
            handles the notification message sent by the custom control in the previous example.
            </para>
            <para>
            <code>INT_PTR CALLBACK DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) { switch (message) { case WM_NOTIFY: switch (((LPNMHDR)lParam)-&gt;code) { case CUSTOM_SELCHANGE: if (((LPNMHDR)lParam)-&gt;idFrom == IDC_CUSTOMLISTBOX1) { ... // Respond to message. return TRUE; } break; ... // More cases on WM_NOTIFY switch. break; } ... // More cases on message switch. } return FALSE; }</code>
            </para>
            <para>
            Some notifications, chiefly those that have been in the API for a long time, are sent as <c>WM_COMMAND</c> messages. For more
            information, see Control Messages.
            </para>
            <para>
            If the message handler is in a dialog box procedure, you must use the <c>SetWindowLong</c> function with DWL_MSGRESULT to set
            a return value.
            </para>
            <para>For Windows Vista and later systems, the <c>WM_NOTIFY</c> message cannot be sent between processes.</para>
            <para>
            Many notifications are available in both ANSI and Unicode formats. The window sending the <c>WM_NOTIFY</c> message uses the
            <c>WM_NOTIFYFORMAT</c> message to determine which format should be used. See <c>WM_NOTIFYFORMAT</c> for further discussion.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_INPUTLANGCHANGEREQUEST">
            <summary>
            <para>
            Posted to the window with the focus when the user chooses a new input language, either with the hotkey (specified in the
            Keyboard control panel application) or from the indicator on the system taskbar. An application can accept the change by
            passing the message to the <c>DefWindowProc</c> function or reject the change (and prevent it from taking place) by returning immediately.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_INPUTLANGCHANGEREQUEST 0x0050</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The new input locale. This parameter can be a combination of the following flags.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>INPUTLANGCHANGE_BACKWARD</c> 0x0004</term>
            <term>
            A hot key was used to choose the previous input locale in the installed list of input locales. This flag cannot be used with
            the INPUTLANGCHANGE_FORWARD flag.
            </term>
            </item>
            <item>
            <term><c>INPUTLANGCHANGE_FORWARD</c> 0x0002</term>
            <term>
            A hot key was used to choose the next input locale in the installed list of input locales. This flag cannot be used with the
            INPUTLANGCHANGE_BACKWARD flag.
            </term>
            </item>
            <item>
            <term><c>INPUTLANGCHANGE_SYSCHARSET</c> 0x0001</term>
            <term>The new input locale's keyboard layout can be used with the system character set.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>The input locale identifier. For more information, see Languages, Locales, and Keyboard Layouts.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>
            This message is posted, not sent, to the application, so the return value is ignored. To accept the change, the application
            should pass the message to <c>DefWindowProc</c>. To reject the change, the application should return zero without calling <c>DefWindowProc</c>.
            </para>
            <remarks>
            <para>
            When the <c>DefWindowProc</c> function receives the <c>WM_INPUTLANGCHANGEREQUEST</c> message, it activates the new input
            locale and notifies the application of the change by sending the <c>WM_INPUTLANGCHANGE</c> message.
            </para>
            <para>
            The language indicator is present on the taskbar only if you have installed more than one keyboard layout and if you have
            enabled the indicator using the Keyboard control panel application.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_INPUTLANGCHANGE">
            <summary>
            <para>
            Sent to the topmost affected window after an application's input language has been changed. You should make any
            application-specific settings and pass the message to the <c>DefWindowProc</c> function, which passes the message to all
            first-level child windows. These child windows can pass the message to <c>DefWindowProc</c> to have it pass the message to
            their child windows, and so on.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_INPUTLANGCHANGE 0x0051</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Type: **WPARAM**</para>
            <para>The code page of the new locale.</para>
            <para><em>lParam</em></para>
            <para>Type: **LPARAM**</para>
            <para>The <c>HKL</c> input locale identifier. For more information, see Languages, Locales, and Keyboard Layouts.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>An application should return nonzero if it processes this message.</para>
            <remarks>
            <para>You can retrieve keyboard locale name via LCIDToLocaleName function. With locale name you can use modern locale functions:</para>
            <para>
            <code>case WM_INPUTLANGCHANGE: { HKL hkl = (HKL)lParam; WCHAR localeName[LOCALE_NAME_MAX_LENGTH]; LCIDToLocaleName(MAKELCID(LOWORD(hkl), SORT_DEFAULT), localeName, LOCALE_NAME_MAX_LENGTH, 0); WCHAR lang[9]; GetLocaleInfoEx(localeName, LOCALE_SISO639LANGNAME2, lang, 9); }</code>
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_TCARD">
            <summary>
            Sent to an application that has initiated a training card with Windows Help. The message informs the application when the
            user clicks an authorable button. An application initiates a training card by specifying the HELP_TCARD command in a call to
            the <c>WinHelp</c> function.
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>idAction</em></para>
            <para>A value that indicates the action the user has taken. This can be one of the following values.</para>
            <para><em><c>IDABORT</c></em></para>
            <para>The user clicked an authorable <c>Abort</c> button.</para>
            <para><em><c>IDCANCEL</c></em></para>
            <para>The user clicked an authorable <c>Cancel</c> button.</para>
            <para><em><c>IDCLOSE</c></em></para>
            <para>The user closed the training card.</para>
            <para><em><c>IDHELP</c></em></para>
            <para>The user clicked an authorable Windows <c>Help</c> button.</para>
            <para><em><c>IDIGNORE</c></em></para>
            <para>The user clicked an authorable <c>Ignore</c> button.</para>
            <para><em><c>IDOK</c></em></para>
            <para>The user clicked an authorable <c>OK</c> button.</para>
            <para><em><c>IDNO</c></em></para>
            <para>The user clicked an authorable <c>No</c> button.</para>
            <para><em><c>IDRETRY</c></em></para>
            <para>The user clicked an authorable <c>Retry</c> button.</para>
            <para><em><c>HELP_TCARD_DATA</c></em></para>
            <para>The user clicked an authorable button. The dwActionData parameter contains a long integer specified by the Help author.</para>
            <para><em><c>HELP_TCARD_OTHER_CALLER</c></em></para>
            <para>Another application has requested training cards.</para>
            <para><em><c>IDYES</c></em></para>
            <para>The user clicked an authorable <c>Yes</c> button.</para>
            <para><strong>Returns</strong></para>
            <para>The return value is ignored; use zero.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_HELP">
            <summary>
            Indicates that the user pressed the F1 key. If a menu is active when F1 is pressed, <c>WM_HELP</c> is sent to the window
            associated with the menu; otherwise, <c>WM_HELP</c> is sent to the window that has the keyboard focus. If no window has the
            keyboard focus, <c>WM_HELP</c> is sent to the currently active window.
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Must be zero.</para>
            <para><em>lphi</em></para>
            <para>
            The address of a <c>HELPINFO</c> structure that contains information about the menu item, control, dialog box, or window for
            which Help is requested.
            </para>
            <para><strong>Returns</strong></para>
            <para>Returns <c>TRUE</c>.</para>
            <remarks>
            The <c>DefWindowProc</c> function passes <c>WM_HELP</c> to the parent window of a child window or to the owner of a top-level window.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_USERCHANGED">
            <summary>
            <para>
            Sent to all windows after the user has logged on or off. When the user logs on or off, the system updates the user-specific
            settings. The system sends this message immediately after updating the settings.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <para>Note</para>
            <para>This message is not supported as of Windows Vista.</para>
            </para>
            <para>
            <code>#define WM_USERCHANGED 0x0054</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>An application should return zero if it processes this message.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NOTIFYFORMAT">
            <summary>
            Determines if a window accepts ANSI or Unicode structures in the <c>WM_NOTIFY</c> notification message.
            <c>WM_NOTIFYFORMAT</c> messages are sent from a common control to its parent window and from the parent window to the common control.
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            A handle to the window that is sending the <c>WM_NOTIFYFORMAT</c> message. If lParam is NF_QUERY, this parameter is the
            handle to a control. If lParam is NF_REQUERY, this parameter is the handle to the parent window of a control.
            </para>
            <para><em>lParam</em></para>
            <para>
            The command value that specifies the nature of the <c>WM_NOTIFYFORMAT</c> message. This will be one of the following values:
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>NF_QUERY</c></term>
            <term>
            The message is a query to determine whether ANSI or Unicode structures should be used in <c>WM_NOTIFY</c> messages. This
            command is sent from a control to its parent window during the creation of a control and in response to an NF_REQUERY command.
            </term>
            </item>
            <item>
            <term><c>NF_REQUERY</c></term>
            <term>
            The message is a request for a control to send an NF_QUERY form of this message to its parent window. This command is sent
            from the parent window. The parent window is asking the control to requery it about the type of structures to use in
            <c>WM_NOTIFY</c> messages. If <c>lParam</c> is NF_REQUERY, the return value is the result of the requery operation.
            </term>
            </item>
            </list>
            <para><strong>Returns</strong></para>
            <para>Returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term><c>NFR_ANSI</c></term>
            <term>ANSI structures should be used in <c>WM_NOTIFY</c> messages sent by the control.</term>
            </item>
            <item>
            <term><c>NFR_UNICODE</c></term>
            <term>Unicode structures should be used in <c>WM_NOTIFY</c> messages sent by the control.</term>
            </item>
            <item>
            <term><c>0</c></term>
            <term>An error occurred.</term>
            </item>
            </list>
            <remarks>
            <para>
            When a common control is created, the control sends a <c>WM_NOTIFYFORMAT</c> message to its parent window to determine the
            type of structures to use in <c>WM_NOTIFY</c> messages. If the parent window does not handle this message, the
            <c>DefWindowProc</c> function responds according to the type of the parent window. That is, if the parent window is a Unicode
            window, <c>DefWindowProc</c> returns NFR_UNICODE, and if the parent window is an ANSI window, <c>DefWindowProc</c> returns
            NFR_ANSI. If the parent window is a dialog box and does not handle this message, the <c>DefDlgProc</c> function similarly
            responds according to the type of the dialog box (Unicode or ANSI).
            </para>
            <para>
            A parent window can change the type of structures a common control uses in <c>WM_NOTIFY</c> messages by setting lParam to
            NF_REQUERY and sending a <c>WM_NOTIFYFORMAT</c> message to the control. This causes the control to send an NF_QUERY form of
            the <c>WM_NOTIFYFORMAT</c> message to the parent window.
            </para>
            <para>
            All common controls will send <c>WM_NOTIFYFORMAT</c> messages. However, the standard Windows controls (edit controls, combo
            boxes, list boxes, buttons, scroll bars, and static controls) do not.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CONTEXTMENU">
            <summary>
            <para>
            Notifies a window that the user desires a context menu to appear. The user may have clicked the right mouse button
            (right-clicked) in the window, pressed Shift+F10 or pressed the applications key (context menu key) available on some keyboards.
            </para>
            <para>
            <code>#define WM_CONTEXTMENU 0x007B</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            A handle to the window in which the user right-clicked the mouse. This can be a child window of the window receiving the
            message. For more information about processing this message, see the Remarks section.
            </para>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the horizontal position of the cursor, in screen coordinates, at the time of the mouse click.
            </para>
            <para>
            The high-order word specifies the vertical position of the cursor, in screen coordinates, at the time of the mouse click.
            </para>
            <para><strong>Returns</strong></para>
            <para>No return value.</para>
            <remarks>
            <para>
            A window can process this message by displaying a shortcut menu using the <c>TrackPopupMenu</c> or <c>TrackPopupMenuEx</c>
            functions. To obtain the horizontal and vertical positions, use the following code.
            </para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            If a window does not display a shortcut menu it should pass this message to the <c>DefWindowProc</c> function. If a window is
            a child window, <c>DefWindowProc</c> sends the message to the parent. Otherwise, <c>DefWindowProc</c> displays a default
            shortcut menu if the specified position is in the window's caption.
            </para>
            <para>
            <c>DefWindowProc</c> generates the <c>WM_CONTEXTMENU</c> message when it processes the <c>WM_RBUTTONUP</c> or
            <c>WM_NCRBUTTONUP</c> message or when the user types SHIFT+F10. The <c>WM_CONTEXTMENU</c> message is also generated when the
            user presses and releases the <c>VK_APPS</c> key.
            </para>
            <para>
            If the context menu is generated from the keyboard for example, if the user types SHIFT+F10 then the x- and y-coordinates are
            -1 and the application should display the context menu at the location of the current selection rather than at (xPos, yPos).
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_STYLECHANGING">
            <summary>
            <para>Sent to a window when the <c>SetWindowLong</c> function is about to change one or more of the window's styles.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_STYLECHANGING 0x007C</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            Indicates whether the window's styles or extended window styles are changing. This parameter can be one or more of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>GWL_EXSTYLE</c> -20</term>
            <term>The extended window styles are changing.</term>
            </item>
            <item>
            <term><c>GWL_STYLE</c> -16</term>
            <term>The window styles are changing.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            A pointer to a <c>STYLESTRUCT</c> structure that contains the proposed new styles for the window. An application can examine
            the styles and, if necessary, change them.
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>An application should return zero if it processes this message.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_STYLECHANGED">
            <summary>
            <para>Sent to a window after the <c>SetWindowLong</c> function has changed one or more of the window's styles.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_STYLECHANGED 0x007D</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            Indicates whether the window's styles or extended window styles have changed. This parameter can be one or more of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>GWL_EXSTYLE</c> -20</term>
            <term>The extended window styles have changed.</term>
            </item>
            <item>
            <term><c>GWL_STYLE</c> -16</term>
            <term>The window styles have changed.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            A pointer to a <c>STYLESTRUCT</c> structure that contains the new styles for the window. An application can examine the
            styles, but cannot change them.
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>An application should return zero if it processes this message.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_DISPLAYCHANGE">
            <summary>
            <para>The <c>WM_DISPLAYCHANGE</c> message is sent to all windows when the display resolution has changed.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The new image depth of the display, in bits per pixel.</para>
            <para><em>lParam</em></para>
            <para>The low-order word specifies the horizontal resolution of the screen.</para>
            <para>The high-order word specifies the vertical resolution of the screen.</para>
            <remarks>This message is only sent to top-level windows. For all other windows it is posted.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_GETICON">
            <summary>
            <para>
            Sent to a window to retrieve a handle to the large or small icon associated with a window. The system displays the large icon
            in the ALT+TAB dialog, and the small icon in the window caption.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_GETICON 0x007F</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The type of icon being retrieved. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>ICON_BIG</c> 1</term>
            <term>Retrieve the large icon for the window.</term>
            </item>
            <item>
            <term><c>ICON_SMALL</c> 0</term>
            <term>Retrieve the small icon for the window.</term>
            </item>
            <item>
            <term><c>ICON_SMALL2</c> 2</term>
            <term>
            Retrieves the small icon provided by the application. If the application does not provide one, the system uses the
            system-generated icon for that window.
            </term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>The DPI of the icon being retrieved. This can be used to provide different icons depending on the icon size.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>HICON</c></para>
            <para>
            The return value is a handle to the large or small icon, depending on the value of wParam. When an application receives this
            message, it can return a handle to a large or small icon, or pass the message to the <c>DefWindowProc</c> function.
            </para>
            <remarks>
            <para>
            When an application receives this message, it can return a handle to a large or small icon, or pass the message to <c>DefWindowProc</c>.
            </para>
            <para>
            <c>DefWindowProc</c> returns a handle to the large or small icon associated with the window, depending on the value of wParam.
            </para>
            <para>
            A window that has no icon explicitly set (with <c>WM_SETICON</c>) uses the icon for the registered window class, and in this
            case <c>DefWindowProc</c> will return 0 for a <c>WM_GETICON</c> message. If sending a <c>WM_GETICON</c> message to a window
            returns 0, next try calling the <c>GetClassLongPtr</c> function for the window. If that returns 0 then try the
            <c>LoadIcon</c> function.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SETICON">
            <summary>
            <para>
            Associates a new large or small icon with a window. The system displays the large icon in the ALT+TAB dialog box, and the
            small icon in the window caption.
            </para>
            <para>
            <code>#define WM_SETICON 0x0080</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The type of icon to be set. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>ICON_BIG</c> 1</term>
            <term>Set the large icon for the window.</term>
            </item>
            <item>
            <term><c>ICON_SMALL</c> 0</term>
            <term>Set the small icon for the window.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>A handle to the new large or small icon. If this parameter is <c>NULL</c>, the icon indicated by wParamis removed.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>
            The return value is a handle to the previous large or small icon, depending on the value of wParam. It is <c>NULL</c> if the
            window previously had no icon of the type indicated by wParam.
            </para>
            <remarks>
            The <c>DefWindowProc</c> function returns a handle to the previous large or small icon associated with the window, depending
            on the value of wParam.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCCREATE">
            <summary>
            <para>Sent prior to the <c>WM_CREATE</c> message when a window is first created.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCCREATE 0x0081</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>
            A pointer to the <c>CREATESTRUCT</c> structure that contains information about the window being created. The members of
            <c>CREATESTRUCT</c> are identical to the parameters of the <c>CreateWindowEx</c> function.
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>
            If an application processes this message, it should return <c>TRUE</c> to continue creation of the window. If the application
            returns <c>FALSE</c>, the <c>CreateWindow</c> or <c>CreateWindowEx</c> function will return a <c>NULL</c> handle.
            </para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCDESTROY">
            <summary>
            <para>
            Notifies a window that its nonclient area is being destroyed. The <c>DestroyWindow</c> function sends the <c>WM_NCDESTROY</c>
            message to the window following the <c>WM_DESTROY</c> message. <c>WM_DESTROY</c> is used to free the allocated memory object
            associated with the window.
            </para>
            <para>
            The <c>WM_NCDESTROY</c> message is sent after the child windows have been destroyed. In contrast, <c>WM_DESTROY</c> is sent
            before the child windows are destroyed.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCDESTROY 0x0082</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>This message frees any memory internally allocated for the window.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCCALCSIZE">
            <summary>
            <para>
            Sent when the size and position of a window's client area must be calculated. By processing this message, an application can
            control the content of the window's client area when the size or position of the window changes.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCCALCSIZE 0x0083</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            If wParam is <c>TRUE</c>, it specifies that the application should indicate which part of the client area contains valid
            information. The system copies the valid information to the specified area within the new client area.
            </para>
            <para>If wParam is <c>FALSE</c>, the application does not need to indicate the valid part of the client area.</para>
            <para><em>lParam</em></para>
            <para>
            If wParam is <c>TRUE</c>, lParam points to an <c>NCCALCSIZE_PARAMS</c> structure that contains information an application can
            use to calculate the new size and position of the client rectangle.
            </para>
            <para>
            If wParam is <c>FALSE</c>, lParam points to a <c>RECT</c> structure. On entry, the structure contains the proposed window
            rectangle for the window. On exit, the structure should contain the screen coordinates of the corresponding window client area.
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If the wParam parameter is <c>FALSE</c>, the application should return zero.</para>
            <para>If wParam is <c>TRUE</c>, the application should return zero or a combination of the following values.</para>
            <para>
            If wParam is <c>TRUE</c> and an application returns zero, the old client area is preserved and is aligned with the upper-left
            corner of the new client area.
            </para>
            <list type="table">
            <listheader>
            <term>Return code/value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term><c>WVR_ALIGNTOP</c> 0x0010</term>
            <term>
            Specifies that the client area of the window is to be preserved and aligned with the top of the new position of the window.
            For example, to align the client area to the upper-left corner, return the WVR_ALIGNTOP and <c>WVR_ALIGNLEFT</c> values.
            </term>
            </item>
            <item>
            <term><c>WVR_ALIGNRIGHT</c> 0x0080</term>
            <term>
            Specifies that the client area of the window is to be preserved and aligned with the right side of the new position of the
            window. For example, to align the client area to the lower-right corner, return the <c>WVR_ALIGNRIGHT</c> and WVR_ALIGNBOTTOM values.
            </term>
            </item>
            <item>
            <term><c>WVR_ALIGNLEFT</c> 0x0020</term>
            <term>
            Specifies that the client area of the window is to be preserved and aligned with the left side of the new position of the
            window. For example, to align the client area to the lower-left corner, return the <c>WVR_ALIGNLEFT</c> and
            <c>WVR_ALIGNBOTTOM</c> values.
            </term>
            </item>
            <item>
            <term><c>WVR_ALIGNBOTTOM</c> 0x0040</term>
            <term>
            Specifies that the client area of the window is to be preserved and aligned with the bottom of the new position of the
            window. For example, to align the client area to the top-left corner, return the WVR_ALIGNTOP and <c>WVR_ALIGNLEFT</c> values.
            </term>
            </item>
            <item>
            <term><c>WVR_HREDRAW</c> 0x0100</term>
            <term>
            Used in combination with any other values, except <c>WVR_VALIDRECTS</c>, causes the window to be completely redrawn if the
            client rectangle changes size horizontally. This value is similar to CS_HREDRAW class style
            </term>
            </item>
            <item>
            <term><c>WVR_VREDRAW</c> 0x0200</term>
            <term>
            Used in combination with any other values, except <c>WVR_VALIDRECTS</c>, causes the window to be completely redrawn if the
            client rectangle changes size vertically. This value is similar to CS_VREDRAW class style
            </term>
            </item>
            <item>
            <term><c>WVR_REDRAW</c> 0x0300</term>
            <term>
            This value causes the entire window to be redrawn. It is a combination of <c>WVR_HREDRAW</c> and <c>WVR_VREDRAW</c> values.
            </term>
            </item>
            <item>
            <term><c>WVR_VALIDRECTS</c> 0x0400</term>
            <term>
            This value indicates that, upon return from <c>WM_NCCALCSIZE</c>, the rectangles specified by the <c>rgrc</c>[1] and
            <c>rgrc</c>[2] members of the <c>NCCALCSIZE_PARAMS</c> structure contain valid destination and source area rectangles,
            respectively. The system combines these rectangles to calculate the area of the window to be preserved. The system copies any
            part of the window image that is within the source rectangle and clips the image to the destination rectangle. Both
            rectangles are in parent-relative or screen-relative coordinates. This flag cannot be combined with any other flags. This
            return value allows an application to implement more elaborate client-area preservation strategies, such as centering or
            preserving a subset of the client area.
            </term>
            </item>
            </list>
            <remarks>
            <para>
            The window may be redrawn, depending on whether the CS_HREDRAW or CS_VREDRAW class style is specified. This is the default,
            backward-compatible processing of this message by the <c>DefWindowProc</c> function (in addition to the usual client
            rectangle calculation described in the preceding table).
            </para>
            <para>
            When wParam is <c>TRUE</c>, simply returning 0 without processing the <c>NCCALCSIZE_PARAMS</c> rectangles will cause the
            client area to resize to the size of the window, including the window frame. This will remove the window frame and caption
            items from your window, leaving only the client area displayed.
            </para>
            <para>
            Starting with Windows Vista, removing the standard frame by simply returning 0 when the wParam is <c>TRUE</c> does not affect
            frames that are extended into the client area using the <c>DwmExtendFrameIntoClientArea</c> function. Only the standard frame
            will be removed.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCHITTEST">
            <summary>
            <para>
            Sent to a window in order to determine what part of the window corresponds to a particular screen coordinate. This can
            happen, for example, when the cursor moves, when a mouse button is pressed or released, or in response to a call to a
            function such as <c>WindowFromPoint</c>. If the mouse is not captured, the message is sent to the window beneath the cursor.
            Otherwise, the message is sent to the window that has captured the mouse.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCHITTEST 0x0084</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the x-coordinate of the cursor. The coordinate is relative to the upper-left corner of the screen.
            </para>
            <para>
            The high-order word specifies the y-coordinate of the cursor. The coordinate is relative to the upper-left corner of the screen.
            </para>
            <para><strong>Returns</strong></para>
            <para>
            The return value of the <c>DefWindowProc</c> function is one of the following values, indicating the position of the cursor
            hot spot.
            </para>
            <list type="table">
            <listheader>
            <term>Return code/value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term><c>HTBORDER</c> 18</term>
            <term>In the border of a window that does not have a sizing border.</term>
            </item>
            <item>
            <term><c>HTBOTTOM</c> 15</term>
            <term>In the lower-horizontal border of a resizable window (the user can click the mouse to resize the window vertically).</term>
            </item>
            <item>
            <term><c>HTBOTTOMLEFT</c> 16</term>
            <term>In the lower-left corner of a border of a resizable window (the user can click the mouse to resize the window diagonally).</term>
            </item>
            <item>
            <term><c>HTBOTTOMRIGHT</c> 17</term>
            <term>In the lower-right corner of a border of a resizable window (the user can click the mouse to resize the window diagonally).</term>
            </item>
            <item>
            <term><c>HTCAPTION</c> 2</term>
            <term>In a title bar.</term>
            </item>
            <item>
            <term><c>HTCLIENT</c> 1</term>
            <term>In a client area.</term>
            </item>
            <item>
            <term><c>HTCLOSE</c> 20</term>
            <term>In a <c>Close</c> button.</term>
            </item>
            <item>
            <term><c>HTERROR</c> -2</term>
            <term>
            On the screen background or on a dividing line between windows (same as <c>HTNOWHERE</c>, except that the
            <c>DefWindowProc</c> function produces a system beep to indicate an error).
            </term>
            </item>
            <item>
            <term><c>HTGROWBOX</c> 4</term>
            <term>In a size box (same as <c>HTSIZE</c>).</term>
            </item>
            <item>
            <term><c>HTHELP</c> 21</term>
            <term>In a <c>Help</c> button.</term>
            </item>
            <item>
            <term><c>HTHSCROLL</c> 6</term>
            <term>In a horizontal scroll bar.</term>
            </item>
            <item>
            <term><c>HTLEFT</c> 10</term>
            <term>In the left border of a resizable window (the user can click the mouse to resize the window horizontally).</term>
            </item>
            <item>
            <term><c>HTMENU</c> 5</term>
            <term>In a menu.</term>
            </item>
            <item>
            <term><c>HTMAXBUTTON</c> 9</term>
            <term>In a <c>Maximize</c> button.</term>
            </item>
            <item>
            <term><c>HTMINBUTTON</c> 8</term>
            <term>In a <c>Minimize</c> button.</term>
            </item>
            <item>
            <term><c>HTNOWHERE</c> 0</term>
            <term>On the screen background or on a dividing line between windows.</term>
            </item>
            <item>
            <term><c>HTREDUCE</c> 8</term>
            <term>In a <c>Minimize</c> button.</term>
            </item>
            <item>
            <term><c>HTRIGHT</c> 11</term>
            <term>In the right border of a resizable window (the user can click the mouse to resize the window horizontally).</term>
            </item>
            <item>
            <term><c>HTSIZE</c> 4</term>
            <term>In a size box (same as <c>HTGROWBOX</c>).</term>
            </item>
            <item>
            <term><c>HTSYSMENU</c> 3</term>
            <term>In a window menu or in a <c>Close</c> button in a child window.</term>
            </item>
            <item>
            <term><c>HTTOP</c> 12</term>
            <term>In the upper-horizontal border of a window.</term>
            </item>
            <item>
            <term><c>HTTOPLEFT</c> 13</term>
            <term>In the upper-left corner of a window border.</term>
            </item>
            <item>
            <term><c>HTTOPRIGHT</c> 14</term>
            <term>In the upper-right corner of a window border.</term>
            </item>
            <item>
            <term><c>HTTRANSPARENT</c> -1</term>
            <term>
            In a window currently covered by another window in the same thread (the message will be sent to underlying windows in the
            same thread until one of them returns a code that is not <c>HTTRANSPARENT</c>).
            </term>
            </item>
            <item>
            <term><c>HTVSCROLL</c> 7</term>
            <term>In the vertical scroll bar.</term>
            </item>
            <item>
            <term><c>HTZOOM</c> 9</term>
            <term>In a <c>Maximize</c> button.</term>
            </item>
            </list>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>
            <c>Windows Vista:</c> When creating custom frames that include the standard caption buttons, this message should first be
            passed to the <c>DwmDefWindowProc</c> function. This enables the Desktop Window Manager (DWM) to provide hit-testing for the
            captions buttons. If <c>DwmDefWindowProc</c> does not handle the message, further processing of <c>WM_NCHITTEST</c> may be needed.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCPAINT">
            <summary>
            <para>The <c>WM_NCPAINT</c> message is sent to a window when its frame must be painted.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the update region of the window. The update region is clipped to the window frame.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>An application returns zero if it processes this message.</para>
            <remarks>
            <para>The <c>DefWindowProc</c> function paints the window frame.</para>
            <para>
            An application can intercept the <c>WM_NCPAINT</c> message and paint its own custom window frame. The clipping region for a
            window is always rectangular, even if the shape of the frame is altered.
            </para>
            <para>The wParam value can be passed to <c>GetDCEx</c> as in the following example.</para>
            <para>
            <code>case WM_NCPAINT: { HDC hdc; hdc = GetDCEx(hwnd, (HRGN)wParam, DCX_WINDOW|DCX_INTERSECTRGN); // Paint into this DC ReleaseDC(hwnd, hdc); }</code>
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCACTIVATE">
            <summary>
            <para>Sent to a window when its nonclient area needs to be changed to indicate an active or inactive state.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCACTIVATE 0x0086</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            Indicates when a title bar or icon needs to be changed to indicate an active or inactive state. If an active title bar or
            icon is to be drawn, the wParam parameter is <c>TRUE</c>. If an inactive title bar or icon is to be drawn, wParam is <c>FALSE</c>.
            </para>
            <para><em>lParam</em></para>
            <para>When a visual style is active for this window, this parameter is not used.</para>
            <para>
            When a visual style is not active for this window, this parameter is a handle to an optional update region for the nonclient
            area of the window. If this parameter is set to -1, <c>DefWindowProc</c> does not repaint the nonclient area to reflect the
            state change.
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>
            When the wParam parameter is <c>FALSE</c>, an application should return <c>TRUE</c> to indicate that the system should
            proceed with the default processing, or it should return <c>FALSE</c> to prevent the change. When wParam is <c>TRUE</c>, the
            return value is ignored.
            </para>
            <remarks>
            <para>
            Processing messages related to the nonclient area of a standard window is not recommended, because the application must be
            able to draw all the required parts of the nonclient area for the window. If an application does process this message, it
            must return <c>TRUE</c> to direct the system to complete the change of active window. If the window is minimized when this
            message is received, the application should pass the message to the <c>DefWindowProc</c> function.
            </para>
            <para>
            The <c>DefWindowProc</c> function draws the title bar or icon title in its active colors when the wParam parameter is
            <c>TRUE</c> and in its inactive colors when wParam is <c>FALSE</c>.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_GETDLGCODE">
            <summary>
            <para>
            Sent to the window procedure associated with a control. By default, the system handles all keyboard input to the control; the
            system interprets certain types of keyboard input as dialog box navigation keys. To override this default behavior, the
            control can respond to the <c>WM_GETDLGCODE</c> message to indicate the types of input it wants to process itself.
            </para>
            <para>
            <code>#define WM_GETDLGCODE 0x0087</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The virtual key, pressed by the user, that prompted Windows to issue this notification. The handler must selectively handle
            these keys. For instance, the handler might accept and process <c>VK_RETURN</c> but delegate <c>VK_TAB</c> to the owner
            window. For a list of values, see <c>Virtual-Key Codes</c>.
            </para>
            <para><em>lParam</em></para>
            <para>A pointer to an <c>MSG</c> structure (or <c>NULL</c> if the system is performing a query).</para>
            <para><strong>Returns</strong></para>
            <para>The return value is one or more of the following values, indicating which type of input the application processes.</para>
            <list type="table">
            <listheader>
            <term>Return code/value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term><c>DLGC_BUTTON</c> 0x2000</term>
            <term>Button.</term>
            </item>
            <item>
            <term><c>DLGC_DEFPUSHBUTTON</c> 0x0010</term>
            <term>Default push button.</term>
            </item>
            <item>
            <term><c>DLGC_HASSETSEL</c> 0x0008</term>
            <term><c>EM_SETSEL</c> messages.</term>
            </item>
            <item>
            <term><c>DLGC_RADIOBUTTON</c> 0x0040</term>
            <term>Radio button.</term>
            </item>
            <item>
            <term><c>DLGC_STATIC</c> 0x0100</term>
            <term>Static control.</term>
            </item>
            <item>
            <term><c>DLGC_UNDEFPUSHBUTTON</c> 0x0020</term>
            <term>Non-default push button.</term>
            </item>
            <item>
            <term><c>DLGC_WANTALLKEYS</c> 0x0004</term>
            <term>All keyboard input.</term>
            </item>
            <item>
            <term><c>DLGC_WANTARROWS</c> 0x0001</term>
            <term>Direction keys.</term>
            </item>
            <item>
            <term><c>DLGC_WANTCHARS</c> 0x0080</term>
            <term><c>WM_CHAR</c> messages.</term>
            </item>
            <item>
            <term><c>DLGC_WANTMESSAGE</c> 0x0004</term>
            <term>All keyboard input (the application passes this message in the <c>MSG</c> structure to the control).</term>
            </item>
            <item>
            <term><c>DLGC_WANTTAB</c> 0x0002</term>
            <term>TAB key.</term>
            </item>
            </list>
            <remarks>
            <para>
            Although the <c>DefWindowProc</c> function always returns zero in response to the <c>WM_GETDLGCODE</c> message, the window
            procedure for the predefined control classes return a code appropriate for each class.
            </para>
            <para>
            The <c>WM_GETDLGCODE</c> message and the returned values are useful only with user-defined dialog box controls or standard
            controls modified by subclassing.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SYNCPAINT">
            <summary>
            <para>The <c>WM_SYNCPAINT</c> message is used to synchronize painting while avoiding linking independent GUI threads.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>An application returns zero if it processes this message.</para>
            <remarks>
            When a window has been hidden, shown, moved, or sized, the system may determine that it is necessary to send a
            <c>WM_SYNCPAINT</c> message to the top-level windows of other threads. Applications must pass <c>WM_SYNCPAINT</c> to
            <c>DefWindowProc</c> for processing. The <c>DefWindowProc</c> function will send a <c>WM_NCPAINT</c> message to the window
            procedure if the window frame must be painted and send a <c>WM_ERASEBKGND</c> message if the window background must be erased.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_UAHDESTROYWINDOW">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_UAHDRAWMENU">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_UAHDRAWMENUITEM">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_UAHINITMENU">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_UAHMEASUREMENUITEM">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_UAHNCPAINTMENUPOPUP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCMOUSEMOVE">
            <summary>
            <para>
            Posted to a window when the cursor is moved within the nonclient area of the window. This message is posted to the window
            that contains the cursor. If a window has captured the mouse, this message is not posted.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCMOUSEMOVE 0x00A0</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The hit-test value returned by the <c>DefWindowProc</c> function as a result of processing the <c>WM_NCHITTEST</c> message.
            For a list of hit-test values, see <c>WM_NCHITTEST</c>.
            </para>
            <para><em>lParam</em></para>
            <para>
            A <c>POINTS</c> structure that contains the x- and y-coordinates of the cursor. The coordinates are relative to the
            upper-left corner of the screen.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>If it is appropriate to do so, the system sends the <c>WM_SYSCOMMAND</c> message to the window.</para>
            <para>
            You can also use the <c>GET_X_LPARAM</c> and <c>GET_Y_LPARAM</c> macros to extract the values of the x- and y- coordinates
            from lParam.
            </para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCLBUTTONDOWN">
            <summary>
            <para>
            Posted when the user presses the left mouse button while the cursor is within the nonclient area of a window. This message is
            posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCLBUTTONDOWN 0x00A1</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The hit-test value returned by the <c>DefWindowProc</c> function as a result of processing the <c>WM_NCHITTEST</c> message.
            For a list of hit-test values, see <c>WM_NCHITTEST</c>.
            </para>
            <para><em>lParam</em></para>
            <para>
            A <c>POINTS</c> structure that contains the x- and y-coordinates of the cursor. The coordinates are relative to the
            upper-left corner of the screen.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            The <c>DefWindowProc</c> function tests the specified point to find the location of the cursor and performs the appropriate
            action. If appropriate, <c>DefWindowProc</c> sends the <c>WM_SYSCOMMAND</c> message to the window.
            </para>
            <para>
            You can also use the <c>GET_X_LPARAM</c> and <c>GET_Y_LPARAM</c> macros to extract the values of the x- and y- coordinates
            from lParam.
            </para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCLBUTTONUP">
            <summary>
            <para>
            Posted when the user releases the left mouse button while the cursor is within the nonclient area of a window. This message
            is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCLBUTTONUP 0x00A2</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The hit-test value returned by the <c>DefWindowProc</c> function as a result of processing the <c>WM_NCHITTEST</c> message.
            For a list of hit-test values, see <c>WM_NCHITTEST</c>.
            </para>
            <para><em>lParam</em></para>
            <para>
            A <c>POINTS</c> structure that contains the x- and y-coordinates of the cursor. The coordinates are relative to the
            upper-left corner of the screen.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            The <c>DefWindowProc</c> function tests the specified point to find out the location of the cursor and performs the
            appropriate action. If appropriate, <c>DefWindowProc</c> sends the <c>WM_SYSCOMMAND</c> message to the window.
            </para>
            <para>
            You can also use the <c>GET_X_LPARAM</c> and <c>GET_Y_LPARAM</c> macros to extract the values of the x- and y- coordinates
            from lParam.
            </para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>If it is appropriate to do so, the system sends the <c>WM_SYSCOMMAND</c> message to the window.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCLBUTTONDBLCLK">
            <summary>
            <para>
            Posted when the user double-clicks the left mouse button while the cursor is within the nonclient area of a window. This
            message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCLBUTTONDBLCLK 0x00A3</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The hit-test value returned by the <c>DefWindowProc</c> function as a result of processing the <c>WM_NCHITTEST</c> message.
            For a list of hit-test values, see <c>WM_NCHITTEST</c>.
            </para>
            <para><em>lParam</em></para>
            <para>
            A <c>POINTS</c> structure that contains the x- and y-coordinates of the cursor. The coordinates are relative to the
            upper-left corner of the screen.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            You can also use the <c>GET_X_LPARAM</c> and <c>GET_Y_LPARAM</c> macros to extract the values of the x- and y- coordinates
            from lParam.
            </para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>
            By default, the <c>DefWindowProc</c> function tests the specified point to find out the location of the cursor and performs
            the appropriate action. If appropriate, <c>DefWindowProc</c> sends the <c>WM_SYSCOMMAND</c> message to the window.
            </para>
            <para>A window need not have the <c>CS_DBLCLKS</c> style to receive <c>WM_NCLBUTTONDBLCLK</c> messages.</para>
            <para>
            The system generates a <c>WM_NCLBUTTONDBLCLK</c> message when the user presses, releases, and again presses the left mouse
            button within the system's double-click time limit. Double-clicking the left mouse button actually generates four messages:
            <c>WM_NCLBUTTONDOWN</c>, <c>WM_NCLBUTTONUP</c>, <c>WM_NCLBUTTONDBLCLK</c>, and <c>WM_NCLBUTTONUP</c> again.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCRBUTTONDOWN">
            <summary>
            <para>
            Posted when the user presses the right mouse button while the cursor is within the nonclient area of a window. This message
            is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCRBUTTONDOWN 0x00A4</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The hit-test value returned by the <c>DefWindowProc</c> function as a result of processing the <c>WM_NCHITTEST</c> message.
            For a list of hit-test values, see <c>WM_NCHITTEST</c>.
            </para>
            <para><em>lParam</em></para>
            <para>
            A <c>POINTS</c> structure that contains the x- and y-coordinates of the cursor. The coordinates are relative to the
            upper-left corner of the screen.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            You can also use the <c>GET_X_LPARAM</c> and <c>GET_Y_LPARAM</c> macros to extract the values of the x- and y- coordinates
            from lParam.
            </para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>If it is appropriate to do so, the system sends the <c>WM_SYSCOMMAND</c> message to the window.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCRBUTTONUP">
            <summary>
            <para>
            Posted when the user releases the right mouse button while the cursor is within the nonclient area of a window. This message
            is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCRBUTTONUP 0x00A5</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The hit-test value returned by the <c>DefWindowProc</c> function as a result of processing the <c>WM_NCHITTEST</c> message.
            For a list of hit-test values, see <c>WM_NCHITTEST</c>.
            </para>
            <para><em>lParam</em></para>
            <para>
            A <c>POINTS</c> structure that contains the x- and y-coordinates of the cursor. The coordinates are relative to the
            upper-left corner of the screen.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            You can also use the <c>GET_X_LPARAM</c> and <c>GET_Y_LPARAM</c> macros to extract the values of the x- and y- coordinates
            from lParam.
            </para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>If it is appropriate to do so, the system sends the <c>WM_SYSCOMMAND</c> message to the window.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCRBUTTONDBLCLK">
            <summary>
            <para>
            Posted when the user double-clicks the right mouse button while the cursor is within the nonclient area of a window. This
            message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCRBUTTONDBLCLK 0x00A6</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The hit-test value returned by the <c>DefWindowProc</c> function as a result of processing the <c>WM_NCHITTEST</c> message.
            For a list of hit-test values, see <c>WM_NCHITTEST</c>.
            </para>
            <para><em>lParam</em></para>
            <para>
            A <c>POINTS</c> structure that contains the x- and y-coordinates of the cursor. The coordinates are relative to the
            upper-left corner of the screen.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>A window need not have the <c>CS_DBLCLKS</c> style to receive <c>WM_NCRBUTTONDBLCLK</c> messages.</para>
            <para>
            The system generates a <c>WM_NCRBUTTONDBLCLK</c> message when the user presses, releases, and again presses the right mouse
            button within the system's double-click time limit. Double-clicking the right mouse button actually generates four messages:
            <c>WM_NCRBUTTONDOWN</c>, <c>WM_NCRBUTTONUP</c>, <c>WM_NCRBUTTONDBLCLK</c>, and <c>WM_NCRBUTTONUP</c> again.
            </para>
            <para>
            You can also use the <c>GET_X_LPARAM</c> and <c>GET_Y_LPARAM</c> macros to extract the values of the x- and y- coordinates
            from lParam.
            </para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>If it is appropriate to do so, the system sends the <c>WM_SYSCOMMAND</c> message to the window.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCMBUTTONDOWN">
            <summary>
            <para>
            Posted when the user presses the middle mouse button while the cursor is within the nonclient area of a window. This message
            is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCMBUTTONDOWN 0x00A7</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The hit-test value returned by the <c>DefWindowProc</c> function as a result of processing the <c>WM_NCHITTEST</c> message.
            For a list of hit-test values, see <c>WM_NCHITTEST</c>.
            </para>
            <para><em>lParam</em></para>
            <para>
            A <c>POINTS</c> structure that contains the x- and y-coordinates of the cursor. The coordinates are relative to the
            upper-left corner of the screen.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            You can also use the <c>GET_X_LPARAM</c> and <c>GET_Y_LPARAM</c> macros to extract the values of the x- and y- coordinates
            from lParam.
            </para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>If it is appropriate to do so, the system sends the <c>WM_SYSCOMMAND</c> message to the window.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCMBUTTONUP">
            <summary>
            <para>
            Posted when the user releases the middle mouse button while the cursor is within the nonclient area of a window. This message
            is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCMBUTTONUP 0x00A8</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The hit-test value returned by the <c>DefWindowProc</c> function as a result of processing the <c>WM_NCHITTEST</c> message.
            For a list of hit-test values, see <c>WM_NCHITTEST</c>.
            </para>
            <para><em>lParam</em></para>
            <para>
            A <c>POINTS</c> structure that contains the x- and y-coordinates of the cursor. The coordinates are relative to the
            upper-left corner of the screen.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            You can also use the <c>GET_X_LPARAM</c> and <c>GET_Y_LPARAM</c> macros to extract the values of the x- and y- coordinates
            from lParam.
            </para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>If it is appropriate to do so, the system sends the <c>WM_SYSCOMMAND</c> message to the window.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCMBUTTONDBLCLK">
            <summary>
            <para>
            Posted when the user double-clicks the middle mouse button while the cursor is within the nonclient area of a window. This
            message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCMBUTTONDBLCLK 0x00A9</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The hit-test value returned by the <c>DefWindowProc</c> function as a result of processing the <c>WM_NCHITTEST</c> message.
            For a list of hit-test values, see <c>WM_NCHITTEST</c>.
            </para>
            <para><em>lParam</em></para>
            <para>
            A <c>POINTS</c> structure that contains the x- and y-coordinates of the cursor. The coordinates are relative to the
            upper-left corner of the screen.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>A window need not have the <c>CS_DBLCLKS</c> style to receive <c>WM_NCMBUTTONDBLCLK</c> messages.</para>
            <para>
            The system generates a <c>WM_NCMBUTTONDBLCLK</c> message when the user presses, releases, and again presses the middle mouse
            button within the system's double-click time limit. Double-clicking the middle mouse button actually generates four messages:
            <c>WM_NCMBUTTONDOWN</c>, <c>WM_NCMBUTTONUP</c>, <c>WM_NCMBUTTONDBLCLK</c>, and <c>WM_NCMBUTTONUP</c> again.
            </para>
            <para>
            You can also use the <c>GET_X_LPARAM</c> and <c>GET_Y_LPARAM</c> macros to extract the values of the x- and y- coordinates
            from lParam.
            </para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>If it is appropriate to do so, the system sends the <c>WM_SYSCOMMAND</c> message to the window.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCXBUTTONDOWN">
            <summary>
            <para>
            Posted when the user presses the first or second X button while the cursor is in the nonclient area of a window. This message
            is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCXBUTTONDOWN 0x00AB</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The low-order word specifies the hit-test value returned by the <c>DefWindowProc</c> function from processing the
            <c>WM_NCHITTEST</c> message. For a list of hit-test values, see <c>WM_NCHITTEST</c>. The high-order word indicates which
            button was pressed. It can be one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>XBUTTON1</c> 0x0001</term>
            <term>The first X button was pressed.</term>
            </item>
            <item>
            <term><c>XBUTTON2</c> 0x0002</term>
            <term>The second X button was pressed.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            A pointer to a <c>POINTS</c> structure that contains the x- and y-coordinates of the cursor. The coordinates are relative to
            the upper-left corner of the screen.
            </para>
            <para><strong>Returns</strong></para>
            <para>
            If an application processes this message, it should return <c>TRUE</c>. For more information about processing the return
            value, see the Remarks section.
            </para>
            <remarks>
            <para>Use the following code to get the information in the wParam parameter.</para>
            <para>
            <code>nHittest = GET_NCHITTEST_WPARAM(wParam); fwButton = GET_XBUTTON_WPARAM(wParam);</code>
            </para>
            <para>You can also use the following code to get the x- and y-coordinates from lParam:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>
            By default, the <c>DefWindowProc</c> function tests the specified point to get the position of the cursor and performs the
            appropriate action. If appropriate, it sends the <c>WM_SYSCOMMAND</c> message to the window.
            </para>
            <para>
            Unlike the <c>WM_NCLBUTTONDOWN</c>, <c>WM_NCMBUTTONDOWN</c>, and <c>WM_NCRBUTTONDOWN</c> messages, an application should
            return <c>TRUE</c> from this message if it processes it. Doing so will allow software that simulates this message on Windows
            systems earlier than Windows 2000 to determine whether the window procedure processed the message or called
            <c>DefWindowProc</c> to process it.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCXBUTTONUP">
            <summary>
            <para>
            Posted when the user releases the first or second X button while the cursor is in the nonclient area of a window. This
            message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCXBUTTONUP 0x00AC</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The low-order word specifies the hit-test value returned by the <c>DefWindowProc</c> function from processing the
            <c>WM_NCHITTEST</c> message. For a list of hit-test values, see <c>WM_NCHITTEST</c>.
            </para>
            <para>The high-order word indicates which button was released. It can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>XBUTTON1</c> 0x0001</term>
            <term>The first X button was released.</term>
            </item>
            <item>
            <term><c>XBUTTON2</c> 0x0002</term>
            <term>The second X button was released.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            A pointer to a <c>POINTS</c> structure that contains the x- and y-coordinates of the cursor. The coordinates are relative to
            the upper-left corner of the screen.
            </para>
            <para><strong>Returns</strong></para>
            <para>
            If an application processes this message, it should return <c>TRUE</c>. For more information about processing the return
            value, see the Remarks section.
            </para>
            <remarks>
            <para>Use the following code to get the information in the wParam parameter.</para>
            <para>
            <code>nHittest = GET_NCHITTEST_WPARAM(wParam); fwButton = GET_XBUTTON_WPARAM(wParam);</code>
            </para>
            <para>You can also use the following code to get the x- and y-coordinates from lParam:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>
            By default, the <c>DefWindowProc</c> function tests the specified point to get the position of the cursor and performs the
            appropriate action. If appropriate, it sends the <c>WM_SYSCOMMAND</c> message to the window.
            </para>
            <para>
            Unlike the <c>WM_NCLBUTTONUP</c>, <c>WM_NCMBUTTONUP</c>, and <c>WM_NCRBUTTONUP</c> messages, an application should return
            <c>TRUE</c> from this message if it processes it. Doing so will allow software that simulates this message on Windows systems
            earlier than Windows 2000 to determine whether the window procedure processed the message or called <c>DefWindowProc</c> to
            process it.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCXBUTTONDBLCLK">
            <summary>
            <para>
            Posted when the user double-clicks the first or second X button while the cursor is in the nonclient area of a window. This
            message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCXBUTTONDBLCLK 0x00AD</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The low-order word specifies the hit-test value returned by the <c>DefWindowProc</c> function from processing the
            <c>WM_NCHITTEST</c> message. For a list of hit-test values, see <c>WM_NCHITTEST</c>.
            </para>
            <para>The high-order word indicates which button was double-clicked. It can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>XBUTTON1</c> 0x0001</term>
            <term>The first X button was double-clicked..</term>
            </item>
            <item>
            <term><c>XBUTTON2</c> 0x0002</term>
            <term>The second X button was double-clicked.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            A pointer to a <c>POINTS</c> structure that contains the x- and y-coordinates of the cursor. The coordinates are relative to
            the upper-left corner of the screen.
            </para>
            <para><strong>Returns</strong></para>
            <para>
            If an application processes this message, it should return <c>TRUE</c>. For more information about processing the return
            value, see the Remarks section.
            </para>
            <remarks>
            <para>Use the following code to get the information in the wParam parameter.</para>
            <para>
            <code>nHittest = GET_NCHITTEST_WPARAM(wParam); fwButton = GET_XBUTTON_WPARAM(wParam);</code>
            </para>
            <para>You can also use the following code to get the x- and y-coordinates from lParam:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>
            By default, the <c>DefWindowProc</c> function tests the specified point to get the position of the cursor and performs the
            appropriate action. If appropriate, it sends the <c>WM_SYSCOMMAND</c> message to the window.
            </para>
            <para>
            A window need not have the <c>CS_DBLCLKS</c> style to receive <c>WM_NCXBUTTONDBLCLK</c> messages. The system generates a
            <c>WM_NCXBUTTONDBLCLK</c> message when the user presses, releases, and again presses an X button within the system's
            double-click time limit. Double-clicking one of these buttons actually generates four messages: <c>WM_NCXBUTTONDOWN</c>,
            <c>WM_NCXBUTTONUP</c>, <c>WM_NCXBUTTONDBLCLK</c>, and <c>WM_NCXBUTTONUP</c> again.
            </para>
            <para>
            Unlike the <c>WM_NCLBUTTONDBLCLK</c>, <c>WM_NCMBUTTONDBLCLK</c>, and <c>WM_NCRBUTTONDBLCLK</c> messages, an application
            should return <c>TRUE</c> from this message if it processes it. Doing so will allow software that simulates this message on
            Windows systems earlier than Windows 2000 to determine whether the window procedure processed the message or called
            <c>DefWindowProc</c> to process it.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_BM_CLICK">
            <summary>
            Simulates the user clicking a button. This message causes the button to receive the <c>WM_LBUTTONDOWN</c> and
            <c>WM_LBUTTONUP</c> messages, and the button's parent window to receive a BN_CLICKED notification code.
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Not used; must be zero.</para>
            <para><em>lParam</em></para>
            <para>Not used; must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>This message does not return a value.</para>
            <remarks>
            If the button is in a dialog box and the dialog box is not active, the <c>BM_CLICK</c> message might fail. To ensure success
            in this situation, call the <c>SetActiveWindow</c> function to activate the dialog box before sending the <c>BM_CLICK</c>
            message to the button.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_INPUT_DEVICE_CHANGE">
            <summary>
            <para>Sent to the window that registered to receive raw input.</para>
            <para>
            Raw input notifications are available only after the application calls RegisterRawInputDevices with RIDEV_DEVNOTIFY flag.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_INPUT_DEVICE_CHANGE 0x00FE</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Type: <c>WPARAM</c></para>
            <para>This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>GIDC_ARRIVAL</c> 1</term>
            <term>
            A new device has been added to the system. You can call GetRawInputDeviceInfo to get more information regarding the device.
            </term>
            </item>
            <item>
            <term><c>GIDC_REMOVAL</c> 2</term>
            <term>A device has been removed from the system.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>Type: <c>LPARAM</c></para>
            <para>The <c>HANDLE</c> to the raw input device.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_INPUT">
            <summary>
            <para>Sent to the window that is getting raw input.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_INPUT 0x00FF</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The input code. Use <c>GET_RAWINPUT_CODE_WPARAM</c> macro to get the value.</para>
            <para>Can be one of the following values:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>RIM_INPUT</c> 0</term>
            <term>
            Input occurred while the application was in the foreground. The application must call <c>DefWindowProc</c> so the system can
            perform cleanup.
            </term>
            </item>
            <item>
            <term><c>RIM_INPUTSINK</c> 1</term>
            <term>Input occurred while the application was not in the foreground.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            A <c>HRAWINPUT</c> handle to the <c>RAWINPUT</c> structure that contains the raw input from the device. To get the raw data,
            use this handle in the call to <c>GetRawInputData</c>.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>Raw input is available only when the application calls <c>RegisterRawInputDevices</c> with valid device specifications.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_KEYFIRST">
            <summary>
            <para>
            Posted to the window with the keyboard focus when a nonsystem key is pressed. A nonsystem key is a key that is pressed when
            the ALT key is not pressed.
            </para>
            <para>
            <code>#define WM_KEYDOWN 0x0100</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The virtual-key code of the nonsystem key. See Virtual-Key Codes.</para>
            <para><em>lParam</em></para>
            <para>
            The repeat count, scan code, extended-key flag, context code, previous key-state flag, and transition-state flag, as shown following.
            </para>
            <list type="table">
            <listheader>
            <term>Bits</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0-15</term>
            <term>
            The repeat count for the current message. The value is the number of times the keystroke is autorepeated as a result of the
            user holding down the key. If the keystroke is held long enough, multiple messages are sent. However, the repeat count is not cumulative.
            </term>
            </item>
            <item>
            <term>16-23</term>
            <term>The scan code. The value depends on the OEM.</term>
            </item>
            <item>
            <term>24</term>
            <term>
            Indicates whether the key is an extended key, such as the right-hand ALT and CTRL keys that appear on an enhanced 101- or
            102-key keyboard. The value is 1 if it is an extended key; otherwise, it is 0.
            </term>
            </item>
            <item>
            <term>25-28</term>
            <term>Reserved; do not use.</term>
            </item>
            <item>
            <term>29</term>
            <term>The context code. The value is always 0 for a <c>WM_KEYDOWN</c> message.</term>
            </item>
            <item>
            <term>30</term>
            <term>The previous key state. The value is 1 if the key is down before the message is sent, or it is zero if the key is up.</term>
            </item>
            <item>
            <term>31</term>
            <term>The transition state. The value is always 0 for a <c>WM_KEYDOWN</c> message.</term>
            </item>
            </list>
            <para>For more detail, see Keystroke Message Flags.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            <para>
            If the F10 key is pressed, the <c>DefWindowProc</c> function sets an internal flag. When <c>DefWindowProc</c> receives the
            <c>WM_KEYUP</c> message, the function checks whether the internal flag is set and, if so, sends a <c>WM_SYSCOMMAND</c>
            message to the top-level window. The <c>WM_SYSCOMMAND</c> parameter of the message is set to SC_KEYMENU.
            </para>
            <para>
            Because of the autorepeat feature, more than one <c>WM_KEYDOWN</c> message may be posted before a <c>WM_KEYUP</c> message is
            posted. The previous key state (bit 30) can be used to determine whether the <c>WM_KEYDOWN</c> message indicates the first
            down transition or a repeated down transition.
            </para>
            <para>
            For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard;
            the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide
            (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the lParam parameter.
            </para>
            <para>Applications must pass wParam to <c>TranslateMessage</c> without altering it at all.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_KEYDOWN">
            <summary>
            <para>
            Posted to the window with the keyboard focus when a nonsystem key is pressed. A nonsystem key is a key that is pressed when
            the ALT key is not pressed.
            </para>
            <para>
            <code>#define WM_KEYDOWN 0x0100</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The virtual-key code of the nonsystem key. See Virtual-Key Codes.</para>
            <para><em>lParam</em></para>
            <para>
            The repeat count, scan code, extended-key flag, context code, previous key-state flag, and transition-state flag, as shown following.
            </para>
            <list type="table">
            <listheader>
            <term>Bits</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0-15</term>
            <term>
            The repeat count for the current message. The value is the number of times the keystroke is autorepeated as a result of the
            user holding down the key. If the keystroke is held long enough, multiple messages are sent. However, the repeat count is not cumulative.
            </term>
            </item>
            <item>
            <term>16-23</term>
            <term>The scan code. The value depends on the OEM.</term>
            </item>
            <item>
            <term>24</term>
            <term>
            Indicates whether the key is an extended key, such as the right-hand ALT and CTRL keys that appear on an enhanced 101- or
            102-key keyboard. The value is 1 if it is an extended key; otherwise, it is 0.
            </term>
            </item>
            <item>
            <term>25-28</term>
            <term>Reserved; do not use.</term>
            </item>
            <item>
            <term>29</term>
            <term>The context code. The value is always 0 for a <c>WM_KEYDOWN</c> message.</term>
            </item>
            <item>
            <term>30</term>
            <term>The previous key state. The value is 1 if the key is down before the message is sent, or it is zero if the key is up.</term>
            </item>
            <item>
            <term>31</term>
            <term>The transition state. The value is always 0 for a <c>WM_KEYDOWN</c> message.</term>
            </item>
            </list>
            <para>For more detail, see Keystroke Message Flags.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            <para>
            If the F10 key is pressed, the <c>DefWindowProc</c> function sets an internal flag. When <c>DefWindowProc</c> receives the
            <c>WM_KEYUP</c> message, the function checks whether the internal flag is set and, if so, sends a <c>WM_SYSCOMMAND</c>
            message to the top-level window. The <c>WM_SYSCOMMAND</c> parameter of the message is set to SC_KEYMENU.
            </para>
            <para>
            Because of the autorepeat feature, more than one <c>WM_KEYDOWN</c> message may be posted before a <c>WM_KEYUP</c> message is
            posted. The previous key state (bit 30) can be used to determine whether the <c>WM_KEYDOWN</c> message indicates the first
            down transition or a repeated down transition.
            </para>
            <para>
            For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard;
            the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide
            (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the lParam parameter.
            </para>
            <para>Applications must pass wParam to <c>TranslateMessage</c> without altering it at all.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_KEYUP">
            <summary>
            <para>
            Posted to the window with the keyboard focus when a nonsystem key is released. A nonsystem key is a key that is pressed when
            the ALT key is not pressed, or a keyboard key that is pressed when a window has the keyboard focus.
            </para>
            <para>
            <code>#define WM_KEYUP 0x0101</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The virtual-key code of the nonsystem key. See Virtual-Key Codes.</para>
            <para><em>lParam</em></para>
            <para>
            The repeat count, scan code, extended-key flag, context code, previous key-state flag, and transition-state flag, as shown in
            the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Bits</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0-15</term>
            <term>
            The repeat count for the current message. The value is the number of times the keystroke is autorepeated as a result of the
            user holding down the key. The repeat count is always 1 for a <c>WM_KEYUP</c> message.
            </term>
            </item>
            <item>
            <term>16-23</term>
            <term>The scan code. The value depends on the OEM.</term>
            </item>
            <item>
            <term>24</term>
            <term>
            Indicates whether the key is an extended key, such as the right-hand ALT and CTRL keys that appear on an enhanced 101- or
            102-key keyboard. The value is 1 if it is an extended key; otherwise, it is 0.
            </term>
            </item>
            <item>
            <term>25-28</term>
            <term>Reserved; do not use.</term>
            </item>
            <item>
            <term>29</term>
            <term>The context code. The value is always 0 for a <c>WM_KEYUP</c> message.</term>
            </item>
            <item>
            <term>30</term>
            <term>The previous key state. The value is always 1 for a <c>WM_KEYUP</c> message.</term>
            </item>
            <item>
            <term>31</term>
            <term>The transition state. The value is always 1 for a <c>WM_KEYUP</c> message.</term>
            </item>
            </list>
            <para>For more detail, see Keystroke Message Flags.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            <para>
            The <c>DefWindowProc</c> function sends a <c>WM_SYSCOMMAND</c> message to the top-level window if the F10 key or the ALT key
            was released. The wParam parameter of the message is set to SC_KEYMENU.
            </para>
            <para>
            For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard;
            the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide
            (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the lParam parameter.
            </para>
            <para>Applications must pass wParam to <c>TranslateMessage</c> without altering it at all.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CHAR">
            <summary>
            <para>
            Posted to the window with the keyboard focus when a <c>WM_KEYDOWN</c> message is translated by the <c>TranslateMessage</c>
            function. The <c>WM_CHAR</c> message contains the character code of the key that was pressed.
            </para>
            <para>
            <code>#define WM_CHAR 0x0102</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The character code of the key.</para>
            <para><em>lParam</em></para>
            <para>
            The repeat count, scan code, extended-key flag, context code, previous key-state flag, and transition-state flag, as shown in
            the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Bits</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0-15</term>
            <term>
            The repeat count for the current message. The value is the number of times the keystroke is autorepeated as a result of the
            user holding down the key. If the keystroke is held long enough, multiple messages are sent. However, the repeat count is not cumulative.
            </term>
            </item>
            <item>
            <term>16-23</term>
            <term>The scan code. The value depends on the OEM.</term>
            </item>
            <item>
            <term>24</term>
            <term>
            Indicates whether the key is an extended key, such as the right-hand ALT and CTRL keys that appear on an enhanced 101- or
            102-key keyboard. The value is 1 if it is an extended key; otherwise, it is 0.
            </term>
            </item>
            <item>
            <term>25-28</term>
            <term>Reserved; do not use.</term>
            </item>
            <item>
            <term>29</term>
            <term>The context code. The value is 1 if the ALT key is held down while the key is pressed; otherwise, the value is 0.</term>
            </item>
            <item>
            <term>30</term>
            <term>The previous key state. The value is 1 if the key is down before the message is sent, or it is 0 if the key is up.</term>
            </item>
            <item>
            <term>31</term>
            <term>The transition state. The value is 1 if the key is being released, or it is 0 if the key is being pressed.</term>
            </item>
            </list>
            <para>For more detail, see Keystroke Message Flags.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            <para>The <c>WM_CHAR</c> message uses Unicode Transformation Format (UTF)-16.</para>
            <para>
            There is not necessarily a one-to-one correspondence between keys pressed and character messages generated, and so the
            information in the high-order word of the lParam parameter is generally not useful to applications. The information in the
            high-order word applies only to the most recent <c>WM_KEYDOWN</c> message that precedes the posting of the <c>WM_CHAR</c> message.
            </para>
            <para>
            For enhanced 101- and 102-key keyboards, extended keys are the right ALT and the right CTRL keys on the main section of the
            keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; and
            the divide (/) and ENTER keys in the numeric keypad. Some other keyboards may support the extended-key bit in the lParam parameter.
            </para>
            <para>
            The <c>WM_UNICHAR</c> message is the same as <c>WM_CHAR</c>, except it uses UTF-32. It is designed to send or post Unicode
            characters to ANSI windows, and it can handle Unicode Supplementary Plane characters.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_DEADCHAR">
            <summary>
            <para>
            Posted to the window with the keyboard focus when a <c>WM_KEYUP</c> message is translated by the <c>TranslateMessage</c>
            function. <c>WM_DEADCHAR</c> specifies a character code generated by a dead key. A dead key is a key that generates a
            character, such as the umlaut (double-dot), that is combined with another character to form a composite character. For
            example, the umlaut-O character ( ) is generated by typing the dead key for the umlaut character, and then typing the O key.
            </para>
            <para>
            <code>#define WM_DEADCHAR 0x0103</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The character code generated by the dead key.</para>
            <para><em>lParam</em></para>
            <para>
            The repeat count, scan code, extended-key flag, context code, previous key-state flag, and transition-state flag, as shown in
            the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Bits</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0-15</term>
            <term>
            The repeat count for the current message. The value is the number of times the keystroke is autorepeated as a result of the
            user holding down the key. If the keystroke is held long enough, multiple messages are sent. However, the repeat count is not cumulative.
            </term>
            </item>
            <item>
            <term>16-23</term>
            <term>The scan code. The value depends on the OEM.</term>
            </item>
            <item>
            <term>24</term>
            <term>
            Indicates whether the key is an extended key, such as the right-hand ALT and CTRL keys that appear on an enhanced 101- or
            102-key keyboard. The value is 1 if it is an extended key; otherwise, it is 0.
            </term>
            </item>
            <item>
            <term>25-28</term>
            <term>Reserved; do not use.</term>
            </item>
            <item>
            <term>29</term>
            <term>The context code. The value is 1 if the ALT key is held down while the key is pressed; otherwise, the value is 0.</term>
            </item>
            <item>
            <term>30</term>
            <term>The previous key state. The value is 1 if the key is down before the message is sent, or it is 0 if the key is up.</term>
            </item>
            <item>
            <term>31</term>
            <term>The transition state. The value is 1 if the key is being released, or it is 0 if the key is being pressed.</term>
            </item>
            </list>
            <para>For more detail, see Keystroke Message Flags.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            <para>
            The <c>WM_DEADCHAR</c> message typically is used by applications to give the user feedback about each key pressed. For
            example, an application can display the accent in the current character position without moving the caret.
            </para>
            <para>
            Because there is not necessarily a one-to-one correspondence between keys pressed and character messages generated, the
            information in the high-order word of the lParam parameter is generally not useful to applications. The information in the
            high-order word applies only to the most recent <c>WM_KEYDOWN</c> message that precedes the posting of the <c>WM_DEADCHAR</c> message.
            </para>
            <para>
            For enhanced 101- and 102-key keyboards, extended keys are the right ALT and the right CTRL keys on the main section of the
            keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; and
            the divide (/) and ENTER keys in the numeric keypad. Some other keyboards may support the extended-key bit in the lParam parameter.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SYSKEYDOWN">
            <summary>
            <para>
            Posted to the window with the keyboard focus when the user presses the F10 key (which activates the menu bar) or holds down
            the ALT key and then presses another key. It also occurs when no window currently has the keyboard focus; in this case, the
            <c>WM_SYSKEYDOWN</c> message is sent to the active window. The window that receives the message can distinguish between these
            two contexts by checking the context code in the lParam parameter.
            </para>
            <para>
            <code>#define WM_SYSKEYDOWN 0x0104</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The virtual-key code of the key being pressed. See <c>Virtual-Key Codes</c>.</para>
            <para><em>lParam</em></para>
            <para>
            The repeat count, scan code, extended-key flag, context code, previous key-state flag, and transition-state flag, as shown in
            the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Bits</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0-15</term>
            <term>
            The repeat count for the current message. The value is the number of times the keystroke is autorepeated as a result of the
            user holding down the key. If the keystroke is held long enough, multiple messages are sent. However, the repeat count is not cumulative.
            </term>
            </item>
            <item>
            <term>16-23</term>
            <term>The scan code. The value depends on the OEM.</term>
            </item>
            <item>
            <term>24</term>
            <term>
            Indicates whether the key is an extended key, such as the right-hand ALT and CTRL keys that appear on an enhanced 101- or
            102-key keyboard. The value is 1 if it is an extended key; otherwise, it is 0.
            </term>
            </item>
            <item>
            <term>25-28</term>
            <term>Reserved; do not use.</term>
            </item>
            <item>
            <term>29</term>
            <term>
            The context code. The value is 1 if the ALT key is down while the key is pressed; it is 0 if the <c>WM_SYSKEYDOWN</c> message
            is posted to the active window because no window has the keyboard focus.
            </term>
            </item>
            <item>
            <term>30</term>
            <term>The previous key state. The value is 1 if the key is down before the message is sent, or it is 0 if the key is up.</term>
            </item>
            <item>
            <term>31</term>
            <term>The transition state. The value is always 0 for a <c>WM_SYSKEYDOWN</c> message.</term>
            </item>
            </list>
            <para>For more detail, see Keystroke Message Flags.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            <para>
            The <c>DefWindowProc</c> function examines the specified key and generates a <c>WM_SYSCOMMAND</c> message if the key is
            either TAB or ENTER.
            </para>
            <para>
            When the context code is zero, the message can be passed to the <c>TranslateAccelerator</c> function, which will handle it as
            though it were a normal key message instead of a character-key message. This allows accelerator keys to be used with the
            active window even if the active window does not have the keyboard focus.
            </para>
            <para>
            Because of automatic repeat, more than one <c>WM_SYSKEYDOWN</c> message may occur before a <c>WM_SYSKEYUP</c> message is
            sent. The previous key state (bit 30) can be used to determine whether the <c>WM_SYSKEYDOWN</c> message indicates the first
            down transition or a repeated down transition.
            </para>
            <para>
            For enhanced 101- and 102-key keyboards, enhanced keys are the right ALT and CTRL keys on the main section of the keyboard;
            the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide
            (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the lParam parameter.
            </para>
            <para>This message is also sent whenever the user presses the F10 key without the ALT key.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SYSKEYUP">
            <summary>
            <para>
            Posted to the window with the keyboard focus when the user releases a key that was pressed while the ALT key was held down.
            It also occurs when no window currently has the keyboard focus; in this case, the <c>WM_SYSKEYUP</c> message is sent to the
            active window. The window that receives the message can distinguish between these two contexts by checking the context code
            in the lParam parameter.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_SYSKEYUP 0x0105</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The virtual-key code of the key being released. See <c>Virtual-Key Codes</c>.</para>
            <para><em>lParam</em></para>
            <para>
            The repeat count, scan code, extended-key flag, context code, previous key-state flag, and transition-state flag, as shown in
            the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Bits</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0-15</term>
            <term>
            The repeat count for the current message. The value is the number of times the keystroke is autorepeated as a result of the
            user holding down the key. The repeat count is always one for a <c>WM_SYSKEYUP</c> message.
            </term>
            </item>
            <item>
            <term>16-23</term>
            <term>The scan code. The value depends on the OEM.</term>
            </item>
            <item>
            <term>24</term>
            <term>
            Indicates whether the key is an extended key, such as the right-hand ALT and CTRL keys that appear on an enhanced 101- or
            102-key keyboard. The value is 1 if it is an extended key; otherwise, it is zero.
            </term>
            </item>
            <item>
            <term>25-28</term>
            <term>Reserved; do not use.</term>
            </item>
            <item>
            <term>29</term>
            <term>
            The context code. The value is 1 if the ALT key is down while the key is released; it is zero if the <c>WM_SYSKEYUP</c>
            message is posted to the active window because no window has the keyboard focus.
            </term>
            </item>
            <item>
            <term>30</term>
            <term>The previous key state. The value is always 1 for a <c>WM_SYSKEYUP</c> message.</term>
            </item>
            <item>
            <term>31</term>
            <term>The transition state. The value is always 1 for a <c>WM_SYSKEYUP</c> message.</term>
            </item>
            </list>
            <para>For more details, see Keystroke Message Flags.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            <para>
            The <c>DefWindowProc</c> function sends a <c>WM_SYSCOMMAND</c> message to the top-level window if the F10 key or the ALT key
            was released. The wParam parameter of the message is set to <c>SC_KEYMENU</c>.
            </para>
            <para>
            When the context code is zero, the message can be passed to the <c>TranslateAccelerator</c> function, which will handle it as
            though it were a normal key message instead of a character-key message. This allows accelerator keys to be used with the
            active window even if the active window does not have the keyboard focus.
            </para>
            <para>
            For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard;
            the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide
            (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the lParam parameter.
            </para>
            <para>
            For non-U.S. enhanced 102-key keyboards, the right ALT key is handled as a CTRL+ALT key. The following table shows the
            sequence of messages that result when the user presses and releases this key.
            </para>
            <list type="table">
            <listheader>
            <term>Message</term>
            <term>Virtual-key code</term>
            </listheader>
            <item>
            <term><c>WM_KEYDOWN</c></term>
            <term><c>VK_CONTROL</c></term>
            </item>
            <item>
            <term><c>WM_KEYDOWN</c></term>
            <term><c>VK_MENU</c></term>
            </item>
            <item>
            <term><c>WM_KEYUP</c></term>
            <term><c>VK_CONTROL</c></term>
            </item>
            <item>
            <term><c>WM_SYSKEYUP</c></term>
            <term><c>VK_MENU</c></term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SYSCHAR">
            <summary>
            <para>
            Posted to the window with the keyboard focus when a <c>WM_SYSKEYDOWN</c> message is translated by the <c>TranslateMessage</c>
            function. It specifies the character code of a system character key that is, a character key that is pressed while the ALT
            key is down.
            </para>
            <para>
            <code>#define WM_SYSCHAR 0x0106</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The character code of the window menu key.</para>
            <para><em>lParam</em></para>
            <para>
            The repeat count, scan code, extended-key flag, context code, previous key-state flag, and transition-state flag, as shown in
            the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Bits</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0 15</term>
            <term>
            The repeat count for the current message. The value is the number of times the keystroke was auto-repeated as a result of the
            user holding down the key. If the keystroke is held long enough, multiple messages are sent. However, the repeat count is not cumulative.
            </term>
            </item>
            <item>
            <term>16 23</term>
            <term>The scan code. The value depends on the original equipment manufacturer (OEM).</term>
            </item>
            <item>
            <term>24</term>
            <term>
            Indicates whether the key is an extended key, such as the right-hand ALT and CTRL keys that appear on an enhanced 101- or
            102-key keyboard. The value is 1 if it is an extended key; otherwise, it is 0.
            </term>
            </item>
            <item>
            <term>25 28</term>
            <term>Reserved; do not use.</term>
            </item>
            <item>
            <term>29</term>
            <term>The context code. The value is 1 if the ALT key is held down while the key is pressed; otherwise, the value is 0.</term>
            </item>
            <item>
            <term>30</term>
            <term>The previous key state. The value is 1 if the key is down before the message is sent, or it is 0 if the key is up.</term>
            </item>
            <item>
            <term>31</term>
            <term>The transition state. The value is 1 if the key is being released, or it is 0 if the key is being pressed.</term>
            </item>
            </list>
            <para>For more detail, see Keystroke Message Flags.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            <para>
            When the context code is zero, the message can be passed to the <c>TranslateAccelerator</c> function, which will handle it as
            though it were a standard key message instead of a system character-key message. This allows accelerator keys to be used with
            the active window even if the active window does not have the keyboard focus.
            </para>
            <para>
            For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard;
            the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; the PRINT SCRN
            key; the BREAK key; the NUMLOCK key; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the
            extended-key bit in the parameter.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SYSDEADCHAR">
            <summary>
            <para>
            Sent to the window with the keyboard focus when a <c>WM_SYSKEYDOWN</c> message is translated by the <c>TranslateMessage</c>
            function. <c>WM_SYSDEADCHAR</c> specifies the character code of a system dead key that is, a dead key that is pressed while
            holding down the ALT key.
            </para>
            <para>
            <code>#define WM_SYSDEADCHAR 0x0107</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The character code generated by the system dead key that is, a dead key that is pressed while holding down the ALT key.
            </para>
            <para><em>lParam</em></para>
            <para>
            The repeat count, scan code, extended-key flag, context code, previous key-state flag, and transition-state flag, as shown in
            the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Bits</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0-15</term>
            <term>
            The repeat count for the current message. The value is the number of times the keystroke is autorepeated as a result of the
            user holding down the key. If the keystroke is held long enough, multiple messages are sent. However, the repeat count is not cumulative.
            </term>
            </item>
            <item>
            <term>16-23</term>
            <term>The scan code. The value depends on the OEM.</term>
            </item>
            <item>
            <term>24</term>
            <term>
            Indicates whether the key is an extended key, such as the right-hand ALT and CTRL keys that appear on an enhanced 101- or
            102-key keyboard. The value is 1 if it is an extended key; otherwise, it is 0.
            </term>
            </item>
            <item>
            <term>25-28</term>
            <term>Reserved; do not use.</term>
            </item>
            <item>
            <term>29</term>
            <term>The context code. The value is 1 if the ALT key is held down while the key is pressed; otherwise, the value is 0.</term>
            </item>
            <item>
            <term>30</term>
            <term>The previous key state. The value is 1 if the key is down before the message is sent, or it is 0 if the key is up.</term>
            </item>
            <item>
            <term>31</term>
            <term>Transition state. The value is 1 if the key is being released, or it is 0 if the key is being pressed.</term>
            </item>
            </list>
            <para>For more detail, see Keystroke Message Flags.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard;
            the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide
            (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the lParam parameter.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_UNICHAR">
            <summary>
            <para>
            The <c>WM_UNICHAR</c> message can be used by an application to post input to other windows. This message contains the
            character code of the key that was pressed. (Test whether a target app can process <c>WM_UNICHAR</c> messages by sending the
            message with wParam set to <c>UNICODE_NOCHAR</c>.)
            </para>
            <para>
            <code>#define WM_UNICHAR 0x0109</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The character code of the key.</para>
            <para>
            If wParam is <c>UNICODE_NOCHAR</c> and the application processes this message, then return <c>TRUE</c>. The
            <c>DefWindowProc</c> function will return <c>FALSE</c> (the default).
            </para>
            <para>
            If wParam is not <c>UNICODE_NOCHAR</c>, return <c>FALSE</c>. The Unicode <c>DefWindowProc</c> posts a <c>WM_CHAR</c> message
            with the same parameters and the ANSI <c>DefWindowProc</c> function posts either one or two <c>WM_CHAR</c> messages with the
            corresponding ANSI character(s).
            </para>
            <para><em>lParam</em></para>
            <para>
            The repeat count, scan code, extended-key flag, context code, previous key-state flag, and transition-state flag, as shown in
            the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Bits</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0-15</term>
            <term>
            The repeat count for the current message. The value is the number of times the keystroke is autorepeated as a result of the
            user holding down the key. If the keystroke is held long enough, multiple messages are sent. However, the repeat count is not cumulative.
            </term>
            </item>
            <item>
            <term>16-23</term>
            <term>The scan code. The value depends on the OEM.</term>
            </item>
            <item>
            <term>24</term>
            <term>
            Indicates whether the key is an extended key, such as the right-hand ALT and CTRL keys that appear on an enhanced 101- or
            102-key keyboard. The value is 1 if it is an extended key; otherwise, it is 0.
            </term>
            </item>
            <item>
            <term>25-28</term>
            <term>Reserved; do not use.</term>
            </item>
            <item>
            <term>29</term>
            <term>The context code. The value is 1 if the ALT key is held down while the key is pressed; otherwise, the value is 0.</term>
            </item>
            <item>
            <term>30</term>
            <term>The previous key state. The value is 1 if the key is down before the message is sent, or it is 0 if the key is up.</term>
            </item>
            <item>
            <term>31</term>
            <term>The transition state. The value is 1 if the key is being released, or it is 0 if the key is being pressed.</term>
            </item>
            </list>
            <para>For more detail, see Keystroke Message Flags.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            <para>
            The <c>WM_UNICHAR</c> message is similar to <c>WM_CHAR</c>, but it uses Unicode Transformation Format (UTF)-32, whereas
            <c>WM_CHAR</c> uses UTF-16.
            </para>
            <para>
            This message is designed to send or post Unicode characters to ANSI windows and can handle Unicode Supplementary Plane characters.
            </para>
            <para>
            Because there is not necessarily a one-to-one correspondence between keys pressed and character messages generated, the
            information in the high-order word of the lParam parameter is generally not useful to applications. The information in the
            high-order word applies only to the most recent <c>WM_KEYDOWN</c> message that precedes the posting of the <c>WM_UNICHAR</c> message.
            </para>
            <para>
            For enhanced 101- and 102-key keyboards, extended keys are the right ALT and the right CTRL keys on the main section of the
            keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; and
            the divide (/) and ENTER keys in the numeric keypad. Some other keyboards may support the extended-key bit in the lParam parameter.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_KEYLAST">
            <summary>Keyboard message filter value.</summary>
            <remarks>
            Use the WM_KEYFIRST and WM_KEYLAST messages to filter for keyboard messages when using the GetMessage and PeekMessage functions.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_IME_STARTCOMPOSITION">
            <summary>
            <para>
            Sent immediately before the IME generates the composition string as a result of a keystroke. A window receives this message
            through its WindowProc function.
            </para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, WM_IME_STARTCOMPOSITION, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><strong>Returns</strong></para>
            <para>This message has no return value.</para>
            <remarks>
            <para>
            This message is a notification to an IME window to open its composition window. An application should process this message if
            it displays composition characters itself.
            </para>
            <para>
            If an application has created an IME window, it should pass this message to that window. The <c>DefWindowProc</c> function
            processes the message by passing it to the default IME window.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_IME_ENDCOMPOSITION">
            <summary>
            <para>
            Sent to an application when the IME ends composition. A window receives this message through its <c>WindowProc</c> function.
            </para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, WM_IME_ENDCOMPOSITION, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><strong>Returns</strong></para>
            <para>This message has no return value.</para>
            <remarks>
            <para>An application should process this message if it displays composition characters itself.</para>
            <para>
            If the application has created an IME window, it should pass this message to that window. The <c>DefWindowProc</c> function
            processes this message by passing it to the default IME window.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_IME_COMPOSITION">
            <summary>
            <para>
            Sent to an application when the IME changes composition status as a result of a keystroke. A window receives this message
            through its WindowProc function.
            </para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, WM_IME_COMPOSITION, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hwnd</em></para>
            <para>A handle to window.</para>
            <para><em>wParam</em></para>
            <para>DBCS character representing the latest change to the composition string.</para>
            <para><em>lParam</em></para>
            <para>
            Value specifying how the composition string or character changed. This parameter can be one or more of the following values.
            For more information about these values, see IME Composition String Values.
            </para>
            <list/>
            <para>The lParam parameter can also have one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>CS_INSERTCHAR</c></term>
            <term>
            Insert the <c>wParam</c> composition character at the current insertion point. An application should display the composition
            character if it processes this message.
            </term>
            </item>
            <item>
            <term><c>CS_NOMOVECARET</c></term>
            <term>
            Do not move the caret position as a result of processing the message. For example, if an IME specifies a combination of
            CS_INSERTCHAR and CS_NOMOVECARET, the application should insert the specified character at the current caret position but
            should not move the caret to the next position. A subsequent WM_IME_COMPOSITION message with GCS_RESULTSTR will replace this character.
            </term>
            </item>
            </list>
            <para><strong>Returns</strong></para>
            <para>This message has no return value.</para>
            <remarks>
            <para>
            An application should process this message if it displays composition characters itself. Otherwise, it should send the
            message to the IME window.
            </para>
            <para>
            If the application has created an IME window, it should pass this message to that window. The <c>DefWindowProc</c> function
            processes this message by passing it to the default IME window. The IME window processes this message by updating its
            appearance based on the change flag specified. An application can call <c>ImmGetCompositionString</c> to retrieve the new
            composition status.
            </para>
            <para>
            If none of the GCS_ values are set, the message indicates that the current composition has been canceled and applications
            that draw the composition string should delete the string.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_IME_KEYLAST">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_INITDIALOG">
            <summary>
            <para>
            Sent to the dialog box procedure immediately before a dialog box is displayed. Dialog box procedures typically use this
            message to initialize controls and carry out any other initialization tasks that affect the appearance of the dialog box.
            </para>
            <para>
            <code>#define WM_INITDIALOG 0x0110</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            A handle to the control to receive the default keyboard focus. The system assigns the default keyboard focus only if the
            dialog box procedure returns <c>TRUE</c>.
            </para>
            <para><em>lParam</em></para>
            <para>
            Additional initialization data. This data is passed to the system as the lParam parameter in a call to the
            <c>CreateDialogIndirectParam</c>, <c>CreateDialogParam</c>, <c>DialogBoxIndirectParam</c>, or <c>DialogBoxParam</c> function
            used to create the dialog box. For property sheets, this parameter is a pointer to the <c>PROPSHEETPAGE</c> structure used to
            create the page. This parameter is zero if any other dialog box creation function is used.
            </para>
            <para><strong>Returns</strong></para>
            <para>
            The dialog box procedure should return <c>TRUE</c> to direct the system to set the keyboard focus to the control specified by
            wParam. Otherwise, it should return <c>FALSE</c> to prevent the system from setting the default keyboard focus.
            </para>
            <para>
            The dialog box procedure should return the value directly. The <c>DWL_MSGRESULT</c> value set by the <c>SetWindowLong</c>
            function is ignored.
            </para>
            <remarks>
            <para>
            The control to receive the default keyboard focus is always the first control in the dialog box that is visible, not
            disabled, and that has the <c>WS_TABSTOP</c> style. When the dialog box procedure returns <c>TRUE</c>, the system checks the
            control to ensure that the procedure has not disabled it. If it has been disabled, the system sets the keyboard focus to the
            next control that is visible, not disabled, and has the <c>WS_TABSTOP</c>.
            </para>
            <para>An application can return <c>FALSE</c> only if it has set the keyboard focus to one of the controls of the dialog box.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_COMMAND">
            <summary>
            <para>
            Sent when the user selects a command item from a menu, when a control sends a notification message to its parent window, or
            when an accelerator keystroke is translated.
            </para>
            <para>
            <code>#define WM_COMMAND 0x0111</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>For a description of this parameter, see Remarks.</para>
            <para><em>lParam</em></para>
            <para>For a description of this parameter, see Remarks.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>Use of the wParam and lParam parameters are summarized here.</para>
            <list type="table">
            <listheader>
            <term>Message Source</term>
            <term>wParam (high word)</term>
            <term>wParam (low word)</term>
            <term>lParam</term>
            </listheader>
            <item>
            <term>Menu</term>
            <term>0</term>
            <term>Menu identifier (IDM_*)</term>
            <term>0</term>
            </item>
            <item>
            <term>Accelerator</term>
            <term>1</term>
            <term>Accelerator identifier (IDM_*)</term>
            <term>0</term>
            </item>
            <item>
            <term>Control</term>
            <term>Control-defined notification code</term>
            <term>Control identifier</term>
            <term>Handle to the control window</term>
            </item>
            </list>
            <para>Menus</para>
            <para>
            If an application enables a menu separator, the system sends a <c>WM_COMMAND</c> message with the low-word of the wParam
            parameter set to zero when the user selects the separator.
            </para>
            <para>
            If a menu is defined with a <c>MENUINFO.dwStyle</c> value of <c>MNS_NOTIFYBYPOS</c>, <c>WM_MENUCOMMAND</c> is sent instead of <c>WM_COMMAND</c>.
            </para>
            <para>Accelerators</para>
            <para>Accelerator keystrokes that select items from the window menu are translated into <c>WM_SYSCOMMAND</c> messages.</para>
            <para>
            If an accelerator keystroke occurs that corresponds to a menu item when the window that owns the menu is minimized, no
            <c>WM_COMMAND</c> message is sent. However, if an accelerator keystroke occurs that does not match any of the items in the
            window's menu or in the window menu, a <c>WM_COMMAND</c> message is sent, even if the window is minimized.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SYSCOMMAND">
            <summary>
            <para>
            A window receives this message when the user chooses a command from the <c>Window</c> menu (formerly known as the system or
            control menu) or when the user chooses the maximize button, minimize button, restore button, or close button.
            </para>
            <para>
            <code>#define WM_SYSCOMMAND 0x0112</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The type of system command requested. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>SC_CLOSE</c> 0xF060</term>
            <term>Closes the window.</term>
            </item>
            <item>
            <term><c>SC_CONTEXTHELP</c> 0xF180</term>
            <term>
            Changes the cursor to a question mark with a pointer. If the user then clicks a control in the dialog box, the control
            receives a <c>WM_HELP</c> message.
            </term>
            </item>
            <item>
            <term><c>SC_DEFAULT</c> 0xF160</term>
            <term>Selects the default item; the user double-clicked the window menu.</term>
            </item>
            <item>
            <term><c>SC_HOTKEY</c> 0xF150</term>
            <term>
            Activates the window associated with the application-specified hot key. The <c>lParam</c> parameter identifies the window to activate.
            </term>
            </item>
            <item>
            <term><c>SC_HSCROLL</c> 0xF080</term>
            <term>Scrolls horizontally.</term>
            </item>
            <item>
            <term><c>SCF_ISSECURE</c> 0x00000001</term>
            <term>Indicates whether the screen saver is secure.</term>
            </item>
            <item>
            <term><c>SC_KEYMENU</c> 0xF100</term>
            <term>Retrieves the window menu as a result of a keystroke. For more information, see the Remarks section.</term>
            </item>
            <item>
            <term><c>SC_MAXIMIZE</c> 0xF030</term>
            <term>Maximizes the window.</term>
            </item>
            <item>
            <term><c>SC_MINIMIZE</c> 0xF020</term>
            <term>Minimizes the window.</term>
            </item>
            <item>
            <term><c>SC_MONITORPOWER</c> 0xF170</term>
            <term>
            Sets the state of the display. This command supports devices that have power-saving features, such as a battery-powered
            personal computer. The <c>lParam</c> parameter can have the following values:
            </term>
            </item>
            <item>
            <term><c>SC_MOUSEMENU</c> 0xF090</term>
            <term>Retrieves the window menu as a result of a mouse click.</term>
            </item>
            <item>
            <term><c>SC_MOVE</c> 0xF010</term>
            <term>Moves the window.</term>
            </item>
            <item>
            <term><c>SC_NEXTWINDOW</c> 0xF040</term>
            <term>Moves to the next window.</term>
            </item>
            <item>
            <term><c>SC_PREVWINDOW</c> 0xF050</term>
            <term>Moves to the previous window.</term>
            </item>
            <item>
            <term><c>SC_RESTORE</c> 0xF120</term>
            <term>Restores the window to its normal position and size.</term>
            </item>
            <item>
            <term><c>SC_SCREENSAVE</c> 0xF140</term>
            <term>Executes the screen saver application specified in the [boot] section of the System.ini file.</term>
            </item>
            <item>
            <term><c>SC_SIZE</c> 0xF000</term>
            <term>Sizes the window.</term>
            </item>
            <item>
            <term><c>SC_TASKLIST</c> 0xF130</term>
            <term>Activates the <c>Start</c> menu.</term>
            </item>
            <item>
            <term><c>SC_VSCROLL</c> 0xF070</term>
            <term>Scrolls vertically.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the horizontal position of the cursor, in screen coordinates, if a window menu command is chosen
            with the mouse. Otherwise, this parameter is not used.
            </para>
            <para>
            The high-order word specifies the vertical position of the cursor, in screen coordinates, if a window menu command is chosen
            with the mouse. This parameter is 1 if the command is chosen using a system accelerator, or zero if using a mnemonic.
            </para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            <para>To obtain the position coordinates in screen coordinates, use the following code:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); // horizontal position yPos = GET_Y_LPARAM(lParam); // vertical position</code>
            </para>
            <para>
            The <c>DefWindowProc</c> function carries out the window menu request for the predefined actions specified in the previous table.
            </para>
            <para>
            In <c>WM_SYSCOMMAND</c> messages, the four low-order bits of the wParam parameter are used internally by the system. To
            obtain the correct result when testing the value of wParam, an application must combine the value 0xFFF0 with the wParam
            value by using the bitwise AND operator.
            </para>
            <para>
            The menu items in a window menu can be modified by using the <c>GetSystemMenu</c>, <c>AppendMenu</c>, <c>InsertMenu</c>,
            <c>ModifyMenu</c>, <c>InsertMenuItem</c>, and <c>SetMenuItemInfo</c> functions. Applications that modify the window menu must
            process <c>WM_SYSCOMMAND</c> messages.
            </para>
            <para>
            An application can carry out any system command at any time by passing a <c>WM_SYSCOMMAND</c> message to
            <c>DefWindowProc</c>. Any <c>WM_SYSCOMMAND</c> messages not handled by the application must be passed to
            <c>DefWindowProc</c>. Any command values added by an application must be processed by the application and cannot be passed to <c>DefWindowProc</c>.
            </para>
            <para>
            If password protection is enabled by policy, the screen saver is started regardless of what an application does with the
            <c>SC_SCREENSAVE</c> notification even if fails to pass it to <c>DefWindowProc</c>.
            </para>
            <para>
            Accelerator keys that are defined to choose items from the window menu are translated into <c>WM_SYSCOMMAND</c> messages; all
            other accelerator keystrokes are translated into <c>WM_COMMAND</c> messages.
            </para>
            <para>
            If the wParam is <c>SC_KEYMENU</c>, lParam contains the character code of the key that is used with the ALT key to display
            the popup menu. For example, pressing ALT+F to display the File popup will cause a <c>WM_SYSCOMMAND</c> with wParam equal to
            <c>SC_KEYMENU</c> and lParam equal to 'f'.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_TIMER">
            <summary>
            <para>
            Posted to the installing thread's message queue when a timer expires. The message is posted by the <c>GetMessage</c> or
            <c>PeekMessage</c> function.
            </para>
            <para>
            <code>#define WM_TIMER 0x0113</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The timer identifier.</para>
            <para><em>lParam</em></para>
            <para>
            A pointer to an application-defined callback function that was passed to the <c>SetTimer</c> function when the timer was installed.
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            <para>
            You can process the message by providing a <c>WM_TIMER</c> case in the window procedure. Otherwise, <c>DispatchMessage</c>
            will call the TimerProc callback function specified in the call to the <c>SetTimer</c> function used to install the timer.
            </para>
            <para>
            The <c>WM_TIMER</c> message is a low-priority message. The <c>GetMessage</c> and <c>PeekMessage</c> functions post this
            message only when no other higher-priority messages are in the thread's message queue.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_HSCROLL">
            <summary>
            <para>
            The <c>WM_HSCROLL</c> message is sent to a window when a scroll event occurs in the window's standard horizontal scroll bar.
            This message is also sent to the owner of a horizontal scroll bar control when a scroll event occurs in the control.
            </para>
            <para>A window receives this message through its WindowProc function.</para>
            <para>
            <code>WM_HSCROLL WPARAM wParam LPARAM lParam;</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The <c>HIWORD</c> specifies the current position of the scroll box if the <c>LOWORD</c> is SB_THUMBPOSITION or SB_THUMBTRACK;
            otherwise, this word is not used.
            </para>
            <para>
            The <c>LOWORD</c> specifies a scroll bar value that indicates the user's scrolling request. This word can be one of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>SB_ENDSCROLL</c></term>
            <term>Ends scroll.</term>
            </item>
            <item>
            <term><c>SB_LEFT</c></term>
            <term>Scrolls to the upper left.</term>
            </item>
            <item>
            <term><c>SB_RIGHT</c></term>
            <term>Scrolls to the lower right.</term>
            </item>
            <item>
            <term><c>SB_LINELEFT</c></term>
            <term>Scrolls left by one unit.</term>
            </item>
            <item>
            <term><c>SB_LINERIGHT</c></term>
            <term>Scrolls right by one unit.</term>
            </item>
            <item>
            <term><c>SB_PAGELEFT</c></term>
            <term>Scrolls left by the width of the window.</term>
            </item>
            <item>
            <term><c>SB_PAGERIGHT</c></term>
            <term>Scrolls right by the width of the window.</term>
            </item>
            <item>
            <term><c>SB_THUMBPOSITION</c></term>
            <term>
            The user has dragged the scroll box (thumb) and released the mouse button. The <c>HIWORD</c> indicates the position of the
            scroll box at the end of the drag operation.
            </term>
            </item>
            <item>
            <term><c>SB_THUMBTRACK</c></term>
            <term>
            The user is dragging the scroll box. This message is sent repeatedly until the user releases the mouse button. The
            <c>HIWORD</c> indicates the position that the scroll box has been dragged to.
            </term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            If the message is sent by a scroll bar control, this parameter is the handle to the scroll bar control. If the message is
            sent by a standard scroll bar, this parameter is <c>NULL</c>.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            The SB_THUMBTRACK request code is typically used by applications that provide feedback as the user drags the scroll box.
            </para>
            <para>
            If an application scrolls the content of the window, it must also reset the position of the scroll box by using the
            <c>SetScrollPos</c> function.
            </para>
            <para>
            Note that the <c>WM_HSCROLL</c> message carries only 16 bits of scroll box position data. Thus, applications that rely solely
            on <c>WM_HSCROLL</c> (and <c>WM_VSCROLL</c>) for scroll position data have a practical maximum position value of 65,535.
            </para>
            <para>
            However, because the <c>SetScrollInfo</c>, <c>SetScrollPos</c>, <c>SetScrollRange</c>, <c>GetScrollInfo</c>,
            <c>GetScrollPos</c>, and <c>GetScrollRange</c> functions support 32-bit scroll bar position data, there is a way to
            circumvent the 16-bit barrier of the <c>WM_HSCROLL</c> and <c>WM_VSCROLL</c> messages. See <c>GetScrollInfo</c> for a
            description of the technique.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_VSCROLL">
            <summary>
            <para>
            The <c>WM_VSCROLL</c> message is sent to a window when a scroll event occurs in the window's standard vertical scroll bar.
            This message is also sent to the owner of a vertical scroll bar control when a scroll event occurs in the control.
            </para>
            <para>A window receives this message through its WindowProc function.</para>
            <para>
            <code>WM_VSCROLL WPARAM wParam LPARAM lParam;</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The <c>HIWORD</c> specifies the current position of the scroll box if the <c>LOWORD</c> is SB_THUMBPOSITION or SB_THUMBTRACK;
            otherwise, this word is not used.
            </para>
            <para>
            The <c>LOWORD</c> specifies a scroll bar value that indicates the user's scrolling request. This parameter can be one of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>SB_BOTTOM</c></term>
            <term>Scrolls to the lower right.</term>
            </item>
            <item>
            <term><c>SB_ENDSCROLL</c></term>
            <term>Ends scroll.</term>
            </item>
            <item>
            <term><c>SB_LINEDOWN</c></term>
            <term>Scrolls one line down.</term>
            </item>
            <item>
            <term><c>SB_LINEUP</c></term>
            <term>Scrolls one line up.</term>
            </item>
            <item>
            <term><c>SB_PAGEDOWN</c></term>
            <term>Scrolls one page down.</term>
            </item>
            <item>
            <term><c>SB_PAGEUP</c></term>
            <term>Scrolls one page up.</term>
            </item>
            <item>
            <term><c>SB_THUMBPOSITION</c></term>
            <term>
            The user has dragged the scroll box (thumb) and released the mouse button. The <c>HIWORD</c> indicates the position of the
            scroll box at the end of the drag operation.
            </term>
            </item>
            <item>
            <term><c>SB_THUMBTRACK</c></term>
            <term>
            The user is dragging the scroll box. This message is sent repeatedly until the user releases the mouse button. The
            <c>HIWORD</c> indicates the position that the scroll box has been dragged to.
            </term>
            </item>
            <item>
            <term><c>SB_TOP</c></term>
            <term>Scrolls to the upper left.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            If the message is sent by a scroll bar control, this parameter is the handle to the scroll bar control. If the message is
            sent by a standard scroll bar, this parameter is <c>NULL</c>.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            The SB_THUMBTRACK request code is typically used by applications that provide feedback as the user drags the scroll box.
            </para>
            <para>
            If an application scrolls the content of the window, it must also reset the position of the scroll box by using the
            <c>SetScrollPos</c> function.
            </para>
            <para>
            Note that the <c>WM_VSCROLL</c> message carries only 16 bits of scroll box position data. Thus, applications that rely solely
            on <c>WM_VSCROLL</c> (and <c>WM_HSCROLL</c>) for scroll position data have a practical maximum position value of 65,535.
            </para>
            <para>
            However, because the <c>SetScrollInfo</c>, <c>SetScrollPos</c>, <c>SetScrollRange</c>, <c>GetScrollInfo</c>,
            <c>GetScrollPos</c>, and <c>GetScrollRange</c> functions support 32-bit scroll bar position data, there is a way to
            circumvent the 16-bit barrier of the <c>WM_HSCROLL</c> and <c>WM_VSCROLL</c> messages. See <c>GetScrollInfo</c> for a
            description of the technique.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_INITMENU">
            <summary>
            <para>
            Sent when a menu is about to become active. It occurs when the user clicks an item on the menu bar or presses a menu key.
            This allows the application to modify the menu before it is displayed.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_INITMENU 0x0116</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the menu to be initialized.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            A <c>WM_INITMENU</c> message is sent only when a menu is first accessed; only one <c>WM_INITMENU</c> message is generated for
            each access. For example, moving the mouse across several menu items while holding down the button does not generate new
            messages. <c>WM_INITMENU</c> does not provide information about menu items.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_INITMENUPOPUP">
            <summary>
            <para>
            Sent when a drop-down menu or submenu is about to become active. This allows an application to modify the menu before it is
            displayed, without changing the entire menu.
            </para>
            <para>
            <code>#define WM_INITMENUPOPUP 0x0117</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the drop-down menu or submenu.</para>
            <para><em>lParam</em></para>
            <para>The low-order word specifies the zero-based relative position of the menu item that opens the drop-down menu or submenu.</para>
            <para>
            The high-order word indicates whether the drop-down menu is the window menu. If the menu is the window menu, this parameter
            is <c>TRUE</c>; otherwise, it is <c>FALSE</c>.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MENUSELECT">
            <summary>
            <para>Sent to a menu's owner window when the user selects a menu item.</para>
            <para>
            <code>#define WM_MENUSELECT 0x011F</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The low-order word specifies the menu item or submenu index. If the selected item is a command item, this parameter contains
            the identifier of the menu item. If the selected item opens a drop-down menu or submenu, this parameter contains the index of
            the drop-down menu or submenu in the main menu, and the lParam parameter contains the handle to the main (clicked) menu; use
            the <c>GetSubMenu</c> function to get the menu handle to the drop-down menu or submenu.
            </para>
            <para>The high-order word specifies one or more menu flags. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MF_BITMAP</c> 0x00000004L</term>
            <term>Item displays a bitmap.</term>
            </item>
            <item>
            <term><c>MF_CHECKED</c> 0x00000008L</term>
            <term>Item is checked.</term>
            </item>
            <item>
            <term><c>MF_DISABLED</c> 0x00000002L</term>
            <term>Item is disabled.</term>
            </item>
            <item>
            <term><c>MF_GRAYED</c> 0x00000001L</term>
            <term>Item is grayed.</term>
            </item>
            <item>
            <term><c>MF_HILITE</c> 0x00000080L</term>
            <term>Item is highlighted.</term>
            </item>
            <item>
            <term><c>MF_MOUSESELECT</c> 0x00008000L</term>
            <term>Item is selected with the mouse.</term>
            </item>
            <item>
            <term><c>MF_OWNERDRAW</c> 0x00000100L</term>
            <term>Item is an owner-drawn item.</term>
            </item>
            <item>
            <term><c>MF_POPUP</c> 0x00000010L</term>
            <term>Item opens a drop-down menu or submenu.</term>
            </item>
            <item>
            <term><c>MF_SYSMENU</c> 0x00002000L</term>
            <term>
            Item is contained in the window menu. The <c>lParam</c> parameter contains a handle to the menu associated with the message.
            </term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>A handle to the menu that was clicked.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            If the high-order word of wParam contains 0xFFFF and the lParam parameter contains <c>NULL</c>, the system has closed the menu.
            </para>
            <para>
            Do not use the value 1 for the high-order word of wParam, because this value is specified as ( <c>UINT</c>)
            <c>HIWORD</c>(wParam). If the value is 0xFFFF, it would be interpreted as 0x0000FFFF, not 1, because of the cast to a <c>UINT</c>.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MENUCHAR">
            <summary>
            <para>
            Sent when a menu is active and the user presses a key that does not correspond to any mnemonic or accelerator key. This
            message is sent to the window that owns the menu.
            </para>
            <para>
            <code>#define WM_MENUCHAR 0x0120</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The low-order word specifies the character code that corresponds to the key the user pressed.</para>
            <para>The high-order word specifies the active menu type. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MF_POPUP</c> 0x00000010L</term>
            <term>A drop-down menu, submenu, or shortcut menu.</term>
            </item>
            <item>
            <term><c>MF_SYSMENU</c> 0x00002000L</term>
            <term>The window menu.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>A handle to the active menu.</para>
            <para><strong>Returns</strong></para>
            <para>
            An application that processes this message should return one of the following values in the high-order word of the return value.
            </para>
            <list type="table">
            <listheader>
            <term>Return code/value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term><c>MNC_CLOSE</c> 1</term>
            <term>Informs the system that it should close the active menu.</term>
            </item>
            <item>
            <term><c>MNC_EXECUTE</c> 2</term>
            <term>
            Informs the system that it should choose the item specified in the low-order word of the return value. The owner window
            receives a <c>WM_COMMAND</c> message.
            </term>
            </item>
            <item>
            <term><c>MNC_IGNORE</c> 0</term>
            <term>Informs the system that it should discard the character the user pressed and create a short beep on the system speaker.</term>
            </item>
            <item>
            <term><c>MNC_SELECT</c> 3</term>
            <term>Informs the system that it should select the item specified in the low-order word of the return value.</term>
            </item>
            </list>
            <remarks>
            <para>The low-order word is ignored if the high-order word contains 0 or 1.</para>
            <para>An application should process this message when an accelerator is used to select a menu item that displays a bitmap.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_ENTERIDLE">
            <summary>
            <para>
            Sent to the owner window of a modal dialog box or menu that is entering an idle state. A modal dialog box or menu enters an
            idle state when no messages are waiting in its queue after it has processed one or more previous messages.
            </para>
            <para>
            <code>#define WM_ENTERIDLE 0x0121</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MSGF_DIALOGBOX</c> 0</term>
            <term>The system is idle because a dialog box is displayed.</term>
            </item>
            <item>
            <term><c>MSGF_MENU</c> 2</term>
            <term>The system is idle because a menu is displayed.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            A handle to the dialog box (if wParam is <c>MSGF_DIALOGBOX</c>) or window containing the displayed menu (if wParam is <c>MSGF_MENU</c>).
            </para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            You can suppress the <c>WM_ENTERIDLE</c> message for a dialog box by creating the dialog box with the <c>DS_NOIDLEMSG</c> style.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MENURBUTTONUP">
            <summary>
            <para>Sent when the user releases the right mouse button while the cursor is on a menu item.</para>
            <para>
            <code>#define WM_MENURBUTTONUP 0x0122</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The zero-based index of the menu item on which the right mouse button was released.</para>
            <para><em>lParam</em></para>
            <para>A handle to the menu containing the item.</para>
            <remarks>
            The <c>WM_MENURBUTTONUP</c> message allows applications to provide a context-sensitive menu also known as a shortcut menu for
            the menu item specified in this message. To display a context-sensitive menu for a menu item, call the
            <c>TrackPopupMenuEx</c> function with <c>TPM_RECURSE</c>.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MENUDRAG">
            <summary>
            <para>Sent to the owner of a drag-and-drop menu when the user drags a menu item.</para>
            <para>
            <code>#define WM_MENUDRAG 0x0123</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The position of the item where the drag operation began.</para>
            <para><em>lParam</em></para>
            <para>A handle to the menu containing the item.</para>
            <para><strong>Returns</strong></para>
            <para>The application should return one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code/value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term><c>MND_CONTINUE</c> 0</term>
            <term>Menu should remain active. If the mouse is released, it should be ignored.</term>
            </item>
            <item>
            <term><c>MND_ENDMENU</c> 1</term>
            <term>Menu should be ended.</term>
            </item>
            </list>
            <remarks>
            <para>The application can call the <c>DoDragDrop</c> function in response to this message.</para>
            <para>To create a drag-and-drop menu, call <c>SetMenuInfo</c> with <c>MNS_DRAGDROP</c>.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MENUGETOBJECT">
            <summary>
            <para>
            Sent to the owner of a drag-and-drop menu when the mouse cursor enters a menu item or moves from the center of the item to
            the top or bottom of the item.
            </para>
            <para>
            <code>#define WM_MENUGETOBJECT 0x0124</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>A pointer to a <c>MENUGETOBJECTINFO</c> structure.</para>
            <para><strong>Returns</strong></para>
            <para>The application should return one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code/value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term><c>MNGO_NOERROR</c> 0x00000001</term>
            <term>An interface pointer was returned in the <c>pvObj</c> member of <c>MENUGETOBJECTINFO</c></term>
            </item>
            <item>
            <term><c>MNGO_NOINTERFACE</c> 0x00000000</term>
            <term>The interface is not supported.</term>
            </item>
            </list>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_UNINITMENUPOPUP">
            <summary>
            <para>Sent when a drop-down menu or submenu has been destroyed.</para>
            <para>
            <code>#define WM_UNINITMENUPOPUP 0x0125</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the menu</para>
            <para><em>lParam</em></para>
            <para>
            The high-order word identifies the menu that was destroyed. Currently, this parameter can only be <c>MF_SYSMENU</c> (the
            window menu).
            </para>
            <remarks>If an application receives a <c>WM_INITMENUPOPUP</c> message, it will receive a <c>WM_UNINITMENUPOPUP</c> message.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MENUCOMMAND">
            <summary>
            <para>Sent when the user makes a selection from a menu.</para>
            <para>
            <code>#define WM_MENUCOMMAND 0x0126</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The zero-based index of the item selected.</para>
            <para><em>lParam</em></para>
            <para>A handle to the menu for the item selected.</para>
            <remarks>
            <para>
            The <c>WM_MENUCOMMAND</c> message gives you a handle to the menu so you can access the menu data in the <c>MENUINFO</c>
            structure and also gives you the index of the selected item, which is typically what applications need. In contrast, the
            <c>WM_COMMAND</c> message gives you the menu item identifier.
            </para>
            <para>
            The <c>WM_MENUCOMMAND</c> message is sent only for menus that are defined with the <c>MNS_NOTIFYBYPOS</c> flag set in the
            <c>dwStyle</c> member of the <c>MENUINFO</c> structure.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CHANGEUISTATE">
            <summary>
            <para>An application sends the <c>WM_CHANGEUISTATE</c> message to indicate that the UI state should be changed.</para>
            <para>
            <code>#define WM_CHANGEUISTATE 0x0127</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The low-order word specifies the action to be taken. This member can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>UIS_CLEAR</c> 2</term>
            <term>The UI state flags specified by the high-order word should be cleared.</term>
            </item>
            <item>
            <term><c>UIS_INITIALIZE</c> 3</term>
            <term>
            The UI state flags specified by the high-order word should be changed based on the last input event. For more information,
            see Remarks.
            </term>
            </item>
            <item>
            <term><c>UIS_SET</c> 1</term>
            <term>The UI state flags specified by the high-order word should be set.</term>
            </item>
            </list>
            <para>
            The high-order word specifies which UI state elements are affected or the style of the control. This member can be one or
            more of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>UISF_ACTIVE</c> 0x4</term>
            <term>A control should be drawn in the style used for active controls.</term>
            </item>
            <item>
            <term><c>UISF_HIDEACCEL</c> 0x2</term>
            <term>Keyboard accelerators are hidden.</term>
            </item>
            <item>
            <term><c>UISF_HIDEFOCUS</c> 0x1</term>
            <term>Focus indicators are hidden.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>This parameter is not used and must be 0.</para>
            <remarks>
            <para>
            A window should send this message to itself or its parent when it must change the UI state elements of all windows in the
            same hierarchy. The window procedure must let <c>DefWindowProc</c> process this message so that the entire window tree has a
            consistent UI state. When the top-level window receives the <c>WM_CHANGEUISTATE</c> message, it sends a
            <c>WM_UPDATEUISTATE</c> message with the same parameters to all child windows. When the system processes the
            <c>WM_UPDATEUISTATE</c> message, it makes the change in the UI state.
            </para>
            <para>
            If the low-order word of wParam is UIS_INITIALIZE, the system will send the <c>WM_UPDATEUISTATE</c> message with a UI state
            based on the last input event. For example, if the last input came from the mouse, the system will hide the keyboard cues.
            And, if the last input came from the keyboard, the system will show the keyboard cues. If the state that results from
            processing <c>WM_CHANGEUISTATE</c> is the same as the old state, <c>DefWindowProc</c> does not send this message.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_UPDATEUISTATE">
            <summary>
            <para>
            An application sends the <c>WM_UPDATEUISTATE</c> message to change the UI state for the specified window and all its child windows.
            </para>
            <para>
            <code>#define WM_UPDATEUISTATE 0x0128</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The low-order word specifies the action to be performed. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>UIS_CLEAR</c> 2</term>
            <term>The UI state element specified by the high-order word should be hidden.</term>
            </item>
            <item>
            <term><c>UIS_INITIALIZE</c> 3</term>
            <term>
            The UI state element specified by the high-order word should be changed based on the last input event. For more information,
            see Remarks.
            </term>
            </item>
            <item>
            <term><c>UIS_SET</c> 1</term>
            <term>The UI state element specified by the high-order word should be visible.</term>
            </item>
            </list>
            <para>
            The high-order word specifies which UI state elements are affected or the style of the control. This parameter can be one or
            more of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>UISF_ACTIVE</c> 0x4</term>
            <term>A control should be drawn in the style used for active controls.</term>
            </item>
            <item>
            <term><c>UISF_HIDEACCEL</c> 0x2</term>
            <term>Keyboard accelerators.</term>
            </item>
            <item>
            <term><c>UISF_HIDEFOCUS</c> 0x1</term>
            <term>Focus indicators.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <remarks>
            <para>
            A window should send this message to change the UI state of all its child windows. In contrast to the <c>WM_CHANGEUISTATE</c>
            message, which is a notification, when <c>DefWindowProc</c> processes the <c>WM_UPDATEUISTATE</c> message it changes the UI
            state and propagates the changes to all child windows.
            </para>
            <para>
            The <c>DefWindowProc</c> function updates the UI state according to the wParam value. If the UI state is modified, the
            function sends the message to all the immediate child windows. <c>DefWindowProc</c> also sends this message when it receives
            a <c>WM_CHANGEUISTATE</c> message notifying the system that a child window intends to modify the UI state.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_QUERYUISTATE">
            <summary>
            <para>An application sends the <c>WM_QUERYUISTATE</c> message to retrieve the UI state for a window.</para>
            <para>
            <code>#define WM_QUERYUISTATE 0x0129</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used and must be 0.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used and must be 0.</para>
            <para><strong>Returns</strong></para>
            <para>
            The return value is <c>NULL</c> if the focus indicators and the keyboard accelerators are visible. Otherwise, the return
            value can be one or more of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code/value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term><c>UISF_ACTIVE</c> 0x4</term>
            <term>A control should be drawn in the style used for active controls.</term>
            </item>
            <item>
            <term><c>UISF_HIDEACCEL</c> 0x2</term>
            <term>Keyboard accelerators are hidden.</term>
            </item>
            <item>
            <term><c>UISF_HIDEFOCUS</c> 0x1</term>
            <term>Focus indicators are hidden.</term>
            </item>
            </list>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CTLCOLORMSGBOX">
            <summary>
            <para>
            The WM_CTLCOLORMSGBOX message is sent to the owner window of a message box before Windows draws the message box. By
            responding to this message, the owner window can set the text and background colors of the message box by using the given
            display device context handle.
            </para>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Type: HDC. Identifies the device context for the message box.</para>
            <para><em>lParam</em></para>
            <para>Type: HWND. Identifies the message box.</para>
            <para><strong>Returns</strong></para>
            <para>
            If an application processes this message, it must return the handle of a brush. Windows uses the brush to paint the
            background of the message box.
            </para>
            </summary>
            <remarks>
            <para>The WM_CTLCOLORMSGBOX message is never sent between threads. It is sent only within one thread.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CTLCOLOREDIT">
            <summary>
            <para>
            An edit control that is not read-only or disabled sends the <c>WM_CTLCOLOREDIT</c> message to its parent window when the
            control is about to be drawn. By responding to this message, the parent window can use the specified device context handle to
            set the text and background colors of the edit control.
            </para>
            <para>
            <code>WM_CTLCOLOREDIT WPARAM wParam; LPARAM lParam;</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the device context for the edit control window.</para>
            <para><em>lParam</em></para>
            <para>A handle to the edit control.</para>
            <para><strong>Returns</strong></para>
            <para>
            If an application processes this message, it must return the handle of a brush. The system uses the brush to paint the
            background of the edit control.
            </para>
            <remarks>
            <para>
            If the application returns a brush that it created (for example, by using the <c>CreateSolidBrush</c> or
            <c>CreateBrushIndirect</c> function), the application must free the brush. If the application returns a system brush (for
            example, one that was retrieved by the <c>GetStockObject</c> or <c>GetSysColorBrush</c> function), the application does not
            need to free the brush.
            </para>
            <para>By default, the <c>DefWindowProc</c> function selects the default system colors for the edit control.</para>
            <para>
            Read-only or disabled edit controls do not send the <c>WM_CTLCOLOREDIT</c> message; instead, they send the
            <c>WM_CTLCOLORSTATIC</c> message.
            </para>
            <para>The <c>WM_CTLCOLOREDIT</c> message is never sent between threads, it is only sent within the same thread.</para>
            <para>
            If a dialog box procedure handles this message, it should cast the desired return value to a <c>INT_PTR</c> and return the
            value directly. If the dialog box procedure returns <c>FALSE</c>, then default message handling is performed. The
            DWL_MSGRESULT value set by the <c>SetWindowLong</c> function is ignored.
            </para>
            <para>
            <c>Rich Edit:</c> This message is not supported. To set the background color for a rich edit control, use the
            <c>EM_SETBKGNDCOLOR</c> message.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CTLCOLORLISTBOX">
            <summary>
            <para>
            Sent to the parent window of a list box before the system draws the list box. By responding to this message, the parent
            window can set the text and background colors of the list box by using the specified display device context handle.
            </para>
            <para>
            <code>WM_CTLCOLORLISTBOX WPARAM wParam; LPARAM lParam;</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Handle to the device context for the list box.</para>
            <para><em>lParam</em></para>
            <para>Handle to the list box.</para>
            <para><strong>Returns</strong></para>
            <para>
            If an application processes this message, it must return a handle to a brush. The system uses the brush to paint the
            background of the list box.
            </para>
            <remarks>
            <para>By default, the <c>DefWindowProc</c> function selects the default system colors for the list box.</para>
            <para>The <c>WM_CTLCOLORLISTBOX</c> message is never sent between threads. It is sent only within one thread.</para>
            <para>
            If a dialog box procedure handles this message, it should cast the desired return value to a <c>INT_PTR</c> and return the
            value directly. If the dialog box procedure returns <c>FALSE</c>, then default message handling is performed. The
            <c>DWL_MSGRESULT</c> value set by the <c>SetWindowLong</c> function is ignored.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CTLCOLORBTN">
            <summary>
            <para>
            The <c>WM_CTLCOLORBTN</c> message is sent to the parent window of a button before drawing the button. The parent window can
            change the button's text and background colors. However, only owner-drawn buttons respond to the parent window processing
            this message.
            </para>
            <para>
            <code>WM_CTLCOLORBTN WPARAM wParam; LPARAM lParam;</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>An <c>HDC</c> that specifies the handle to the display context for the button.</para>
            <para><em>lParam</em></para>
            <para>An <c>HWND</c> that specifies the handle to the button.</para>
            <para><strong>Returns</strong></para>
            <para>
            If an application processes this message, it must return a handle to a brush. The system uses the brush to paint the
            background of the button.
            </para>
            <remarks>
            <para>
            If the application returns a brush that it created (for example, by using the <c>CreateSolidBrush</c> or
            <c>CreateBrushIndirect</c> function), the application must free the brush. If the application returns a system brush (for
            example, one that was retrieved by the <c>GetStockObject</c> or <c>GetSysColorBrush</c> function), the application does not
            need to free the brush.
            </para>
            <para>
            By default, the <c>DefWindowProc</c> function selects the default system colors for the button. Buttons with the
            <c>BS_PUSHBUTTON</c>, <c>BS_DEFPUSHBUTTON</c>, or <c>BS_PUSHLIKE</c> styles do not use the returned brush. Buttons with these
            styles are always drawn with the default system colors. Drawing push buttons requires several different brushes-face,
            highlight, and shadow-but the <c>WM_CTLCOLORBTN</c> message allows only one brush to be returned. To provide a custom
            appearance for push buttons, use an owner-drawn button. For more information, see Creating Owner-Drawn Controls.
            </para>
            <para>The <c>WM_CTLCOLORBTN</c> message is never sent between threads. It is sent only within one thread.</para>
            <para>
            The text color of a check box or radio button applies to the box or button, its check mark, and the text. The focus rectangle
            for these buttons remains the system default color (typically black). The text color of a group box applies to the text but
            not to the line that defines the box. The text color of a push button applies only to its focus rectangle; it does not affect
            the color of the text.
            </para>
            <para>
            If a dialog box procedure handles this message, it should cast the desired return value to a <c>INT_PTR</c> and return the
            value directly. If the dialog box procedure returns <c>FALSE</c>, then default message handling is performed. The
            DWL_MSGRESULT value set by the <c>SetWindowLong</c> function is ignored.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CTLCOLORDLG">
            <summary>
            <para>
            Sent to a dialog box before the system draws the dialog box. By responding to this message, the dialog box can set its text
            and background colors using the specified display device context handle.
            </para>
            <para>
            <code>#define WM_CTLCOLORDLG 0x0136</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the device context for the dialog box.</para>
            <para><em>lParam</em></para>
            <para>A handle to the dialog box.</para>
            <para><strong>Returns</strong></para>
            <para>
            If an application processes this message, it must return a handle to a brush. The system uses the brush to paint the
            background of the dialog box.
            </para>
            <remarks>
            <para>By default, the <c>DefWindowProc</c> function selects the default system colors for the dialog box.</para>
            <para>
            The system does not automatically destroy the returned brush. It is the application's responsibility to destroy the brush
            when it is no longer needed.
            </para>
            <para>The <c>WM_CTLCOLORDLG</c> message is never sent between threads. It is sent only within one thread.</para>
            <para>
            Note that the <c>WM_CTLCOLORDLG</c> message is sent to the dialog box itself; all of the other <c>WM_CTLCOLOR*</c> messages
            are sent to the owner of the control.
            </para>
            <para>
            If a dialog box procedure handles this message, it should cast the desired return value to an <c>INT_PTR</c> and return the
            value directly. If the dialog box procedure returns <c>FALSE</c>, then default message handling is performed. The
            <c>DWL_MSGRESULT</c> value set by the <c>SetWindowLong</c> function is ignored.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CTLCOLORSCROLLBAR">
            <summary>
            <para>
            The <c>WM_CTLCOLORSCROLLBAR</c> message is sent to the parent window of a scroll bar control when the control is about to be
            drawn. By responding to this message, the parent window can use the display context handle to set the background color of the
            scroll bar control.
            </para>
            <para>A window receives this message through its WindowProc function.</para>
            <para>
            <code>WM_CTLCOLORSCROLLBAR WPARAM wParam LPARAM lParam;</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Handle to the device context for the scroll bar control.</para>
            <para><em>lParam</em></para>
            <para>Handle to the scroll bar.</para>
            <para><strong>Returns</strong></para>
            <para>
            If an application processes this message, it must return the handle to a brush. The system uses the brush to paint the
            background of the scroll bar control.
            </para>
            <remarks>
            <para>
            If the application returns a brush that it created (for example, by using the <c>CreateSolidBrush</c> or
            <c>CreateBrushIndirect</c> function), the application must free the brush. If the application returns a system brush (for
            example, one that was retrieved by the <c>GetStockObject</c> or <c>GetSysColorBrush</c> function), the application does not
            need to free the brush.
            </para>
            <para>By default, the <c>DefWindowProc</c> function selects the default system colors for the scroll bar control.</para>
            <para>The <c>WM_CTLCOLORSCROLLBAR</c> message is never sent between threads; it is only sent within the same thread.</para>
            <para>
            If a dialog box procedure handles this message, it should cast the desired return value to a <c>INT_PTR</c> and return the
            value directly. If the dialog box procedure returns <c>FALSE</c>, then default message handling is performed. The
            DWL_MSGRESULT value set by the <c>SetWindowLong</c> function is ignored.
            </para>
            <para>
            The <c>WM_CTLCOLORSCROLLBAR</c> message is used only by child scroll bar controls. Scrollbars attached to a window (WS_SCROLL
            and WS_VSCROLL) do not generate this message. To customize the appearance of scrollbars attached to a window, use the flat
            scroll bar functions.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CTLCOLORSTATIC">
            <summary>
            <para>
            A static control, or an edit control that is read-only or disabled, sends the <c>WM_CTLCOLORSTATIC</c> message to its parent
            window when the control is about to be drawn. By responding to this message, the parent window can use the specified device
            context handle to set the text foreground and background colors of the static control.
            </para>
            <para>A window receives this message through its WindowProc function.</para>
            <para>
            <code>WM_CTLCOLORSTATIC WPARAM wParam; LPARAM lParam;</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Handle to the device context for the static control window.</para>
            <para><em>lParam</em></para>
            <para>Handle to the static control.</para>
            <para><strong>Returns</strong></para>
            <para>
            If an application processes this message, the return value is a handle to a brush that the system uses to paint the
            background of the static control.
            </para>
            <remarks>
            <para>
            If the application returns a brush that it created (for example, by using the <c>CreateSolidBrush</c> or
            <c>CreateBrushIndirect</c> function), the application must free the brush. If the application returns a system brush (for
            example, one that was retrieved by the <c>GetStockObject</c> or <c>GetSysColorBrush</c> function), the application does not
            need to free the brush.
            </para>
            <para>By default, the <c>DefWindowProc</c> function selects the default system colors for the static control.</para>
            <para>
            You can set the text background color of a disabled edit control, but you cannot set the text foreground color. The system
            always uses COLOR_GRAYTEXT.
            </para>
            <para>
            Edit controls that are not read-only or disabled do not send the <c>WM_CTLCOLORSTATIC</c> message; instead, they send the
            <c>WM_CTLCOLOREDIT</c> message.
            </para>
            <para>The <c>WM_CTLCOLORSTATIC</c> message is never sent between threads; it is sent only within the same thread.</para>
            <para>
            If a dialog box procedure handles this message, it should cast the desired return value to a <c>INT_PTR</c> and return the
            value directly. If the dialog box procedure returns <c>FALSE</c>, then default message handling is performed. The
            DWL_MSGRESULT value set by the <c>SetWindowLong</c> function is ignored.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MOUSEFIRST">
            <summary>The first mouse related message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MOUSEMOVE">
            <summary>
            <para>
            Posted to a window when the cursor moves. If the mouse is not captured, the message is posted to the window that contains the
            cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_MOUSEMOVE 0x0200</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Indicates whether various virtual keys are down. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is down.</term>
            </item>
            <item>
            <term><c>MK_LBUTTON</c> 0x0001</term>
            <term>The left mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The right mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_SHIFT</c> 0x0004</term>
            <term>The SHIFT key is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the x-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para>
            The high-order word specifies the y-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_LBUTTONDOWN">
            <summary>
            <para>
            Posted when the user presses the left mouse button while the cursor is in the client area of a window. If the mouse is not
            captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has
            captured the mouse.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_LBUTTONDOWN 0x0201</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Indicates whether various virtual keys are down. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is down.</term>
            </item>
            <item>
            <term><c>MK_LBUTTON</c> 0x0001</term>
            <term>The left mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The right mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_SHIFT</c> 0x0004</term>
            <term>The SHIFT key is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the x-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para>
            The high-order word specifies the y-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>
            To detect that the ALT key was pressed, check whether <c>GetKeyState</c> with <c>VK_MENU</c> &lt; 0. Note, this must not be <c>GetAsyncKeyState</c>.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_LBUTTONUP">
            <summary>
            <para>
            Posted when the user releases the left mouse button while the cursor is in the client area of a window. If the mouse is not
            captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has
            captured the mouse.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_LBUTTONUP 0x0202</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Indicates whether various virtual keys are down. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is down.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The right mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_SHIFT</c> 0x0004</term>
            <term>The SHIFT key is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the x-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para>
            The high-order word specifies the y-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the lParam value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_LBUTTONDBLCLK">
            <summary>
            <para>
            Posted when the user double-clicks the left mouse button while the cursor is in the client area of a window. If the mouse is
            not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has
            captured the mouse.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_LBUTTONDBLCLK 0x0203</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Indicates whether various virtual keys are down. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is down.</term>
            </item>
            <item>
            <term><c>MK_LBUTTON</c> 0x0001</term>
            <term>The left mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The right mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_SHIFT</c> 0x0004</term>
            <term>The SHIFT key is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the x-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para>
            The high-order word specifies the y-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>
            Only windows that have the <c>CS_DBLCLKS</c> style can receive <c>WM_LBUTTONDBLCLK</c> messages, which the system generates
            whenever the user presses, releases, and again presses the left mouse button within the system's double-click time limit.
            Double-clicking the left mouse button actually generates a sequence of four messages: <c>WM_LBUTTONDOWN</c>,
            <c>WM_LBUTTONUP</c>, <c>WM_LBUTTONDBLCLK</c>, and <c>WM_LBUTTONUP</c>.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_RBUTTONDOWN">
            <summary>
            <para>
            Posted when the user presses the right mouse button while the cursor is in the client area of a window. If the mouse is not
            captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has
            captured the mouse.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_RBUTTONDOWN 0x0204</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Indicates whether various virtual keys are down. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is down.</term>
            </item>
            <item>
            <term><c>MK_LBUTTON</c> 0x0001</term>
            <term>The left mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The right mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_SHIFT</c> 0x0004</term>
            <term>The SHIFT key is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the x-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para>
            The high-order word specifies the y-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>
            To detect that the ALT key was pressed, check whether <c>GetKeyState</c> with <c>VK_MENU</c> &lt; 0. Note, this must not be <c>GetAsyncKeyState</c>.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_RBUTTONUP">
            <summary>
            <para>
            Posted when the user releases the right mouse button while the cursor is in the client area of a window. If the mouse is not
            captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has
            captured the mouse.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_RBUTTONUP 0x0205</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Indicates whether various virtual keys are down. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is down.</term>
            </item>
            <item>
            <term><c>MK_LBUTTON</c> 0x0001</term>
            <term>The left mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The SHIFT key is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the x-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para>
            The high-order word specifies the y-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_RBUTTONDBLCLK">
            <summary>
            <para>
            Posted when the user double-clicks the right mouse button while the cursor is in the client area of a window. If the mouse is
            not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has
            captured the mouse.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_RBUTTONDBLCLK 0x0206</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Indicates whether various virtual keys are down. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is down.</term>
            </item>
            <item>
            <term><c>MK_LBUTTON</c> 0x0001</term>
            <term>The left mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The right mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_SHIFT</c> 0x0004</term>
            <term>The SHIFT key is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the x-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para>
            The high-order word specifies the y-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            Only windows that have the <c>CS_DBLCLKS</c> style can receive <c>WM_RBUTTONDBLCLK</c> messages, which the system generates
            whenever the user presses, releases, and again presses the right mouse button within the system's double-click time limit.
            Double-clicking the right mouse button actually generates four messages: <c>WM_RBUTTONDOWN</c>, <c>WM_RBUTTONUP</c>,
            <c>WM_RBUTTONDBLCLK</c>, and <c>WM_RBUTTONUP</c> again.
            </para>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MBUTTONDOWN">
            <summary>
            <para>
            Posted when the user presses the middle mouse button while the cursor is in the client area of a window. If the mouse is not
            captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has
            captured the mouse.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_MBUTTONDOWN 0x0207</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Indicates whether various virtual keys are down. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is down.</term>
            </item>
            <item>
            <term><c>MK_LBUTTON</c> 0x0001</term>
            <term>The left mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The right mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_SHIFT</c> 0x0004</term>
            <term>The SHIFT key is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the x-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para>
            The high-order word specifies the y-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>
            To detect that the ALT key was pressed, check whether <c>GetKeyState</c> with <c>VK_MENU</c> &lt; 0. Note, this must not be <c>GetAsyncKeyState</c>.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MBUTTONUP">
            <summary>
            <para>
            Posted when the user releases the middle mouse button while the cursor is in the client area of a window. If the mouse is not
            captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has
            captured the mouse.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_MBUTTONUP 0x0208</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Indicates whether various virtual keys are down. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is down.</term>
            </item>
            <item>
            <term><c>MK_LBUTTON</c> 0x0001</term>
            <term>The left mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The right mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_SHIFT</c> 0x0004</term>
            <term>The SHIFT key is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the x-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para>
            The high-order word specifies the y-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para>
            Note that when a shortcut menu is present (displayed), coordinates are relative to the screen, not the client area. Because
            <c>TrackPopupMenu</c> is an asynchronous call and the <c>WM_MBUTTONUP</c> notification does not have a special flag
            indicating coordinate derivation, an application cannot tell if the x,y coordinates contained in lParam are relative to the
            screen or the client area.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MBUTTONDBLCLK">
            <summary>
            <para>
            Posted when the user double-clicks the middle mouse button while the cursor is in the client area of a window. If the mouse
            is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that
            has captured the mouse.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_MBUTTONDBLCLK 0x0209</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Indicates whether various virtual keys are down. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is down.</term>
            </item>
            <item>
            <term><c>MK_LBUTTON</c> 0x0001</term>
            <term>The left mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The right mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_SHIFT</c> 0x0004</term>
            <term>The SHIFT key is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the x-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para>
            The high-order word specifies the y-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>
            Only windows that have the <c>CS_DBLCLKS</c> style can receive <c>WM_MBUTTONDBLCLK</c> messages, which the system generates
            when the user presses, releases, and again presses the middle mouse button within the system's double-click time limit.
            Double-clicking the middle mouse button actually generates four messages: <c>WM_MBUTTONDOWN</c>, <c>WM_MBUTTONUP</c>,
            <c>WM_MBUTTONDBLCLK</c>, and <c>WM_MBUTTONUP</c> again.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MOUSEWHEEL">
            <summary>
            <para>
            Sent to the focus window when the mouse wheel is rotated. The <c>DefWindowProc</c> function propagates the message to the
            window's parent. There should be no internal forwarding of the message, since <c>DefWindowProc</c> propagates it up the
            parent chain until it finds a window that processes it.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_MOUSEWHEEL 0x020A</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The high-order word indicates the distance the wheel is rotated, expressed in multiples or divisions of <c>WHEEL_DELTA</c>,
            which is 120. A positive value indicates that the wheel was rotated forward, away from the user; a negative value indicates
            that the wheel was rotated backward, toward the user.
            </para>
            <para>
            The low-order word indicates whether various virtual keys are down. This parameter can be one or more of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is down.</term>
            </item>
            <item>
            <term><c>MK_LBUTTON</c> 0x0001</term>
            <term>The left mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The right mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_SHIFT</c> 0x0004</term>
            <term>The SHIFT key is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>The low-order word specifies the x-coordinate of the pointer, relative to the upper-left corner of the screen.</para>
            <para>The high-order word specifies the y-coordinate of the pointer, relative to the upper-left corner of the screen.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>Use the following code to get the information in the wParam parameter:</para>
            <para>
            <code>fwKeys = GET_KEYSTATE_WPARAM(wParam); zDelta = GET_WHEEL_DELTA_WPARAM(wParam);</code>
            </para>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>
            The wheel rotation will be a multiple of <c>WHEEL_DELTA</c>, which is set at 120. This is the threshold for action to be
            taken, and one such action (for example, scrolling one increment) should occur for each delta.
            </para>
            <para>
            The delta was set to 120 to allow Microsoft or other vendors to build finer-resolution wheels (a freely-rotating wheel with
            no notches) to send more messages per rotation, but with a smaller value in each message. To use this feature, you can either
            add the incoming delta values until <c>WHEEL_DELTA</c> is reached (so for a delta-rotation you get the same response), or
            scroll partial lines in response to the more frequent messages. You can also choose your scroll granularity and accumulate
            deltas until it is reached.
            </para>
            <para>Note, there is no fwKeys for <c>MSH_MOUSEWHEEL</c>. Otherwise, the parameters are exactly the same as for <c>WM_MOUSEWHEEL</c>.</para>
            <para>
            It is up to the application to forward <c>MSH_MOUSEWHEEL</c> to any embedded objects or controls. The application is required
            to send the message to an active embedded OLE application. It is optional that the application sends it to a wheel-enabled
            control with focus. If the application does send the message to a control, it can check the return value to see if the
            message was processed. Controls are required to return a value of <c>TRUE</c> if they process the message.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_XBUTTONDOWN">
            <summary>
            <para>
            Posted when the user presses the first or second X button while the cursor is in the client area of a window. If the mouse is
            not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has
            captured the mouse.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_XBUTTONDOWN 0x020B</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The low-order word indicates whether various virtual keys are down. It can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is down.</term>
            </item>
            <item>
            <term><c>MK_LBUTTON</c> 0x0001</term>
            <term>The left mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The right mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_SHIFT</c> 0x0004</term>
            <term>The SHIFT key is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para>The high-order word indicates which button was clicked. It can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>XBUTTON1</c> 0x0001</term>
            <term>The first X button was clicked.</term>
            </item>
            <item>
            <term><c>XBUTTON2</c> 0x0002</term>
            <term>The second X button was clicked.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the x-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para>
            The high-order word specifies the y-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para><strong>Returns</strong></para>
            <para>
            If an application processes this message, it should return <c>TRUE</c>. For more information about processing the return
            value, see the Remarks section.
            </para>
            <remarks>
            <para>Use the following code to get the information in the wParam parameter:</para>
            <para>
            <code>fwKeys = GET_KEYSTATE_WPARAM (wParam); fwButton = GET_XBUTTON_WPARAM (wParam);</code>
            </para>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>
            Unlike the <c>WM_LBUTTONDOWN</c>, <c>WM_MBUTTONDOWN</c>, and <c>WM_RBUTTONDOWN</c> messages, an application should return
            <c>TRUE</c> from this message if it processes it. Doing so allows software that simulates this message on Windows systems
            earlier than Windows 2000 to determine whether the window procedure processed the message or called <c>DefWindowProc</c> to
            process it.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_XBUTTONUP">
            <summary>
            <para>
            Posted when the user releases the first or second X button while the cursor is in the client area of a window. If the mouse
            is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that
            has captured the mouse.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_XBUTTONUP 0x020C</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The low-order word indicates whether various virtual keys are down. It can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is down.</term>
            </item>
            <item>
            <term><c>MK_LBUTTON</c> 0x0001</term>
            <term>The left mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The right mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_SHIFT</c> 0x0004</term>
            <term>The SHIFT key is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para>The high-order word indicates which button was released. It can be one of the following values:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>XBUTTON1</c> 0x0001</term>
            <term>The first X button was released.</term>
            </item>
            <item>
            <term><c>XBUTTON2</c> 0x0002</term>
            <term>The second X button was released.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the x-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para>
            The high-order word specifies the y-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para><strong>Returns</strong></para>
            <para>
            If an application processes this message, it should return <c>TRUE</c>. For more information about processing the return
            value, see the Remarks section.
            </para>
            <remarks>
            <para>Use the following code to get the information in the wParam parameter:</para>
            <para>
            <code>fwKeys = GET_KEYSTATE_WPARAM (wParam); fwButton = GET_XBUTTON_WPARAM (wParam);</code>
            </para>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>
            Unlike the <c>WM_LBUTTONUP</c>, <c>WM_MBUTTONUP</c>, and <c>WM_RBUTTONUP</c> messages, an application should return
            <c>TRUE</c> from this message if it processes it. Doing so will allow software that simulates this message on Windows systems
            earlier than Windows 2000 to determine whether the window procedure processed the message or called <c>DefWindowProc</c> to
            process it.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_XBUTTONDBLCLK">
            <summary>
            <para>
            Posted when the user double-clicks the first or second X button while the cursor is in the client area of a window. If the
            mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window
            that has captured the mouse.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_XBUTTONDBLCLK 0x020D</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The low-order word indicates whether various virtual keys are down. It can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is down.</term>
            </item>
            <item>
            <term><c>MK_LBUTTON</c> 0x0001</term>
            <term>The left mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The right mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_SHIFT</c> 0x0004</term>
            <term>The SHIFT key is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para>The high-order word indicates which button was double-clicked. It can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>XBUTTON1</c> 0x0001</term>
            <term>The first X button was double-clicked.</term>
            </item>
            <item>
            <term><c>XBUTTON2</c> 0x0002</term>
            <term>The second X button was double-clicked.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the x-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para>
            The high-order word specifies the y-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para><strong>Returns</strong></para>
            <para>
            If an application processes this message, it should return <c>TRUE</c>. For more information about processing the return
            value, see the Remarks section.
            </para>
            <remarks>
            <para>Use the following code to get the information in the wParam parameter:</para>
            <para>
            <code>fwKeys = GET_KEYSTATE_WPARAM (wParam); fwButton = GET_XBUTTON_WPARAM (wParam);</code>
            </para>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>
            Only windows that have the <c>CS_DBLCLKS</c> style can receive <c>WM_XBUTTONDBLCLK</c> messages, which the system generates
            whenever the user presses, releases, and again presses an X button within the system's double-click time limit.
            Double-clicking one of these buttons actually generates four messages: <c>WM_XBUTTONDOWN</c>, <c>WM_XBUTTONUP</c>,
            <c>WM_XBUTTONDBLCLK</c>, and <c>WM_XBUTTONUP</c> again.
            </para>
            <para>
            Unlike the <c>WM_LBUTTONDBLCLK</c>, <c>WM_MBUTTONDBLCLK</c>, and <c>WM_RBUTTONDBLCLK</c> messages, an application should
            return <c>TRUE</c> from this message if it processes it. Doing so will allow software that simulates this message on Windows
            systems earlier than Windows 2000 to determine whether the window procedure processed the message or called
            <c>DefWindowProc</c> to process it.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MOUSEHWHEEL">
            <summary>
            <para>
            Sent to the active window when the mouse's horizontal scroll wheel is tilted or rotated. The <c>DefWindowProc</c> function
            propagates the message to the window's parent. There should be no internal forwarding of the message, since
            <c>DefWindowProc</c> propagates it up the parent chain until it finds a window that processes it.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_MOUSEHWHEEL 0x020E</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The high-order word indicates the distance the wheel is rotated, expressed in multiples or factors of <c>WHEEL_DELTA</c>,
            which is set to 120. A positive value indicates that the wheel was rotated to the right; a negative value indicates that the
            wheel was rotated to the left.
            </para>
            <para>
            The low-order word indicates whether various virtual keys are down. This parameter can be one or more of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is down.</term>
            </item>
            <item>
            <term><c>MK_LBUTTON</c> 0x0001</term>
            <term>The left mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The right mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_SHIFT</c> 0x0004</term>
            <term>The SHIFT key is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>The low-order word specifies the x-coordinate of the pointer, relative to the upper-left corner of the screen.</para>
            <para>The high-order word specifies the y-coordinate of the pointer, relative to the upper-left corner of the screen.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>Use the following code to obtain the information in the wParam parameter.</para>
            <para>
            <code>fwKeys = GET_KEYSTATE_WPARAM(wParam); zDelta = GET_WHEEL_DELTA_WPARAM(wParam);</code>
            </para>
            <para>Use the following code to obtain the horizontal and vertical position.</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            <para>
            The wheel rotation is a multiple of <c>WHEEL_DELTA</c>, which is set to 120. This is the threshold for action to be taken,
            and one such action (for example, scrolling one increment) should occur for each delta.
            </para>
            <para>
            The delta was set to 120 to allow Microsoft or other vendors to build finer-resolution wheels (for example, a freely-rotating
            wheel with no notches) to send more messages per rotation, but with a smaller value in each message. To use this feature, you
            can either add the incoming delta values until <c>WHEEL_DELTA</c> is reached (so for a delta-rotation you get the same
            response), or scroll partial lines in response to more frequent messages. You can also choose your scroll granularity and
            accumulate deltas until it is reached.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MOUSELAST">
            <summary>The last mouse related message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_PARENTNOTIFY">
            <summary>
            <para>
            Sent to a window when a significant action occurs on a descendant window. This message is now extended to include the
            <c>WM_POINTERDOWN</c> event. When the child window is being created, the system sends <c>WM_PARENTNOTIFY</c> just before the
            <c>CreateWindow</c> or <c>CreateWindowEx</c> function that creates the window returns. When the child window is being
            destroyed, the system sends the message before any processing to destroy the window takes place.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <para>
            [!Important] Desktop apps should be DPI aware. If your app is not DPI aware, screen coordinates contained in pointer messages
            and related structures might appear inaccurate due to DPI virtualization. DPI virtualization provides automatic scaling
            support to applications that are not DPI aware and is active by default (users can turn it off). For more information, see
            Writing High-DPI Win32 Applications.
            </para>
            </para>
            <para>
            <code>#define WM_PARENTNOTIFY 0x0210</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The low-order word of wParam specifies the event for which the parent is being notified. The value of the high-order word
            depends on the value of the low-order word. This parameter can be one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>LOWORD( <c>wParam</c>)</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>WM_CREATE</c> 0x0001</term>
            <term>
            The child window is being created. HIWORD( <c>wParam</c>) is the identifier of the child window. <c>lParam</c> is a handle to
            the child window.
            </term>
            </item>
            <item>
            <term><c>WM_DESTROY</c> 0x0002</term>
            <term>
            The child window is being destroyed. HIWORD( <c>wParam</c>) is the identifier of the child window. <c>lParam</c> is a handle
            to the child window.
            </term>
            </item>
            <item>
            <term><c>WM_LBUTTONDOWN</c> 0x0201</term>
            <term>
            The user has placed the cursor over the child window and has clicked the left mouse button. HIWORD( <c>wParam</c>) is
            undefined. <c>lParam</c> is the x-coordinate of the cursor is the low-order word, and the y-coordinate of the cursor is the
            high-order word.
            </term>
            </item>
            <item>
            <term><c>WM_MBUTTONDOWN</c> 0x0207</term>
            <term>
            The user has placed the cursor over the child window and has clicked the middle mouse button. HIWORD( <c>wParam</c>) is
            undefined. <c>lParam</c> is the x-coordinate of the cursor is the low-order word, and the y-coordinate of the cursor is the
            high-order word.
            </term>
            </item>
            <item>
            <term><c>WM_RBUTTONDOWN</c> 0x0204</term>
            <term>
            The user has placed the cursor over the child window and has clicked the right mouse button. HIWORD( <c>wParam</c>) is
            undefined. <c>lParam</c> is the x-coordinate of the cursor is the low-order word, and the y-coordinate of the cursor is the
            high-order word.
            </term>
            </item>
            <item>
            <term><c>WM_XBUTTONDOWN</c> 0x020B</term>
            <term>
            The user has placed the cursor over the child window and has clicked the first or second X button. HIWORD( <c>wParam</c>)
            indicates which button was pressed. This parameter can be one of the following values: XBUTTON1 or XBUTTON2. <c>lParam</c> is
            the x-coordinate of the cursor is the low-order word, and the y-coordinate of the cursor is the high-order word.
            </term>
            </item>
            <item>
            <term><c>WM_POINTERDOWN</c> 0x0246</term>
            <term>
            A pointer has made contact with the child window. HIWORD( <c>wParam</c>) contains the identifier of the pointer that
            generated the <c>WM_POINTERDOWN</c> event.
            </term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>Contains the point location of the pointer.</para>
            <para>
            <para>Note</para>
            <para>
            Because the pointer may make contact with the device over a non-trivial area, this point location may be a simplification of
            a more complex pointer area. Whenever possible, an application should use the complete pointer area information instead of
            the point location.
            </para>
            </para>
            <para>Use the following macros to retrieve the physical screen coordinates of the point.</para>
            <list type="bullet">
            <item>
            <term><c>GET_X_LPARAM</c>(lParam): the x (horizontal point) coordinate.</term>
            </item>
            <item>
            <term><c>GET_Y_LPARAM</c>(lParam): the y (vertical point) coordinate.</term>
            </item>
            </list>
            <para><strong>Returns</strong></para>
            <para>If the application processes this message, it returns zero.</para>
            <para>If the application does not process this message, it calls <c>DefWindowProc</c>.</para>
            <remarks>
            <para>This message is also sent to all ancestor windows of the child window, including the top-level window.</para>
            <para>
            All child windows, except those that have the <c>WS_EX_NOPARENTNOTIFY</c> extended window style, send this message to their
            parent windows. By default, child windows in a dialog box have the <c>WS_EX_NOPARENTNOTIFY</c> style, unless the
            <c>CreateWindowEx</c> function is called to create the child window without this style.
            </para>
            <para>
            This notification provides the child window's ancestor windows an opportunity to examine the pointer information and, if
            required, capture the pointer using the pointer capture functions.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_ENTERMENULOOP">
            <summary>
            <para>Notifies an application's main window procedure that a menu modal loop has been entered.</para>
            <para>
            <code>#define WM_ENTERMENULOOP 0x0211</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            Specifies whether the window menu was entered using the <c>TrackPopupMenu</c> function. This parameter has a value of
            <c>TRUE</c> if the window menu was entered using <c>TrackPopupMenu</c>, and <c>FALSE</c> if it was not.
            </para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>The <c>DefWindowProc</c> function returns zero.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_EXITMENULOOP">
            <summary>
            <para>Notifies an application's main window procedure that a menu modal loop has been exited.</para>
            <para>
            <code>#define WM_EXITMENULOOP 0x0212</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            Specifies whether the menu is a shortcut menu. This parameter has a value of <c>TRUE</c> if it is a shortcut menu,
            <c>FALSE</c> if it is not.
            </para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>The <c>DefWindowProc</c> function returns zero.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NEXTMENU">
            <summary>
            <para>Sent to an application when the right or left arrow key is used to switch between the menu bar and the system menu.</para>
            <para>
            <code>#define WM_NEXTMENU 0x0213</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The virtual-key code of the key. See <c>Virtual-Key Codes</c>.</para>
            <para><em>lParam</em></para>
            <para>A pointer to a <c>MDINEXTMENU</c> structure that contains information about the menu to be activated.</para>
            <remarks>
            In responding to this message, the application can specify the menu to switch to in the <c>hmenuNext</c> member of
            <c>MDINEXTMENU</c> and the window to receive the menu notification messages in the <c>hwndNext</c> member of the
            <c>MDINEXTMENU</c> structure. You must set both members for the changes to take effect (they are initially <c>NULL</c>).
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SIZING">
            <summary>
            <para>
            Sent to a window that the user is resizing. By processing this message, an application can monitor the size and position of
            the drag rectangle and, if needed, change its size or position.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_SIZING 0x0214</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The edge of the window that is being sized. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>WMSZ_BOTTOM</c> 6</term>
            <term>Bottom edge</term>
            </item>
            <item>
            <term><c>WMSZ_BOTTOMLEFT</c> 7</term>
            <term>Bottom-left corner</term>
            </item>
            <item>
            <term><c>WMSZ_BOTTOMRIGHT</c> 8</term>
            <term>Bottom-right corner</term>
            </item>
            <item>
            <term><c>WMSZ_LEFT</c> 1</term>
            <term>Left edge</term>
            </item>
            <item>
            <term><c>WMSZ_RIGHT</c> 2</term>
            <term>Right edge</term>
            </item>
            <item>
            <term><c>WMSZ_TOP</c> 3</term>
            <term>Top edge</term>
            </item>
            <item>
            <term><c>WMSZ_TOPLEFT</c> 4</term>
            <term>Top-left corner</term>
            </item>
            <item>
            <term><c>WMSZ_TOPRIGHT</c> 5</term>
            <term>Top-right corner</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            A pointer to a <c>RECT</c> structure with the screen coordinates of the drag rectangle. To change the size or position of the
            drag rectangle, an application must change the members of this structure.
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>An application should return <c>TRUE</c> if it processes this message.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CAPTURECHANGED">
            <summary>
            <para>Sent to the window that is losing the mouse capture.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_CAPTURECHANGED 0x0215</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>A handle to the window gaining the mouse capture.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            <para>
            A window receives this message even if it calls <c>ReleaseCapture</c> itself. An application should not attempt to set the
            mouse capture in response to this message.
            </para>
            <para>When it receives this message, a window should redraw itself, if necessary, to reflect the new mouse-capture state.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MOVING">
            <summary>
            <para>
            Sent to a window that the user is moving. By processing this message, an application can monitor the position of the drag
            rectangle and, if needed, change its position.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_MOVING 0x0216</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>
            A pointer to a <c>RECT</c> structure with the current position of the window, in screen coordinates. To change the position
            of the drag rectangle, an application must change the members of this structure.
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>An application should return <c>TRUE</c> if it processes this message.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_POWERBROADCAST">
            <summary>
            <para>Notifies applications that a power-management event has occurred.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, // handle to window UINT uMsg, // WM_POWERBROADCAST WPARAM wParam, // power-management event LPARAM lParam // function-specific data );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hwnd</em></para>
            <para>A handle to window.</para>
            <para><em>*uMsg*</em></para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c><c>WM_POWERBROADCAST</c></c> 536 (0x218)</term>
            <term>Message identifier.</term>
            </item>
            </list>
            <para><em>wParam</em></para>
            <para>The power-management event. This parameter can be one of the following event identifiers.</para>
            <list type="table">
            <listheader>
            <term>Event</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>PBT_APMPOWERSTATUSCHANGE</c> 10 (0xA)</term>
            <term>Power status has changed.</term>
            </item>
            <item>
            <term><c>PBT_APMRESUMEAUTOMATIC</c> 18 (0x12)</term>
            <term>Operation is resuming automatically from a low-power state. This message is sent every time the system resumes.</term>
            </item>
            <item>
            <term><c>PBT_APMRESUMESUSPEND</c> 7 (0x7)</term>
            <term>
            Operation is resuming from a low-power state. This message is sent after PBT_APMRESUMEAUTOMATIC if the resume is triggered by
            user input, such as pressing a key.
            </term>
            </item>
            <item>
            <term><c>PBT_APMSUSPEND</c> 4 (0x4)</term>
            <term>System is suspending operation.</term>
            </item>
            <item>
            <term><c>PBT_POWERSETTINGCHANGE</c> 32787 (0x8013)</term>
            <term>A power setting change event has been received.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>The event-specific data. For most events, this parameter is reserved and not used.</para>
            <para>
            If the wParam parameter is PBT_POWERSETTINGCHANGE, the lParam parameter is a pointer to a <c>POWERBROADCAST_SETTING</c> structure.
            </para>
            <para><strong>Returns</strong></para>
            <para>An application should return <c>TRUE</c> if it processes this message.</para>
            <remarks>
            <para>
            The system always sends a PBT_APMRESUMEAUTOMATIC message whenever the system resumes. If the system resumes in response to
            user input such as pressing a key, the system also sends a <c>PBT_APMRESUMESUSPEND</c> message after sending PBT_APMRESUMEAUTOMATIC.
            </para>
            <para>
            <c>WM_POWERBROADCAST</c> messages do not distinguish between different low-power states. An application can determine only
            that the system is entering or has resumed from a low-power state; it cannot determine the specific power state. The system
            records details about power state transitions in the Windows System event log.
            </para>
            <para>
            To prevent the system from transitioning to a low-power state in Windows Vista, an application must call
            <c>SetThreadExecutionState</c> to inform the system that it is in use.
            </para>
            <para>The following messages are not supported on any of the operating systems specified in the Requirements section:</para>
            <list type="bullet">
            <item>
            <term>PBT_APMQUERYSTANDBY</term>
            </item>
            <item>
            <term>PBT_APMQUERYSTANDBYFAILED</term>
            </item>
            <item>
            <term>PBT_APMSTANDBY</term>
            </item>
            <item>
            <term>PBT_APMRESUMESTANDBY</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_DEVICECHANGE">
            <summary>
            <para>Notifies an application of a change to the hardware configuration of a device or the computer.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc(HWND hwnd, // handle to window UINT uMsg, // WM_DEVICECHANGE WPARAM wParam, // device-change event LPARAM lParam ); // event-specific data</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hwnd</em></para>
            <para>A handle to the window.</para>
            <para><em>uMsg</em></para>
            <para>The <c>WM_DEVICECHANGE</c> identifier.</para>
            <para><em>wParam</em></para>
            <para>The event that has occurred. This parameter can be one of the following values from the Dbt.h header file.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>DBT_DEVNODES_CHANGED</c> 0x0007</term>
            <term>A device has been added to or removed from the system.</term>
            </item>
            <item>
            <term><c>DBT_QUERYCHANGECONFIG</c> 0x0017</term>
            <term>Permission is requested to change the current configuration (dock or undock).</term>
            </item>
            <item>
            <term><c>DBT_CONFIGCHANGED</c> 0x0018</term>
            <term>The current configuration has changed, due to a dock or undock.</term>
            </item>
            <item>
            <term><c>DBT_CONFIGCHANGECANCELED</c> 0x0019</term>
            <term>A request to change the current configuration (dock or undock) has been canceled.</term>
            </item>
            <item>
            <term><c>DBT_DEVICEARRIVAL</c> 0x8000</term>
            <term>A device or piece of media has been inserted and is now available.</term>
            </item>
            <item>
            <term><c>DBT_DEVICEQUERYREMOVE</c> 0x8001</term>
            <term>
            Permission is requested to remove a device or piece of media. Any application can deny this request and cancel the removal.
            </term>
            </item>
            <item>
            <term><c>DBT_DEVICEQUERYREMOVEFAILED</c> 0x8002</term>
            <term>A request to remove a device or piece of media has been canceled.</term>
            </item>
            <item>
            <term><c>DBT_DEVICEREMOVEPENDING</c> 0x8003</term>
            <term>A device or piece of media is about to be removed. Cannot be denied.</term>
            </item>
            <item>
            <term><c>DBT_DEVICEREMOVECOMPLETE</c> 0x8004</term>
            <term>A device or piece of media has been removed.</term>
            </item>
            <item>
            <term><c>DBT_DEVICETYPESPECIFIC</c> 0x8005</term>
            <term>A device-specific event has occurred.</term>
            </item>
            <item>
            <term><c>DBT_CUSTOMEVENT</c> 0x8006</term>
            <term>A custom event has occurred.</term>
            </item>
            <item>
            <term><c>DBT_USERDEFINED</c> 0xFFFF</term>
            <term>The meaning of this message is user-defined.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            A pointer to a structure that contains event-specific data. Its format depends on the value of the wParam parameter. For more
            information, refer to the documentation for each event.
            </para>
            <para><strong>Returns</strong></para>
            <para>Return <c>TRUE</c> to grant the request.</para>
            <para>Return <c>BROADCAST_QUERY_DENY</c> to deny the request.</para>
            <remarks>
            For devices that offer software-controllable features, such as ejection and locking, the system typically sends a
            DBT_DEVICEREMOVEPENDING message to let applications and device drivers end their use of the device gracefully. If the system
            forcibly removes a device, it may not send a DBT_DEVICEQUERYREMOVE message before doing so.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MDICREATE">
            <summary>
            <para>
            An application sends the <c>WM_MDICREATE</c> message to a multiple-document interface (MDI) client window to create an MDI
            child window.
            </para>
            <para>
            <code>#define WM_MDICREATE 0x0220</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>
            A pointer to an <c>MDICREATESTRUCT</c> structure containing information that the system uses to create the MDI child window.
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>HWND</c></para>
            <para>If the message succeeds, the return value is the handle to the new child window.</para>
            <para>If the message fails, the return value is <c>NULL</c>.</para>
            <remarks>
            <para>
            The MDI child window is created with the <c>window style</c> bits <c>WS_CHILD</c>, <c>WS_CLIPSIBLINGS</c>,
            <c>WS_CLIPCHILDREN</c>, <c>WS_SYSMENU</c>, <c>WS_CAPTION</c>, <c>WS_THICKFRAME</c>, <c>WS_MINIMIZEBOX</c>, and
            <c>WS_MAXIMIZEBOX</c>, plus additional style bits specified in the <c>MDICREATESTRUCT</c> structure. The system adds the
            title of the new child window to the window menu of the frame window. An application should use this message to create all
            child windows of the client window.
            </para>
            <para>
            If an MDI client window receives any message that changes the activation of its child windows while the active child window
            is maximized, the system restores the active child window and maximizes the newly activated child window.
            </para>
            <para>
            When an MDI child window is created, the system sends the <c>WM_CREATE</c> message to the window. The lParam parameter of the
            <c>WM_CREATE</c> message contains a pointer to a <c>CREATESTRUCT</c> structure. The lpCreateParams member of this structure
            contains a pointer to the <c>MDICREATESTRUCT</c> structure passed with the <c>WM_MDICREATE</c> message that created the MDI
            child window.
            </para>
            <para>
            An application should not send a second <c>WM_MDICREATE</c> message while a <c>WM_MDICREATE</c> message is still being
            processed. For example, it should not send a <c>WM_MDICREATE</c> message while an MDI child window is processing its
            <c>WM_MDICREATE</c> message.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MDIDESTROY">
            <summary>
            <para>
            An application sends the <c>WM_MDIDESTROY</c> message to a multiple-document interface (MDI) client window to close an MDI
            child window.
            </para>
            <para>
            <code>#define WM_MDIDESTROY 0x0221</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the MDI child window to be closed.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>zero</c></para>
            <para>This message always returns zero.</para>
            <remarks>
            <para>
            This message removes the title of the MDI child window from the MDI frame window and deactivates the child window. An
            application should use this message to close all MDI child windows.
            </para>
            <para>
            If an MDI client window receives a message that changes the activation of its child windows and the active MDI child window
            is maximized, the system restores the active child window and maximizes the newly activated child window.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MDIACTIVATE">
            <summary>
            <para>
            An application sends the <c>WM_MDIACTIVATE</c> message to a multiple-document interface (MDI) client window to instruct the
            client window to activate a different MDI child window.
            </para>
            <para>
            <code>#define WM_MDIACTIVATE 0x0222</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the MDI child window to be activated.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If an application sends this message to an MDI client window, the return value is zero.</para>
            <para>An MDI child window should return zero if it processes this message.</para>
            <remarks>
            <para>
            As the client window processes this message, it sends <c>WM_MDIACTIVATE</c> to the child window being deactivated and to the
            child window being activated. The message parameters received by an MDI child window are as follows:
            </para>
            <list>
            <item>
            <term>
            <para>wParam</para>
            </term>
            <term>
            <para>lParam</para>
            </term>
            </item>
            </list>
            <para>
            An MDI child window is activated independently of the MDI frame window. When the frame window becomes active, the child
            window last activated by using the <c>WM_MDIACTIVATE</c> message receives the <c>WM_NCACTIVATE</c> message to draw an active
            window frame and title bar; the child window does not receive another <c>WM_MDIACTIVATE</c> message.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MDIRESTORE">
            <summary>
            <para>
            An application sends the <c>WM_MDIRESTORE</c> message to a multiple-document interface (MDI) client window to restore an MDI
            child window from maximized or minimized size.
            </para>
            <para>
            <code>#define WM_MDIRESTORE 0x0223</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the MDI child window to be restored.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>zero</c></para>
            <para>The return value is always zero.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MDINEXT">
            <summary>
            <para>
            An application sends the <c>WM_MDINEXT</c> message to a multiple-document interface (MDI) client window to activate the next
            or previous child window.
            </para>
            <para>
            <code>#define WM_MDINEXT 0x0224</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            A handle to the MDI child window. The system activates the child window that is immediately before or after the specified
            child window, depending on the value of the lParam parameter. If the wParam parameter is <c>NULL</c>, the system activates
            the child window that is immediately before or after the currently active child window.
            </para>
            <para><em>lParam</em></para>
            <para>
            If this parameter is zero, the system activates the next MDI child window and places the child window identified by the
            wParam parameter behind all other child windows. If this parameter is nonzero, the system activates the previous child
            window, placing it in front of the child window identified by wParam.
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>zero</c></para>
            <para>The return value is always zero.</para>
            <remarks>
            If an MDI client window receives any message that changes the activation of its child windows while the active MDI child
            window is maximized, the system restores the active child window and maximizes the newly activated child window.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MDIMAXIMIZE">
            <summary>
            <para>
            An application sends the <c>WM_MDIMAXIMIZE</c> message to a multiple-document interface (MDI) client window to maximize an
            MDI child window. The system resizes the child window to make its client area fill the client window. The system places the
            child window's window menu icon in the rightmost position of the frame window's menu bar, and places the child window's
            restore icon in the leftmost position. The system also appends the title bar text of the child window to that of the frame window.
            </para>
            <para>
            <code>#define WM_MDIMAXIMIZE 0x0225</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the MDI child window to be maximized.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>zero</c></para>
            <para>The return value is always zero.</para>
            <remarks>
            If an MDI client window receives any message that changes the activation of its child windows while the currently active MDI
            child window is maximized, the system restores the active child window and maximizes the newly activated child window.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MDITILE">
            <summary>
            <para>
            An application sends the <c>WM_MDITILE</c> message to a multiple-document interface (MDI) client window to arrange all of its
            MDI child windows in a tile format.
            </para>
            <para>
            <code>#define WM_MDITILE 0x0226</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The tiling option. This parameter can be one of the following values, optionally combined with <c>MDITILE_SKIPDISABLED</c> to
            prevent disabled MDI child windows from being tiled.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MDITILE_HORIZONTAL</c> 0x0001</term>
            <term>Tiles windows horizontally.</term>
            </item>
            <item>
            <term><c>MDITILE_VERTICAL</c> 0x0000</term>
            <term>Tiles windows vertically.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>BOOL</c></para>
            <para>If the message succeeds, the return value is <c>TRUE</c>.</para>
            <para>If the message fails, the return value is <c>FALSE</c>.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MDICASCADE">
            <summary>
            <para>
            An application sends the <c>WM_MDICASCADE</c> message to a multiple-document interface (MDI) client window to arrange all its
            child windows in a cascade format.
            </para>
            <para>
            <code>#define WM_MDICASCADE 0x0227</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The cascade behavior. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MDITILE_SKIPDISABLED</c> 0x0002</term>
            <term>Prevents disabled MDI child windows from being cascaded.</term>
            </item>
            <item>
            <term><c>MDITILE_ZORDER</c> 0x0004</term>
            <term>Arranges the windows in Z order.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>BOOL</c></para>
            <para>If the message succeeds, the return value is <c>TRUE</c>.</para>
            <para>If the message fails, the return value is <c>FALSE</c>.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MDIICONARRANGE">
            <summary>
            <para>
            An application sends the <c>WM_MDIICONARRANGE</c> message to a multiple-document interface (MDI) client window to arrange all
            minimized MDI child windows. It does not affect child windows that are not minimized.
            </para>
            <para>
            <code>#define WM_MDIICONARRANGE 0x0228</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used; it must be zero.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used; it must be zero.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MDIGETACTIVE">
            <summary>
            <para>
            An application sends the <c>WM_MDIGETACTIVE</c> message to a multiple-document interface (MDI) client window to retrieve the
            handle to the active MDI child window.
            </para>
            <para>
            <code>#define WM_MDIGETACTIVE 0x0229</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>
            The maximized state. If this parameter is not <c>NULL</c>, it is a pointer to a value that indicates the maximized state of
            the MDI child window. If the value is <c>TRUE</c>, the window is maximized; a value of <c>FALSE</c> indicates that it is not.
            If this parameter is <c>NULL</c>, the parameter is ignored.
            </para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>HWND</c></para>
            <para>The return value is the handle to the active MDI child window.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MDISETMENU">
            <summary>
            <para>
            An application sends the <c>WM_MDISETMENU</c> message to a multiple-document interface (MDI) client window to replace the
            entire menu of an MDI frame window, to replace the window menu of the frame window, or both.
            </para>
            <para>
            <code>#define WM_MDISETMENU 0x0230</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the new frame window menu. If this parameter is <c>NULL</c>, the frame window menu is not changed.</para>
            <para><em>lParam</em></para>
            <para>A handle to the new window menu. If this parameter is <c>NULL</c>, the window menu is not changed.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>HMENU</c></para>
            <para>If the message succeeds, the return value is the handle to the old frame window menu.</para>
            <para>If the message fails, the return value is zero.</para>
            <remarks>
            <para>After sending this message, an application must call the <c>DrawMenuBar</c> function to update the menu bar.</para>
            <para>
            If this message replaces the window menu, the MDI child window menu items are removed from the previous window menu and added
            to the new window menu.
            </para>
            <para>
            If an MDI child window is maximized and this message replaces the MDI frame window menu, the window menu icon and restore
            icon are removed from the previous frame window menu and added to the new frame window menu.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_ENTERSIZEMOVE">
            <summary>
            <para>
            Sent one time to a window after it enters the moving or sizing modal loop. The window enters the moving or sizing modal loop
            when the user clicks the window's title bar or sizing border, or when the window passes the <c>WM_SYSCOMMAND</c> message to
            the <c>DefWindowProc</c> function and the wParam parameter of the message specifies the <c>SC_MOVE</c> or <c>SC_SIZE</c>
            value. The operation is complete when <c>DefWindowProc</c> returns.
            </para>
            <para>The system sends the <c>WM_ENTERSIZEMOVE</c> message regardless of whether the dragging of full windows is enabled.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_ENTERSIZEMOVE 0x0231</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>An application should return zero if it processes this message.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_EXITSIZEMOVE">
            <summary>
            <para>
            Sent one time to a window, after it has exited the moving or sizing modal loop. The window enters the moving or sizing modal
            loop when the user clicks the window's title bar or sizing border, or when the window passes the <c>WM_SYSCOMMAND</c> message
            to the <c>DefWindowProc</c> function and the wParam parameter of the message specifies the <c>SC_MOV</c> E or <c>SC_SIZE</c>
            value. The operation is complete when <c>DefWindowProc</c> returns.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_EXITSIZEMOVE 0x0232</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>An application should return zero if it processes this message.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_DROPFILES">
            <summary>
            <para>
            Sent when the user drops a file on the window of an application that has registered itself as a recipient of dropped files.
            </para>
            <para>
            <code>PostMessage( (HWND) hWndControl, // handle to destination control (UINT) WM_DROPFILES, // message ID (WPARAM) wParam, // = (WPARAM) (HDROP) hDrop; (LPARAM) lParam // = 0; not used, must be zero );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hDrop</em></para>
            <para>
            A handle to an internal structure describing the dropped files. Pass this handle <c>DragFinish</c>, <c>DragQueryFile</c>, or
            <c>DragQueryPoint</c> to retrieve information about the dropped files.
            </para>
            <para><em>lParam</em></para>
            <para>Must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>An application should return zero if it processes this message.</para>
            <remarks>
            The HDROP handle is declared in Shellapi.h. You must include this header in your build to use <c>WM_DROPFILES</c>. For
            further discussion of how to use drag-and-drop to transfer Shell data, see Transferring Shell Data Using Drag-and-Drop or the Clipboard.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MDIREFRESHMENU">
            <summary>
            <para>
            An application sends the <c>WM_MDIREFRESHMENU</c> message to a multiple-document interface (MDI) client window to refresh the
            window menu of the MDI frame window.
            </para>
            <para>
            <code>#define WM_MDIREFRESHMENU 0x0234</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>HMENU</c></para>
            <para>If the message succeeds, the return value is the handle to the frame window menu.</para>
            <para>If the message fails, the return value is <c>NULL</c>.</para>
            <remarks>After sending this message, an application must call the <c>DrawMenuBar</c> function to update the menu bar.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_IME_SETCONTEXT">
            <summary>
            <para>Sent to an application when a window is activated. A window receives this message through its WindowProc function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, WM_IME_SETCONTEXT, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hwnd</em></para>
            <para>A handle to window.</para>
            <para><em>wParam</em></para>
            <para><c>TRUE</c> if the window is active, and <c>FALSE</c> otherwise.</para>
            <para><em>lParam</em></para>
            <para>Display options. This parameter can have one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>ISC_SHOWUICOMPOSITIONWINDOW</c></term>
            <term>Show the composition window by user interface window.</term>
            </item>
            <item>
            <term><c>ISC_SHOWUIGUIDWINDOW</c></term>
            <term>Show the guide window by user interface window.</term>
            </item>
            <item>
            <term><c>ISC_SHOWUISOFTKBD</c></term>
            <term>Show the soft keyboard by user interface window.</term>
            </item>
            <item>
            <term><c>ISC_SHOWUICANDIDATEWINDOW</c></term>
            <term>Show the candidate window of index 0 by user interface window.</term>
            </item>
            <item>
            <term>ISC_SHOWUICANDIDATEWINDOW &lt;&lt; 1</term>
            <term>Show the candidate window of index 1 by user interface window.</term>
            </item>
            <item>
            <term>ISC_SHOWUICANDIDATEWINDOW &lt;&lt; 2</term>
            <term>Show the candidate window of index 2 by user interface window.</term>
            </item>
            <item>
            <term>ISC_SHOWUICANDIDATEWINDOW &lt;&lt; 3</term>
            <term>Show the candidate window of index 3 by user interface window.</term>
            </item>
            </list>
            <para><strong>Returns</strong></para>
            <para>Returns the value returned by <c>DefWindowProc</c> or <c>ImmIsUIMessage</c>.</para>
            <remarks>
            <para>
            If the application has created an IME window, it should call <c>ImmIsUIMessage</c>. Otherwise, it should pass this message to <c>DefWindowProc</c>.
            </para>
            <para>
            If the application draws the composition window, the default IME window does not have to show its composition window. In this
            case, the application must clear the <c>ISC_SHOWUICOMPOSITIONWINDOW</c> value from the lParam parameter before passing the
            message to <c>DefWindowProc</c> or <c>ImmIsUIMessage</c>. To display a certain user interface window, an application should
            remove the corresponding value so that the IME will not display it.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_IME_NOTIFY">
            <summary>
            <para>
            Sent to an application to notify it of changes to the IME window. A window receives this message through its
            <c>WindowProc</c> function.
            </para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, WM_IME_NOTIFY, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hwnd</em></para>
            <para>A handle to window.</para>
            <para><em>wParam</em></para>
            <para>The command. This parameter can have one of the following values.</para>
            <list/>
            <para><em>lParam</em></para>
            <para>
            Command-specific data, with format dependent on the value of the wParam parameter. For more information, refer to the
            documentation for each command.
            </para>
            <para><strong>Returns</strong></para>
            <para>The return value depends on the command sent.</para>
            <remarks>An application processes this message if it is responsible for managing the IME window.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_IME_CONTROL">
            <summary>
            <para>
            Sent by an application to direct the IME window to carry out the requested command. The application uses this message to
            control the IME window that it has created. To send this message, the application calls the <c>SendMessage</c> function with
            the following parameters.
            </para>
            <para>
            <code>SendMessage( HWND hwnd, WM_IME_CONTROL, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hwnd</em></para>
            <para>Handle to the window.</para>
            <para><em>wParam</em></para>
            <para>The command. This parameter can have one of the following values:</para>
            <list/>
            <para><em>lParam</em></para>
            <para>
            Command-specific data, with format dependent on the value of the wParam parameter. For more information, refer to the
            documentation for each command.
            </para>
            <para><strong>Returns</strong></para>
            <para>The message returns a command-specific value.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_IME_COMPOSITIONFULL">
            <summary>
            <para>
            Sent to an application when the IME window finds no space to extend the area for the composition window. A window receives
            this message through its <c>WindowProc</c> function.
            </para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, WM_IME_COMPOSITIONFULL, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><strong>Returns</strong></para>
            <para>This message has no return value.</para>
            <remarks>
            <para>The application should use the IMC_SETCOMPOSITIONWINDOW command to specify how the window should be displayed.</para>
            <para>The IME window, instead of the IME, sends this notification message by the <c>SendMessage</c> function.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_IME_SELECT">
            <summary>
            <para>
            Sent to an application when the operating system is about to change the current IME. A window receives this message through
            its WindowProc function.
            </para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, WM_IME_SELECT, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hwnd</em></para>
            <para>A handle to window.</para>
            <para><em>wParam</em></para>
            <para>
            Selection indicator. This parameter specifies <c>TRUE</c> if the indicated IME is selected. The parameter is set to
            <c>FALSE</c> if the specified IME is no longer selected.
            </para>
            <para><em>lParam</em></para>
            <para>Input locale identifier associated with the IME.</para>
            <para><strong>Returns</strong></para>
            <para>This message has no return value.</para>
            <remarks>
            <para>
            An application that has created an IME window should pass this message to that window so that it can retrieve the keyboard
            layout handle to the newly selected IME.
            </para>
            <para>The <c>DefWindowProc</c> function processes this message by passing the information to the default IME window.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_IME_CHAR">
            <summary>
            <para>
            Sent to an application when the IME gets a character of the conversion result. A window receives this message through its
            <c>WindowProc</c> function.
            </para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, WM_IME_CHAR, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hwnd</em></para>
            <para>A handle to window.</para>
            <para><em>wParam</em></para>
            <para>
            <c>DBCS:</c> A single-byte or double-byte character value. For a double-byte character, (BYTE)(wParam &gt;&gt; 8) contains
            the lead byte. Note that the parentheses are necessary because the cast operator has higher precedence than the shift operator.
            </para>
            <para><c>Unicode:</c> A Unicode character value.</para>
            <para><em>lParam</em></para>
            <para>
            The repeat count, scan code, extended key flag, context code, previous key state flag, and transition state flag, with values
            as defined below.
            </para>
            <list type="table">
            <listheader>
            <term>Bit</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0-15</term>
            <term>Repeat count. Since the first byte and second byte are continuous, this is always 1.</term>
            </item>
            <item>
            <term>16-23</term>
            <term>Scan code for a complete Asian character.</term>
            </item>
            <item>
            <term>24</term>
            <term>Extended key.</term>
            </item>
            <item>
            <term>25-28</term>
            <term>Not used.</term>
            </item>
            <item>
            <term>29</term>
            <term>Context code.</term>
            </item>
            <item>
            <term>30</term>
            <term>Previous key state.</term>
            </item>
            <item>
            <term>31</term>
            <term>Transition state.</term>
            </item>
            </list>
            <remarks>
            <para>
            Unlike the <c>WM_CHAR</c> message for a non-Unicode window, this message can include double-byte and single-byte character
            values. For a Unicode window, this message is the same as WM_CHAR.
            </para>
            <para>
            For a non-Unicode window, if the WM_IME_CHAR message includes a double-byte character and the application passes this message
            to <c>DefWindowProc</c>, the IME converts this message into two WM_CHAR messages, each containing one byte of the double-byte character.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_IME_REQUEST">
            <summary>
            <para>
            Sent to an application to provide commands and request information. A window receives this message through its
            <c>WindowProc</c> function.
            </para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, WM_IME_REQUEST, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hwnd</em></para>
            <para>A handle to window.</para>
            <para><em>wParam</em></para>
            <para>Command. This parameter can have one of the following values:</para>
            <list/>
            <para><em>lParam</em></para>
            <para>Command-specific data. For more information, see the description for each command.</para>
            <para><strong>Returns</strong></para>
            <para>Returns a command-specific value.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_IME_KEYDOWN">
            <summary>
            <para>
            Sent to an application by the IME to notify the application of a key press and to keep message order. A window receives this
            message through its <c>WindowProc</c> function.
            </para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, WM_IME_KEYDOWN, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hwnd</em></para>
            <para>A handle to window.</para>
            <para><em>wParam</em></para>
            <para>Virtual key code of the key.</para>
            <para><em>lParam</em></para>
            <para>
            Repeat count, scan code, extended key flag, context code, previous key state flag, and transition state flag, as shown in the
            following table.
            </para>
            <list type="table">
            <listheader>
            <term>Bit</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0-15</term>
            <term>Repeat count.</term>
            </item>
            <item>
            <term>16-23</term>
            <term>Scan code.</term>
            </item>
            <item>
            <term>24</term>
            <term>Extended key. This value is 1 if it is an extended key. Otherwise, it is 0.</term>
            </item>
            <item>
            <term>25-28</term>
            <term>Not used.</term>
            </item>
            <item>
            <term>29</term>
            <term>Context code. This value is always 0.</term>
            </item>
            <item>
            <term>30</term>
            <term>Previous key state. This value is 1 if the key is down or 0 if it is up.</term>
            </item>
            <item>
            <term>31</term>
            <term>Transition state. This value is always 0.</term>
            </item>
            </list>
            <para><strong>Returns</strong></para>
            <para>An application should return 0 if it processes this message.</para>
            <remarks>
            An application can process this message or pass it to the <c>DefWindowProc</c> function to generate a matching
            <c>WM_KEYDOWN</c> message.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_IME_KEYUP">
            <summary>
            <para>
            Sent to an application by the IME to notify the application of a key release and to keep message order. A window receives
            this message through its <c>WindowProc</c> function.
            </para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, WM_IME_KEYUP, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hwnd</em></para>
            <para>A handle to window.</para>
            <para><em>wParam</em></para>
            <para>Virtual key code of the key.</para>
            <para><em>lParam</em></para>
            <para>
            Repeat count, scan code, extended key flag, context code, previous key state flag, and transition state flag, as shown below.
            </para>
            <list type="table">
            <listheader>
            <term>Bit</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0-15</term>
            <term>Repeat count. This value is always 1.</term>
            </item>
            <item>
            <term>16-23</term>
            <term>Scan code.</term>
            </item>
            <item>
            <term>24</term>
            <term>Extended key. This value is 1 if it is an extended key. Otherwise, it is 0.</term>
            </item>
            <item>
            <term>25-28</term>
            <term>Not used.</term>
            </item>
            <item>
            <term>29</term>
            <term>Context code. This value is always 0.</term>
            </item>
            <item>
            <term>30</term>
            <term>Previous key state. This value is always 1.</term>
            </item>
            <item>
            <term>31</term>
            <term>Transition state. This value is always 1.</term>
            </item>
            </list>
            <para><strong>Returns</strong></para>
            <para>An application should return 0 if it processes this message.</para>
            <remarks>
            An application can process this message or pass it to the <c>DefWindowProc</c> function to generate a matching
            <c>WM_KEYUP</c> message.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MOUSEHOVER">
            <summary>
            <para>
            Posted to a window when the cursor hovers over the client area of the window for the period of time specified in a prior call
            to <c>TrackMouseEvent</c>.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_MOUSEHOVER 0x02A1</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Indicates whether various virtual keys are down. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is depressed.</term>
            </item>
            <item>
            <term><c>MK_LBUTTON</c> 0x0001</term>
            <term>The left mouse button is depressed.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is depressed.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The right mouse button is depressed.</term>
            </item>
            <item>
            <term><c>MK_SHIFT</c> 0x0004</term>
            <term>The SHIFT key is depressed.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the x-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para>
            The high-order word specifies the y-coordinate of the cursor. The coordinate is relative to the upper-left corner of the
            client area.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            Hover tracking stops when <c>WM_MOUSEHOVER</c> is generated. The application must call <c>TrackMouseEvent</c> again if it
            requires further tracking of mouse hover behavior.
            </para>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the <c>MAKEPOINTS</c> macro to obtain a <c>POINTS</c> structure from the
            return value. You can also use the <c>GET_X_LPARAM</c> or <c>GET_Y_LPARAM</c> macro to extract the x- or y-coordinate.
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_MOUSELEAVE">
            <summary>
            <para>Posted to a window when the cursor leaves the client area of the window specified in a prior call to <c>TrackMouseEvent</c>.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_MOUSELEAVE 0x02A3</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            All tracking requested by <c>TrackMouseEvent</c> is canceled when this message is generated. The application must call
            <c>TrackMouseEvent</c> when the mouse reenters its window if it requires further tracking of mouse hover behavior.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCMOUSEHOVER">
            <summary>
            <para>
            Posted to a window when the cursor hovers over the nonclient area of the window for the period of time specified in a prior
            call to <c>TrackMouseEvent</c>.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCMOUSEHOVER 0x02A0</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The hit-test value returned by the <c>DefWindowProc</c> function as a result of processing the <c>WM_NCHITTEST</c> message.
            For a list of hit-test values, see <c>WM_NCHITTEST</c>.
            </para>
            <para><em>lParam</em></para>
            <para>
            A <c>POINTS</c> structure that contains the x- and y-coordinates of the cursor. The coordinates are relative to the
            upper-left corner of the screen.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            Hover tracking stops when this message is generated. The application must call <c>TrackMouseEvent</c> again if it requires
            further tracking of mouse hover behavior.
            </para>
            <para>
            You can also use the <c>GET_X_LPARAM</c> and <c>GET_Y_LPARAM</c> macros to extract the values of the x- and y- coordinates
            from lParam.
            </para>
            <para>
            <code>xPos = GET_X_LPARAM(lParam); yPos = GET_Y_LPARAM(lParam);</code>
            </para>
            <para>
            <para>Important</para>
            <para>
            Do not use the <c>LOWORD</c> or <c>HIWORD</c> macros to extract the x- and y- coordinates of the cursor position because
            these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x-
            and y- coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_NCMOUSELEAVE">
            <summary>
            <para>Posted to a window when the cursor leaves the nonclient area of the window specified in a prior call to <c>TrackMouseEvent</c>.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_NCMOUSELEAVE 0x02A2</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            All tracking requested by <c>TrackMouseEvent</c> is canceled when this message is generated. The application must call
            <c>TrackMouseEvent</c> when the mouse reenters its window if it requires further tracking of mouse hover behavior.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_WTSSESSION_CHANGE">
            <summary>
            <para>Notifies applications of changes in session state.</para>
            <para>The window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hWnd, // handle to window UINT Msg, // WM_WTSSESSION_CHANGE WPARAM wParam, // session state change event LPARAM lParam // session ID );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>hWnd</em></para>
            <para>Handle to the window.</para>
            <para><em>Msg</em></para>
            <para>Specifies the message ( <c>WM_WTSSESSION_CHANGE</c>).</para>
            <para><em>wParam</em></para>
            <para>
            Status code describing the reason the session state change notification was sent. This parameter can be one of the following values.
            </para>
            <para><em><c>WTS_CONSOLE_CONNECT</c> (0x1)</em></para>
            <para>The session identified by lParam was connected to the console terminal or RemoteFX session.</para>
            <para><em><c>WTS_CONSOLE_DISCONNECT</c> (0x2)</em></para>
            <para>The session identified by lParam was disconnected from the console terminal or RemoteFX session.</para>
            <para><em><c>WTS_REMOTE_CONNECT</c> (0x3)</em></para>
            <para>The session identified by lParam was connected to the remote terminal.</para>
            <para><em><c>WTS_REMOTE_DISCONNECT</c> (0x4)</em></para>
            <para>The session identified by lParam was disconnected from the remote terminal.</para>
            <para><em><c>WTS_SESSION_LOGON</c> (0x5)</em></para>
            <para>A user has logged on to the session identified by lParam.</para>
            <para><em><c>WTS_SESSION_LOGOFF</c> (0x6)</em></para>
            <para>A user has logged off the session identified by lParam.</para>
            <para><em><c>WTS_SESSION_LOCK</c> (0x7)</em></para>
            <para>The session identified by lParam has been locked.</para>
            <para><em><c>WTS_SESSION_UNLOCK</c> (0x8)</em></para>
            <para>The session identified by lParam has been unlocked.</para>
            <para><em><c>WTS_SESSION_REMOTE_CONTROL</c> (0x9)</em></para>
            <para>
            The session identified by lParam has changed its remote controlled status. To determine the status, call
            <c>GetSystemMetrics</c> and check the <c>SM_REMOTECONTROL</c> metric.
            </para>
            <para><em><c>WTS_SESSION_CREATE</c> (0xA)</em></para>
            <para>Reserved for future use.</para>
            <para><em><c>WTS_SESSION_TERMINATE</c> (0xB)</em></para>
            <para>Reserved for future use.</para>
            <para><strong>Returns</strong></para>
            <para>The return value is ignored.</para>
            <remarks>
            <para>This message is sent only to applications that have registered to receive this message by calling <c>WTSRegisterSessionNotification</c>.</para>
            <para>
            Examples of how applications can respond to this message include releasing or acquiring console-specific resources,
            determining how a screen is to be painted, or triggering console animation effects.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_TABLET_LAST">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_DPICHANGED">
            <summary>
            <para>
            Sent when the effective dots per inch (dpi) for a window has changed. The DPI is the scale factor for a window. There are
            multiple events that can cause the DPI to change. The following list indicates the possible causes for the change in DPI.
            </para>
            <list type="bullet">
            <item>
            <term>The window is moved to a new monitor that has a different DPI.</term>
            </item>
            <item>
            <term>The DPI of the monitor hosting the window changes.</term>
            </item>
            </list>
            <para>
            The current DPI for a window always equals the last DPI sent by <c>WM_DPICHANGED</c>. This is the scale factor that the
            window should be scaling to for threads that are aware of DPI changes.
            </para>
            <para>
            <code>#define WM_DPICHANGED 0x02E0</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The <c>HIWORD</c> of the wParam contains the Y-axis value of the new dpi of the window. The <c>LOWORD</c> of the wParam
            contains the X-axis value of the new DPI of the window. For example, 96, 120, 144, or 192. The values of the X-axis and the
            Y-axis are identical for Windows apps.
            </para>
            <para><em>lParam</em></para>
            <para>
            A pointer to a <c>RECT</c> structure that provides a suggested size and position of the current window scaled for the new
            DPI. The expectation is that apps will reposition and resize windows based on the suggestions provided by lParam when
            handling this message.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            This message is only relevant for <c>PROCESS_PER_MONITOR_DPI_AWARE</c> applications or <c>DPI_AWARENESS_PER_MONITOR_AWARE</c>
            threads. It may be received on certain DPI changes if your top-level window or process is running as <c>DPI unaware</c> or
            <c>system DPI aware</c>, but in those situations it can be safely ignored. For more information about the different types of
            awareness, see <c>PROCESS_DPI_AWARENESS</c> and <c>DPI_AWARENESS</c>. Older versions of Windows required DPI awareness to be
            tied at the level of an application. Those apps use <c>PROCESS_DPI_AWARENESS</c>. Currently, DPI awareness is tied to threads
            and individual windows rather than the entire application. These apps use <c>DPI_AWARENESS</c>.
            </para>
            <para>You only need to use either the X-axis or the Y-axis value when scaling your application since they are the same.</para>
            <para>
            In order to handle this message correctly, you will need to resize and reposition your window based on the suggestions
            provided by lParam and using <c>SetWindowPos</c>. If you do not do this, your window will grow or shrink with respect to
            everything else on the new monitor. For example, if a user is using multiple monitors and drags your window from a 96 DPI
            monitor to a 192 DPI monitor, your window will appear to be half as large with respect to other items on the 192 DPI monitor.
            </para>
            <para>
            The base value of DPI is defined as <c>USER_DEFAULT_SCREEN_DPI</c> which is set to 96. To determine the scaling factor for a
            monitor, take the DPI value and divide by <c>USER_DEFAULT_SCREEN_DPI</c>. The following table provides some sample DPI values
            and associated scaling factors.
            </para>
            <list type="table">
            <listheader>
            <term>DPI value</term>
            <term>Scaling percentage</term>
            </listheader>
            <item>
            <term>96</term>
            <term>100%</term>
            </item>
            <item>
            <term>120</term>
            <term>125%</term>
            </item>
            <item>
            <term>144</term>
            <term>150%</term>
            </item>
            <item>
            <term>192</term>
            <term>200%</term>
            </item>
            </list>
            <para>The following example provides a sample DPI change handler.</para>
            <para>
            <code> case WM_DPICHANGED: { g_dpi = HIWORD(wParam); UpdateDpiDependentFontsAndResources(); RECT* const prcNewWindow = (RECT*)lParam; SetWindowPos(hWnd, NULL, prcNewWindow -&gt;left, prcNewWindow -&gt;top, prcNewWindow-&gt;right - prcNewWindow-&gt;left, prcNewWindow-&gt;bottom - prcNewWindow-&gt;top, SWP_NOZORDER | SWP_NOACTIVATE); break; }</code>
            </para>
            <para>The following code linearly scales a value from 100% (96 DPI) to an arbitrary DPI defined by g_dpi.</para>
            <para>
            <code> INT iBorderWidth100 = 5; iBorderWidth = MulDiv(iBorderWidth100, g_dpi, USER_DEFAULT_SCREEN_DPI);</code>
            </para>
            <para>An alternative way to scale a value is to convert the DPI value into a scale factor and use that.</para>
            <para>
            <code> INT iBorderWidth100 = 5; FLOAT fscale = (float) g_dpi / USER_DEFAULT_SCREEN_DPI; iBorderWidth = iBorderWidth100 * fscale;</code>
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CUT">
            <summary>
            <para>
            An application sends a <c>WM_CUT</c> message to an edit control or combo box to delete (cut) the current selection, if any,
            in the edit control and copy the deleted text to the clipboard in <c>CF_TEXT</c> format.
            </para>
            <para>
            <code>#define WM_CUT 0x0300</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>This message does not return a value.</para>
            <remarks>
            <para>The deletion performed by the <c>WM_CUT</c> message can be undone by sending the edit control an <c>EM_UNDO</c> message.</para>
            <para>To delete the current selection without placing the deleted text on the clipboard, use the <c>WM_CLEAR</c> message.</para>
            <para>
            When sent to a combo box, the <c>WM_CUT</c> message is handled by its edit control. This message has no effect when sent to a
            combo box with the <c>CBS_DROPDOWNLIST</c> style.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_COPY">
            <summary>
            <para>
            An application sends the <c>WM_COPY</c> message to an edit control or combo box to copy the current selection to the
            clipboard in <c>CF_TEXT</c> format.
            </para>
            <para>
            <code>#define WM_COPY 0x0301</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>Returns nonzero value on success, else zero.</para>
            <remarks>
            When sent to a combo box, the <c>WM_COPY</c> message is handled by its edit control. This message has no effect when sent to
            a combo box with the <c>CBS_DROPDOWNLIST</c> style.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_PASTE">
            <summary>
            <para>
            An application sends a <c>WM_PASTE</c> message to an edit control or combo box to copy the current content of the clipboard
            to the edit control at the current caret position. Data is inserted only if the clipboard contains data in <c>CF_TEXT</c> format.
            </para>
            <para>
            <code>#define WM_PASTE 0x0302</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>This message does not return a value.</para>
            <remarks>
            When sent to a combo box, the <c>WM_PASTE</c> message is handled by its edit control. This message has no effect when sent to
            a combo box with the <c>CBS_DROPDOWNLIST</c> style.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CLEAR">
            <summary>
            <para>
            An application sends a <c>WM_CLEAR</c> message to an edit control or combo box to delete (clear) the current selection, if
            any, from the edit control.
            </para>
            <para>
            <code>#define WM_CLEAR 0x0303</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>This message does not return a value.</para>
            <remarks>
            <para>The deletion performed by the <c>WM_CLEAR</c> message can be undone by sending the edit control an <c>EM_UNDO</c> message.</para>
            <para>To delete the current selection and place the deleted content on the clipboard, use the <c>WM_CUT</c> message.</para>
            <para>
            When sent to a combo box, the <c>WM_CLEAR</c> message is handled by its edit control. This message has no effect when sent to
            a combo box with the <c>CBS_DROPDOWNLIST</c> style.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_UNDO">
            <summary>
            An application sends a <c>WM_UNDO</c> message to an edit control to undo the last operation. When this message is sent to an
            edit control, the previously deleted text is restored or the previously added text is deleted.
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Not used; must be zero.</para>
            <para><em>lParam</em></para>
            <para>Not used; must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>If the message succeeds, the return value is <c>TRUE</c>.</para>
            <para>If the message fails, the return value is <c>FALSE</c>.</para>
            <remarks><c>Rich Edit:</c> It is recommended that <c>EM_UNDO</c> be used instead of <c>WM_UNDO</c>.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_RENDERFORMAT">
            <summary>
            <para>
            Sent to the clipboard owner if it has delayed rendering a specific clipboard format and if an application has requested data
            in that format. The clipboard owner must render data in the specified format and place it on the clipboard by calling the
            <c>SetClipboardData</c> function.
            </para>
            <para>
            <code>#define WM_RENDERFORMAT 0x0305</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The clipboard format to be rendered.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            When responding to a <c>WM_RENDERFORMAT</c> message, the clipboard owner must not open the clipboard before calling
            <c>SetClipboardData</c>. Opening the clipboard is not necessary before placing data in response to <c>WM_RENDERFORMAT</c>,
            and any attempt to open the clipboard will fail because the clipboard is currently being held open by the application that
            requested the format to be rendered.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_RENDERALLFORMATS">
            <summary>
            <para>
            Sent to the clipboard owner before it is destroyed, if the clipboard owner has delayed rendering one or more clipboard
            formats. For the content of the clipboard to remain available to other applications, the clipboard owner must render data in
            all the formats it is capable of generating, and place the data on the clipboard by calling the <c>SetClipboardData</c> function.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_RENDERALLFORMATS 0x0306</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            When responding to a <c>WM_RENDERALLFORMATS</c> message, the application must call the <c>OpenClipboard</c> function and then
            check that it is still the clipboard owner by calling the <c>GetClipboardOwner</c> function before calling <c>SetClipboardData</c>.
            </para>
            <para>
            The application needs to check that it is still the clipboard owner after opening the clipboard because after it receives the
            <c>WM_RENDERALLFORMATS</c> message, but before it opens the clipboard, another application may have opened and taken
            ownership of the clipboard, and that application's data should not be overwritten.
            </para>
            <para>
            In most cases, the application should not call the <c>EmptyClipboard</c> function before calling <c>SetClipboardData</c>,
            since doing so will erase the clipboard formats that the application has already rendered.
            </para>
            <para>
            When the application returns, the system removes any unrendered formats from the list of available clipboard formats. For
            information about delayed rendering, see Delayed Rendering.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_DESTROYCLIPBOARD">
            <summary>
            <para>Sent to the clipboard owner when a call to the <c>EmptyClipboard</c> function empties the clipboard.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_DESTROYCLIPBOARD 0x0307</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_DRAWCLIPBOARD">
            <summary>
            <para>
            Sent to the first window in the clipboard viewer chain when the content of the clipboard changes. This enables a clipboard
            viewer window to display the new content of the clipboard.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_DRAWCLIPBOARD 0x0308</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <remarks>
            <para>
            Only clipboard viewer windows receive this message. These are windows that have been added to the clipboard viewer chain by
            using the <c>SetClipboardViewer</c> function.
            </para>
            <para>
            Each window that receives the <c>WM_DRAWCLIPBOARD</c> message must call the <c>SendMessage</c> function to pass the message
            on to the next window in the clipboard viewer chain. The handle to the next window in the chain is returned by
            <c>SetClipboardViewer</c>, and may change in response to a <c>WM_CHANGECBCHAIN</c> message.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_PAINTCLIPBOARD">
            <summary>
            <para>
            Sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the <c>CF_OWNERDISPLAY</c>
            format and the clipboard viewer's client area needs repainting.
            </para>
            <para>
            <code>#define WM_PAINTCLIPBOARD 0x0309</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the clipboard viewer window.</para>
            <para><em>lParam</em></para>
            <para>
            A handle to a global memory object that contains a <c>PAINTSTRUCT</c> structure. The structure defines the part of the client
            area to paint.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            To determine whether the entire client area or just a portion of it needs repainting, the clipboard owner must compare the
            dimensions of the drawing area given in the <c>rcPaint</c> member of <c>PAINTSTRUCT</c> to the dimensions given in the most
            recent <c>WM_SIZECLIPBOARD</c> message.
            </para>
            <para>
            The clipboard owner must use the <c>GlobalLock</c> function to lock the memory that contains the <c>PAINTSTRUCT</c>
            structure. Before returning, the clipboard owner must unlock that memory by using the <c>GlobalUnlock</c> function.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_VSCROLLCLIPBOARD">
            <summary>
            <para>
            Sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the <c>CF_OWNERDISPLAY</c>
            format and an event occurs in the clipboard viewer's vertical scroll bar. The owner should scroll the clipboard image and
            update the scroll bar values.
            </para>
            <para>
            <code>#define WM_VSCROLLCLIPBOARD 0x030A</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the clipboard viewer window.</para>
            <para><em>lParam</em></para>
            <para>The low-order word of lParam specifies a scroll bar event. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>SB_BOTTOM</c> 7</term>
            <term>Scroll to lower right.</term>
            </item>
            <item>
            <term><c>SB_ENDSCROLL</c> 8</term>
            <term>End scroll.</term>
            </item>
            <item>
            <term><c>SB_LINEDOWN</c> 1</term>
            <term>Scroll one line down.</term>
            </item>
            <item>
            <term><c>SB_LINEUP</c> 0</term>
            <term>Scroll one line up.</term>
            </item>
            <item>
            <term><c>SB_PAGEDOWN</c> 3</term>
            <term>Scroll one page down.</term>
            </item>
            <item>
            <term><c>SB_PAGEUP</c> 2</term>
            <term>Scroll one page up.</term>
            </item>
            <item>
            <term><c>SB_THUMBPOSITION</c> 4</term>
            <term>Scroll to absolute position. The current position is specified by the high-order word.</term>
            </item>
            <item>
            <term><c>SB_TOP</c> 6</term>
            <term>Scroll to upper left.</term>
            </item>
            </list>
            <para>
            The high-order word of lParam specifies the current position of the scroll box if the low-order word of lParam is
            <c>SB_THUMBPOSITION</c>; otherwise, the high-order word of lParam is not used.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            The clipboard owner can use the <c>ScrollWindow</c> function to scroll the image in the clipboard viewer window and
            invalidate the appropriate region.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SIZECLIPBOARD">
            <summary>
            <para>
            Sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the <c>CF_OWNERDISPLAY</c>
            format and the clipboard viewer's client area has changed size.
            </para>
            <para>
            <code>#define WM_SIZECLIPBOARD 0x030B</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the clipboard viewer window.</para>
            <para><em>lParam</em></para>
            <para>
            A handle to a global memory object that contains a <c>RECT</c> structure. The structure specifies the new dimensions of the
            clipboard viewer's client area.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            When the clipboard viewer window is about to be destroyed or resized, a <c>WM_SIZECLIPBOARD</c> message is sent with a null
            rectangle (0, 0, 0, 0) as the new size. This permits the clipboard owner to free its display resources.
            </para>
            <para>
            The clipboard owner must use the <c>GlobalLock</c> function to lock the memory object that contains <c>RECT</c>. Before
            returning, the clipboard owner must unlock the object by using the <c>GlobalUnlock</c> function.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_ASKCBFORMATNAME">
            <summary>
            <para>
            Sent to the clipboard owner by a clipboard viewer window to request the name of a <c>CF_OWNERDISPLAY</c> clipboard format.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_ASKCBFORMATNAME 0x030C</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>The size, in characters, of the buffer pointed to by the lParam parameter.</para>
            <para><em>lParam</em></para>
            <para>A pointer to the buffer that is to receive the clipboard format name.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            In response to this message, the clipboard owner should copy the name of the owner-display format to the specified buffer,
            not exceeding the buffer size specified by the wParam parameter.
            </para>
            <para>
            A clipboard viewer window sends this message to the clipboard owner to determine the name of the <c>CF_OWNERDISPLAY</c>
            format for example, to initialize a menu listing available formats.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CHANGECBCHAIN">
            <summary>
            <para>Sent to the first window in the clipboard viewer chain when a window is being removed from the chain.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_CHANGECBCHAIN 0x030D</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the window being removed from the clipboard viewer chain.</para>
            <para><em>lParam</em></para>
            <para>
            A handle to the next window in the chain following the window being removed. This parameter is <c>NULL</c> if the window
            being removed is the last window in the chain.
            </para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            Each clipboard viewer window saves the handle to the next window in the clipboard viewer chain. Initially, this handle is the
            return value of the <c>SetClipboardViewer</c> function.
            </para>
            <para>
            When a clipboard viewer window receives the <c>WM_CHANGECBCHAIN</c> message, it should call the <c>SendMessage</c> function
            to pass the message to the next window in the chain, unless the next window is the window being removed. In this case, the
            clipboard viewer should save the handle specified by the lParam parameter as the next window in the chain.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_HSCROLLCLIPBOARD">
            <summary>
            <para>
            Sent to the clipboard owner by a clipboard viewer window. This occurs when the clipboard contains data in the
            <c>CF_OWNERDISPLAY</c> format and an event occurs in the clipboard viewer's horizontal scroll bar. The owner should scroll
            the clipboard image and update the scroll bar values.
            </para>
            <para>
            <code>#define WM_HSCROLLCLIPBOARD 0x030E</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the clipboard viewer window.</para>
            <para><em>lParam</em></para>
            <para>
            The low-order word of lParam specifies a scroll bar event. This parameter can be one of the following values. The high-order
            word of lParam specifies the current position of the scroll box if the low-order word of lParam is <c>SB_THUMBPOSITION</c>;
            otherwise, the high-order word is not used.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>SB_ENDSCROLL</c> 8</term>
            <term>End scroll.</term>
            </item>
            <item>
            <term><c>SB_LEFT</c> 6</term>
            <term>Scroll to upper left.</term>
            </item>
            <item>
            <term><c>SB_RIGHT</c> 7</term>
            <term>Scroll to lower right.</term>
            </item>
            <item>
            <term><c>SB_LINELEFT</c> 0</term>
            <term>Scrolls left by one unit.</term>
            </item>
            <item>
            <term><c>SB_LINERIGHT</c> 1</term>
            <term>Scrolls right by one unit.</term>
            </item>
            <item>
            <term><c>SB_PAGELEFT</c> 2</term>
            <term>Scrolls left by the width of the window.</term>
            </item>
            <item>
            <term><c>SB_PAGERIGHT</c> 3</term>
            <term>Scrolls right by the width of the window.</term>
            </item>
            <item>
            <term><c>SB_THUMBPOSITION</c> 4</term>
            <term>Scroll to absolute position. The current position is specified by the high-order word.</term>
            </item>
            </list>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            The clipboard owner can use the <c>ScrollWindow</c> function to scroll the image in the clipboard viewer window and
            invalidate the appropriate region.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_QUERYNEWPALETTE">
            <summary>
            <para>
            The <c>WM_QUERYNEWPALETTE</c> message informs a window that it is about to receive the keyboard focus, giving the window the
            opportunity to realize its logical palette when it receives the focus.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>If the window realizes its logical palette, it must return <c>TRUE</c>; otherwise, it must return <c>FALSE</c>.</para>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_PALETTEISCHANGING">
            <summary>
            <para>The <c>WM_PALETTEISCHANGING</c> message informs applications that an application is going to realize its logical palette.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the window that is going to realize its logical palette.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>
            The application changing its palette does not wait for acknowledgment of this message before changing the palette and sending
            the <c>WM_PALETTECHANGED</c> message. As a result, the palette may already be changed by the time an application receives
            this message.
            </para>
            <para>
            If the application either ignores or fails to process this message and a second application realizes its palette while the
            first is using palette indexes, there is a strong possibility that the user will see unexpected colors during subsequent
            drawing operations.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_PALETTECHANGED">
            <summary>
            <para>
            The <c>WM_PALETTECHANGED</c> message is sent to all top-level and overlapped windows after the window with the keyboard focus
            has realized its logical palette, thereby changing the system palette. This message enables a window that uses a color
            palette but does not have the keyboard focus to realize its logical palette and update its client area.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the window that caused the system palette to change.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used.</para>
            <remarks>
            <para>
            This message must be sent to all top-level and overlapped windows, including the one that changed the system palette. If any
            child windows use a color palette, this message must be passed on to them as well.
            </para>
            <para>
            To avoid creating an infinite loop, a window that receives this message must not realize its palette, unless it determines
            that wParam does not contain its own window handle.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_HOTKEY">
            <summary>
            <para>
            Posted when the user presses a hot key registered by the <c>RegisterHotKey</c> function. The message is placed at the top of
            the message queue associated with the thread that registered the hot key.
            </para>
            <para>
            <code>#define WM_HOTKEY 0x0312</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            The identifier of the hot key that generated the message. If the message was generated by a system-defined hot key, this
            parameter will be one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>IDHOT_SNAPDESKTOP</c> -2</term>
            <term>The "snap desktop" hot key was pressed.</term>
            </item>
            <item>
            <term><c>IDHOT_SNAPWINDOW</c> -1</term>
            <term>The "snap window" hot key was pressed.</term>
            </item>
            </list>
            <para><em>lParam</em></para>
            <para>
            The low-order word specifies the keys that were to be pressed in combination with the key specified by the high-order word to
            generate the <c>WM_HOTKEY</c> message. This word can be one or more of the following values. The high-order word specifies
            the virtual key code of the hot key.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MOD_ALT</c> 0x0001</term>
            <term>Either ALT key was held down.</term>
            </item>
            <item>
            <term><c>MOD_CONTROL</c> 0x0002</term>
            <term>Either CTRL key was held down.</term>
            </item>
            <item>
            <term><c>MOD_SHIFT</c> 0x0004</term>
            <term>Either SHIFT key was held down.</term>
            </item>
            <item>
            <term><c>MOD_WIN</c> 0x0008</term>
            <term>
            Either WINDOWS key was held down. These keys are labeled with the Windows logo. Hotkeys that involve the Windows key are
            reserved for use by the operating system.
            </term>
            </item>
            </list>
            <remarks>
            <c>WM_HOTKEY</c> is unrelated to the <c>WM_GETHOTKEY</c> and <c>WM_SETHOTKEY</c> hot keys. The <c>WM_HOTKEY</c> message is
            sent for generic hot keys while the <c>WM_SETHOTKEY</c> and <c>WM_GETHOTKEY</c> messages relate to window activation hot keys.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_PRINT">
            <summary>
            <para>
            The <c>WM_PRINT</c> message is sent to a window to request that it draw itself in the specified device context, most commonly
            in a printer device context.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the device context to draw in.</para>
            <para><em>lParam</em></para>
            <para>The drawing options. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>PRF_CHECKVISIBLE</c></term>
            <term>Draws the window only if it is visible.</term>
            </item>
            <item>
            <term><c>PRF_CHILDREN</c></term>
            <term>Draws all visible children windows.</term>
            </item>
            <item>
            <term><c>PRF_CLIENT</c></term>
            <term>Draws the client area of the window.</term>
            </item>
            <item>
            <term><c>PRF_ERASEBKGND</c></term>
            <term>Erases the background before drawing the window.</term>
            </item>
            <item>
            <term><c>PRF_NONCLIENT</c></term>
            <term>Draws the nonclient area of the window.</term>
            </item>
            <item>
            <term><c>PRF_OWNED</c></term>
            <term>Draws all owned windows.</term>
            </item>
            </list>
            <remarks>
            The <c>DefWindowProc</c> function processes this message based on which drawing option is specified: if PRF_CHECKVISIBLE is
            specified and the window is not visible, do nothing, if PRF_NONCLIENT is specified, draw the nonclient area in the specified
            device context, if PRF_ERASEBKGND is specified, send the window a <c>WM_ERASEBKGND</c> message, if PRF_CLIENT is specified,
            send the window a <c>WM_PRINTCLIENT</c> message, if PRF_CHILDREN is set, send each visible child window a <c>WM_PRINT</c>
            message, if PRF_OWNED is set, send each visible owned window a <c>WM_PRINT</c> message.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_PRINTCLIENT">
            <summary>
            <para>
            The <c>WM_PRINTCLIENT</c> message is sent to a window to request that it draw its client area in the specified device
            context, most commonly in a printer device context.
            </para>
            <para>
            Unlike <c>WM_PRINT</c>, <c>WM_PRINTCLIENT</c> is not processed by <c>DefWindowProc</c>. A window should process the
            <c>WM_PRINTCLIENT</c> message through an application-defined <c>WindowProc</c> function for it to be used properly.
            </para>
            <para>
            <code>LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>A handle to the device context to draw in.</para>
            <para><em>lParam</em></para>
            <para>The drawing options. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>PRF_CHECKVISIBLE</c></term>
            <term>Draws the window only if it is visible.</term>
            </item>
            <item>
            <term><c>PRF_CHILDREN</c></term>
            <term>Draws all visible children windows.</term>
            </item>
            <item>
            <term><c>PRF_CLIENT</c></term>
            <term>Draws the client area of the window.</term>
            </item>
            <item>
            <term><c>PRF_ERASEBKGND</c></term>
            <term>Erases the background before drawing the window.</term>
            </item>
            <item>
            <term><c>PRF_NONCLIENT</c></term>
            <term>Draws the nonclient area of the window.</term>
            </item>
            <item>
            <term><c>PRF_OWNED</c></term>
            <term>Draws all owned windows.</term>
            </item>
            </list>
            <remarks>
            <para>
            A window can process this message in much the same manner as <c>WM_PAINT</c>, except that <c>BeginPaint</c> and
            <c>EndPaint</c> need not be called (a device context is provided), and the window should draw its entire client area rather
            than just the invalid region.
            </para>
            <para>
            Windows that can be used anywhere in the system, such as controls, should process this message. It is probably worthwhile for
            other windows to process this message as well because it is relatively easy to implement.
            </para>
            <para>The AnimateWindow function requires that the window being animated implements the <c>WM_PRINTCLIENT</c> message.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_APPCOMMAND">
            <summary>
            <para>
            Notifies a window that the user generated an application command event, for example, by clicking an application command
            button using the mouse or typing an application command key on the keyboard.
            </para>
            <para>
            <code>#define WM_APPCOMMAND 0x0319</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            A handle to the window where the user clicked the button or pressed the key. This can be a child window of the window
            receiving the message. For more information about processing this message, see the Remarks section.
            </para>
            <para><em>lParam</em></para>
            <para>Use the following code to get the information contained in the lParam parameter.</para>
            <para>
            <code>cmd = GET_APPCOMMAND_LPARAM(lParam); uDevice = GET_DEVICE_LPARAM(lParam); dwKeys = GET_KEYSTATE_LPARAM(lParam);</code>
            </para>
            <para>The application command is cmd, which can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>APPCOMMAND_BASS_BOOST</c> 20</term>
            <term>Toggle the bass boost on and off.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_BASS_DOWN</c> 19</term>
            <term>Decrease the bass.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_BASS_UP</c> 21</term>
            <term>Increase the bass.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_BROWSER_BACKWARD</c> 1</term>
            <term>Navigate backward.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_BROWSER_FAVORITES</c> 6</term>
            <term>Open favorites.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_BROWSER_FORWARD</c> 2</term>
            <term>Navigate forward.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_BROWSER_HOME</c> 7</term>
            <term>Navigate home.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_BROWSER_REFRESH</c> 3</term>
            <term>Refresh page.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_BROWSER_SEARCH</c> 5</term>
            <term>Open search.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_BROWSER_STOP</c> 4</term>
            <term>Stop download.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_CLOSE</c> 31</term>
            <term>Close the window (not the application).</term>
            </item>
            <item>
            <term><c>APPCOMMAND_COPY</c> 36</term>
            <term>Copy the selection.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_CORRECTION_LIST</c> 45</term>
            <term>Brings up the correction list when a word is incorrectly identified during speech input.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_CUT</c> 37</term>
            <term>Cut the selection.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE</c> 43</term>
            <term>
            Toggles between two modes of speech input: dictation and command/control (giving commands to an application or accessing menus).
            </term>
            </item>
            <item>
            <term><c>APPCOMMAND_FIND</c> 28</term>
            <term>Open the <c>Find</c> dialog.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_FORWARD_MAIL</c> 40</term>
            <term>Forward a mail message.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_HELP</c> 27</term>
            <term>Open the <c>Help</c> dialog.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_LAUNCH_APP1</c> 17</term>
            <term>Start App1.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_LAUNCH_APP2</c> 18</term>
            <term>Start App2.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_LAUNCH_MAIL</c> 15</term>
            <term>Open mail.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_LAUNCH_MEDIA_SELECT</c> 16</term>
            <term>Go to Media Select mode.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_MEDIA_CHANNEL_DOWN</c> 52</term>
            <term>Decrement the channel value, for example, for a TV or radio tuner.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_MEDIA_CHANNEL_UP</c> 51</term>
            <term>Increment the channel value, for example, for a TV or radio tuner.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_MEDIA_FAST_FORWARD</c> 49</term>
            <term>
            Increase the speed of stream playback. This can be implemented in many ways, for example, using a fixed speed or toggling
            through a series of increasing speeds.
            </term>
            </item>
            <item>
            <term><c>APPCOMMAND_MEDIA_NEXTTRACK</c> 11</term>
            <term>Go to next track.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_MEDIA_PAUSE</c> 47</term>
            <term>
            Pause. If already paused, take no further action. This is a direct PAUSE command that has no state. If there are discrete
            Play and Pause buttons, applications should take action on this command as well as <c>APPCOMMAND_MEDIA_PLAY_PAUSE</c>.
            </term>
            </item>
            <item>
            <term><c>APPCOMMAND_MEDIA_PLAY</c> 46</term>
            <term>
            Begin playing at the current position. If already paused, it will resume. This is a direct PLAY command that has no state. If
            there are discrete <c>Play</c> and <c>Pause</c> buttons, applications should take action on this command as well as <c>APPCOMMAND_MEDIA_PLAY_PAUSE</c>.
            </term>
            </item>
            <item>
            <term><c>APPCOMMAND_MEDIA_PLAY_PAUSE</c> 14</term>
            <term>
            Play or pause playback. If there are discrete <c>Play</c> and <c>Pause</c> buttons, applications should take action on this
            command as well as <c>APPCOMMAND_MEDIA_PLAY</c> and <c>APPCOMMAND_MEDIA_PAUSE</c>.
            </term>
            </item>
            <item>
            <term><c>APPCOMMAND_MEDIA_PREVIOUSTRACK</c> 12</term>
            <term>Go to previous track.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_MEDIA_RECORD</c> 48</term>
            <term>Begin recording the current stream.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_MEDIA_REWIND</c> 50</term>
            <term>
            Go backward in a stream at a higher rate of speed. This can be implemented in many ways, for example, using a fixed speed or
            toggling through a series of increasing speeds.
            </term>
            </item>
            <item>
            <term><c>APPCOMMAND_MEDIA_STOP</c> 13</term>
            <term>Stop playback.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_MIC_ON_OFF_TOGGLE</c> 44</term>
            <term>Toggle the microphone.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_MICROPHONE_VOLUME_DOWN</c> 25</term>
            <term>Decrease microphone volume.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_MICROPHONE_VOLUME_MUTE</c> 24</term>
            <term>Mute the microphone.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_MICROPHONE_VOLUME_UP</c> 26</term>
            <term>Increase microphone volume.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_NEW</c> 29</term>
            <term>Create a new window.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_OPEN</c> 30</term>
            <term>Open a window.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_PASTE</c> 38</term>
            <term>Paste</term>
            </item>
            <item>
            <term><c>APPCOMMAND_PRINT</c> 33</term>
            <term>Print current document.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_REDO</c> 35</term>
            <term>Redo last action.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_REPLY_TO_MAIL</c> 39</term>
            <term>Reply to a mail message.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_SAVE</c> 32</term>
            <term>Save current document.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_SEND_MAIL</c> 41</term>
            <term>Send a mail message.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_SPELL_CHECK</c> 42</term>
            <term>Initiate a spell check.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_TREBLE_DOWN</c> 22</term>
            <term>Decrease the treble.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_TREBLE_UP</c> 23</term>
            <term>Increase the treble.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_UNDO</c> 34</term>
            <term>Undo last action.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_VOLUME_DOWN</c> 9</term>
            <term>Lower the volume.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_VOLUME_MUTE</c> 8</term>
            <term>Mute the volume.</term>
            </item>
            <item>
            <term><c>APPCOMMAND_VOLUME_UP</c> 10</term>
            <term>Raise the volume.</term>
            </item>
            </list>
            <para>The uDevice component indicates the input device that generated the input event, and can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>FAPPCOMMAND_KEY</c> 0</term>
            <term>User pressed a key.</term>
            </item>
            <item>
            <term><c>FAPPCOMMAND_MOUSE</c> 0x8000</term>
            <term>User clicked a mouse button.</term>
            </item>
            <item>
            <term><c>FAPPCOMMAND_OEM</c> 0x1000</term>
            <term>An unidentified hardware source generated the event. It could be a mouse or a keyboard event.</term>
            </item>
            </list>
            <para>The dwKeys component indicates whether various virtual keys are down, and can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>MK_CONTROL</c> 0x0008</term>
            <term>The CTRL key is down.</term>
            </item>
            <item>
            <term><c>MK_LBUTTON</c> 0x0001</term>
            <term>The left mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_MBUTTON</c> 0x0010</term>
            <term>The middle mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_RBUTTON</c> 0x0002</term>
            <term>The right mouse button is down.</term>
            </item>
            <item>
            <term><c>MK_SHIFT</c> 0x0004</term>
            <term>The SHIFT key is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON1</c> 0x0020</term>
            <term>The first X button is down.</term>
            </item>
            <item>
            <term><c>MK_XBUTTON2</c> 0x0040</term>
            <term>The second X button is down.</term>
            </item>
            </list>
            <para><strong>Returns</strong></para>
            <para>
            If an application processes this message, it should return <c>TRUE</c>. For more information about processing the return
            value, see the Remarks section.
            </para>
            <remarks>
            <para>
            <c>DefWindowProc</c> generates the <c>WM_APPCOMMAND</c> message when it processes the <c>WM_XBUTTONUP</c> or
            <c>WM_NCXBUTTONUP</c> message, or when the user types an application command key.
            </para>
            <para>
            If a child window does not process this message and instead calls <c>DefWindowProc</c>, <c>DefWindowProc</c> will send the
            message to its parent window. If a top level window does not process this message and instead calls <c>DefWindowProc</c>,
            <c>DefWindowProc</c> will call a shell hook with the hook code equal to <c>HSHELL_APPCOMMAND</c>.
            </para>
            <para>
            To get the coordinates of the cursor if the message was generated by a mouse click, the application can call
            <c>GetMessagePos</c>. An application can test whether the message was generated by the mouse by checking whether lParam
            contains <c>FAPPCOMMAND_MOUSE</c>.
            </para>
            <para>
            Unlike other windows messages, an application should return <c>TRUE</c> from this message if it processes it. Doing so will
            allow software that simulates this message on Windows systems earlier than Windows 2000 to determine whether the window
            procedure processed the message or called <c>DefWindowProc</c> to process it.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_THEMECHANGED">
            <summary>
            <para>
            Broadcast to every window following a theme change event. Examples of theme change events are the activation of a theme, the
            deactivation of a theme, or a transition from one theme to another.
            </para>
            <para>
            <code>#define WM_THEMECHANGED 0x031A</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is reserved.</para>
            <para><em>lParam</em></para>
            <para>This parameter is reserved.</para>
            <para><strong>Returns</strong></para>
            <para>Type: <c>LRESULT</c></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <para>Note</para>
            <para>This message is posted by the operating system. Applications typically do not send this message.</para>
            </para>
            <para>
            Themes are specifications for the appearance of controls, so that the visual element of a control is treated separately from
            its functionality.
            </para>
            <para>To release an existing theme handle, call <c>CloseThemeData</c>. To acquire a new theme handle, use <c>OpenThemeData</c>.</para>
            <para>
            Following the <c>WM_THEMECHANGED</c> broadcast, any existing theme handles are invalid. A theme-aware window should release
            and reopen any of its pre-existing theme handles when it receives the <c>WM_THEMECHANGED</c> message. If the
            <c>OpenThemeData</c> function returns <c>NULL</c>, the window should paint unthemed.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CLIPBOARDUPDATE">
            <summary>
            <para>Sent when the contents of the clipboard have changed.</para>
            <para>
            <code>#define WM_CLIPBOARDUPDATE 0x031D</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><em>lParam</em></para>
            <para>This parameter is not used and must be zero.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>To register a window to receive this message, use the <c>AddClipboardFormatListener</c> function.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_DWMCOMPOSITIONCHANGED">
            <summary>
            <para>Informs all top-level windows that Desktop Window Manager (DWM) composition has been enabled or disabled.</para>
            <para>
            <para>Note</para>
            <para>As of Windows 8, DWM composition is always enabled, so this message is not sent regardless of video mode changes.</para>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Not used.</para>
            <para><em>lParam</em></para>
            <para>Not used.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>The <c>DwmIsCompositionEnabled</c> function can be used to determine the current composition state.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_DWMNCRENDERINGCHANGED">
            <summary>Sent when the non-client area rendering policy has changed.</summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>
            Specifies whether DWM rendering is enabled for the non-client area of the window. <c>TRUE</c> if enabled; otherwise, <c>FALSE</c>.
            </para>
            <para><em>lParam</em></para>
            <para>Not used.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            The <c>DwmGetWindowAttribute</c> and <c>DwmSetWindowAttribute</c> functions are used to get or set the non-client rendering policy.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_DWMCOLORIZATIONCOLORCHANGED">
            <summary>Informs all top-level windows that the colorization color has changed.</summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Specifies the new colorization color. The color format is 0xAARRGGBB.</para>
            <para><em>lParam</em></para>
            <para>Specifies whether the new color is blended with opacity.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            <para><c>DwmGetColorizationColor</c> is used to determine the current color value.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_DWMWINDOWMAXIMIZEDCHANGE">
            <summary>Sent when a Desktop Window Manager (DWM) composed window is maximized.</summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>Set to true to specify that the window has been maximized.</para>
            <para><em>lParam</em></para>
            <para>Not used.</para>
            <para><strong>Returns</strong></para>
            <para>If an application processes this message, it should return zero.</para>
            <remarks>A window receives this message through its <c>WindowProc</c> function.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_GETTITLEBARINFOEX">
            <summary>
            <para>Sent to request extended title bar information. A window receives this message through its <c>WindowProc</c> function.</para>
            <para>
            <code>#define WM_GETTITLEBARINFOEX 0x033F</code>
            </para>
            </summary>
            <para><strong>Parameters</strong></para>
            <para><em>wParam</em></para>
            <para>This parameter is not used and must be 0.</para>
            <para><em>lParam</em></para>
            <para>
            A pointer to a <c>TITLEBARINFOEX</c> structure. The message sender is responsible for allocating memory for this structure.
            Set the <c>cbSize</c> member of this structure to
            <code>sizeof(TITLEBARINFOEX)</code>
            before passing this structure with the message.
            </para>
            <remarks>
            <para>
            The following example shows how the message receiver casts an <c>LPARAM</c> value to retrieve the <c>TITLEBARINFOEX</c> structure.
            </para>
            <para>
            <code>TITLEBARINFOEX *ptinfo = (TITLEBARINFOEX *)lParam;</code>
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_HANDHELDFIRST">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_HANDHELDLAST">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_AFXFIRST">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_AFXLAST">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_PENWINFIRST">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_PENWINLAST">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_APP">
            <summary>
            <para>Used to define private messages, usually of the form <c>WM_APP</c>+x, where x is an integer value.</para>
            <para>
            <code>#define WM_APP 0x8000</code>
            </para>
            </summary>
            <remarks>
            <para>
            The <c>WM_APP</c> constant is used to distinguish between message values that are reserved for use by the system and values
            that can be used by an application to send messages within a private window class. The following are the ranges of message
            numbers available.
            </para>
            <list type="table">
            <listheader>
            <term>Range</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0 through <c>WM_USER</c> –1</term>
            <term>Messages reserved for use by the system.</term>
            </item>
            <item>
            <term><c>WM_USER</c> through 0x7FFF</term>
            <term>Integer messages for use by private window classes.</term>
            </item>
            <item>
            <term><c>WM_APP</c> through 0xBFFF</term>
            <term>Messages available for use by applications.</term>
            </item>
            <item>
            <term>0xC000 through 0xFFFF</term>
            <term>String messages for use by applications.</term>
            </item>
            <item>
            <term>Greater than 0xFFFF</term>
            <term>Reserved by the system.</term>
            </item>
            </list>
            <para>
            Message numbers in the first range (0 through <c>WM_USER</c> –1) are defined by the system. Values in this range that are not
            explicitly defined are reserved by the system.
            </para>
            <para>
            Message numbers in the second range ( <c>WM_USER</c> through 0x7FFF) can be defined and used by an application to send
            messages within a private window class. These values cannot be used to define messages that are meaningful throughout an
            application because some predefined window classes already define values in this range. For example, predefined control
            classes such as <c>BUTTON</c>, <c>EDIT</c>, <c>LISTBOX</c>, and <c>COMBOBOX</c> may use these values. Messages in this range
            should not be sent to other applications unless the applications have been designed to exchange messages and to attach the
            same meaning to the message numbers.
            </para>
            <para>
            Message numbers in the third range (0x8000 through 0xBFFF) are available for applications to use as private messages.
            Messages in this range do not conflict with system messages.
            </para>
            <para>
            Message numbers in the fourth range (0xC000 through 0xFFFF) are defined at run time when an application calls the
            <c>RegisterWindowMessage</c> function to retrieve a message number for a string. All applications that register the same
            string can use the associated message number for exchanging messages. The actual message number, however, is not a constant
            and cannot be assumed to be the same between different sessions.
            </para>
            <para>Message numbers in the fifth range (greater than 0xFFFF) are reserved by the system.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_USER">
            <summary>
            <para>
            Used to define private messages for use by private window classes, usually of the form <c>WM_USER</c>+x, where x is an
            integer value.
            </para>
            <para>
            <code>#define WM_USER 0x0400</code>
            </para>
            </summary>
            <remarks>
            <para>The following are the ranges of message numbers.</para>
            <list type="table">
            <listheader>
            <term>Range</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0 through <c>WM_USER</c> –1</term>
            <term>Messages reserved for use by the system.</term>
            </item>
            <item>
            <term><c>WM_USER</c> through 0x7FFF</term>
            <term>Integer messages for use by private window classes.</term>
            </item>
            <item>
            <term><c>WM_APP</c> (0x8000) through 0xBFFF</term>
            <term>Messages available for use by applications.</term>
            </item>
            <item>
            <term>0xC000 through 0xFFFF</term>
            <term>String messages for use by applications.</term>
            </item>
            <item>
            <term>Greater than 0xFFFF</term>
            <term>Reserved by the system.</term>
            </item>
            </list>
            <para>
            Message numbers in the first range (0 through <c>WM_USER</c> –1) are defined by the system. Values in this range that are not
            explicitly defined are reserved by the system.
            </para>
            <para>
            Message numbers in the second range ( <c>WM_USER</c> through 0x7FFF) can be defined and used by an application to send
            messages within a private window class. These values cannot be used to define messages that are meaningful throughout an
            application because some predefined window classes already define values in this range. For example, predefined control
            classes such as <c>BUTTON</c>, <c>EDIT</c>, <c>LISTBOX</c>, and <c>COMBOBOX</c> may use these values. Messages in this range
            should not be sent to other applications unless the applications have been designed to exchange messages and to attach the
            same meaning to the message numbers.
            </para>
            <para>
            Message numbers in the third range (0x8000 through 0xBFFF) are available for applications to use as private messages.
            Messages in this range do not conflict with system messages.
            </para>
            <para>
            Message numbers in the fourth range (0xC000 through 0xFFFF) are defined at run time when an application calls the
            <c>RegisterWindowMessage</c> function to retrieve a message number for a string. All applications that register the same
            string can use the associated message number for exchanging messages. The actual message number, however, is not a constant
            and cannot be assumed to be the same between different sessions.
            </para>
            <para>Message numbers in the fifth range (greater than 0xFFFF) are reserved by the system.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CPL_LAUNCH">
            <summary>
            An application sends the WM_CPL_LAUNCH message to Windows Control Panel to request that a Control Panel application be started.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_CPL_LAUNCHED">
            <summary>
            The WM_CPL_LAUNCHED message is sent when a Control Panel application, started by the WM_CPL_LAUNCH message, has closed. The
            WM_CPL_LAUNCHED message is sent to the window identified by the wParam parameter of the WM_CPL_LAUNCH message that started
            the application.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_REFLECT">
            <summary>
            Reflects messages back to child controls. Sometimes you want to write a self-contained control based on standard Windows
            control, typically by using subclassing or superclassing. Unfortunately, most standard controls send interesting
            notifications to their parents, not to themselves, so your window proc won't normally receive them. A parent window could
            help by reflecting (sending) those messages back to the child window so that your window proc could process them. By
            convention, a message WM_X is reflected back as (OCM__BASE + WM_X). This is mainly to avoid conflicts with real notifications
            coming from the child windows of the control (e.g. a list view control has a header control as its child window, and receives
            WM_NOTIFY from the header. It would be inconvenient if you had to figure out every time whether WM_NOTIFY came from the
            header or reflected from your parent).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowMessage.WM_SYSTIMER">
            <summary>
            WM_SYSTIMER is a well-known yet still undocumented message. Windows uses WM_SYSTIMER for internal actions like scrolling.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.WindowStyles">
            <summary>
            Window Styles. The following styles can be specified wherever a window style is required. After the control has been created,
            these styles cannot be modified, except as noted.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_BORDER">
            <summary>The window has a thin-line border.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_CAPTION">
            <summary>The window has a title bar (includes the WS_BORDER style).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_CHILD">
            <summary>
            The window is a child window. A window with this style cannot have a menu bar. This style cannot be used with the WS_POPUP style.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_CLIPCHILDREN">
            <summary>
            Excludes the area occupied by child windows when drawing occurs within the parent window. This style is used when creating
            the parent window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_CLIPSIBLINGS">
            <summary>
            Clips child windows relative to each other; that is, when a particular child window receives a WM_PAINT message, the
            WS_CLIPSIBLINGS style clips all other overlapping child windows out of the region of the child window to be updated. If
            WS_CLIPSIBLINGS is not specified and child windows overlap, it is possible, when drawing within the client area of a child
            window, to draw within the client area of a neighboring child window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_DISABLED">
            <summary>
            The window is initially disabled. A disabled window cannot receive input from the user. To change this after a window has
            been created, use the EnableWindow function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_DLGFRAME">
            <summary>
            The window has a border of a style typically used with dialog boxes. A window with this style cannot have a title bar.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_GROUP">
            <summary>
            The window is the first control of a group of controls. The group consists of this first control and all controls defined
            after it, up to the next control with the WS_GROUP style. The first control in each group usually has the WS_TABSTOP style so
            that the user can move from group to group. The user can subsequently change the keyboard focus from one control in the group
            to the next control in the group by using the direction keys. You can turn this style on and off to change dialog box
            navigation. To change this style after a window has been created, use the SetWindowLong function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_HSCROLL">
            <summary>The window has a horizontal scroll bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_MAXIMIZE">
            <summary>The window is initially maximized.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_MAXIMIZEBOX">
            <summary>
            The window has a maximize button. Cannot be combined with the WS_EX_CONTEXTHELP style. The WS_SYSMENU style must also be specified.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_MINIMIZE">
            <summary>The window is initially minimized.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_MINIMIZEBOX">
            <summary>
            The window has a minimize button. Cannot be combined with the WS_EX_CONTEXTHELP style. The WS_SYSMENU style must also be specified.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_OVERLAPPED">
            <summary>The window is an overlapped window. An overlapped window has a title bar and a border.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_OVERLAPPEDWINDOW">
            <summary>The window is an overlapped window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_POPUP">
            <summary>The window is a pop-up window. This style cannot be used with the WS_CHILD style.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_POPUPWINDOW">
            <summary>
            The window is a pop-up window. The WS_CAPTION and WS_POPUPWINDOW styles must be combined to make the window menu visible.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_THICKFRAME">
            <summary>The window has a sizing border.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_SYSMENU">
            <summary>The window has a window menu on its title bar. The WS_CAPTION style must also be specified.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_TABSTOP">
            <summary>
            The window is a control that can receive the keyboard focus when the user presses the TAB key. Pressing the TAB key changes
            the keyboard focus to the next control with the WS_TABSTOP style. You can turn this style on and off to change dialog box
            navigation. To change this style after a window has been created, use the SetWindowLong function. For user-created windows
            and modeless dialogs to work with tab stops, alter the message loop to call the IsDialogMessage function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_VISIBLE">
            <summary>
            The window is initially visible. This style can be turned on and off by using the ShowWindow or SetWindowPos function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_VSCROLL">
            <summary>The window has a vertical scroll bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_TILED">
            <summary>
            The window is an overlapped window. An overlapped window has a title bar and a border. Same as the WS_OVERLAPPED style.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_ICONIC">
            <summary>The window is initially minimized. Same as the WS_MINIMIZE style.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_SIZEBOX">
            <summary>The window has a sizing border. Same as the WS_THICKFRAME style.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_TILEDWINDOW">
            <summary>The window is an overlapped window. Same as the WS_OVERLAPPEDWINDOW style.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStyles.WS_CHILDWINDOW">
            <summary>Same as the WS_CHILD style.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.WindowStylesEx">
            <summary>Extended window styles.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_ACCEPTFILES">
            <summary>Specifies a window that accepts drag-drop files.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_APPWINDOW">
            <summary>Forces a top-level window onto the taskbar when the window is visible.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_CLIENTEDGE">
            <summary>Specifies a window that has a border with a sunken edge.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_COMPOSITED">
            <summary>
            Specifies a window that paints all descendants in bottom-to-top painting order using double-buffering. This cannot be used if
            the window has a class style of either CS_OWNDC or CS_CLASSDC. This style is not supported in Windows 2000.
            </summary>
            <remarks>
            With WS_EX_COMPOSITED set, all descendants of a window get bottom-to-top painting order using double-buffering. Bottom-to-top
            painting order allows a descendent window to have translucency (alpha) and transparency (color-key) effects, but only if the
            descendent window also has the WS_EX_TRANSPARENT bit set. Double-buffering allows the window and its descendents to be
            painted without flicker.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_CONTEXTHELP">
            <summary>
            Specifies a window that includes a question mark in the title bar. When the user clicks the question mark, the cursor changes
            to a question mark with a pointer. If the user then clicks a child window, the child receives a WM_HELP message. The child
            window should pass the message to the parent window procedure, which should call the WinHelp function using the HELP_WM_HELP
            command. The Help application displays a pop-up window that typically contains help for the child window. WS_EX_CONTEXTHELP
            cannot be used with the WS_MAXIMIZEBOX or WS_MINIMIZEBOX styles.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_CONTROLPARENT">
            <summary>
            Specifies a window which contains child windows that should take part in dialog box navigation. If this style is specified,
            the dialog manager recurses into children of this window when performing navigation operations such as handling the TAB key,
            an arrow key, or a keyboard mnemonic.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_DLGMODALFRAME">
            <summary>Specifies a window that has a double border.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_LAYERED">
            <summary>
            Specifies a window that is a layered window. This cannot be used for child windows or if the window has a class style of
            either CS_OWNDC or CS_CLASSDC.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_LAYOUTRTL">
            <summary>
            Specifies a window with the horizontal origin on the right edge. Increasing horizontal values advance to the left. The shell
            language must support reading-order alignment for this to take effect.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_LEFT">
            <summary>Specifies a window that has generic left-aligned properties. This is the default.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_LEFTSCROLLBAR">
            <summary>
            Specifies a window with the vertical scroll bar (if present) to the left of the client area. The shell language must support
            reading-order alignment for this to take effect.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_LTRREADING">
            <summary>Specifies a window that displays text using left-to-right reading-order properties. This is the default.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_MDICHILD">
            <summary>Specifies a multiple-document interface (MDI) child window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_NOACTIVATE">
            <summary>
            Specifies a top-level window created with this style does not become the foreground window when the user clicks it. The
            system does not bring this window to the foreground when the user minimizes or closes the foreground window. The window does
            not appear on the taskbar by default. To force the window to appear on the taskbar, use the WS_EX_APPWINDOW style. To
            activate the window, use the SetActiveWindow or SetForegroundWindow function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_NOINHERITLAYOUT">
            <summary>Specifies a window which does not pass its window layout to its child windows.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_NOPARENTNOTIFY">
            <summary>
            Specifies that a child window created with this style does not send the WM_PARENTNOTIFY message to its parent window when it
            is created or destroyed.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_NOREDIRECTIONBITMAP">
            <summary>
            The window does not render to a redirection surface. This is for windows that do not have visible content or that use
            mechanisms other than surfaces to provide their visual.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_OVERLAPPEDWINDOW">
            <summary>Specifies an overlapped window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_PALETTEWINDOW">
            <summary>Specifies a palette window, which is a modeless dialog box that presents an array of commands.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_RIGHT">
            <summary>
            Specifies a window that has generic "right-aligned" properties. This depends on the window class. The shell language must
            support reading-order alignment for this to take effect. Using the WS_EX_RIGHT style has the same effect as using the
            SS_RIGHT (static), ES_RIGHT (edit), and BS_RIGHT/BS_RIGHTBUTTON (button) control styles.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_RIGHTSCROLLBAR">
            <summary>Specifies a window with the vertical scroll bar (if present) to the right of the client area. This is the default.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_RTLREADING">
            <summary>
            Specifies a window that displays text using right-to-left reading-order properties. The shell language must support
            reading-order alignment for this to take effect.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_STATICEDGE">
            <summary>
            Specifies a window with a three-dimensional border style intended to be used for items that do not accept user input.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_TOOLWINDOW">
            <summary>
            Specifies a window that is intended to be used as a floating toolbar. A tool window has a title bar that is shorter than a
            normal title bar, and the window title is drawn using a smaller font. A tool window does not appear in the taskbar or in the
            dialog that appears when the user presses ALT+TAB. If a tool window has a system menu, its icon is not displayed on the title
            bar. However, you can display the system menu by right-clicking or by typing ALT+SPACE.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_TOPMOST">
            <summary>
            Specifies a window that should be placed above all non-topmost windows and should stay above them, even when the window is
            deactivated. To add or remove this style, use the SetWindowPos function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_TRANSPARENT">
            <summary>
            Specifies a window that should not be painted until siblings beneath the window (that were created by the same thread) have
            been painted. The window appears transparent because the bits of underlying sibling windows have already been painted. To
            achieve transparency without these restrictions, use the SetWindowRgn function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowStylesEx.WS_EX_WINDOWEDGE">
            <summary>Specifies a window that has a border with a raised edge.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.FVIRT">
            <summary>Flags used by <see cref="F:Vanara.PInvoke.User32.ACCEL.fVirt"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FVIRT.FVIRTKEY">
            <summary>
            The key member specifies a virtual-key code. If this flag is not specified, key is assumed to specify a character code.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FVIRT.FNOINVERT">
            <summary>
            No top-level menu item is highlighted when the accelerator is used. If this flag is not specified, a top-level menu item will
            be highlighted, if possible, when the accelerator is used. This attribute is obsolete and retained only for backward
            compatibility with resource files designed for 16-bit Windows.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FVIRT.FSHIFT">
            <summary>The SHIFT key must be held down when the accelerator key is pressed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FVIRT.FCONTROL">
            <summary>The CTRL key must be held down when the accelerator key is pressed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FVIRT.FALT">
            <summary>The ALT key must be held down when the accelerator key is pressed.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.CopyAcceleratorTable(Vanara.PInvoke.HACCEL,Vanara.PInvoke.User32.ACCEL[],System.Int32)">
            <summary>
            Copies the specified accelerator table. This function is used to obtain the accelerator-table data that corresponds to an
            accelerator-table handle, or to determine the size of the accelerator-table data.
            </summary>
            <param name="hAccelSrc">
            <para>Type: <c>HACCEL</c></para>
            <para>A handle to the accelerator table to copy.</para>
            </param>
            <param name="lpAccelDst">
            <para>Type: <c>LPACCEL</c></para>
            <para>An array of ACCEL structures that receives the accelerator-table information.</para>
            </param>
            <param name="cAccelEntries">
            <para>Type: <c>int</c></para>
            <para>The number of ACCEL structures to copy to the buffer pointed to by the lpAccelDst parameter.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            If lpAccelDst is <c>NULL</c>, the return value specifies the number of accelerator-table entries in the original table.
            Otherwise, it specifies the number of accelerator-table entries that were copied.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateAcceleratorTable(Vanara.PInvoke.User32.ACCEL[],System.Int32)">
            <summary>Creates an accelerator table.</summary>
            <param name="paccel">
            <para>Type: <c>LPACCEL</c></para>
            <para>An array of ACCEL structures that describes the accelerator table.</para>
            </param>
            <param name="cAccel">
            <para>Type: <c>int</c></para>
            <para>The number of ACCEL structures in the array. This must be within the range 1 to 32767 or the function will fail.</para>
            </param>
            <returns>
            <para>Type: <c>HACCEL</c></para>
            <para>
            If the function succeeds, the return value is the handle to the created accelerator table; otherwise, it is <c>NULL</c>. To get
            extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            Before an application closes, it can use the DestroyAcceleratorTable function to destroy any accelerator tables that it created
            by using the <c>CreateAcceleratorTable</c> function.
            </para>
            <para>Examples</para>
            <para>For an example, see Creating User Editable Accelerators.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DestroyAcceleratorTable(Vanara.PInvoke.HACCEL)">
            <summary>Destroys an accelerator table.</summary>
            <param name="hAccel">
            <para>Type: <c>HACCEL</c></para>
            <para>
            A handle to the accelerator table to be destroyed. This handle must have been created by a call to the CreateAcceleratorTable or
            LoadAccelerators function.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            If the function succeeds, the return value is nonzero. However, if the table has been loaded more than one call to
            LoadAccelerators, the function will return a nonzero value only when <c>DestroyAcceleratorTable</c> has been called an equal
            number of times.
            </para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadAccelerators(Vanara.PInvoke.HINSTANCE,System.String)">
            <summary>Loads the specified accelerator table.</summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to the module whose executable file contains the accelerator table to be loaded.</para>
            </param>
            <param name="lpTableName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The name of the accelerator table to be loaded. Alternatively, this parameter can specify the resource identifier of an
            accelerator-table resource in the low-order word and zero in the high-order word. To create this value, use the MAKEINTRESOURCE macro.
            </para>
            </param>
            <returns>
            <para>Type: <c>HACCEL</c></para>
            <para>If the function succeeds, the return value is a handle to the loaded accelerator table.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>If the accelerator table has not yet been loaded, the function loads it from the specified executable file.</para>
            <para>Accelerator tables loaded from resources are freed automatically when the application terminates.</para>
            <para>Examples</para>
            <para>For an example, see Creating Accelerators for Font Attributes.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.TranslateAccelerator(Vanara.PInvoke.HWND,Vanara.PInvoke.HACCEL,Vanara.PInvoke.MSG@)">
            <summary>
            Processes accelerator keys for menu commands. The function translates a WM_KEYDOWN or WM_SYSKEYDOWN message to a WM_COMMAND or
            WM_SYSCOMMAND message (if there is an entry for the key in the specified accelerator table) and then sends the <c>WM_COMMAND</c>
            or <c>WM_SYSCOMMAND</c> message directly to the specified window procedure. <c>TranslateAccelerator</c> does not return until the
            window procedure has processed the message.
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose messages are to be translated.</para>
            </param>
            <param name="hAccTable">
            <para>Type: <c>HACCEL</c></para>
            <para>
            A handle to the accelerator table. The accelerator table must have been loaded by a call to the LoadAccelerators function or
            created by a call to the CreateAcceleratorTable function.
            </para>
            </param>
            <param name="lpMsg">
            <para>Type: <c>LPMSG</c></para>
            <para>
            A pointer to an MSG structure that contains message information retrieved from the calling thread's message queue using the
            GetMessage or PeekMessage function.
            </para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            To differentiate the message that this function sends from messages sent by menus or controls, the high-order word of the wParam
            parameter of the WM_COMMAND or WM_SYSCOMMAND message contains the value 1.
            </para>
            <para>
            Accelerator key combinations used to select items from the <c>window</c> menu are translated into WM_SYSCOMMAND messages; all
            other accelerator key combinations are translated into WM_COMMAND messages.
            </para>
            <para>
            When <c>TranslateAccelerator</c> returns a nonzero value and the message is translated, the application should not use the
            TranslateMessage function to process the message again.
            </para>
            <para>An accelerator need not correspond to a menu command.</para>
            <para>
            If the accelerator command corresponds to a menu item, the application is sent WM_INITMENU and WM_INITMENUPOPUP messages, as if
            the user were trying to display the menu. However, these messages are not sent if any of the following conditions exist:
            </para>
            <list type="bullet">
            <item>
            <term>The window is disabled.</term>
            </item>
            <item>
            <term>The accelerator key combination does not correspond to an item on the <c>window</c> menu and the window is minimized.</term>
            </item>
            <item>
            <term>A mouse capture is in effect. For information about mouse capture, see the SetCapture function.</term>
            </item>
            </list>
            <para>
            If the specified window is the active window and no window has the keyboard focus (which is generally the case if the window is
            minimized), <c>TranslateAccelerator</c> translates WM_SYSKEYUP and WM_SYSKEYDOWN messages instead of WM_KEYUP and WM_KEYDOWN messages.
            </para>
            <para>
            If an accelerator keystroke occurs that corresponds to a menu item when the window that owns the menu is minimized,
            <c>TranslateAccelerator</c> does not send a WM_COMMAND message. However, if an accelerator keystroke occurs that does not match
            any of the items in the window's menu or in the <c>window</c> menu, the function sends a <c>WM_COMMAND</c> message, even if the
            window is minimized.
            </para>
            <para>Examples</para>
            <para>For an example, see Creating Accelerators for Font Attributes.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.ACCEL">
            <summary>
            <para>Defines an accelerator key used in an accelerator table.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ACCEL.fVirt">
            <summary>The accelerator behavior. This member can be one or more of the following values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ACCEL.key">
            <summary>
            <para>Type: <c>WORD</c></para>
            <para>The accelerator key. This member can be either a virtual-key code or a character code.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ACCEL.cmd">
            <summary>
            The accelerator identifier. This value is placed in the low-order word of the wParam parameter of the WM_COMMAND or
            WM_SYSCOMMAND message when the accelerator is pressed.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SafeHACCEL">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <see cref="T:Vanara.PInvoke.HACCEL"/> that is disposed using <see cref="M:Vanara.PInvoke.User32.DestroyAcceleratorTable(Vanara.PInvoke.HACCEL)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHACCEL.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHACCEL"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHACCEL.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHACCEL"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHACCEL.op_Implicit(Vanara.PInvoke.User32.SafeHACCEL)~Vanara.PInvoke.HACCEL">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.User32.SafeHACCEL"/> to <see cref="T:Vanara.PInvoke.HACCEL"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHACCEL.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.ButtonMessage">
            <summary>Message identifiers used with the SendMessage function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BM_GETCHECK">
            <summary>
            Gets the check state of a radio button or check box. Return value is one of the <see cref="T:Vanara.PInvoke.User32.ButtonStateFlags"/> values.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BM_SETCHECK">
            <summary>Sets the check state of a radio button or check box. wParam is one of the <see cref="T:Vanara.PInvoke.User32.ButtonStateFlags"/> values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BM_GETSTATE">
            <summary>Retrieves the state of a button or check box. Return value is one of the <see cref="T:Vanara.PInvoke.User32.ButtonStateFlags"/> values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BM_SETSTATE">
            <summary>
            Sets the highlight state of a button. The highlight state indicates whether the button is highlighted as if the user had
            pushed it.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BM_SETSTYLE">
            <summary>Sets the style of a button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BM_CLICK">
            <summary>
            Simulates the user clicking a button. This message causes the button to receive the WM_LBUTTONDOWN and WM_LBUTTONUP messages,
            and the button's parent window to receive a BN_CLICKED notification code.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BM_GETIMAGE">
            <summary>Retrieves a handle to the image (icon or bitmap) associated with the button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BM_SETIMAGE">
            <summary>Associates a new image (icon or bitmap) with the button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BM_SETDONTCLICK">
            <summary>Sets a flag on a radio button that controls the generation of BN_CLICKED messages when the button receives focus.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BCM_GETIDEALSIZE">
            <summary>Gets the size of the button that best fits its text and image, if an image list is present.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BCM_SETIMAGELIST">
            <summary>Assigns an image list to a button control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BCM_GETIMAGELIST">
            <summary>Gets the BUTTON_IMAGELIST structure that describes the image list assigned to a button control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BCM_SETTEXTMARGIN">
            <summary>The BCM_SETTEXTMARGIN message sets the margins for drawing text in a button control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BCM_GETTEXTMARGIN">
            <summary>Gets the margins used to draw text in a button control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BCM_SETDROPDOWNSTATE">
            <summary>Sets the drop down state for a button with style TBSTYLE_DROPDOWN.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BCM_SETSPLITINFO">
            <summary>Sets information for a split button control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BCM_GETSPLITINFO">
            <summary>Gets information for a split button control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BCM_SETNOTE">
            <summary>Sets the text of the note associated with a command link button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BCM_GETNOTE">
            <summary>Gets the text of the note associated with a command link button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BCM_GETNOTELENGTH">
            <summary>Gets the length of the note text that may be displayed in the description for a command link button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonMessage.BCM_SETSHIELD">
            <summary>Sets the elevation required state for a specified button or command link to display an elevated icon.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ButtonNotification">
            <summary>Notifications for buttons.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonNotification.BN_CLICKED">
            <summary>
            Sent when the user clicks a button. The parent window of the button receives this notification code through the WM_COMMAND message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonNotification.BN_PAINT">
            <summary>
            Sent when a button should be painted. <note type="note">This notification code is provided only for compatibility with 16-bit
            versions of Windows earlier than version 3.0. Applications should use the BS_OWNERDRAW button style and the DRAWITEMSTRUCT
            structure for this task.</note>
            <para>The parent window of the button receives this notification code through the WM_COMMAND message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonNotification.BN_HILITE">
            <summary>
            Sent when the user selects a button. <note type="note">This notification code is provided only for compatibility with 16-bit
            versions of Windows earlier than version 3.0. Applications should use the BS_OWNERDRAW button style and the DRAWITEMSTRUCT
            structure for this task.</note>
            <para>The parent window of the button receives this notification code through the WM_COMMAND message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonNotification.BN_UNHILITE">
            <summary>
            Sent when the highlight should be removed from a button. <note type="note">This notification code is provided only for
            compatibility with 16-bit versions of Windows earlier than version 3.0. Applications should use the BS_OWNERDRAW button style
            and the DRAWITEMSTRUCT structure for this task.</note>
            <para>The parent window of the button receives this notification code through the WM_COMMAND message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonNotification.BN_DISABLE">
            <summary>
            Sent when a button is disabled. <note type="note">This notification code is provided only for compatibility with 16-bit
            versions of Windows earlier than version 3.0. Applications should use the BS_OWNERDRAW button style and the DRAWITEMSTRUCT
            structure for this task.</note>
            <para>The parent window of the button receives this notification code through the WM_COMMAND message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonNotification.BN_DOUBLECLICKED">
            <summary>
            Sent when the user double-clicks a button. This notification code is sent automatically for BS_USERBUTTON, BS_RADIOBUTTON,
            and BS_OWNERDRAW buttons. Other button types send BN_DBLCLK only if they have the BS_NOTIFY style. The parent window of the
            button receives this notification code through the WM_COMMAND message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonNotification.BN_PUSHED">
            <summary>
            Sent when the push state of a button is set to pushed. <note type="note">This notification code is provided only for
            compatibility with 16-bit versions of Windows earlier than version 3.0. Applications should use the BS_OWNERDRAW button style
            and the DRAWITEMSTRUCT structure for this task.</note>
            <para>The parent window of the button receives this notification code through the WM_COMMAND message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonNotification.BN_UNPUSHED">
            <summary>
            Sent when the push state of a button is set to unpushed. <note type="note">This notification code is provided only for
            compatibility with 16-bit versions of Windows earlier than version 3.0. Applications should use the BS_OWNERDRAW button style
            and the DRAWITEMSTRUCT structure for this task.</note>
            <para>The parent window of the button receives this notification code through the WM_COMMAND message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonNotification.BN_DBLCLK">
            <summary>
            Sent when the user double-clicks a button. This notification code is sent automatically for BS_USERBUTTON, BS_RADIOBUTTON,
            and BS_OWNERDRAW buttons. Other button types send BN_DBLCLK only if they have the BS_NOTIFY style. The parent window of the
            button receives this notification code through the WM_COMMAND message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonNotification.BN_SETFOCUS">
            <summary>
            Sent when a button receives the keyboard focus. The button must have the BS_NOTIFY style to send this notification code.
            <para>The parent window of the button receives this notification code through the WM_COMMAND message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonNotification.BN_KILLFOCUS">
            <summary>
            Sent when a button loses the keyboard focus. The button must have the BS_NOTIFY style to send this notification code.
            <para>The parent window of the button receives this notification code through the WM_COMMAND message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonNotification.BCN_HOTITEMCHANGE">
            <summary>
            Notifies the button control owner that the mouse is entering or leaving the client area of the button control. The button
            control sends this notification code in the form of a WM_NOTIFY message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonNotification.BCN_DROPDOWN">
            <summary>
            Sent when the user clicks a drop down arrow on a button. The parent window of the control receives this notification code in
            the form of a WM_NOTIFY message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonNotification.NM_GETCUSTOMSPLITRECT">
            <summary>
            Sent by a button control to its parent to get measurements for the two rectangles of the split button. This notification code
            is sent in the form of a WM_NOTIFY message.
            <list>
            <item>
            <term>lParam</term>
            <description>
            A pointer to an NMCUSTOMSPLITRECTINFO to receive bounding rectangles information. The NMCUSTOMSPLITRECTINFO structure is sent
            with the notification code as a request for the parent to provide measurements for the rectangles of the split button.
            </description>
            </item>
            <item>
            <term>Return value</term>
            <description>
            Return CDRF_SKIPDEFAULT to tell the button control to use the values returned in the NMCUSTOMSPLITRECTINFO structure;
            otherwise, return CDRF_DODEFAULT.
            </description>
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ButtonStateFlags">
            <summary>Flags indicating the state of buttons.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStateFlags.BST_UNCHECKED">
            <summary>No special state. Equivalent to zero.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStateFlags.BST_CHECKED">
            <summary>The button is checked.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStateFlags.BST_INDETERMINATE">
            <summary>The state of the button is indeterminate. Applies only if the button has the BS_3STATE or BS_AUTO3STATE style.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStateFlags.BST_PUSHED">
            <summary>The button is being shown in the pushed state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStateFlags.BST_FOCUS">
            <summary>The button has the keyboard focus.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStateFlags.BST_HOT">
            <summary>The button is hot; that is, the mouse is hovering over it.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStateFlags.BST_DROPDOWNPUSHED">
            <summary>
            <c>Windows Vista.</c> The button is in the drop-down state. Applies only if the button has the TBSTYLE_DROPDOWN style.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ButtonStyle">
            <summary>
            Specifies a combination of button styles. If you create a button using the BUTTON class with the CreateWindow or CreateWindowEx
            function, you can specify any of the button styles listed below.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_3STATE">
            <summary>
            Creates a button that is the same as a check box, except that the box can be grayed as well as checked or cleared. Use the
            grayed state to show that the state of the check box is not determined.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_AUTO3STATE">
            <summary>
            Creates a button that is the same as a three-state check box, except that the box changes its state when the user selects it.
            The state cycles through checked, indeterminate, and cleared.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_AUTOCHECKBOX">
            <summary>
            Creates a button that is the same as a check box, except that the check state automatically toggles between checked and
            cleared each time the user selects the check box.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_AUTORADIOBUTTON">
            <summary>
            Creates a button that is the same as a radio button, except that when the user selects it, the system automatically sets the
            button's check state to checked and automatically sets the check state for all other buttons in the same group to cleared.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_BITMAP">
            <summary>Specifies that the button displays a bitmap. See the Remarks section for its interaction with BS_ICON.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_BOTTOM">
            <summary>Places text at the bottom of the button rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_CENTER">
            <summary>Centers text horizontally in the button rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_CHECKBOX">
            <summary>
            Creates a small, empty check box with text. By default, the text is displayed to the right of the check box. To display the
            text to the left of the check box, combine this flag with the BS_LEFTTEXT style (or with the equivalent BS_RIGHTBUTTON style).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_COMMANDLINK">
            <summary>
            Creates a command link button that behaves like a BS_PUSHBUTTON style button, but the command link button has a green arrow
            on the left pointing to the button text. A caption for the button text can be set by sending the BCM_SETNOTE message to the button.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_DEFCOMMANDLINK">
            <summary>
            Creates a command link button that behaves like a BS_PUSHBUTTON style button. If the button is in a dialog box, the user can
            select the command link button by pressing the ENTER key, even when the command link button does not have the input focus.
            This style is useful for enabling the user to quickly select the most likely (default) option.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_DEFPUSHBUTTON">
            <summary>
            Creates a push button that behaves like a BS_PUSHBUTTON style button, but has a distinct appearance. If the button is in a
            dialog box, the user can select the button by pressing the ENTER key, even when the button does not have the input focus.
            This style is useful for enabling the user to quickly select the most likely (default) option.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_DEFSPLITBUTTON">
            <summary>
            Creates a split button that behaves like a BS_PUSHBUTTON style button, but also has a distinctive appearance. If the split
            button is in a dialog box, the user can select the split button by pressing the ENTER key, even when the split button does
            not have the input focus. This style is useful for enabling the user to quickly select the most likely (default) option.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_GROUPBOX">
            <summary>
            Creates a rectangle in which other controls can be grouped. Any text associated with this style is displayed in the
            rectangle's upper left corner.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_ICON">
            <summary>Specifies that the button displays an icon. See the Remarks section for its interaction with BS_BITMAP.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_FLAT">
            <summary>Specifies that the button is two-dimensional; it does not use the default shading to create a 3-D image.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_LEFT">
            <summary>
            Left-justifies the text in the button rectangle. However, if the button is a check box or radio button that does not have the
            BS_RIGHTBUTTON style, the text is left justified on the right side of the check box or radio button.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_LEFTTEXT">
            <summary>
            Places text on the left side of the radio button or check box when combined with a radio button or check box style. Same as
            the BS_RIGHTBUTTON style.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_MULTILINE">
            <summary>
            Wraps the button text to multiple lines if the text string is too long to fit on a single line in the button rectangle.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_NOTIFY">
            <summary>
            Enables a button to send BN_KILLFOCUS and BN_SETFOCUS notification codes to its parent window.
            <para>
            Note that buttons send the BN_CLICKED notification code regardless of whether it has this style. To get BN_DBLCLK
            notification codes, the button must have the BS_RADIOBUTTON or BS_OWNERDRAW style.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_OWNERDRAW">
            <summary>
            Creates an owner-drawn button. The owner window receives a WM_DRAWITEM message when a visual aspect of the button has
            changed. Do not combine the BS_OWNERDRAW style with any other button styles.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_PUSHBUTTON">
            <summary>Creates a push button that posts a WM_COMMAND message to the owner window when the user selects the button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_PUSHLIKE">
            <summary>
            Makes a button (such as a check box, three-state check box, or radio button) look and act like a push button. The button
            looks raised when it isn't pushed or checked, and sunken when it is pushed or checked.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_RADIOBUTTON">
            <summary>
            Creates a small circle with text. By default, the text is displayed to the right of the circle. To display the text to the
            left of the circle, combine this flag with the BS_LEFTTEXT style (or with the equivalent BS_RIGHTBUTTON style). Use radio
            buttons for groups of related, but mutually exclusive choices.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_RIGHT">
            <summary>
            Right-justifies text in the button rectangle. However, if the button is a check box or radio button that does not have the
            BS_RIGHTBUTTON style, the text is right justified on the right side of the check box or radio button.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_RIGHTBUTTON">
            <summary>
            Positions a radio button's circle or a check box's square on the right side of the button rectangle. Same as the BS_LEFTTEXT style.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_SPLITBUTTON">
            <summary>Creates a split button. A split button has a drop down arrow.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_TEXT">
            <summary>Specifies that the button displays text.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_TOP">
            <summary>Places text at the top of the button rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_TYPEMASK">
            <summary>
            Do not use this style. A composite style bit that results from using the OR operator on BS_* style bits. It can be used to
            mask out valid BS_* bits from a given bitmask. Note that this is out of date and does not correctly include all valid styles.
            Thus, you should not use this style.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_USERBUTTON">
            <summary>
            Obsolete, but provided for compatibility with 16-bit versions of Windows. Applications should use BS_OWNERDRAW instead.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ButtonStyle.BS_VCENTER">
            <summary>Places text in the middle (vertically) of the button rectangle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.CheckDlgButton(Vanara.PInvoke.HWND,System.Int32,Vanara.PInvoke.User32.ButtonStateFlags)">
            <summary>
            <para>Changes the check state of a button control.</para>
            </summary>
            <param name="hDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box that contains the button.</para>
            </param>
            <param name="nIDButton">
            <para>Type: <c>int</c></para>
            <para>The identifier of the button to modify.</para>
            </param>
            <param name="uCheck">
            <para>Type: <c>UINT</c></para>
            <para>The check state of the button. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>BST_CHECKED</term>
            <term>Sets the button state to checked.</term>
            </item>
            <item>
            <term>BST_INDETERMINATE</term>
            <term>
            Sets the button state to grayed, indicating an indeterminate state. Use this value only if the button has the BS_3STATE or
            BS_AUTO3STATE style.
            </term>
            </item>
            <item>
            <term>BST_UNCHECKED</term>
            <term>Sets the button state to cleared</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>CheckDlgButton</c> function sends a BM_SETCHECK message to the specified button control in the specified dialog box.
            </para>
            <para>Examples</para>
            <para>For an example, see <c>Creating a Modeless Dialog Box</c> in Using Dialog Boxes.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CheckRadioButton(Vanara.PInvoke.HWND,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            Adds a check mark to (checks) a specified radio button in a group and removes a check mark from (clears) all other radio buttons
            in the group.
            </para>
            </summary>
            <param name="hDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box that contains the radio button.</para>
            </param>
            <param name="nIDFirstButton">
            <para>Type: <c>int</c></para>
            <para>The identifier of the first radio button in the group.</para>
            </param>
            <param name="nIDLastButton">
            <para>Type: <c>int</c></para>
            <para>The identifier of the last radio button in the group.</para>
            </param>
            <param name="nIDCheckButton">
            <para>Type: <c>int</c></para>
            <para>The identifier of the radio button to select.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>The <c>CheckRadioButton</c> function sends a BM_SETCHECK message to each of the radio buttons in the indicated group.</para>
            <para>
            The nIDFirstButton and nIDLastButton parameters specify a range of button identifiers (normally the resource IDs of the buttons).
            The position of buttons in the tab order is irrelevant; if a button forms part of a group, but has an ID outside the specified
            range, it is not affected by this call.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsDlgButtonChecked(Vanara.PInvoke.HWND,System.Int32)">
            <summary>
            <para>
            The <c>IsDlgButtonChecked</c> function determines whether a button control is checked or whether a three-state button control is
            checked, unchecked, or indeterminate.
            </para>
            </summary>
            <param name="hDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box that contains the button control.</para>
            </param>
            <param name="nIDButton">
            <para>Type: <c>int</c></para>
            <para>The identifier of the button control.</para>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>
            The return value from a button created with the BS_AUTOCHECKBOX, BS_AUTORADIOBUTTON, BS_AUTO3STATE, BS_CHECKBOX, BS_RADIOBUTTON,
            or BS_3STATE styles can be one of the values in the following table. If the button has any other style, the return value is zero.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>BST_CHECKED</term>
            <term>The button is checked.</term>
            </item>
            <item>
            <term>BST_INDETERMINATE</term>
            <term>The button is in an indeterminate state (applies only if the button has the BS_3STATE or BS_AUTO3STATE style).</term>
            </item>
            <item>
            <term>BST_UNCHECKED</term>
            <term>The button is not checked.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>IsDlgButtonChecked</c> function sends a BM_GETCHECK message to the specified button control.</para>
            <para>Examples</para>
            <para>For an example, see the section titled "Creating a Modeless Dialog Box" in Using Dialog Boxes.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateCaret(Vanara.PInvoke.HWND,Vanara.PInvoke.HBITMAP,System.Int32,System.Int32)">
            <summary>
            Creates a new shape for the system caret and assigns ownership of the caret to the specified window. The caret shape can be a
            line, a block, or a bitmap.
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that owns the caret.</para>
            </param>
            <param name="hBitmap">
            <para>Type: <c>HBITMAP</c></para>
            <para>
            A handle to the bitmap that defines the caret shape. If this parameter is <c>NULL</c>, the caret is solid. If this parameter is ,
            the caret is gray. If this parameter is a bitmap handle, the caret is the specified bitmap. The bitmap handle must have been
            created by the CreateBitmap, CreateDIBitmap, or LoadBitmap function.
            </para>
            <para>
            If hBitmap is a bitmap handle, <c>CreateCaret</c> ignores the nWidth and nHeight parameters; the bitmap defines its own width and height.
            </para>
            </param>
            <param name="nWidth">
            <para>Type: <c>int</c></para>
            <para>
            The width of the caret, in logical units. If this parameter is zero, the width is set to the system-defined window border width.
            If hBitmap is a bitmap handle, <c>CreateCaret</c> ignores this parameter.
            </para>
            </param>
            <param name="nHeight">
            <para>Type: <c>int</c></para>
            <para>
            The height of the caret, in logical units. If this parameter is zero, the height is set to the system-defined window border
            height. If hBitmap is a bitmap handle, <c>CreateCaret</c> ignores this parameter.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The nWidth and nHeight parameters specify the caret's width and height, in logical units; the exact width and height, in pixels,
            depend on the window's mapping mode.
            </para>
            <para>
            <c>CreateCaret</c> automatically destroys the previous caret shape, if any, regardless of the window that owns the caret. The
            caret is hidden until the application calls the ShowCaret function to make the caret visible.
            </para>
            <para>
            The system provides one caret per queue. A window should create a caret only when it has the keyboard focus or is active. The
            window should destroy the caret before losing the keyboard focus or becoming inactive.
            </para>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. The width and height parameters are interpreted as logical sizes in terms of
            the window in question. The calling thread is not taken into consideration.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DestroyCaret">
            <summary>Destroys the caret's current shape, frees the caret from the window, and removes the caret from the screen.</summary>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            <c>DestroyCaret</c> destroys the caret only if a window in the current task owns the caret. If a window that is not in the
            current task owns the caret, <c>DestroyCaret</c> does nothing and returns <c>FALSE</c>.
            </para>
            <para>
            The system provides one caret per queue. A window should create a caret only when it has the keyboard focus or is active. The
            window should destroy the caret before losing the keyboard focus or becoming inactive.
            </para>
            <para>For an example, see Destroying a Caret</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetCaretBlinkTime">
            <summary>Retrieves the time required to invert the caret's pixels. The user can set this value.</summary>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>If the function succeeds, the return value is the blink time, in milliseconds.</para>
            <para>A return value of <c>INFINITE</c> indicates that the caret does not blink.</para>
            <para>A return value is zero indicates that the function has failed. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetCaretPos(Vanara.PInvoke.POINT@)">
            <summary>Copies the caret's position to the specified POINT structure.</summary>
            <param name="lpPoint">
            <para>Type: <c>LPPOINT</c></para>
            <para>A pointer to the POINT structure that is to receive the client coordinates of the caret.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>The caret position is always given in the client coordinates of the window that contains the caret.</para>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. The returned values are interpreted as logical sizes in terms of the window
            in question. The calling thread is not taken into consideration.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.HideCaret(Vanara.PInvoke.HWND)">
            <summary>
            Removes the caret from the screen. Hiding a caret does not destroy its current shape or invalidate the insertion point.
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window that owns the caret. If this parameter is <c>NULL</c>, <c>HideCaret</c> searches the current task for the
            window that owns the caret.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            <c>HideCaret</c> hides the caret only if the specified window owns the caret. If the specified window does not own the caret,
            <c>HideCaret</c> does nothing and returns <c>FALSE</c>.
            </para>
            <para>
            Hiding is cumulative. If your application calls <c>HideCaret</c> five times in a row, it must also call ShowCaret five times
            before the caret is displayed.
            </para>
            <para>For an example, see Hiding a Caret.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetCaretBlinkTime(System.UInt32)">
            <summary>
            Sets the caret blink time to the specified number of milliseconds. The blink time is the elapsed time, in milliseconds, required
            to invert the caret's pixels.
            </summary>
            <param name="uMSeconds">
            <para>Type: <c>UINT</c></para>
            <para>The new blink time, in milliseconds.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The user can set the blink time using the Control Panel. Applications should respect the setting that the user has chosen. The
            <c>SetCaretBlinkTime</c> function should only be used by application that allow the user to set the blink time, such as a Control
            Panel applet.
            </para>
            <para>
            If you change the blink time, subsequently activated applications will use the modified blink time, even if you restore the
            previous blink time when you lose the keyboard focus or become inactive. This is due to the multithreaded environment, where
            deactivation of your application is not synchronized with the activation of another application. This feature allows the system
            to activate another application even if the current application is not responding.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetCaretPos(System.Int32,System.Int32)">
            <summary>
            Moves the caret to the specified coordinates. If the window that owns the caret was created with the <c>CS_OWNDC</c> class style,
            then the specified coordinates are subject to the mapping mode of the device context associated with that window.
            </summary>
            <param name="X">
            <para>Type: <c>int</c></para>
            <para>The new x-coordinate of the caret.</para>
            </param>
            <param name="Y">
            <para>Type: <c>int</c></para>
            <para>The new y-coordinate of the caret.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para><c>SetCaretPos</c> moves the caret whether the caret is hidden.</para>
            <para>
            The system provides one caret per queue. A window should create a caret only when it has the keyboard focus or is active. The
            window should destroy the caret before losing the keyboard focus or becoming inactive. A window can set the caret position only
            if it owns the caret.
            </para>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. The provided position is interpreted as logical coordinates in terms of the
            window associated with the caret. The calling thread is not taken into consideration.
            </para>
            <para>Examples</para>
            <para>For an example, see Creating and Displaying a Caret.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ShowCaret(Vanara.PInvoke.HWND)">
            <summary>
            Makes the caret visible on the screen at the caret's current position. When the caret becomes visible, it begins flashing automatically.
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window that owns the caret. If this parameter is <c>NULL</c>, <c>ShowCaret</c> searches the current task for the
            window that owns the caret.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            <c>ShowCaret</c> shows the caret only if the specified window owns the caret, the caret has a shape, and the caret has not been
            hidden two or more times in a row. If one or more of these conditions is not met, <c>ShowCaret</c> does nothing and returns <c>FALSE</c>.
            </para>
            <para>
            Hiding is cumulative. If your application calls HideCaret five times in a row, it must also call <c>ShowCaret</c> five times
            before the caret reappears.
            </para>
            <para>
            The system provides one caret per queue. A window should create a caret only when it has the keyboard focus or is active. The
            window should destroy the caret before losing the keyboard focus or becoming inactive.
            </para>
            <para>Examples</para>
            <para>For an example, see Creating and Displaying a Caret.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.ClipboardNotificationMessage">
            <summary>Messages sent by Clipboard functions to the message window to notify of operations.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ClipboardNotificationMessage.WM_ASKCBFORMATNAME">
            <summary>
            <para>
            Sent to the clipboard owner by a clipboard viewer window to request the name of a <c>CF_OWNERDISPLAY</c> clipboard format.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            </summary>
            <returns>
            <para>If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>
            In response to this message, the clipboard owner should copy the name of the owner-display format to the specified buffer,
            not exceeding the buffer size specified by the wParam parameter.
            </para>
            <para>
            A clipboard viewer window sends this message to the clipboard owner to determine the name of the <c>CF_OWNERDISPLAY</c>
            format for example, to initialize a menu listing available formats.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.ClipboardNotificationMessage.WM_CHANGECBCHAIN">
            <summary>
            <para>Sent to the first window in the clipboard viewer chain when a window is being removed from the chain.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            </summary>
            <returns>
            <para>If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>
            Each clipboard viewer window saves the handle to the next window in the clipboard viewer chain. Initially, this handle is the
            return value of the <c>SetClipboardViewer</c> function.
            </para>
            <para>
            When a clipboard viewer window receives the <c>WM_CHANGECBCHAIN</c> message, it should call the <c>SendMessage</c> function
            to pass the message to the next window in the chain, unless the next window is the window being removed. In this case, the
            clipboard viewer should save the handle specified by the lParam parameter as the next window in the chain.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.ClipboardNotificationMessage.WM_CLIPBOARDUPDATE">
            <summary>
            <para>Sent when the contents of the clipboard have changed.</para>
            </summary>
            <returns>
            <para>If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>To register a window to receive this message, use the <c>AddClipboardFormatListener</c> function.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.ClipboardNotificationMessage.WM_DESTROYCLIPBOARD">
            <summary>
            <para>Sent to the clipboard owner when a call to the <c>EmptyClipboard</c> function empties the clipboard.</para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            </summary>
            <returns>
            <para>If an application processes this message, it should return zero.</para>
            </returns>
        </member>
        <member name="F:Vanara.PInvoke.User32.ClipboardNotificationMessage.WM_DRAWCLIPBOARD">
            <summary>
            <para>
            Sent to the first window in the clipboard viewer chain when the content of the clipboard changes. This enables a clipboard
            viewer window to display the new content of the clipboard.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            </summary>
            <remarks>
            <para>
            Only clipboard viewer windows receive this message. These are windows that have been added to the clipboard viewer chain by
            using the <c>SetClipboardViewer</c> function.
            </para>
            <para>
            Each window that receives the <c>WM_DRAWCLIPBOARD</c> message must call the <c>SendMessage</c> function to pass the message
            on to the next window in the clipboard viewer chain. The handle to the next window in the chain is returned by
            <c>SetClipboardViewer</c>, and may change in response to a <c>WM_CHANGECBCHAIN</c> message.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.ClipboardNotificationMessage.WM_HSCROLLCLIPBOARD">
            <summary>
            <para>
            Sent to the clipboard owner by a clipboard viewer window. This occurs when the clipboard contains data in the
            <c>CF_OWNERDISPLAY</c> format and an event occurs in the clipboard viewer's horizontal scroll bar. The owner should scroll
            the clipboard image and update the scroll bar values.
            </para>
            </summary>
            <returns>
            <para>If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>
            The clipboard owner can use the <c>ScrollWindow</c> function to scroll the image in the clipboard viewer window and
            invalidate the appropriate region.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.ClipboardNotificationMessage.WM_PAINTCLIPBOARD">
            <summary>
            <para>
            Sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the <c>CF_OWNERDISPLAY</c>
            format and the clipboard viewer's client area needs repainting.
            </para>
            </summary>
            <returns>
            <para>If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>
            To determine whether the entire client area or just a portion of it needs repainting, the clipboard owner must compare the
            dimensions of the drawing area given in the <c>rcPaint</c> member of <c>PAINTSTRUCT</c> to the dimensions given in the most
            recent <c>WM_SIZECLIPBOARD</c> message.
            </para>
            <para>
            The clipboard owner must use the <c>GlobalLock</c> function to lock the memory that contains the <c>PAINTSTRUCT</c>
            structure. Before returning, the clipboard owner must unlock that memory by using the <c>GlobalUnlock</c> function.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.ClipboardNotificationMessage.WM_RENDERALLFORMATS">
            <summary>
            <para>
            Sent to the clipboard owner before it is destroyed, if the clipboard owner has delayed rendering one or more clipboard
            formats. For the content of the clipboard to remain available to other applications, the clipboard owner must render data in
            all the formats it is capable of generating, and place the data on the clipboard by calling the <c>SetClipboardData</c> function.
            </para>
            <para>A window receives this message through its <c>WindowProc</c> function.</para>
            </summary>
            <returns>
            <para>If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>
            When responding to a <c>WM_RENDERALLFORMATS</c> message, the clipboard owner must call the <c>OpenClipboard</c> and
            <c>EmptyClipboard</c> functions before calling <c>SetClipboardData</c>.
            </para>
            <para>
            When the application returns, the system removes any unrendered formats from the list of available clipboard formats. For
            information about delayed rendering, see <c>SetClipboardData</c>.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.ClipboardNotificationMessage.WM_RENDERFORMAT">
            <summary>
            <para>
            Sent to the clipboard owner if it has delayed rendering a specific clipboard format and if an application has requested data
            in that format. The clipboard owner must render data in the specified format and place it on the clipboard by calling the
            <c>SetClipboardData</c> function.
            </para>
            </summary>
            <returns>
            <para>If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>
            When responding to a <c>WM_RENDERFORMAT</c> message, the clipboard owner must not open the clipboard before calling <c>SetClipboardData</c>.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.ClipboardNotificationMessage.WM_SIZECLIPBOARD">
            <summary>
            <para>
            Sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the <c>CF_OWNERDISPLAY</c>
            format and the clipboard viewer's client area has changed size.
            </para>
            </summary>
            <returns>
            <para>If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>
            When the clipboard viewer window is about to be destroyed or resized, a <c>WM_SIZECLIPBOARD</c> message is sent with a null
            rectangle (0, 0, 0, 0) as the new size. This permits the clipboard owner to free its display resources.
            </para>
            <para>
            The clipboard owner must use the <c>GlobalLock</c> function to lock the memory object that contains <c>RECT</c>. Before
            returning, the clipboard owner must unlock the object by using the <c>GlobalUnlock</c> function.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.ClipboardNotificationMessage.WM_VSCROLLCLIPBOARD">
            <summary>
            <para>
            Sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the <c>CF_OWNERDISPLAY</c>
            format and an event occurs in the clipboard viewer's vertical scroll bar. The owner should scroll the clipboard image and
            update the scroll bar values.
            </para>
            </summary>
            <returns>
            <para>If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>
            The clipboard owner can use the <c>ScrollWindow</c> function to scroll the image in the clipboard viewer window and
            invalidate the appropriate region.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.StandardClipboardFormat">
            <summary>The clipboard formats defined by the system are called standard clipboard formats.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_BITMAP">
            <summary>A handle to a bitmap (HBITMAP).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_DIB">
            <summary>A memory object containing a BITMAPINFO structure followed by the bitmap bits.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_DIBV5">
            <summary>
            A memory object containing a BITMAPV5HEADER structure followed by the bitmap color space information and the bitmap bits.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_DIF">
            <summary>Software Arts' Data Interchange Format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_DSPBITMAP">
            <summary>
            Bitmap display format associated with a private format. The hMem parameter must be a handle to data that can be displayed in
            bitmap format in lieu of the privately formatted data.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_DSPENHMETAFILE">
            <summary>
            Enhanced metafile display format associated with a private format. The hMem parameter must be a handle to data that can be
            displayed in enhanced metafile format in lieu of the privately formatted data.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_DSPMETAFILEPICT">
            <summary>
            Metafile-picture display format associated with a private format. The hMem parameter must be a handle to data that can be
            displayed in metafile-picture format in lieu of the privately formatted data.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_DSPTEXT">
            <summary>
            Text display format associated with a private format. The hMem parameter must be a handle to data that can be displayed in
            text format in lieu of the privately formatted data.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_ENHMETAFILE">
            <summary>A handle to an enhanced metafile (HENHMETAFILE).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_GDIOBJFIRST">
            <summary>
            Start of a range of integer values for application-defined GDI object clipboard formats. The end of the range is CF_GDIOBJLAST.
            <para>
            Handles associated with clipboard formats in this range are not automatically deleted using the GlobalFree function when the
            clipboard is emptied. Also, when using values in this range, the hMem parameter is not a handle to a GDI object, but is a
            handle allocated by the GlobalAlloc function with the GMEM_MOVEABLE flag.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_GDIOBJLAST">
            <summary>See CF_GDIOBJFIRST.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_HDROP">
            <summary>
            A handle to type HDROP that identifies a list of files. An application can retrieve information about the files by passing
            the handle to the DragQueryFile function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_LOCALE">
            <summary>
            The data is a handle to the locale identifier associated with text in the clipboard. When you close the clipboard, if it
            contains CF_TEXT data but no CF_LOCALE data, the system automatically sets the CF_LOCALE format to the current input
            language. You can use the CF_LOCALE format to associate a different locale with the clipboard text.
            <para>
            An application that pastes text from the clipboard can retrieve this format to determine which character set was used to
            generate the text.
            </para>
            <para>
            Note that the clipboard does not support plain text in multiple character sets. To achieve this, use a formatted text data
            type such as RTF instead.
            </para>
            <para>
            The system uses the code page associated with CF_LOCALE to implicitly convert from CF_TEXT to CF_UNICODETEXT. Therefore, the
            correct code page table is used for the conversion.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_METAFILEPICT">
            <summary>
            Handle to a metafile picture format as defined by the METAFILEPICT structure. When passing a CF_METAFILEPICT handle by means
            of DDE, the application responsible for deleting hMem should also free the metafile referred to by the CF_METAFILEPICT handle.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_OEMTEXT">
            <summary>
            Text format containing characters in the OEM character set. Each line ends with a carriage return/linefeed (CR-LF)
            combination. A null character signals the end of the data.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_OWNERDISPLAY">
            <summary>
            Owner-display format. The clipboard owner must display and update the clipboard viewer window, and receive the
            WM_ASKCBFORMATNAME, WM_HSCROLLCLIPBOARD, WM_PAINTCLIPBOARD, WM_SIZECLIPBOARD, and WM_VSCROLLCLIPBOARD messages. The hMem
            parameter must be NULL.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_PALETTE">
            <summary>
            Handle to a color palette. Whenever an application places data in the clipboard that depends on or assumes a color palette,
            it should place the palette on the clipboard as well.
            <para>
            If the clipboard contains data in the CF_PALETTE (logical color palette) format, the application should use the SelectPalette
            and RealizePalette functions to realize (compare) any other data in the clipboard against that logical palette.
            </para>
            <para>
            When displaying clipboard data, the clipboard always uses as its current palette any object on the clipboard that is in the
            CF_PALETTE format.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_PENDATA">
            <summary>Data for the pen extensions to the Microsoft Windows for Pen Computing.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_PRIVATEFIRST">
            <summary>
            Start of a range of integer values for private clipboard formats. The range ends with CF_PRIVATELAST. Handles associated with
            private clipboard formats are not freed automatically; the clipboard owner must free such handles, typically in response to
            the WM_DESTROYCLIPBOARD message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_PRIVATELAST">
            <summary>See CF_PRIVATEFIRST.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_RIFF">
            <summary>Represents audio data more complex than can be represented in a CF_WAVE standard wave format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_SYLK">
            <summary>Microsoft Symbolic Link (SYLK) format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_TEXT">
            <summary>
            Text format. Each line ends with a carriage return/linefeed (CR-LF) combination. A null character signals the end of the
            data. Use this format for ANSI text.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_TIFF">
            <summary>Tagged-image file format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_UNICODETEXT">
            <summary>
            Unicode text format. Each line ends with a carriage return/linefeed (CR-LF) combination. A null character signals the end of
            the data.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardClipboardFormat.CF_WAVE">
            <summary>Represents audio data in one of the standard wave formats, such as 11 kHz or 22 kHz PCM.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.AddClipboardFormatListener(Vanara.PInvoke.HWND)">
            <summary>
            <para>Places the given window in the system-maintained clipboard format listener list.</para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be placed in the clipboard format listener list.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if successful, <c>FALSE</c> otherwise. Call GetLastError for additional details.</para>
            </returns>
            <remarks>
            <para>
            When a window has been added to the clipboard format listener list, it is posted a WM_CLIPBOARDUPDATE message whenever the
            contents of the clipboard have changed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ChangeClipboardChain(Vanara.PInvoke.HWND,Vanara.PInvoke.HWND)">
            <summary>
            <para>Removes a specified window from the chain of clipboard viewers.</para>
            </summary>
            <param name="hWndRemove">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be removed from the chain. The handle must have been passed to the SetClipboardViewer function.</para>
            </param>
            <param name="hWndNewNext">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window that follows the hWndRemove window in the clipboard viewer chain. (This is the handle returned by
            SetClipboardViewer, unless the sequence was changed in response to a WM_CHANGECBCHAIN message.)
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            The return value indicates the result of passing the WM_CHANGECBCHAIN message to the windows in the clipboard viewer chain.
            Because a window in the chain typically returns <c>FALSE</c> when it processes <c>WM_CHANGECBCHAIN</c>, the return value from
            <c>ChangeClipboardChain</c> is typically <c>FALSE</c>. If there is only one window in the chain, the return value is typically <c>TRUE</c>.
            </para>
            </returns>
            <remarks>
            <para>
            The window identified by hWndNewNext replaces the hWndRemove window in the chain. The SetClipboardViewer function sends a
            WM_CHANGECBCHAIN message to the first window in the clipboard viewer chain.
            </para>
            <para>For an example, see Removing a Window from the Clipboard Viewer Chain.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CloseClipboard">
            <summary>
            <para>Closes the clipboard.</para>
            </summary>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            When the window has finished examining or changing the clipboard, close the clipboard by calling <c>CloseClipboard</c>. This
            enables other windows to access the clipboard.
            </para>
            <para>Do not place an object on the clipboard after calling <c>CloseClipboard</c>.</para>
            <para>Examples</para>
            <para>For an example, see Example of a Clipboard Viewer.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CountClipboardFormats">
            <summary>
            <para>Retrieves the number of different data formats currently on the clipboard.</para>
            </summary>
            <returns>
            <para>Type: <c>int</c></para>
            <para>If the function succeeds, the return value is the number of different data formats currently on the clipboard.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.EmptyClipboard">
            <summary>
            <para>
            Empties the clipboard and frees handles to data in the clipboard. The function then assigns ownership of the clipboard to the
            window that currently has the clipboard open.
            </para>
            </summary>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Before calling <c>EmptyClipboard</c>, an application must open the clipboard by using the OpenClipboard function. If the
            application specifies a <c>NULL</c> window handle when opening the clipboard, <c>EmptyClipboard</c> succeeds but sets the
            clipboard owner to <c>NULL</c>. Note that this causes SetClipboardData to fail.
            </para>
            <para>Examples</para>
            <para>For an example, see Copying Information to the Clipboard.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnumClipboardFormats(System.UInt32)">
            <summary>
            <para>Enumerates the data formats currently available on the clipboard.</para>
            <para>
            Clipboard data formats are stored in an ordered list. To perform an enumeration of clipboard data formats, you make a series of
            calls to the <c>EnumClipboardFormats</c> function. For each call, the format parameter specifies an available clipboard format,
            and the function returns the next available clipboard format.
            </para>
            </summary>
            <param name="format">
            <para>Type: <c>UINT</c></para>
            <para>A clipboard format that is known to be available.</para>
            <para>
            To start an enumeration of clipboard formats, set format to zero. When format is zero, the function retrieves the first available
            clipboard format. For subsequent calls during an enumeration, set format to the result of the previous
            <c>EnumClipboardFormats</c> call.
            </para>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>
            If the function succeeds, the return value is the clipboard format that follows the specified format, namely the next available
            clipboard format.
            </para>
            <para>
            If the function fails, the return value is zero. To get extended error information, call GetLastError. If the clipboard is not
            open, the function fails.
            </para>
            <para>
            If there are no more clipboard formats to enumerate, the return value is zero. In this case, the GetLastError function returns
            the value <c>ERROR_SUCCESS</c>. This lets you distinguish between function failure and the end of enumeration.
            </para>
            </returns>
            <remarks>
            <para>
            You must open the clipboard before enumerating its formats. Use the OpenClipboard function to open the clipboard. The
            <c>EnumClipboardFormats</c> function fails if the clipboard is not open.
            </para>
            <para>
            The <c>EnumClipboardFormats</c> function enumerates formats in the order that they were placed on the clipboard. If you are
            copying information to the clipboard, add clipboard objects in order from the most descriptive clipboard format to the least
            descriptive clipboard format. If you are pasting information from the clipboard, retrieve the first clipboard format that you can
            handle. That will be the most descriptive clipboard format that you can handle.
            </para>
            <para>
            The system provides automatic type conversions for certain clipboard formats. In the case of such a format, this function
            enumerates the specified format, then enumerates the formats to which it can be converted. For more information, see Standard
            Clipboard Formats and Synthesized Clipboard Formats.
            </para>
            <para>Examples</para>
            <para>For an example, see Example of a Clipboard Viewer.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnumClipboardFormats">
            <summary>
            <para>Enumerates the data formats currently available on the clipboard.</para>
            <para>Clipboard data formats are stored in an ordered list.</para>
            </summary>
            <returns>An enumeration of the data formats currently available on the clipboard.</returns>
            <remarks>
            <para>
            You must open the clipboard before enumerating its formats. Use the OpenClipboard function to open the clipboard. The
            <c>EnumClipboardFormats</c> function fails if the clipboard is not open.
            </para>
            <para>
            The <c>EnumClipboardFormats</c> function enumerates formats in the order that they were placed on the clipboard. If you are
            copying information to the clipboard, add clipboard objects in order from the most descriptive clipboard format to the least
            descriptive clipboard format. If you are pasting information from the clipboard, retrieve the first clipboard format that you can
            handle. That will be the most descriptive clipboard format that you can handle.
            </para>
            <para>
            The system provides automatic type conversions for certain clipboard formats. In the case of such a format, this function
            enumerates the specified format, then enumerates the formats to which it can be converted. For more information, see Standard
            Clipboard Formats and Synthesized Clipboard Formats.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetClipboardData(System.UInt32)">
            <summary>
            <para>Retrieves data from the clipboard in a specified format. The clipboard must have been opened previously.</para>
            </summary>
            <param name="uFormat">
            <para>Type: <c>UINT</c></para>
            <para>A clipboard format. For a description of the standard clipboard formats, see Standard Clipboard Formats.</para>
            </param>
            <returns>
            <para>Type: <c>HANDLE</c></para>
            <para>If the function succeeds, the return value is the handle to a clipboard object in the specified format.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para><c>Caution</c> Clipboard data is not trusted. Parse the data carefully before using it in your application.</para>
            <para>An application can enumerate the available formats in advance by using the EnumClipboardFormats function.</para>
            <para>
            The clipboard controls the handle that the <c>GetClipboardData</c> function returns, not the application. The application should
            copy the data immediately. The application must not free the handle nor leave it locked. The application must not use the handle
            after the EmptyClipboard or CloseClipboard function is called, or after the SetClipboardData function is called with the same
            clipboard format.
            </para>
            <para>
            The system performs implicit data format conversions between certain clipboard formats when an application calls the
            <c>GetClipboardData</c> function. For example, if the CF_OEMTEXT format is on the clipboard, a window can retrieve data in the
            CF_TEXT format. The format on the clipboard is converted to the requested format on demand. For more information, see Synthesized
            Clipboard Formats.
            </para>
            <para>Examples</para>
            <para>For an example, see Copying Information to the Clipboard.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetClipboardFormatName(System.UInt32,System.Text.StringBuilder,System.Int32)">
            <summary>
            <para>
            Retrieves from the clipboard the name of the specified registered format. The function copies the name to the specified buffer.
            </para>
            </summary>
            <param name="format">
            <para>Type: <c>UINT</c></para>
            <para>The type of format to be retrieved. This parameter must not specify any of the predefined clipboard formats.</para>
            </param>
            <param name="lpszFormatName">
            <para>Type: <c>LPTSTR</c></para>
            <para>The buffer that is to receive the format name.</para>
            </param>
            <param name="cchMaxCount">
            <para>Type: <c>int</c></para>
            <para>The maximum length, in characters, of the string to be copied to the buffer. If the name exceeds this limit, it is truncated.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>If the function succeeds, the return value is the length, in characters, of the string copied to the buffer.</para>
            <para>
            If the function fails, the return value is zero, indicating that the requested format does not exist or is predefined. To get
            extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>Security Considerations</para>
            <para>
            Using this function incorrectly might compromise the security of your program. For example, miscalculating the proper size of the
            lpszFormatName buffer, especially when the application is used in both ANSI and Unicode versions, can cause a buffer overflow.
            Also, note that the string is truncated if it is longer than the cchMaxCount parameter, which can lead to loss of information.
            </para>
            <para>Examples</para>
            <para>For an example, see Example of a Clipboard Viewer.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetClipboardOwner">
            <summary>
            <para>Retrieves the window handle of the current owner of the clipboard.</para>
            </summary>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>If the function succeeds, the return value is the handle to the window that owns the clipboard.</para>
            <para>If the clipboard is not owned, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>The clipboard can still contain data even if the clipboard is not currently owned.</para>
            <para>
            In general, the clipboard owner is the window that last placed data in clipboard. The EmptyClipboard function assigns clipboard ownership.
            </para>
            <para>Examples</para>
            <para>For an example, see Example of a Clipboard Viewer.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetClipboardSequenceNumber">
            <summary>
            <para>Retrieves the clipboard sequence number for the current window station.</para>
            </summary>
            <returns>
            <para>Type: <c>DWORD</c></para>
            <para>
            The return value is the clipboard sequence number. If you do not have <c>WINSTA_ACCESSCLIPBOARD</c> access to the window station,
            the function returns zero.
            </para>
            </returns>
            <remarks>
            <para>
            The system keeps a serial number for the clipboard for each window station. This number is incremented whenever the contents of
            the clipboard change or the clipboard is emptied. You can track this value to determine whether the clipboard contents have
            changed and optimize creating DataObjects. If clipboard rendering is delayed, the sequence number is not incremented until the
            changes are rendered.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetClipboardViewer">
            <summary>
            <para>Retrieves the handle to the first window in the clipboard viewer chain.</para>
            </summary>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>If the function succeeds, the return value is the handle to the first window in the clipboard viewer chain.</para>
            <para>If there is no clipboard viewer, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetOpenClipboardWindow">
            <summary>
            <para>Retrieves the handle to the window that currently has the clipboard open.</para>
            </summary>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>
            If the function succeeds, the return value is the handle to the window that has the clipboard open. If no window has the
            clipboard open, the return value is <c>NULL</c>. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            If an application or DLL specifies a <c>NULL</c> window handle when calling the OpenClipboard function, the clipboard is opened
            but is not associated with a window. In such a case, <c>GetOpenClipboardWindow</c> returns <c>NULL</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPriorityClipboardFormat(System.UInt32[],System.Int32)">
            <summary>
            <para>Retrieves the first available clipboard format in the specified list.</para>
            </summary>
            <param name="paFormatPriorityList">
            <para>Type: <c>UINT*</c></para>
            <para>
            The clipboard formats, in priority order. For a description of the standard clipboard formats, see Standard Clipboard Formats .
            </para>
            </param>
            <param name="cFormats">
            <para>Type: <c>int</c></para>
            <para>
            The number of entries in the paFormatPriorityList array. This value must not be greater than the number of entries in the list.
            </para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            If the function succeeds, the return value is the first clipboard format in the list for which data is available. If the
            clipboard is empty, the return value is NULL. If the clipboard contains data, but not in any of the specified formats, the return
            value is –1. To get extended error information, call GetLastError.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetUpdatedClipboardFormats(System.UInt32[],System.UInt32,System.UInt32@)">
            <summary>
            <para>Retrieves the currently supported clipboard formats.</para>
            </summary>
            <param name="lpuiFormats">
            <para>Type: <c>PUINT</c></para>
            <para>An array of clipboard formats. For a description of the standard clipboard formats, see Standard Clipboard Formats.</para>
            </param>
            <param name="cFormats">
            <para>Type: <c>UINT</c></para>
            <para>The number of entries in the array pointed to by lpuiFormats.</para>
            </param>
            <param name="pcFormatsOut">
            <para>Type: <c>PUINT</c></para>
            <para>The actual number of clipboard formats in the array pointed to by lpuiFormats.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>The function returns <c>TRUE</c> if successful; otherwise, <c>FALSE</c>. Call GetLastError for additional details.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsClipboardFormatAvailable(System.UInt32)">
            <summary>
            <para>Determines whether the clipboard contains data in the specified format.</para>
            </summary>
            <param name="format">
            <para>Type: <c>UINT</c></para>
            <para>
            A standard or registered clipboard format. For a description of the standard clipboard formats, see Standard Clipboard Formats .
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the clipboard format is available, the return value is nonzero.</para>
            <para>If the clipboard format is not available, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Typically, an application that recognizes only one clipboard format would call this function when processing the WM_INITMENU or
            WM_INITMENUPOPUP message. The application would then enable or disable the Paste menu item, depending on the return value.
            Applications that recognize more than one clipboard format should use the GetPriorityClipboardFormat function for this purpose.
            </para>
            <para>Examples</para>
            <para>For an example, see Pasting Information from the Clipboard.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.OpenClipboard(Vanara.PInvoke.HWND)">
            <summary>
            <para>Opens the clipboard for examination and prevents other applications from modifying the clipboard content.</para>
            </summary>
            <param name="hWndNewOwner">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window to be associated with the open clipboard. If this parameter is <c>NULL</c>, the open clipboard is
            associated with the current task.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para><c>OpenClipboard</c> fails if another window has the clipboard open.</para>
            <para>An application should call the CloseClipboard function after every successful call to <c>OpenClipboard</c>.</para>
            <para>
            The window identified by the hWndNewOwner parameter does not become the clipboard owner unless the EmptyClipboard function is called.
            </para>
            <para>
            If an application calls <c>OpenClipboard</c> with hwnd set to <c>NULL</c>, EmptyClipboard sets the clipboard owner to
            <c>NULL</c>; this causes SetClipboardData to fail.
            </para>
            <para>Examples</para>
            <para>For an example, see Copying Information to the Clipboard.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterClipboardFormat(System.String)">
            <summary>
            <para>Registers a new clipboard format. This format can then be used as a valid clipboard format.</para>
            </summary>
            <param name="lpszFormat">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The name of the new format.</para>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>If the function succeeds, the return value identifies the registered clipboard format.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If a registered format with the specified name already exists, a new format is not registered and the return value identifies the
            existing format. This enables more than one application to copy and paste data using the same registered clipboard format. Note
            that the format name comparison is case-insensitive.
            </para>
            <para>Registered clipboard formats are identified by values in the range 0xC000 through 0xFFFF.</para>
            <para>
            When registered clipboard formats are placed on or retrieved from the clipboard, they must be in the form of an <c>HGLOBAL</c> value.
            </para>
            <para>Examples</para>
            <para>For an example, see Registering a Clipboard Format.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.RemoveClipboardFormatListener(Vanara.PInvoke.HWND)">
            <summary>
            <para>Removes the given window from the system-maintained clipboard format listener list.</para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to remove from the clipboard format listener list.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns <c>TRUE</c> if successful, <c>FALSE</c> otherwise. Call GetLastError for additional details.</para>
            </returns>
            <remarks>
            <para>When a window has been removed from the clipboard format listener list, it will no longer receive WM_CLIPBOARDUPDATE messages.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetClipboardData(System.UInt32,System.IntPtr)">
            <summary>
            <para>
            Places data on the clipboard in a specified clipboard format. The window must be the current clipboard owner, and the application
            must have called the OpenClipboard function. (When responding to the WM_RENDERFORMAT and WM_RENDERALLFORMATS messages, the
            clipboard owner must not call <c>OpenClipboard</c> before calling <c>SetClipboardData</c>.)
            </para>
            </summary>
            <param name="uFormat">
            <para>Type: <c>UINT</c></para>
            <para>
            The clipboard format. This parameter can be a registered format or any of the standard clipboard formats. For more information,
            see Standard Clipboard Formats and Registered Clipboard Formats.
            </para>
            </param>
            <param name="hMem">
            <para>Type: <c>HANDLE</c></para>
            <para>
            A handle to the data in the specified format. This parameter can be <c>NULL</c>, indicating that the window provides data in the
            specified clipboard format (renders the format) upon request. If a window delays rendering, it must process the WM_RENDERFORMAT
            and WM_RENDERALLFORMATS messages.
            </para>
            <para>
            If <c>SetClipboardData</c> succeeds, the system owns the object identified by the hMem parameter. The application may not write
            to or free the data once ownership has been transferred to the system, but it can lock and read from the data until the
            CloseClipboard function is called. (The memory must be unlocked before the Clipboard is closed.) If the hMem parameter identifies
            a memory object, the object must have been allocated using the function with the <c>GMEM_MOVEABLE</c> flag.
            </para>
            </param>
            <returns>
            <para>Type: <c>HANDLE</c></para>
            <para>If the function succeeds, the return value is the handle to the data.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            <c>Windows 8:</c> Bitmaps to be shared with Windows Store app apps must be in the <c>CF_BITMAP</c> format (device-dependent bitmap).
            </para>
            <para>
            If an application calls <c>SetClipboardData</c> in response to WM_RENDERFORMAT or WM_RENDERALLFORMATS, the application should not
            use the handle after <c>SetClipboardData</c> has been called.
            </para>
            <para>
            If an application calls OpenClipboard with hwnd set to <c>NULL</c>, EmptyClipboard sets the clipboard owner to <c>NULL</c>; this
            causes <c>SetClipboardData</c> to fail.
            </para>
            <para>
            The system performs implicit data format conversions between certain clipboard formats when an application calls the
            GetClipboardData function. For example, if the <c>CF_OEMTEXT</c> format is on the clipboard, a window can retrieve data in the
            <c>CF_TEXT</c> format. The format on the clipboard is converted to the requested format on demand. For more information, see
            Synthesized Clipboard Formats.
            </para>
            <para>Examples</para>
            <para>For an example, see Copying Information to the Clipboard.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetClipboardViewer(Vanara.PInvoke.HWND)">
            <summary>
            <para>
            Adds the specified window to the chain of clipboard viewers. Clipboard viewer windows receive a WM_DRAWCLIPBOARD message whenever
            the content of the clipboard changes. This function is used for backward compatibility with earlier versions of Windows.
            </para>
            </summary>
            <param name="hWndNewViewer">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be added to the clipboard chain.</para>
            </param>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>
            If the function succeeds, the return value identifies the next window in the clipboard viewer chain. If an error occurs or there
            are no other windows in the clipboard viewer chain, the return value is NULL. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            The windows that are part of the clipboard viewer chain, called clipboard viewer windows, must process the clipboard messages
            WM_CHANGECBCHAIN and WM_DRAWCLIPBOARD. Each clipboard viewer window calls the SendMessage function to pass these messages to the
            next window in the clipboard viewer chain.
            </para>
            <para>
            A clipboard viewer window must eventually remove itself from the clipboard viewer chain by calling the ChangeClipboardChain
            function — for example, in response to the WM_DESTROY message.
            </para>
            <para>
            The <c>SetClipboardViewer</c> function exists to provide backward compatibility with earlier versions of Windows. The clipboard
            viewer chain can be broken by an application that fails to handle the clipboard chain messages properly. New applications should
            use more robust techniques such as the clipboard sequence number or the registration of a clipboard format listener. For further
            details on these alternatives techniques, see Monitoring Clipboard Contents.
            </para>
            <para>Examples</para>
            <para>For an example, see Adding a Window to the Clipboard Viewer Chain.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.METAFILEPICT">
            <summary>
            <para>Defines the metafile picture format used for exchanging metafile data through the clipboard.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.METAFILEPICT.mm">
            <summary>
            <para>Type: <c>LONG</c></para>
            <para>The mapping mode in which the picture is drawn.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.METAFILEPICT.xExt">
            <summary>
            <para>Type: <c>LONG</c></para>
            <para>
            The size of the metafile picture for all modes except the <c>MM_ISOTROPIC</c> and <c>MM_ANISOTROPIC</c> modes. (For more
            information about these modes, see the <c>yExt</c> member.) The x-extent specifies the width of the rectangle within which
            the picture is drawn. The coordinates are in units that correspond to the mapping mode.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.METAFILEPICT.yExt">
            <summary>
            <para>Type: <c>LONG</c></para>
            <para>
            The size of the metafile picture for all modes except the <c>MM_ISOTROPIC</c> and <c>MM_ANISOTROPIC</c> modes. The y-extent
            specifies the height of the rectangle within which the picture is drawn. The coordinates are in units that correspond to the
            mapping mode. For <c>MM_ISOTROPIC</c> and <c>MM_ANISOTROPIC</c> modes, which can be scaled, the <c>xExt</c> and <c>yExt</c>
            members contain an optional suggested size in <c>MM_HIMETRIC</c> units. For <c>MM_ANISOTROPIC</c> pictures, <c>xExt</c> and
            <c>yExt</c> can be zero when no suggested size is supplied. For <c>MM_ISOTROPIC</c> pictures, an aspect ratio must be
            supplied even when no suggested size is given. (If a suggested size is given, the aspect ratio is implied by the size.) To
            give an aspect ratio without implying a suggested size, set <c>xExt</c> and <c>yExt</c> to negative values whose ratio is the
            appropriate aspect ratio. The magnitude of the negative <c>xExt</c> and <c>yExt</c> values is ignored; only the ratio is used.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.METAFILEPICT.hMF">
            <summary>
            <para>Type: <c>HMETAFILE</c></para>
            <para>A handle to a memory metafile.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CBEN_FIRST">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.CBM_FIRST">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.User32.ComboBoxInfoState">
            <summary>Contains combo box status information.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxInfoState.None">
            <summary>The button exists and is not pressed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxInfoState.STATE_SYSTEM_INVISIBLE">
            <summary>There is no button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxInfoState.STATE_SYSTEM_PRESSED">
            <summary>The button is pressed.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ComboBoxMessage">
            <summary>Windows messages for combo-boxes.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ComboBoxNotification">
            <summary>Combo Box Notification Codes</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBN_ERRSPACE">
            <summary>
            Sent when a combo box cannot allocate enough memory to meet a specific request. The parent window of the combo box receives
            this notification code through the WM_COMMAND message.
            <list>
            <item>
            <term>wParam</term>
            <description>The LOWORD contains the control identifier of the combo box. The HIWORD specifies the notification code.</description>
            </item>
            <item>
            <term>lParam</term>
            <description>Handle to the combo box.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBN_SELCHANGE">
            <summary>
            Sent when the user changes the current selection in the list box of a combo box. The user can change the selection by
            clicking in the list box or by using the arrow keys. The parent window of the combo box receives this notification code in
            the form of a WM_COMMAND message.
            <list>
            <item>
            <term>wParam</term>
            <description>The LOWORD contains the control identifier of the combo box. The HIWORD specifies the notification code.</description>
            </item>
            <item>
            <term>lParam</term>
            <description>Handle to the combo box.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBN_DBLCLK">
            <summary>
            Sent when the user double-clicks a string in the list box of a combo box. The parent window of the combo box receives this
            notification code through the WM_COMMAND message.
            <list>
            <item>
            <term>wParam</term>
            <description>The LOWORD contains the control identifier of the combo box. The HIWORD specifies the notification code.</description>
            </item>
            <item>
            <term>lParam</term>
            <description>Handle to the combo box.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBN_SETFOCUS">
            <summary>
            Sent when a combo box receives the keyboard focus. The parent window of the combo box receives this notification code through
            the WM_COMMAND message.
            <list>
            <item>
            <term>wParam</term>
            <description>The LOWORD contains the control identifier of the combo box. The HIWORD specifies the notification code.</description>
            </item>
            <item>
            <term>lParam</term>
            <description>Handle to the combo box.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBN_KILLFOCUS">
            <summary>
            Sent when a combo box loses the keyboard focus. The parent window of the combo box receives this notification code through
            the WM_COMMAND message.
            <list>
            <item>
            <term>wParam</term>
            <description>The LOWORD contains the control identifier of the combo box. The HIWORD specifies the notification code.</description>
            </item>
            <item>
            <term>lParam</term>
            <description>Handle to the combo box.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBN_EDITCHANGE">
            <summary>
            Sent after the user has taken an action that may have altered the text in the edit control portion of a combo box. Unlike the
            CBN_EDITUPDATE notification code, this notification code is sent after the system updates the screen. The parent window of
            the combo box receives this notification code through the WM_COMMAND message.
            <list>
            <item>
            <term>wParam</term>
            <description>The LOWORD contains the control identifier of the combo box. The HIWORD specifies the notification code.</description>
            </item>
            <item>
            <term>lParam</term>
            <description>Handle to the combo box.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBN_EDITUPDATE">
            <summary>
            Sent when the edit control portion of a combo box is about to display altered text. This notification code is sent after the
            control has formatted the text, but before it displays the text. The parent window of the combo box receives this
            notification code through the WM_COMMAND message.
            <list>
            <item>
            <term>wParam</term>
            <description>The LOWORD contains the control identifier of the combo box. The HIWORD specifies the notification code.</description>
            </item>
            <item>
            <term>lParam</term>
            <description>Handle to the combo box.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBN_DROPDOWN">
            <summary>
            Sent when the list box of a combo box is about to be made visible. The parent window of the combo box receives this
            notification code through the WM_COMMAND message.
            <list>
            <item>
            <term>wParam</term>
            <description>The LOWORD contains the control identifier of the combo box. The HIWORD specifies the notification code.</description>
            </item>
            <item>
            <term>lParam</term>
            <description>Handle to the combo box.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBN_CLOSEUP">
            <summary>
            Sent when the list box of a combo box has been closed. The parent window of the combo box receives this notification code
            through the WM_COMMAND message.
            <list>
            <item>
            <term>wParam</term>
            <description>The LOWORD contains the control identifier of the combo box. The HIWORD specifies the notification code.</description>
            </item>
            <item>
            <term>lParam</term>
            <description>Handle to the combo box.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBN_SELENDOK">
            <summary>
            Sent when the user selects a list item, or selects an item and then closes the list. It indicates that the user's selection
            is to be processed. The parent window of the combo box receives this notification code through the WM_COMMAND message.
            <list>
            <item>
            <term>wParam</term>
            <description>The LOWORD contains the control identifier of the combo box. The HIWORD specifies the notification code.</description>
            </item>
            <item>
            <term>lParam</term>
            <description>Handle to the combo box.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBN_SELENDCANCEL">
            <summary>
            Sent when the user selects an item, but then selects another control or closes the dialog box. It indicates the user's
            initial selection is to be ignored. The parent window of the combo box receives this notification code through the WM_COMMAND message.
            <list>
            <item>
            <term>wParam</term>
            <description>The LOWORD contains the control identifier of the combo box. The HIWORD specifies the notification code.</description>
            </item>
            <item>
            <term>lParam</term>
            <description>Handle to the combo box.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBEN_INSERTITEM">
            <summary>
            Sent when a new item has been inserted in the control. This notification code is sent in the form of a WM_NOTIFY message.
            <list>
            <item>
            <term>lParam</term>
            <description>
            A pointer to an <c>NMCOMBOBOXEX</c> structure containing information about the notification code and the item that was inserted.
            </description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBEN_DELETEITEM">
            <summary>
            Sent when an item has been deleted. This notification code is sent in the form of a WM_NOTIFY message.
            <list>
            <item>
            <term>lParam</term>
            <description>
            A pointer to an <c>NMCOMBOBOXEX</c> structure that contains information about the notification code and the deleted item.
            </description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBEN_BEGINEDIT">
            <summary>
            Sent when the user activates the drop-down list or clicks in the control's edit box. This notification code is sent in the
            form of a WM_NOTIFY message.
            <list>
            <item>
            <term>lParam</term>
            <description>
            A pointer to an <see cref="T:Vanara.PInvoke.User32.NMHDR"/> structure that contains information about the notification code.
            </description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBEN_ENDEDITA">
            <summary>
            Sent when the user has concluded an operation within the edit box or has selected an item from the control's drop-down list.
            This notification code is sent in the form of a WM_NOTIFY message.
            <list>
            <item>
            <term>lParam</term>
            <description>
            A pointer to an <c>NMCBEENDEDIT</c> structure that contains information about how the user concluded the edit operation.
            </description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBEN_ENDEDITW">
            <summary>
            Sent when the user has concluded an operation within the edit box or has selected an item from the control's drop-down list.
            This notification code is sent in the form of a WM_NOTIFY message.
            <list>
            <item>
            <term>lParam</term>
            <description>
            A pointer to an <c>NMCBEENDEDIT</c> structure that contains information about how the user concluded the edit operation.
            </description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBEN_GETDISPINFO">
            <summary>
            Sent to retrieve display information about a callback item. This notification code is sent in the form of a WM_NOTIFY message.
            <list>
            <item>
            <term>lParam</term>
            <description>
            A pointer to an <c>NMCOMBOBOXEX</c> structure that contains information about the notification code.
            </description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxNotification.CBEN_DRAGBEGIN">
            <summary>
            Sent when the user begins dragging the image of the item displayed in the edit portion of the control. This notification code
            is sent in the form of a WM_NOTIFY message.
            <list>
            <item>
            <term>lParam</term>
            <description>
            A pointer to a <c>NMCBEDRAGBEGIN</c> structure that contains information about the notification code.
            </description>
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ComboBoxStyle">
            <summary>
            To create a combo box using the CreateWindow or CreateWindowEx function, specify the COMBOBOX class, appropriate window style
            constants, and a combination of the following combo box styles.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxStyle.CBS_SIMPLE">
            <summary>Displays the list box at all times. The current selection in the list box is displayed in the edit control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxStyle.CBS_DROPDOWN">
            <summary>
            Similar to CBS_SIMPLE, except that the list box is not displayed unless the user selects an icon next to the edit control.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxStyle.CBS_DROPDOWNLIST">
            <summary>
            Similar to CBS_DROPDOWN, except that the edit control is replaced by a static text item that displays the current selection
            in the list box.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxStyle.CBS_OWNERDRAWFIXED">
            <summary>
            Specifies that the owner of the list box is responsible for drawing its contents and that the items in the list box are all
            the same height. The owner window receives a WM_MEASUREITEM message when the combo box is created and a WM_DRAWITEM message
            when a visual aspect of the combo box has changed.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxStyle.CBS_OWNERDRAWVARIABLE">
            <summary>
            Specifies that the owner of the list box is responsible for drawing its contents and that the items in the list box are
            variable in height. The owner window receives a WM_MEASUREITEM message for each item in the combo box when you create the
            combo box and a WM_DRAWITEM message when a visual aspect of the combo box has changed.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxStyle.CBS_AUTOHSCROLL">
            <summary>
            Automatically scrolls the text in an edit control to the right when the user types a character at the end of the line. If
            this style is not set, only text that fits within the rectangular boundary is allowed.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxStyle.CBS_OEMCONVERT">
            <summary>
            Converts text entered in the combo box edit control from the Windows character set to the OEM character set and then back to
            the Windows character set. This ensures proper character conversion when the application calls the CharToOem function to
            convert a Windows string in the combo box to OEM characters. This style is most useful for combo boxes that contain file
            names and applies only to combo boxes created with the CBS_SIMPLE or CBS_DROPDOWN style.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxStyle.CBS_SORT">
            <summary>Automatically sorts strings added to the list box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxStyle.CBS_HASSTRINGS">
            <summary>
            Specifies that an owner-drawn combo box contains items consisting of strings. The combo box maintains the memory and address
            for the strings so the application can use the CB_GETLBTEXT message to retrieve the text for a particular item.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxStyle.CBS_NOINTEGRALHEIGHT">
            <summary>
            Specifies that the size of the combo box is exactly the size specified by the application when it created the combo box.
            Normally, the system sizes a combo box so that it does not display partial items.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxStyle.CBS_DISABLENOSCROLL">
            <summary>
            Shows a disabled vertical scroll bar in the list box when the box does not contain enough items to scroll. Without this
            style, the scroll bar is hidden when the list box does not contain enough items.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxStyle.CBS_UPPERCASE">
            <summary>Converts to uppercase all text in both the selection field and the list.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ComboBoxStyle.CBS_LOWERCASE">
            <summary>Converts to lowercase all text in both the selection field and the list.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ORIENTATION_PREFERENCE">
            <summary>
            <para>Indicates the screen orientation preference for a desktop app process.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ORIENTATION_PREFERENCE.ORIENTATION_PREFERENCE_NONE">
            <summary>The process has no device orientation preferences. The system may choose any available setting.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ORIENTATION_PREFERENCE.ORIENTATION_PREFERENCE_LANDSCAPE">
            <summary>The process represents a desktop app that can be used in landscape mode.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ORIENTATION_PREFERENCE.ORIENTATION_PREFERENCE_PORTRAIT">
            <summary>The process represents a desktop app that can be used in portrait mode.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ORIENTATION_PREFERENCE.ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED">
            <summary>The process represents a desktop app that can be used in flipped landscape mode.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ORIENTATION_PREFERENCE.ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED">
            <summary>The process represents a desktop app that can be used in flipped portrait mode.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.ClientToScreen(Vanara.PInvoke.HWND,Vanara.PInvoke.POINT@)">
            <summary>The <c>ClientToScreen</c> function converts the client-area coordinates of a specified point to screen coordinates.</summary>
            <param name="hWnd">A handle to the window whose client area is used for the conversion.</param>
            <param name="lpPoint">
            A pointer to a POINT structure that contains the client coordinates to be converted. The new screen coordinates are copied into
            this structure if the function succeeds.
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            The <c>ClientToScreen</c> function replaces the client-area coordinates in the POINT structure with the screen coordinates. The
            screen coordinates are relative to the upper-left corner of the screen. Note, a screen-coordinate point that is above the
            window's client area has a negative y-coordinate. Similarly, a screen coordinate to the left of a client area has a negative x-coordinate.
            </para>
            <para>All coordinates are device coordinates.</para>
            <para>Examples</para>
            <para>For an example, see "Drawing Lines with the Mouse" in Using Mouse Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetDisplayAutoRotationPreferences(Vanara.PInvoke.User32.ORIENTATION_PREFERENCE@)">
            <summary>Retrieves the screen auto-rotation preferences for the current process.</summary>
            <param name="pOrientation">
            Pointer to a location in memory that will receive the current orientation preference setting for the calling process.
            </param>
            <returns>TRUE if the method succeeds, otherwise FALSE.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.MapWindowPoints(Vanara.PInvoke.HWND,Vanara.PInvoke.HWND,Vanara.PInvoke.RECT@,System.UInt32)">
            <summary>
            The MapWindowPoints function converts (maps) a set of points from a coordinate space relative to one window to a coordinate space
            relative to another window.
            </summary>
            <param name="hWndFrom">
            A handle to the window from which points are converted. If this parameter is NULL or HWND_DESKTOP, the points are presumed to be
            in screen coordinates.
            </param>
            <param name="hWndTo">
            A handle to the window to which points are converted. If this parameter is NULL or HWND_DESKTOP, the points are converted to
            screen coordinates.
            </param>
            <param name="lpPoints">
            A pointer to an array of POINT structures that contain the set of points to be converted. The points are in device units. This
            parameter can also point to a RECT structure, in which case the cPoints parameter should be set to 2.
            </param>
            <param name="cPoints">The number of POINT structures in the array pointed to by the lpPoints parameter.</param>
            <returns>
            If the function succeeds, the low-order word of the return value is the number of pixels added to the horizontal coordinate of
            each source point in order to compute the horizontal coordinate of each destination point. (In addition to that, if precisely one
            of hWndFrom and hWndTo is mirrored, then each resulting horizontal coordinate is multiplied by -1.) The high-order word is the
            number of pixels added to the vertical coordinate of each source point in order to compute the vertical coordinate of each
            destination point.
            <para>
            If the function fails, the return value is zero. Call SetLastError prior to calling this method to differentiate an error return
            value from a legitimate "0" return value.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.MapWindowPoints(Vanara.PInvoke.HWND,Vanara.PInvoke.HWND,Vanara.PInvoke.POINT@,System.UInt32)">
            <summary>
            The MapWindowPoints function converts (maps) a set of points from a coordinate space relative to one window to a coordinate space
            relative to another window.
            </summary>
            <param name="hWndFrom">
            A handle to the window from which points are converted. If this parameter is NULL or HWND_DESKTOP, the points are presumed to be
            in screen coordinates.
            </param>
            <param name="hWndTo">
            A handle to the window to which points are converted. If this parameter is NULL or HWND_DESKTOP, the points are converted to
            screen coordinates.
            </param>
            <param name="lpPoints">
            A pointer to an array of POINT structures that contain the set of points to be converted. The points are in device units. This
            parameter can also point to a RECT structure, in which case the cPoints parameter should be set to 2.
            </param>
            <param name="cPoints">The number of POINT structures in the array pointed to by the lpPoints parameter.</param>
            <returns>
            If the function succeeds, the low-order word of the return value is the number of pixels added to the horizontal coordinate of
            each source point in order to compute the horizontal coordinate of each destination point. (In addition to that, if precisely one
            of hWndFrom and hWndTo is mirrored, then each resulting horizontal coordinate is multiplied by -1.) The high-order word is the
            number of pixels added to the vertical coordinate of each source point in order to compute the vertical coordinate of each
            destination point.
            <para>
            If the function fails, the return value is zero. Call SetLastError prior to calling this method to differentiate an error return
            value from a legitimate "0" return value.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.MapWindowPoints(Vanara.PInvoke.HWND,Vanara.PInvoke.HWND,Vanara.PInvoke.POINT[],System.Int32)">
            <summary>
            The MapWindowPoints function converts (maps) a set of points from a coordinate space relative to one window to a coordinate space
            relative to another window.
            </summary>
            <param name="hWndFrom">
            A handle to the window from which points are converted. If this parameter is NULL or HWND_DESKTOP, the points are presumed to be
            in screen coordinates.
            </param>
            <param name="hWndTo">
            A handle to the window to which points are converted. If this parameter is NULL or HWND_DESKTOP, the points are converted to
            screen coordinates.
            </param>
            <param name="lpPoints">
            A pointer to an array of POINT structures that contain the set of points to be converted. The points are in device units. This
            parameter can also point to a RECT structure, in which case the cPoints parameter should be set to 2.
            </param>
            <param name="cPoints">The number of POINT structures in the array pointed to by the lpPoints parameter.</param>
            <returns>
            If the function succeeds, the low-order word of the return value is the number of pixels added to the horizontal coordinate of
            each source point in order to compute the horizontal coordinate of each destination point. (In addition to that, if precisely one
            of hWndFrom and hWndTo is mirrored, then each resulting horizontal coordinate is multiplied by -1.) The high-order word is the
            number of pixels added to the vertical coordinate of each source point in order to compute the vertical coordinate of each
            destination point.
            <para>
            If the function fails, the return value is zero. Call SetLastError prior to calling this method to differentiate an error return
            value from a legitimate "0" return value.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.ScreenToClient(Vanara.PInvoke.HWND,Vanara.PInvoke.POINT@)">
            <summary>The ScreenToClient function converts the screen coordinates of a specified point on the screen to client-area coordinates.</summary>
            <param name="hWnd">A handle to the window whose client area will be used for the conversion.</param>
            <param name="lpPoint">A pointer to a POINT structure that specifies the screen coordinates to be converted.</param>
            <returns>
            If the function succeeds, the return value is true. If the function fails, the return value is false. To get extended error
            information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetDisplayAutoRotationPreferences(Vanara.PInvoke.User32.ORIENTATION_PREFERENCE)">
            <summary>Sets the orientation preferences of the display.</summary>
            <param name="orientation">The orientation.</param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If this function set the orientation preferences, the return value is nonzero.</para>
            <para>If the orientation preferences weren't set, the return value is zero.</para>
            </returns>
            <remarks>
            An app can remove the orientation preferences of the display after it sets them by passing <c>ORIENTATION_PREFERENCE_NONE</c> to
            <c>SetDisplayAutoRotationPreferences</c>. An app can change the orientation preferences of the display by passing a different
            combination of <c>ORIENTATION_PREFERENCE</c>-typed values to <c>SetDisplayAutoRotationPreferences</c>.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.AR_STATE">
            <summary>
            <para>
            Indicates the state of screen auto-rotation for the system. For example, whether auto-rotation is supported, and whether it is
            enabled by the user. This enum is a bitwise OR of one or more of the following values.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AR_STATE.AR_ENABLED">
            <summary>Auto-rotation is enabled by the user.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AR_STATE.AR_DISABLED">
            <summary>Auto-rotation is disabled by the user.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AR_STATE.AR_SUPPRESSED">
            <summary>Auto-rotation is currently suppressed by one or more process auto-rotation preferences.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AR_STATE.AR_REMOTESESSION">
            <summary>The session is remote, and auto-rotation is temporarily disabled as a result.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AR_STATE.AR_MULTIMON">
            <summary>The system has multiple monitors attached, and auto-rotation is temporarily disabled as a result.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AR_STATE.AR_NOSENSOR">
            <summary>The system does not have an auto-rotation sensor.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AR_STATE.AR_NOT_SUPPORTED">
            <summary>Auto-rotation is not supported with the current system configuration.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AR_STATE.AR_DOCKED">
            <summary>The device is docked, and auto-rotation is temporarily disabled as a result.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AR_STATE.AR_LAPTOP">
            <summary>The device is in laptop mode, and auto-rotation is temporarily disabled as a result.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TOOLTIP_DISMISS_FLAGS">
            <summary>Defines constants that indicate whether a window is registered or unregistered to receive tooltip dismiss notifications.</summary>
            <remarks>This enumeration is used by the RegisterForTooltipDismissNotification function.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOOLTIP_DISMISS_FLAGS.TDF_REGISTER">
            <summary>The window is registered to receive tooltip dismiss notifications.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOOLTIP_DISMISS_FLAGS.TDF_UNREGISTER">
            <summary>The window is unregistered from receiving tooltip dismiss notifications.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.CharToOem(System.String,System.Text.StringBuilder)">
            <summary>
            <para>Translates a string into the OEM-defined character set.</para>
            <para><c>Warning</c> Do not use. See Security Considerations.</para>
            </summary>
            <param name="pSrc">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The null-terminated string to be translated.</para>
            </param>
            <param name="pDst">
            <para>Type: <c>LPSTR</c></para>
            <para>
            The destination buffer, which receives the translated string. If the <c>CharToOem</c> function is being used as an ANSI function,
            the string can be translated in place by setting the lpszDst parameter to the same address as the lpszSrc parameter. This cannot
            be done if <c>CharToOem</c> is being used as a wide-character function.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            The return value is always nonzero except when you pass the same address to lpszSrc and lpszDst in the wide-character version of
            the function. In this case the function returns zero and GetLastError returns <c>ERROR_INVALID_ADDRESS</c>.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.CharToOemBuff(System.String,System.Text.StringBuilder,System.UInt32)">
            <summary>Translates a specified number of characters in a string into the OEM-defined character set.</summary>
            <param name="lpszSrc">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The null-terminated string to be translated.</para>
            </param>
            <param name="lpszDst">
            <para>Type: <c>LPSTR</c></para>
            <para>
            The buffer for the translated string. If the <c>CharToOemBuff</c> function is being used as an ANSI function, the string can be
            translated in place by setting the lpszDst parameter to the same address as the lpszSrc parameter. This cannot be done if
            <c>CharToOemBuff</c> is being used as a wide-character function.
            </para>
            </param>
            <param name="cchDstLength">
            <para>Type: <c>DWORD</c></para>
            <para>The number of characters to translate in the string identified by the lpszSrc parameter.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            The return value is always nonzero except when you pass the same address to lpszSrc and lpszDst in the wide-character version of
            the function. In this case the function returns zero and GetLastError returns <c>ERROR_INVALID_ADDRESS</c>.
            </para>
            </returns>
            <remarks>
            Unlike the CharToOem function, the <c>CharToOemBuff</c> function does not stop converting characters when it encounters a null
            character in the buffer pointed to by lpszSrc. The <c>CharToOemBuff</c> function converts all cchDstLength characters.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetAutoRotationState(Vanara.PInvoke.User32.AR_STATE@)">
            <summary>
            Retrieves an AR_STATE value containing the state of screen auto-rotation for the system, for example whether auto-rotation is
            supported, and whether it is enabled by the user. <c>GetAutoRotationState</c> provides a robust and diverse way of querying for
            auto-rotation state, and more. For example, if you want your app to behave differently when multiple monitors are attached then
            you can determine that from the <c>AR_STATE</c> returned.
            </summary>
            <param name="pState">Pointer to a location in memory that will receive the current state of auto-rotation for the system.</param>
            <returns>
            <para>TRUE if the method succeeds, otherwise FALSE.</para>
            <para>See GetDisplayAutoRotationPreferences for an example of using this function.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.OemToChar(System.String,System.Text.StringBuilder)">
            <summary>
            <para>Translates a string from the OEM-defined character set into either an ANSI or a wide-character string.</para>
            <para><c>Warning</c> Do not use. See Security Considerations.</para>
            </summary>
            <param name="pSrc">
            <para>Type: <c>LPCSTR</c></para>
            <para>A null-terminated string of characters from the OEM-defined character set.</para>
            </param>
            <param name="pDst">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            The destination buffer, which receives the translated string. If the <c>OemToChar</c> function is being used as an ANSI function,
            the string can be translated in place by setting the lpszDst parameter to the same address as the lpszSrc parameter. This cannot
            be done if <c>OemToChar</c> is being used as a wide-character function.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            The return value is always nonzero except when you pass the same address to lpszSrc and lpszDst in the wide-character version of
            the function. In this case the function returns zero and GetLastError returns <c>ERROR_INVALID_ADDRESS</c>.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.OemToCharBuff(System.String,System.Text.StringBuilder,System.UInt32)">
            <summary>
            Translates a specified number of characters in a string from the OEM-defined character set into either an ANSI or a
            wide-character string.
            </summary>
            <param name="lpszSrc">
            <para>Type: <c>LPCSTR</c></para>
            <para>One or more characters from the OEM-defined character set.</para>
            </param>
            <param name="lpszDst">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            The destination buffer, which receives the translated string. If the <c>OemToCharBuff</c> function is being used as an ANSI
            function, the string can be translated in place by setting the lpszDst parameter to the same address as the lpszSrc parameter.
            This cannot be done if the <c>OemToCharBuff</c> function is being used as a wide-character function.
            </para>
            </param>
            <param name="cchDstLength">
            <para>Type: <c>DWORD</c></para>
            <para>The number of characters to be translated in the buffer identified by the lpszSrc parameter.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            The return value is always nonzero except when you pass the same address to lpszSrc and lpszDst in the wide-character version of
            the function. In this case the function returns zero and GetLastError returns <c>ERROR_INVALID_ADDRESS</c>.
            </para>
            </returns>
            <remarks>
            Unlike the OemToChar function, the <c>OemToCharBuff</c> function does not stop converting characters when it encounters a null
            character in the buffer pointed to by lpszSrc. The <c>OemToCharBuff</c> function converts all cchDstLength characters.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterForTooltipDismissNotification(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.TOOLTIP_DISMISS_FLAGS)">
            <summary>Registers or unregisters windows to receive notification to dismiss their tooltip windows.</summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>The handle of the window to receive the <c>WM_TOOLTIPDISMISS</c> message.</para>
            </param>
            <param name="tdFlags">
            <para>Type: <c>TOOLTIP_DISMISS_FLAGS</c></para>
            <para>
            A value of the enumeration that specifies whether the function registers or unregisters the window. <c>TDF_REGISTER</c> to
            register; <c>TDF_UNREGISTER</c> to unregister.
            </para>
            </param>
            <returns><c>TRUE</c> if the window was successfully registered or unregistered; otherwise, <c>FALSE</c>. (See Remarks.)</returns>
            <remarks>
            <para>
            This function makes tooltips more accessible by letting apps and frameworks that support tooltips register and unregister to be
            notified by a <c>WM_TOOLTIPDISMISS</c> message when the system requires all showing tooltips to be dismissed.
            </para>
            <para>
            Apps should register for this notification each time they show a tooltip and hide their tooltips in response to a
            <c>WM_TOOLTIPDISMISS</c> message. When a tooltip is hidden for some other reason, like a mouse action, the app should unregister.
            </para>
            <para>
            System-defined triggers for tooltip dismissal include a solitary Ctrl key up or Ctrl+Shift+F10. (The set of triggers may change
            over time.)
            </para>
            <para>The function takes either the <c>HWND</c> of a tooltip window or the <c>HWND</c> of an app window that has child tooltips.</para>
            <list type="bullet">
            <item>
            <term>
            If a tooltip <c>HWND</c> itself is registered, the tooltip window is expected to register upon showing and to dismiss upon
            receiving a <c>WM_TOOLTIPDISMISS</c> message.
            </term>
            </item>
            <item>
            <term>
            If an app <c>HWND</c> registers on behalf of its tooltips, the app's window is expected to register upon showing tooltips and
            dismiss all of its tooltips upon receiving a <c>WM_TOOLTIPDISMISS</c> message.
            </term>
            </item>
            </list>
            <para>
            Tooltip or app windows are expected to call the function to register each time tooltips are shown. Registered windows are
            automatically unregistered upon posting <c>WM_TOOLTIPDISMISS</c>.
            </para>
            <para>
            The <c>TDF_UNREGISTER</c> flag is used to explicitly unregister a window when a tooltip window is dismissed by application or
            framework prerogative (such as moving the cursor out of the "safe zone"). If an app or framework calls with <c>TDF_UNREGISTER</c>
            after the window has been automatically unregistered, the function returns <c>FALSE</c>. There is no impact on future registrations.
            </para>
            <para>Return values</para>
            <para>The HWND passed into the function must be owned by the calling process; otherwise, the function returns <c>FALSE</c>.</para>
            <para>
            When called with <c>TDF_REGISTER</c> and a window belonging to the calling process, the function returns <c>TRUE</c> if the
            window was successfully registered or <c>FALSE</c> if the window was already registered. The window is treated as registered
            either way.
            </para>
            <para>
            When called with <c>TDF_UNREGISTER</c> and a windows belonging to the calling process, the function returns <c>TRUE</c> if the
            window is successfully unregistered, or <c>FALSE</c> if the windows was not currently registered. The window is treated as
            unregistered either way.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetLastErrorEx(System.UInt32,System.UInt32)">
            <summary>
            <para>Sets the last-error code.</para>
            <para>Currently, this function is identical to the SetLastError function. The second parameter is ignored.</para>
            </summary>
            <param name="dwErrCode">The last-error code for the thread.</param>
            <param name="dwType">This parameter is ignored.</param>
            <remarks>
            <para>The last-error code is kept in thread local storage so that multiple threads do not overwrite each other's values.</para>
            <para>
            Most functions call SetLastError or <c>SetLastErrorEx</c> only when they fail. However, some system functions call
            <c>SetLastError</c> or <c>SetLastErrorEx</c> under conditions of success; those cases are noted in each function's documentation.
            </para>
            <para>
            Applications can optionally retrieve the value set by this function by using the GetLastError function immediately after a
            function fails.
            </para>
            <para>
            Error codes are 32-bit values (bit 31 is the most significant bit). Bit 29 is reserved for application-defined error codes; no
            system error code has this bit set. If you are defining an error code for your application, set this bit to indicate that the
            error code has been defined by the application and to ensure that your error code does not conflict with any system-defined error codes.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_APPSTARTING">
            <summary>Standard arrow and small hourglass</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_ARROW">
            <summary>Standard arrow</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_CROSS">
            <summary>Crosshair</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_HAND">
            <summary>Hand</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_HELP">
            <summary>Arrow and question mark</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_IBEAM">
            <summary>I-beam</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_ICON">
            <summary>Obsolete for applications marked version 4.0 or later.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_NO">
            <summary>Slashed circle</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_PERSON">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_PIN">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_SIZE">
            <summary>Obsolete for applications marked version 4.0 or later. Use <c>IDC_SIZEALL</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_SIZEALL">
            <summary>Four-pointed arrow pointing north, south, east, and west</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_SIZENESW">
            <summary>Double-pointed arrow pointing northeast and southwest</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_SIZENS">
            <summary>Double-pointed arrow pointing north and south</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_SIZENWSE">
            <summary>Double-pointed arrow pointing northwest and southeast</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_SIZEWE">
            <summary>Double-pointed arrow pointing west and east</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_UPARROW">
            <summary>Vertical arrow</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDC_WAIT">
            <summary>Hourglass</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.CursorState">
            <summary>The cursor state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CursorState.CURSOR_HIDDEN">
            <summary>The cursor is hidden.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CursorState.CURSOR_SHOWING">
            <summary>The cursor is showing.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CursorState.CURSOR_SUPPRESSED">
            <summary>
            Windows 8: The cursor is suppressed. This flag indicates that the system is not drawing the cursor because the user is
            providing input through touch or pen instead of the mouse.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.OCR">
            <summary>System cursor types.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.OCR.OCR_APPSTARTING">
            <summary>Standard arrow and small hourglass</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.OCR.OCR_NORMAL">
            <summary>Standard arrow</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.OCR.OCR_CROSS">
            <summary>Crosshair</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.OCR.OCR_HAND">
            <summary>Hand</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.OCR.OCR_HELP">
            <summary>Arrow and question mark</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.OCR.OCR_IBEAM">
            <summary>I-beam</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.OCR.OCR_NO">
            <summary>Slashed circle</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.OCR.OCR_SIZEALL">
            <summary>Four-pointed arrow pointing north, south, east, and west</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.OCR.OCR_SIZENESW">
            <summary>Double-pointed arrow pointing northeast and southwest</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.OCR.OCR_SIZENS">
            <summary>Double-pointed arrow pointing north and south</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.OCR.OCR_SIZENWSE">
            <summary>Double-pointed arrow pointing northwest and southeast</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.OCR.OCR_SIZEWE">
            <summary>Double-pointed arrow pointing west and east</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.OCR.OCR_UP">
            <summary>Vertical arrow</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.OCR.OCR_WAIT">
            <summary>Hourglass</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.ClipCursor(Vanara.PInvoke.RECT@)">
            <summary>
            <para>
            Confines the cursor to a rectangular area on the screen. If a subsequent cursor position (set by the SetCursorPos function or the
            mouse) lies outside the rectangle, the system automatically adjusts the position to keep the cursor inside the rectangular area.
            </para>
            </summary>
            <param name="lpRect">
            <para>Type: <c>const RECT*</c></para>
            <para>
            A pointer to the structure that contains the screen coordinates of the upper-left and lower-right corners of the confining
            rectangle. If this parameter is <c>NULL</c>, the cursor is free to move anywhere on the screen.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The cursor is a shared resource. If an application confines the cursor, it must release the cursor by using <c>ClipCursor</c>
            before relinquishing control to another application.
            </para>
            <para>The calling process must have <c>WINSTA_WRITEATTRIBUTES</c> access to the window station.</para>
            <para>Examples</para>
            <para>For an example, see Confining a Cursor.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CopyCursor(Vanara.PInvoke.HCURSOR,Vanara.PInvoke.SIZE,Vanara.PInvoke.User32.CopyImageOptions)">
            <summary>
            Creates a new cursor and copies the attributes of the specified image to the new one. If necessary, the function stretches the
            bits to fit the desired size of the new image.
            </summary>
            <param name="h">
            <para>A handle to the image to be copied.</para>
            </param>
            <param name="desiredSize">
            The desired size, in pixels, of the image. If this is Size.Empty, then the returned image will have the same size as the original hImage.
            </param>
            <param name="options">
            <para>This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>LR_COPYDELETEORG 0x00000008</term>
            <term>Deletes the original image after creating the copy.</term>
            </item>
            <item>
            <term>LR_COPYFROMRESOURCE 0x00004000</term>
            <term>
            Tries to reload an icon or cursor resource from the original resource file rather than simply copying the current image. This is
            useful for creating a different-sized copy when the resource file contains multiple sizes of the resource. Without this flag,
            CopyImage stretches the original image to the new size. If this flag is set, CopyImage uses the size in the resource file closest
            to the desired size. This will succeed only if hImage was loaded by LoadIcon or LoadCursor, or by LoadImage with the LR_SHARED flag.
            </term>
            </item>
            <item>
            <term>LR_COPYRETURNORG 0x00000004</term>
            <term>
            Returns the original hImage if it satisfies the criteria for the copy—that is, correct dimensions and color depth—in which case
            the LR_COPYDELETEORG flag is ignored. If this flag is not specified, a new object is always created.
            </term>
            </item>
            <item>
            <term>LR_CREATEDIBSECTION 0x00002000</term>
            <term>
            If this is set and a new bitmap is created, the bitmap is created as a DIB section. Otherwise, the bitmap image is created as a
            device-dependent bitmap. This flag is only valid if uType is IMAGE_BITMAP.
            </term>
            </item>
            <item>
            <term>LR_DEFAULTSIZE 0x00000040</term>
            <term>
            Uses the width or height specified by the system metric values for cursors or icons, if the cxDesired or cyDesired values are set
            to zero. If this flag is not specified and cxDesired and cyDesired are set to zero, the function uses the actual resource size.
            If the resource contains multiple images, the function uses the size of the first image.
            </term>
            </item>
            <item>
            <term>LR_MONOCHROME 0x00000001</term>
            <term>Creates a new monochrome image.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>The return value is a safe handle to the newly created image.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateCursor(Vanara.PInvoke.HINSTANCE,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            <para>Creates a cursor having the specified size, bit patterns, and hot spot.</para>
            </summary>
            <param name="hInst">
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to the current instance of the application creating the cursor.</para>
            </param>
            <param name="xHotSpot">
            <para>Type: <c>int</c></para>
            <para>The horizontal position of the cursor's hot spot.</para>
            </param>
            <param name="yHotSpot">
            <para>Type: <c>int</c></para>
            <para>The vertical position of the cursor's hot spot.</para>
            </param>
            <param name="nWidth">
            <para>Type: <c>int</c></para>
            <para>The width of the cursor, in pixels.</para>
            </param>
            <param name="nHeight">
            <para>Type: <c>int</c></para>
            <para>The height of the cursor, in pixels.</para>
            </param>
            <param name="pvANDPlane">
            <para>Type: <c>const VOID*</c></para>
            <para>An array of bytes that contains the bit values for the AND mask of the cursor, as in a device-dependent monochrome bitmap.</para>
            </param>
            <param name="pvXORPlane">
            <para>Type: <c>const VOID*</c></para>
            <para>An array of bytes that contains the bit values for the XOR mask of the cursor, as in a device-dependent monochrome bitmap.</para>
            </param>
            <returns>
            <para>Type: <c>HCURSOR</c></para>
            <para>If the function succeeds, the return value is a handle to the cursor.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The nWidth and nHeight parameters must specify a width and height that are supported by the current display driver, because the
            system cannot create cursors of other sizes. To determine the width and height supported by the display driver, use the
            GetSystemMetrics function, specifying the <c>SM_CXCURSOR</c> or <c>SM_CYCURSOR</c> value.
            </para>
            <para>Before closing, an application must call the DestroyCursor function to free any system resources associated with the cursor.</para>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. The output returned is in terms of physical coordinates, and is not affected
            by the DPI of the calling thread. Note that the cursor created may still be scaled to match the DPI of any given window it is
            drawn into.
            </para>
            <para>Examples</para>
            <para>For an example, see Creating a Cursor.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DestroyCursor(Vanara.PInvoke.HCURSOR)">
            <summary>
            <para>Destroys a cursor and frees any memory the cursor occupied. Do not use this function to destroy a shared cursor.</para>
            </summary>
            <param name="hCursor">
            <para>Type: <c>HCURSOR</c></para>
            <para>A handle to the cursor to be destroyed. The cursor must not be in use.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>DestroyCursor</c> function destroys a nonshared cursor. Do not use this function to destroy a shared cursor. A shared
            cursor is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared cursor:
            </para>
            <list type="bullet">
            <item>
            <term>LoadCursor</term>
            </item>
            <item>
            <term>LoadCursorFromFile</term>
            </item>
            <item>
            <term>LoadImage (if you use the <c>LR_SHARED</c> flag)</term>
            </item>
            <item>
            <term>CopyImage (if you use the <c>LR_COPYRETURNORG</c> flag and the hImage parameter is a shared cursor)</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetClipCursor(Vanara.PInvoke.RECT@)">
            <summary>
            <para>Retrieves the screen coordinates of the rectangular area to which the cursor is confined.</para>
            </summary>
            <param name="lpRect">
            <para>Type: <c>LPRECT</c></para>
            <para>
            A pointer to a RECT structure that receives the screen coordinates of the confining rectangle. The structure receives the
            dimensions of the screen if the cursor is not confined to a rectangle.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The cursor is a shared resource. If an application confines the cursor with the ClipCursor function, it must later release the
            cursor by using <c>ClipCursor</c> before relinquishing control to another application.
            </para>
            <para>The calling process must have <c>WINSTA_READATTRIBUTES</c> access to the window station.</para>
            <para>Examples</para>
            <para>For an example, see Confining a Cursor.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetCursor">
            <summary>
            <para>Retrieves a handle to the current cursor.</para>
            <para>To get information on the global cursor, even if it is not owned by the current thread, use GetCursorInfo.</para>
            </summary>
            <returns>
            <para>Type: <c>HCURSOR</c></para>
            <para>The return value is the handle to the current cursor. If there is no cursor, the return value is <c>NULL</c>.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetCursorInfo(Vanara.PInvoke.User32.CURSORINFO@)">
            <summary>
            <para>Retrieves information about the global cursor.</para>
            </summary>
            <param name="pci">
            <para>Type: <c>PCURSORINFO</c></para>
            <para>
            A pointer to a CURSORINFO structure that receives the information. Note that you must set the <c>cbSize</c> member to before
            calling this function.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetCursorPos(Vanara.PInvoke.POINT@)">
            <summary>
            <para>Retrieves the position of the mouse cursor, in screen coordinates.</para>
            </summary>
            <param name="lpPoint">
            <para>Type: <c>LPPOINT</c></para>
            <para>A pointer to a POINT structure that receives the screen coordinates of the cursor.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns nonzero if successful or zero otherwise. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The cursor position is always specified in screen coordinates and is not affected by the mapping mode of the window that contains
            the cursor.
            </para>
            <para>The calling process must have <c>WINSTA_READATTRIBUTES</c> access to the window station.</para>
            <para>
            The input desktop must be the current desktop when you call <c>GetCursorPos</c>. Call OpenInputDesktop to determine whether the
            current desktop is the input desktop. If it is not, call SetThreadDesktop with the <c>HDESK</c> returned by
            <c>OpenInputDesktop</c> to switch to that desktop.
            </para>
            <para>Examples</para>
            <para>For an example, see Using the Keyboard to Move the Cursor.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPhysicalCursorPos(Vanara.PInvoke.POINT@)">
            <summary>
            <para>Retrieves the position of the cursor in physical coordinates.</para>
            </summary>
            <param name="lpPoint">
            <para>Type: <c>LPPOINT</c></para>
            <para>The position of the cursor, in physical coordinates.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para><c>TRUE</c> if successful; otherwise <c>FALSE</c>.</para>
            <para>GetLastError can be called to get more information about any error that is generated.</para>
            </returns>
            <remarks>
            <para>For a description of the difference between logicial coordinates and physical coordinates, see PhysicalToLogicalPoint.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadCursor(Vanara.PInvoke.HINSTANCE,System.String)">
            <summary>
            <para>Loads the specified cursor resource from the executable (.EXE) file associated with an application instance.</para>
            <para><c>Note</c> This function has been superseded by the LoadImage function.</para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to an instance of the module whose executable file contains the cursor to be loaded.</para>
            </param>
            <param name="lpCursorName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The name of the cursor resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the
            low-order word and zero in the high-order word. The MAKEINTRESOURCE macro can also be used to create this value. To use one of
            the predefined cursors, the application must set the hInstance parameter to <c>NULL</c> and the lpCursorName parameter to one the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IDC_APPSTARTING MAKEINTRESOURCE(32650)</term>
            <term>Standard arrow and small hourglass</term>
            </item>
            <item>
            <term>IDC_ARROW MAKEINTRESOURCE(32512)</term>
            <term>Standard arrow</term>
            </item>
            <item>
            <term>IDC_CROSS MAKEINTRESOURCE(32515)</term>
            <term>Crosshair</term>
            </item>
            <item>
            <term>IDC_HAND MAKEINTRESOURCE(32649)</term>
            <term>Hand</term>
            </item>
            <item>
            <term>IDC_HELP MAKEINTRESOURCE(32651)</term>
            <term>Arrow and question mark</term>
            </item>
            <item>
            <term>IDC_IBEAM MAKEINTRESOURCE(32513)</term>
            <term>I-beam</term>
            </item>
            <item>
            <term>IDC_ICON MAKEINTRESOURCE(32641)</term>
            <term>Obsolete for applications marked version 4.0 or later.</term>
            </item>
            <item>
            <term>IDC_NO MAKEINTRESOURCE(32648)</term>
            <term>Slashed circle</term>
            </item>
            <item>
            <term>IDC_SIZE MAKEINTRESOURCE(32640)</term>
            <term>Obsolete for applications marked version 4.0 or later. Use IDC_SIZEALL.</term>
            </item>
            <item>
            <term>IDC_SIZEALL MAKEINTRESOURCE(32646)</term>
            <term>Four-pointed arrow pointing north, south, east, and west</term>
            </item>
            <item>
            <term>IDC_SIZENESW MAKEINTRESOURCE(32643)</term>
            <term>Double-pointed arrow pointing northeast and southwest</term>
            </item>
            <item>
            <term>IDC_SIZENS MAKEINTRESOURCE(32645)</term>
            <term>Double-pointed arrow pointing north and south</term>
            </item>
            <item>
            <term>IDC_SIZENWSE MAKEINTRESOURCE(32642)</term>
            <term>Double-pointed arrow pointing northwest and southeast</term>
            </item>
            <item>
            <term>IDC_SIZEWE MAKEINTRESOURCE(32644)</term>
            <term>Double-pointed arrow pointing west and east</term>
            </item>
            <item>
            <term>IDC_UPARROW MAKEINTRESOURCE(32516)</term>
            <term>Vertical arrow</term>
            </item>
            <item>
            <term>IDC_WAIT MAKEINTRESOURCE(32514)</term>
            <term>Hourglass</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>HCURSOR</c></para>
            <para>If the function succeeds, the return value is the handle to the newly loaded cursor.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>LoadCursor</c> function loads the cursor resource only if it has not been loaded; otherwise, it retrieves the handle to
            the existing resource. This function returns a valid cursor handle only if the lpCursorName parameter is a pointer to a cursor
            resource. If lpCursorName is a pointer to any type of resource other than a cursor (such as an icon), the return value is not
            <c>NULL</c>, even though it is not a valid cursor handle.
            </para>
            <para>
            The <c>LoadCursor</c> function searches the cursor resource most appropriate for the cursor for the current display device. The
            cursor resource can be a color or monochrome bitmap.
            </para>
            <para>DPI Virtualization</para>
            <para>This API does not participate in DPI virtualization. The output returned is not affected by the DPI of the calling thread.</para>
            <para>Examples</para>
            <para>For an example, see Creating a Cursor.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadCursor(Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.ResourceId)">
            <summary>
            <para>Loads the specified cursor resource from the executable (.EXE) file associated with an application instance.</para>
            <para><c>Note</c> This function has been superseded by the LoadImage function.</para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to an instance of the module whose executable file contains the cursor to be loaded.</para>
            </param>
            <param name="lpCursorName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The name of the cursor resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the
            low-order word and zero in the high-order word. The MAKEINTRESOURCE macro can also be used to create this value. To use one of
            the predefined cursors, the application must set the hInstance parameter to <c>NULL</c> and the lpCursorName parameter to one the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IDC_APPSTARTING MAKEINTRESOURCE(32650)</term>
            <term>Standard arrow and small hourglass</term>
            </item>
            <item>
            <term>IDC_ARROW MAKEINTRESOURCE(32512)</term>
            <term>Standard arrow</term>
            </item>
            <item>
            <term>IDC_CROSS MAKEINTRESOURCE(32515)</term>
            <term>Crosshair</term>
            </item>
            <item>
            <term>IDC_HAND MAKEINTRESOURCE(32649)</term>
            <term>Hand</term>
            </item>
            <item>
            <term>IDC_HELP MAKEINTRESOURCE(32651)</term>
            <term>Arrow and question mark</term>
            </item>
            <item>
            <term>IDC_IBEAM MAKEINTRESOURCE(32513)</term>
            <term>I-beam</term>
            </item>
            <item>
            <term>IDC_ICON MAKEINTRESOURCE(32641)</term>
            <term>Obsolete for applications marked version 4.0 or later.</term>
            </item>
            <item>
            <term>IDC_NO MAKEINTRESOURCE(32648)</term>
            <term>Slashed circle</term>
            </item>
            <item>
            <term>IDC_SIZE MAKEINTRESOURCE(32640)</term>
            <term>Obsolete for applications marked version 4.0 or later. Use IDC_SIZEALL.</term>
            </item>
            <item>
            <term>IDC_SIZEALL MAKEINTRESOURCE(32646)</term>
            <term>Four-pointed arrow pointing north, south, east, and west</term>
            </item>
            <item>
            <term>IDC_SIZENESW MAKEINTRESOURCE(32643)</term>
            <term>Double-pointed arrow pointing northeast and southwest</term>
            </item>
            <item>
            <term>IDC_SIZENS MAKEINTRESOURCE(32645)</term>
            <term>Double-pointed arrow pointing north and south</term>
            </item>
            <item>
            <term>IDC_SIZENWSE MAKEINTRESOURCE(32642)</term>
            <term>Double-pointed arrow pointing northwest and southeast</term>
            </item>
            <item>
            <term>IDC_SIZEWE MAKEINTRESOURCE(32644)</term>
            <term>Double-pointed arrow pointing west and east</term>
            </item>
            <item>
            <term>IDC_UPARROW MAKEINTRESOURCE(32516)</term>
            <term>Vertical arrow</term>
            </item>
            <item>
            <term>IDC_WAIT MAKEINTRESOURCE(32514)</term>
            <term>Hourglass</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>HCURSOR</c></para>
            <para>If the function succeeds, the return value is the handle to the newly loaded cursor.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>LoadCursor</c> function loads the cursor resource only if it has not been loaded; otherwise, it retrieves the handle to
            the existing resource. This function returns a valid cursor handle only if the lpCursorName parameter is a pointer to a cursor
            resource. If lpCursorName is a pointer to any type of resource other than a cursor (such as an icon), the return value is not
            <c>NULL</c>, even though it is not a valid cursor handle.
            </para>
            <para>
            The <c>LoadCursor</c> function searches the cursor resource most appropriate for the cursor for the current display device. The
            cursor resource can be a color or monochrome bitmap.
            </para>
            <para>DPI Virtualization</para>
            <para>This API does not participate in DPI virtualization. The output returned is not affected by the DPI of the calling thread.</para>
            <para>Examples</para>
            <para>For an example, see Creating a Cursor.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadCursorFromFile(System.String)">
            <summary>
            <para>Creates a cursor based on data contained in a file.</para>
            </summary>
            <param name="lpFileName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The source of the file data to be used to create the cursor. The data in the file must be in either .CUR or .ANI format.</para>
            <para>
            If the high-order word of lpFileName is nonzero, it is a pointer to a string that is a fully qualified name of a file containing
            cursor data.
            </para>
            </param>
            <returns>
            <para>Type: <c>HCURSOR</c></para>
            <para>If the function is successful, the return value is a handle to the new cursor.</para>
            <para>
            If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError. <c>GetLastError</c>
            may return the following value.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ERROR_FILE_NOT_FOUND</term>
            <term>The specified file cannot be found.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>DPI Virtualization</para>
            <para>This API does not participate in DPI virtualization. The output returned is not affected by the DPI of the calling thread.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetCursor(Vanara.PInvoke.User32.SafeHCURSOR)">
            <summary>
            <para>Sets the cursor shape.</para>
            </summary>
            <param name="hCursor">
            <para>Type: <c>HCURSOR</c></para>
            <para>
            A handle to the cursor. The cursor must have been created by the CreateCursor function or loaded by the LoadCursor or LoadImage
            function. If this parameter is <c>NULL</c>, the cursor is removed from the screen.
            </para>
            </param>
            <returns>
            <para>Type: <c>HCURSOR</c></para>
            <para>The return value is the handle to the previous cursor, if there was one.</para>
            <para>If there was no previous cursor, the return value is <c>NULL</c>.</para>
            </returns>
            <remarks>
            <para>The cursor is set only if the new cursor is different from the previous cursor; otherwise, the function returns immediately.</para>
            <para>
            The cursor is a shared resource. A window should set the cursor shape only when the cursor is in its client area or when the
            window is capturing mouse input. In systems without a mouse, the window should restore the previous cursor before the cursor
            leaves the client area or before it relinquishes control to another window.
            </para>
            <para>
            If your application must set the cursor while it is in a window, make sure the class cursor for the specified window's class is
            set to <c>NULL</c>. If the class cursor is not <c>NULL</c>, the system restores the class cursor each time the mouse is moved.
            </para>
            <para>
            The cursor is not shown on the screen if the internal cursor display count is less than zero. This occurs if the application uses
            the ShowCursor function to hide the cursor more times than to show the cursor.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying a Cursor.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetCursorPos(System.Int32,System.Int32)">
            <summary>
            <para>
            Moves the cursor to the specified screen coordinates. If the new coordinates are not within the screen rectangle set by the most
            recent ClipCursor function call, the system automatically adjusts the coordinates so that the cursor stays within the rectangle.
            </para>
            </summary>
            <param name="X">
            <para>Type: <c>int</c></para>
            <para>The new x-coordinate of the cursor, in screen coordinates.</para>
            </param>
            <param name="Y">
            <para>Type: <c>int</c></para>
            <para>The new y-coordinate of the cursor, in screen coordinates.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns nonzero if successful or zero otherwise. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>The cursor is a shared resource. A window should move the cursor only when the cursor is in the window's client area.</para>
            <para>The calling process must have <c>WINSTA_WRITEATTRIBUTES</c> access to the window station.</para>
            <para>
            The input desktop must be the current desktop when you call <c>SetCursorPos</c>. Call OpenInputDesktop to determine whether the
            current desktop is the input desktop. If it is not, call SetThreadDesktop with the <c>HDESK</c> returned by
            <c>OpenInputDesktop</c> to switch to that desktop.
            </para>
            <para>Examples</para>
            <para>For an example, see Using the Keyboard to Move the Cursor.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetPhysicalCursorPos(System.Int32,System.Int32)">
            <summary>
            <para>Sets the position of the cursor in physical coordinates.</para>
            </summary>
            <param name="X">
            <para>Type: <c>int</c></para>
            <para>The new x-coordinate of the cursor, in physical coordinates.</para>
            </param>
            <param name="Y">
            <para>Type: <c>int</c></para>
            <para>The new y-coordinate of the cursor, in physical coordinates.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para><c>TRUE</c> if successful; otherwise <c>FALSE</c>.</para>
            </returns>
            <remarks>
            <para>For a description of the difference between logicial coordinates and physical coordinates, see PhysicalToLogicalPoint.</para>
            <para>GetLastError can be called to get more information about any error that is generated.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetSystemCursor(Vanara.PInvoke.HCURSOR,Vanara.PInvoke.User32.OCR)">
            <summary>
            Enables an application to customize the system cursors. It replaces the contents of the system cursor specified by the id
            parameter with the contents of the cursor specified by the hcur parameter and then destroys hcur.
            </summary>
            <param name="hcur">
            <para>Type: <c>HCURSOR</c></para>
            <para>
            A handle to the cursor. The function replaces the contents of the system cursor specified by id with the contents of the cursor
            handled by hcur.
            </para>
            <para>
            The system destroys hcur by calling the DestroyCursor function. Therefore, hcur cannot be a cursor loaded using the LoadCursor
            function. To specify a cursor loaded from a resource, copy the cursor using the CopyCursor function, then pass the copy to <c>SetSystemCursor</c>.
            </para>
            </param>
            <param name="id">
            <para>Type: <c>DWORD</c></para>
            <para>The system cursor to replace with the contents of hcur. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>OCR_APPSTARTING 32650</term>
            <term>Standard arrow and small hourglass</term>
            </item>
            <item>
            <term>OCR_NORMAL 32512</term>
            <term>Standard arrow</term>
            </item>
            <item>
            <term>OCR_CROSS 32515</term>
            <term>Crosshair</term>
            </item>
            <item>
            <term>OCR_HAND 32649</term>
            <term>Hand</term>
            </item>
            <item>
            <term>OCR_HELP 32651</term>
            <term>Arrow and question mark</term>
            </item>
            <item>
            <term>OCR_IBEAM 32513</term>
            <term>I-beam</term>
            </item>
            <item>
            <term>OCR_NO 32648</term>
            <term>Slashed circle</term>
            </item>
            <item>
            <term>OCR_SIZEALL 32646</term>
            <term>Four-pointed arrow pointing north, south, east, and west</term>
            </item>
            <item>
            <term>OCR_SIZENESW 32643</term>
            <term>Double-pointed arrow pointing northeast and southwest</term>
            </item>
            <item>
            <term>OCR_SIZENS 32645</term>
            <term>Double-pointed arrow pointing north and south</term>
            </item>
            <item>
            <term>OCR_SIZENWSE 32642</term>
            <term>Double-pointed arrow pointing northwest and southeast</term>
            </item>
            <item>
            <term>OCR_SIZEWE 32644</term>
            <term>Double-pointed arrow pointing west and east</term>
            </item>
            <item>
            <term>OCR_UP 32516</term>
            <term>Vertical arrow</term>
            </item>
            <item>
            <term>OCR_WAIT 32514</term>
            <term>Hourglass</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            For an application to use any of the OCR_ constants, the constant <c>OEMRESOURCE</c> must be defined before the Windows.h header
            file is included.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ShowCursor(System.Boolean)">
            <summary>Displays or hides the cursor.</summary>
            <param name="bShow">
            <para>Type: <c>BOOL</c></para>
            <para>
            If bShow is <c>TRUE</c>, the display count is incremented by one. If bShow is <c>FALSE</c>, the display count is decremented by one.
            </para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>The return value specifies the new display counter.</para>
            </returns>
            <remarks>
            <para><c>Windows 8</c>: Call GetCursorInfo to determine the cursor visibility.</para>
            <para>
            This function sets an internal display counter that determines whether the cursor should be displayed. The cursor is displayed
            only if the display count is greater than or equal to 0. If a mouse is installed, the initial display count is 0. If no mouse is
            installed, the display count is –1.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.CURSORINFO">
            <summary>
            <para>Contains global cursor information.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CURSORINFO.cbSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The size of the structure, in bytes. The caller must set this to .</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CURSORINFO.flags">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The cursor state. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The cursor is hidden.</term>
            </item>
            <item>
            <term>CURSOR_SHOWING 0x00000001</term>
            <term>The cursor is showing.</term>
            </item>
            <item>
            <term>CURSOR_SUPPRESSED 0x00000002</term>
            <term>
            Windows 8: The cursor is suppressed. This flag indicates that the system is not drawing the cursor because the user is
            providing input through touch or pen instead of the mouse.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CURSORINFO.hCursor">
            <summary>
            <para>Type: <c>HCURSOR</c></para>
            <para>A handle to the cursor.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CURSORINFO.ptScreenPos">
            <summary>
            <para>Type: <c>POINT</c></para>
            <para>A structure that receives the screen coordinates of the cursor.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SafeHCURSOR">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> to a Windows that disposes a created HCURSOR instance at disposal using DestroyCursor.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHCURSOR.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.HCURSOR"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHCURSOR.op_Implicit(Vanara.PInvoke.User32.SafeHCURSOR)~Vanara.PInvoke.HCURSOR">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.User32.SafeHCURSOR"/> to <see cref="T:Vanara.PInvoke.HCURSOR"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHCURSOR.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.StandardCursor">
            <summary>Predefined cursors for <see cref="M:Vanara.PInvoke.User32.LoadCursor(Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.ResourceId)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_ARROW">
            <summary>Standard arrow</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_IBEAM">
            <summary>I-beam</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_WAIT">
            <summary>Hourglass</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_CROSS">
            <summary>Crosshair</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_UPARROW">
            <summary>Vertical arrow</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_SIZE">
            <summary>Obsolete for applications marked version 4.0 or later. Use IDC_SIZEALL.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_ICON">
            <summary>Obsolete for applications marked version 4.0 or later.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_SIZENWSE">
            <summary>Double-pointed arrow pointing northwest and southeast</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_SIZENESW">
            <summary>Double-pointed arrow pointing northeast and southwest</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_SIZEWE">
            <summary>Double-pointed arrow pointing west and east</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_SIZENS">
            <summary>Double-pointed arrow pointing north and south</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_SIZEALL">
            <summary>Four-pointed arrow pointing north, south, east, and west</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_NO">
            <summary>Slashed circle</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_HAND">
            <summary>Hand</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_APPSTARTING">
            <summary>Standard arrow and small hourglass</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_HELP">
            <summary>Arrow and question mark</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_PIN">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StandardCursor.IDC_PERSON">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WM_DEVICECHANGE">
            <summary>A message indicating a device change.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DBT_DEVTYPE">
            <summary>The device type, which determines the event-specific information that follows the first three members.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DBT_DEVTYPE.DBT_DEVTYP_OEM">
            <summary>OEM- or IHV-defined device type. This structure is a DEV_BROADCAST_OEM structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DBT_DEVTYPE.DBT_DEVTYP_DEVNODE">
            <summary>devnode number</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DBT_DEVTYPE.DBT_DEVTYP_VOLUME">
            <summary>Logical volume. This structure is a DEV_BROADCAST_VOLUME structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DBT_DEVTYPE.DBT_DEVTYP_PORT">
            <summary>Port device (serial or parallel). This structure is a DEV_BROADCAST_PORT structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DBT_DEVTYPE.DBT_DEVTYP_NET">
            <summary>network resource</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DBT_DEVTYPE.DBT_DEVTYP_DEVICEINTERFACE">
            <summary>Class of devices. This structure is a DEV_BROADCAST_DEVICEINTERFACE structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DBT_DEVTYPE.DBT_DEVTYP_HANDLE">
            <summary>File system handle. This structure is a DEV_BROADCAST_HANDLE structure.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DBTF">
            <summary>Flags for DEV_BROADCAST_VOLUME.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DBTF.DBTF_MEDIA">
            <summary>Change affects media in drive. If not set, change affects physical device or drive.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DBTF.DBTF_NET">
            <summary>Indicated logical volume is a network volume.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DEVICE_NOTIFY">
            <summary>Flags for <see cref="M:Vanara.PInvoke.User32.RegisterDeviceNotification(Vanara.PInvoke.HANDLE,System.IntPtr,Vanara.PInvoke.User32.DEVICE_NOTIFY)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEVICE_NOTIFY.DEVICE_NOTIFY_WINDOW_HANDLE">
            <summary>The hRecipient parameter is a window handle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEVICE_NOTIFY.DEVICE_NOTIFY_SERVICE_HANDLE">
            <summary>The hRecipient parameter is a service status handle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEVICE_NOTIFY.DEVICE_NOTIFY_ALL_INTERFACE_CLASSES">
            <summary>
            Notifies the recipient of device interface events for all device interface classes. (The dbcc_classguid member is ignored.)
            <para>This value can be used only if the dbch_devicetype member is DBT_DEVTYP_DEVICEINTERFACE.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DeviceBroadcastEvent">
            <summary>Possible WPARAM values for WM_DEVICECHANGE messages.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_APPYBEGIN">
            <summary>'Appy-time is now available.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_APPYEND">
            <summary>'Appy-time is no longer available.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_DEVNODES_CHANGED">
            <summary>
            The system broadcasts the DBT_DEVNODES_CHANGED device event when a device has been added to or removed from the system.
            Applications that maintain lists of devices in the system should refresh their lists.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_QUERYCHANGECONFIG">
            <summary>
            The system broadcasts the DBT_QUERYCHANGECONFIG device event to request permission to change the current configuration (dock
            or undock). Any application can deny this request and cancel the change.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_CONFIGCHANGED">
            <summary>
            The system broadcasts the DBT_CONFIGCHANGED device event to indicate that the current configuration has changed, due to a
            dock or undock. An application or driver that stores data in the registry under the HKEY_CURRENT_CONFIG key should update the data.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_CONFIGCHANGECANCELED">
            <summary>
            The system broadcasts the DBT_CONFIGCHANGECANCELED device event when a request to change the current configuration (dock or
            undock) has been canceled.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_MONITORCHANGE">
            <summary>
            This message is sent when the display monitor has changed and the system should change the display mode to match it.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_SHELLLOGGEDON">
            <summary>The shell has finished login on: VxD can now do Shell_EXEC.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_CONFIGMGAPI32">
            <summary>CONFIGMG ring 3 call.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_VXDINITCOMPLETE">
            <summary>CONFIGMG ring 3 call.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_VOLLOCKQUERYLOCK">
            <summary>
            Messages issued by IFSMGR for volume locking purposes on WM_DEVICECHANGE. All these messages pass a pointer to a struct which
            has no pointers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_VOLLOCKLOCKTAKEN">
            <summary>
            Messages issued by IFSMGR for volume locking purposes on WM_DEVICECHANGE. All these messages pass a pointer to a struct which
            has no pointers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_VOLLOCKLOCKFAILED">
            <summary>
            Messages issued by IFSMGR for volume locking purposes on WM_DEVICECHANGE. All these messages pass a pointer to a struct which
            has no pointers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_VOLLOCKQUERYUNLOCK">
            <summary>
            Messages issued by IFSMGR for volume locking purposes on WM_DEVICECHANGE. All these messages pass a pointer to a struct which
            has no pointers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_VOLLOCKLOCKRELEASED">
            <summary>
            Messages issued by IFSMGR for volume locking purposes on WM_DEVICECHANGE. All these messages pass a pointer to a struct which
            has no pointers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_VOLLOCKUNLOCKFAILED">
            <summary>
            Messages issued by IFSMGR for volume locking purposes on WM_DEVICECHANGE. All these messages pass a pointer to a struct which
            has no pointers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_NO_DISK_SPACE">
            <summary>Message issued by IFS manager when it detects that a drive is run out of free space.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_LOW_DISK_SPACE">
            <summary>
            Message issued by VFAT when it detects that a drive it has mounted has the remaining free space below a threshold specified
            by the registry or by a disk space management application. The broadcast is issued by VFAT ONLY when space is either
            allocated or freed by VFAT.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_CONFIGMGPRIVATE">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_DEVICEARRIVAL">
            <summary>
            The system broadcasts the DBT_DEVICEARRIVAL device event when a device or piece of media has been inserted and becomes available.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_DEVICEQUERYREMOVE">
            <summary>
            The system broadcasts the DBT_DEVICEQUERYREMOVE device event to request permission to remove a device or piece of media. This
            message is the last chance for applications and drivers to prepare for this removal. However, any application can deny this
            request and cancel the operation.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_DEVICEQUERYREMOVEFAILED">
            <summary>
            The system broadcasts the DBT_DEVICEQUERYREMOVEFAILED device event when a request to remove a device or piece of media has
            been canceled.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_DEVICEREMOVEPENDING">
            <summary>
            The system broadcasts the DBT_DEVICEREMOVEPENDING device event when a device or piece of media is being removed and is no
            longer available for use.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_DEVICEREMOVECOMPLETE">
            <summary>
            The system broadcasts the DBT_DEVICEREMOVECOMPLETE device event when a device or piece of media has been physically removed.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_DEVICETYPESPECIFIC">
            <summary>The system broadcasts the DBT_DEVICETYPESPECIFIC device event when a device-specific event occurs.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_CUSTOMEVENT">
            <summary>The system sends the DBT_CUSTOMEVENT device event when a driver-defined custom event has occurred.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_VPOWERDAPI">
            <summary>VPOWERD API for Win95</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DeviceBroadcastEvent.DBT_USERDEFINED">
            <summary>The DBT_USERDEFINED device event identifies a user-defined event.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.LOCKF">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LOCKF.LOCKF_LOGICAL_LOCK">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LOCKF.LOCKF_PHYSICAL_LOCK">
            <summary>Undocumented.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.LOCKP">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LOCKP.LOCKP_ALLOW_WRITES">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LOCKP.LOCKP_FAIL_WRITES">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LOCKP.LOCKP_FAIL_MEM_MAPPING">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LOCKP.LOCKP_ALLOW_MEM_MAPPING">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LOCKP.LOCKP_USER_MASK">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LOCKP.LOCKP_LOCK_FOR_FORMAT">
            <summary>Undocumented.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterDeviceNotification(Vanara.PInvoke.HANDLE,System.IntPtr,Vanara.PInvoke.User32.DEVICE_NOTIFY)">
            <summary>Registers the device or type of device for which a window will receive notifications.</summary>
            <param name="hRecipient">
            <para>
            A handle to the window or service that will receive device events for the devices specified in the NotificationFilter parameter.
            The same window handle can be used in multiple calls to <c>RegisterDeviceNotification</c>.
            </para>
            <para>Services can specify either a window handle or service status handle.</para>
            </param>
            <param name="NotificationFilter">
            A pointer to a block of data that specifies the type of device for which notifications should be sent. This block always begins
            with the DEV_BROADCAST_HDR structure. The data following this header is dependent on the value of the <c>dbch_devicetype</c>
            member, which can be <c>DBT_DEVTYP_DEVICEINTERFACE</c> or <c>DBT_DEVTYP_HANDLE</c>. For more information, see Remarks.
            </param>
            <param name="Flags">
            <para>This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DEVICE_NOTIFY_WINDOW_HANDLE 0x00000000</term>
            <term>The hRecipient parameter is a window handle.</term>
            </item>
            <item>
            <term>DEVICE_NOTIFY_SERVICE_HANDLE 0x00000001</term>
            <term>The hRecipient parameter is a service status handle.</term>
            </item>
            </list>
            <para>In addition, you can specify the following value.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DEVICE_NOTIFY_ALL_INTERFACE_CLASSES 0x00000004</term>
            <term>
            Notifies the recipient of device interface events for all device interface classes. (The dbcc_classguid member is ignored.) This
            value can be used only if the dbch_devicetype member is DBT_DEVTYP_DEVICEINTERFACE.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a device notification handle.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Applications send event notifications using the BroadcastSystemMessage function. Any application with a top-level window can
            receive basic notifications by processing the WM_DEVICECHANGE message. Applications can use the <c>RegisterDeviceNotification</c>
            function to register to receive device notifications.
            </para>
            <para>
            Services can use the <c>RegisterDeviceNotification</c> function to register to receive device notifications. If a service
            specifies a window handle in the hRecipient parameter, the notifications are sent to the window procedure. If hRecipient is a
            service status handle, <c>SERVICE_CONTROL_DEVICEEVENT</c> notifications are sent to the service control handler. For more
            information about the service control handler, see HandlerEx.
            </para>
            <para>
            Be sure to handle Plug and Play device events as quickly as possible. Otherwise, the system may become unresponsive. If your
            event handler is to perform an operation that may block execution (such as I/O), it is best to start another thread to perform
            the operation asynchronously.
            </para>
            <para>
            Device notification handles returned by <c>RegisterDeviceNotification</c> must be closed by calling the
            UnregisterDeviceNotification function when they are no longer needed.
            </para>
            <para>
            The DBT_DEVICEARRIVAL and DBT_DEVICEREMOVECOMPLETE events are automatically broadcast to all top-level windows for port devices.
            Therefore, it is not necessary to call <c>RegisterDeviceNotification</c> for ports, and the function fails if the
            <c>dbch_devicetype</c> member is <c>DBT_DEVTYP_PORT</c>. Volume notifications are also broadcast to top-level windows, so the
            function fails if <c>dbch_devicetype</c> is <c>DBT_DEVTYP_VOLUME</c>. OEM-defined devices are not used directly by the system, so
            the function fails if <c>dbch_devicetype</c> is <c>DBT_DEVTYP_OEM</c>.
            </para>
            <para>Examples</para>
            <para>For an example, see Registering for Device Notification.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterDeviceNotification``1(Vanara.PInvoke.HANDLE,``0@,Vanara.PInvoke.User32.DEVICE_NOTIFY)">
            <summary>Registers the device or type of device for which a window will receive notifications.</summary>
            <param name="hRecipient">
            <para>
            A handle to the window or service that will receive device events for the devices specified in the NotificationFilter parameter.
            The same window handle can be used in multiple calls to <c>RegisterDeviceNotification</c>.
            </para>
            <para>Services can specify either a window handle or service status handle.</para>
            </param>
            <param name="NotificationFilter">
            A pointer to a block of data that specifies the type of device for which notifications should be sent. This block always begins
            with the DEV_BROADCAST_HDR structure. The data following this header is dependent on the value of the <c>dbch_devicetype</c>
            member, which can be <c>DBT_DEVTYP_DEVICEINTERFACE</c> or <c>DBT_DEVTYP_HANDLE</c>. For more information, see Remarks.
            </param>
            <param name="Flags">
            <para>This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DEVICE_NOTIFY_WINDOW_HANDLE 0x00000000</term>
            <term>The hRecipient parameter is a window handle.</term>
            </item>
            <item>
            <term>DEVICE_NOTIFY_SERVICE_HANDLE 0x00000001</term>
            <term>The hRecipient parameter is a service status handle.</term>
            </item>
            </list>
            <para>In addition, you can specify the following value.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DEVICE_NOTIFY_ALL_INTERFACE_CLASSES 0x00000004</term>
            <term>
            Notifies the recipient of device interface events for all device interface classes. (The dbcc_classguid member is ignored.) This
            value can be used only if the dbch_devicetype member is DBT_DEVTYP_DEVICEINTERFACE.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a device notification handle.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Applications send event notifications using the BroadcastSystemMessage function. Any application with a top-level window can
            receive basic notifications by processing the WM_DEVICECHANGE message. Applications can use the <c>RegisterDeviceNotification</c>
            function to register to receive device notifications.
            </para>
            <para>
            Services can use the <c>RegisterDeviceNotification</c> function to register to receive device notifications. If a service
            specifies a window handle in the hRecipient parameter, the notifications are sent to the window procedure. If hRecipient is a
            service status handle, <c>SERVICE_CONTROL_DEVICEEVENT</c> notifications are sent to the service control handler. For more
            information about the service control handler, see HandlerEx.
            </para>
            <para>
            Be sure to handle Plug and Play device events as quickly as possible. Otherwise, the system may become unresponsive. If your
            event handler is to perform an operation that may block execution (such as I/O), it is best to start another thread to perform
            the operation asynchronously.
            </para>
            <para>
            Device notification handles returned by <c>RegisterDeviceNotification</c> must be closed by calling the
            UnregisterDeviceNotification function when they are no longer needed.
            </para>
            <para>
            The DBT_DEVICEARRIVAL and DBT_DEVICEREMOVECOMPLETE events are automatically broadcast to all top-level windows for port devices.
            Therefore, it is not necessary to call <c>RegisterDeviceNotification</c> for ports, and the function fails if the
            <c>dbch_devicetype</c> member is <c>DBT_DEVTYP_PORT</c>. Volume notifications are also broadcast to top-level windows, so the
            function fails if <c>dbch_devicetype</c> is <c>DBT_DEVTYP_VOLUME</c>. OEM-defined devices are not used directly by the system, so
            the function fails if <c>dbch_devicetype</c> is <c>DBT_DEVTYP_OEM</c>.
            </para>
            <para>Examples</para>
            <para>For an example, see Registering for Device Notification.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.UnregisterDeviceNotification(Vanara.PInvoke.User32.HDEVNOTIFY)">
            <summary>Closes the specified device notification handle.</summary>
            <param name="Handle">Device notification handle returned by the RegisterDeviceNotification function.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.User32.DEV_BROADCAST_DEVICEINTERFACE">
            <summary>Contains information about a class of devices.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_DEVICEINTERFACE.dbcc_size">
            <summary>
            The size of this structure, in bytes. This is the size of the members plus the actual length of the <c>dbcc_name</c> string
            (the null character is accounted for by the declaration of <c>dbcc_name</c> as a one-character array.)
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_DEVICEINTERFACE.dbcc_devicetype">
            <summary>Set to <c>DBT_DEVTYP_DEVICEINTERFACE</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_DEVICEINTERFACE.dbcc_reserved">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_DEVICEINTERFACE.dbcc_classguid">
            <summary>The GUID for the interface device class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_DEVICEINTERFACE.dbcc_name">
            <summary>
            <para>A null-terminated string that specifies the name of the device.</para>
            <para>
            When this structure is returned to a window through the WM_DEVICECHANGE message, the <c>dbcc_name</c> string is converted to
            ANSI as appropriate. Services always receive a Unicode string, whether they call <c>RegisterDeviceNotificationW</c> or <c>RegisterDeviceNotificationA</c>.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DEV_BROADCAST_DEVNODE">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_DEVNODE.dbcd_size">
            <summary>The size of this structure, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_DEVNODE.dbcd_devicetype">
            <summary>Set to <c>DBT_DEVTYP_DEVNODE</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_DEVNODE.dbcd_reserved">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_DEVNODE.dbcd_devnode">
            <summary>Undocumented.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DEV_BROADCAST_HANDLE">
            <summary>Contains information about a file system handle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_HANDLE.dbch_size">
            <summary>The size of this structure, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_HANDLE.dbch_devicetype">
            <summary>Set to DBT_DEVTYP_HANDLE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_HANDLE.dbch_reserved">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_HANDLE.dbch_handle">
            <summary>A handle to the device to be checked.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_HANDLE.dbch_hdevnotify">
            <summary>A handle to the device notification. This handle is returned by RegisterDeviceNotification.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_HANDLE.dbch_eventguid">
            <summary>The GUID for the custom event. For more information, see Device Events. Valid only for DBT_CUSTOMEVENT.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_HANDLE.dbch_nameoffset">
            <summary>The offset of an optional string buffer. Valid only for DBT_CUSTOMEVENT.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_HANDLE.dbch_data">
            <summary>Optional binary data. This member is valid only for DBT_CUSTOMEVENT.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DEV_BROADCAST_HDR">
            <summary>
            <para>Serves as a standard header for information related to a device event reported through the WM_DEVICECHANGE message.</para>
            <para>
            The members of the <c>DEV_BROADCAST_HDR</c> structure are contained in each device management structure. To determine which
            structure you have received through WM_DEVICECHANGE, treat the structure as a <c>DEV_BROADCAST_HDR</c> structure and check its
            <c>dbch_devicetype</c> member.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_HDR.dbch_size">
            <summary>
            <para>The size of this structure, in bytes.</para>
            <para>
            If this is a user-defined event, this member must be the size of this header, plus the size of the variable-length data in
            the _DEV_BROADCAST_USERDEFINED structure.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_HDR.dbch_devicetype">
            <summary>
            <para>
            The device type, which determines the event-specific information that follows the first three members. This member can be one
            of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DBT_DEVTYP_DEVICEINTERFACE 0x00000005</term>
            <term>Class of devices. This structure is a DEV_BROADCAST_DEVICEINTERFACE structure.</term>
            </item>
            <item>
            <term>DBT_DEVTYP_HANDLE 0x00000006</term>
            <term>File system handle. This structure is a DEV_BROADCAST_HANDLE structure.</term>
            </item>
            <item>
            <term>DBT_DEVTYP_OEM 0x00000000</term>
            <term>OEM- or IHV-defined device type. This structure is a DEV_BROADCAST_OEM structure.</term>
            </item>
            <item>
            <term>DBT_DEVTYP_PORT 0x00000003</term>
            <term>Port device (serial or parallel). This structure is a DEV_BROADCAST_PORT structure.</term>
            </item>
            <item>
            <term>DBT_DEVTYP_VOLUME 0x00000002</term>
            <term>Logical volume. This structure is a DEV_BROADCAST_VOLUME structure.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_HDR.dbch_reserved">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DEV_BROADCAST_NET">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_NET.dbcn_size">
            <summary>The size of this structure, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_NET.dbcn_devicetype">
            <summary>Set to <c>DBT_DEVTYP_NET</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_NET.dbcn_reserved">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_NET.dbcn_resource">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_NET.dbcn_flags">
            <summary>Undocumented.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DEV_BROADCAST_OEM">
            <summary>Contains information about a OEM-defined device type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_OEM.dbco_size">
            <summary>The size of this structure, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_OEM.dbco_devicetype">
            <summary>Set to <c>DBT_DEVTYP_OEM</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_OEM.dbco_reserved">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_OEM.dbco_identifier">
            <summary>The OEM-specific identifier for the device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_OEM.dbco_suppfunc">
            <summary>The OEM-specific function value. Possible values depend on the device.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DEV_BROADCAST_PORT">
            <summary>Contains information about a modem, serial, or parallel port.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_PORT.dbcp_size">
            <summary>
            The size of this structure, in bytes. This is the size of the members plus the actual length of the <c>dbcp_name</c> string
            (the null character is accounted for by the declaration of <c>dbcp_name</c> as a one-character array.)
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_PORT.dbcp_devicetype">
            <summary>Set to <c>DBT_DEVTYP_PORT</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_PORT.dbcp_reserved">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_PORT.dbcp_name">
            <summary>
            A null-terminated string specifying the friendly name of the port or the device connected to the port. Friendly names are
            intended to help the user quickly and accurately identify the device—for example, "COM1" and "Standard 28800 bps Modem" are
            considered friendly names.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DEV_BROADCAST_USERDEFINED">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_USERDEFINED.dbud_dbh">
            <summary>Header.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_USERDEFINED.dbud_szName">
            <summary>Undocumented.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DEV_BROADCAST_VOLUME">
            <summary>Contains information about a logical volume.</summary>
            <remarks>
            <para>
            Although the <c>dbcv_unitmask</c> member may specify more than one volume in any message, this does not guarantee that only one
            message is generated for a specified event. Multiple system features may independently generate messages for logical volumes at
            the same time.
            </para>
            <para>
            Messages for media arrival and removal are sent only for media in devices that support a soft-eject mechanism. For example,
            applications will not see media-related volume messages for floppy disks.
            </para>
            <para>
            Messages for network drive arrival and removal are not sent whenever network commands are issued, but rather when network
            connections will disappear as the result of a hardware event.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_VOLUME.dbcv_size">
            <summary>The size of this structure, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_VOLUME.dbcv_devicetype">
            <summary>Set to <c>DBT_DEVTYP_VOLUME</c> (2).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_VOLUME.dbcv_reserved">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_VOLUME.dbcv_unitmask">
            <summary>
            The logical unit mask identifying one or more logical units. Each bit in the mask corresponds to one logical drive. Bit 0
            represents drive A, bit 1 represents drive B, and so on.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEV_BROADCAST_VOLUME.dbcv_flags">
            <summary>
            <para>This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DBTF_MEDIA 0x0001</term>
            <term>Change affects media in drive. If not set, change affects physical device or drive.</term>
            </item>
            <item>
            <term>DBTF_NET 0x0002</term>
            <term>Indicated logical volume is a network volume.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.HDEVNOTIFY">
            <summary>Provides a handle to a device notification.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.HDEVNOTIFY.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.HDEVNOTIFY"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.User32.HDEVNOTIFY.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.User32.HDEVNOTIFY"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.HDEVNOTIFY.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.HDEVNOTIFY.op_Explicit(Vanara.PInvoke.User32.HDEVNOTIFY)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.User32.HDEVNOTIFY"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HDEVNOTIFY.op_Implicit(System.IntPtr)~Vanara.PInvoke.User32.HDEVNOTIFY">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.User32.HDEVNOTIFY"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HDEVNOTIFY.op_Inequality(Vanara.PInvoke.User32.HDEVNOTIFY,Vanara.PInvoke.User32.HDEVNOTIFY)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HDEVNOTIFY.op_Equality(Vanara.PInvoke.User32.HDEVNOTIFY,Vanara.PInvoke.User32.HDEVNOTIFY)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HDEVNOTIFY.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.HDEVNOTIFY.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.HDEVNOTIFY.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.VolLockBroadcast">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VolLockBroadcast.vlb_dbh">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VolLockBroadcast.vlb_owner">
            <summary>thread on which lock request is being issued.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VolLockBroadcast.vlb_perms">
            <summary>lock permission flags.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VolLockBroadcast.vlb_lockType">
            <summary>type of lock</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VolLockBroadcast.vlb_drive">
            <summary>drive on which lock is issued</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VolLockBroadcast.vlb_flags">
            <summary>miscellaneous flags</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SafeHDEVNOTIFY">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <see cref="T:Vanara.PInvoke.User32.HDEVNOTIFY"/> that is disposed using <see cref="M:Vanara.PInvoke.User32.UnregisterDeviceNotification(Vanara.PInvoke.User32.HDEVNOTIFY)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHDEVNOTIFY.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHDEVNOTIFY"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHDEVNOTIFY.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHDEVNOTIFY"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHDEVNOTIFY.op_Implicit(Vanara.PInvoke.User32.SafeHDEVNOTIFY)~Vanara.PInvoke.User32.HDEVNOTIFY">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.User32.SafeHDEVNOTIFY"/> to <see cref="T:Vanara.PInvoke.User32.HDEVNOTIFY"/>.</summary>
            <param name="h">The SafeHDEVNOTIFY.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHDEVNOTIFY.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.EnumDesktopProc">
            <summary>
            <para>An application-defined callback function used with the <c>EnumDesktops</c> function. It receives a desktop name.</para>
            <para>
            The DESKTOPENUMPROC type defines a pointer to this callback function. <c>EnumDesktopProc</c> is a placeholder for the
            application-defined function name.
            </para>
            </summary>
            <param name="lpszDesktop">The name of the desktop.</param>
            <param name="lParam">An application-defined value specified in the <c>EnumDesktops</c> function.</param>
            <returns>To continue enumeration, the callback function must return TRUE. To stop enumeration, it must return FALSE.</returns>
        </member>
        <member name="T:Vanara.PInvoke.User32.EnumWindowStationProc">
            <summary>
            <para>
            An application-defined callback function used with the <c>EnumWindowStations</c> function. It receives a window station name.
            </para>
            <para>
            The <c>WINSTAENUMPROC</c> type defines a pointer to this callback function. <c>EnumWindowStationProc</c> is a placeholder for the
            application-defined function name.
            </para>
            </summary>
            <param name="lpszWindowStation">The name of the window station.</param>
            <param name="lParam">An application-defined value specified in the <c>EnumWindowStations</c> function.</param>
            <returns>To continue enumeration, the callback function must return TRUE. To stop enumeration, it must return FALSE.</returns>
        </member>
        <member name="T:Vanara.PInvoke.User32.CreateDesktopFlags">
            <summary>Flags used by CreateDesktop.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CreateDesktopFlags.DF_ALLOWOTHERACCOUNTHOOK">
            <summary>Enables processes running in other accounts on the desktop to set hooks in this process.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.CreateWindowStationFlags">
            <summary>Flags used by CreateWindowStation.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CreateWindowStationFlags.CWF_CREATE_ONLY">
            <summary>
            If used and the window station already exists, the call fails. If this flag is not specified and the window station already
            exists, the function succeeds and returns a new handle to the existing window station.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.UserObjectInformationType">
            <summary>The information to be retrieved by GetUserObjectInformation or set by SetUserObjectInformation.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UserObjectInformationType.UOI_FLAGS">
            <summary>The handle flags. The pvInfo parameter must point to a USEROBJECTFLAGS structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UserObjectInformationType.UOI_HEAPSIZE">
            <summary>
            The size of the desktop heap, in KB, as a ULONG value. The hObj parameter must be a handle to a desktop object, otherwise,
            the function fails.
            <para>Windows Server 2003 and Windows XP/2000: This value is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UserObjectInformationType.UOI_IO">
            <summary>
            TRUE if the hObj parameter is a handle to the desktop object that is receiving input from the user. FALSE otherwise.
            <para>Windows Server 2003 and Windows XP/2000: This value is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UserObjectInformationType.UOI_NAME">
            <summary>The name of the object, as a string.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UserObjectInformationType.UOI_TYPE">
            <summary>The type name of the object, as a string.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UserObjectInformationType.UOI_USER_SID">
            <summary>
            The SID structure that identifies the user that is currently associated with the specified object. If no user is associated
            with the object, the value returned in the buffer pointed to by lpnLengthNeeded is zero. Note that SID is a variable length
            structure. You will usually make a call to GetUserObjectInformation to determine the length of the SID before retrieving its value.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.CloseDesktop(Vanara.PInvoke.HDESK)">
            <summary>
            <para>Closes an open handle to a desktop object.</para>
            </summary>
            <param name="hDesktop">
            <para>
            A handle to the desktop to be closed. This can be a handle returned by the CreateDesktop, OpenDesktop, or OpenInputDesktop
            functions. Do not specify the handle returned by the GetThreadDesktop function.
            </para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>CloseDesktop</c> function will fail if any thread in the calling process is using the specified desktop handle or if the
            handle refers to the initial desktop of the calling process.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CloseWindowStation(Vanara.PInvoke.HWINSTA)">
            <summary>
            <para>Closes an open window station handle.</para>
            </summary>
            <param name="hWinSta">
            <para>
            A handle to the window station to be closed. This handle is returned by the CreateWindowStation or OpenWindowStation function. Do
            not specify the handle returned by the GetProcessWindowStation function.
            </para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            <para><c>Windows Server 2003 and Windows XP/2000:</c> This function does not set the last error code on failure.</para>
            </returns>
            <remarks>
            <para>
            The <c>CloseWindowStation</c> function will fail if the handle being closed is for the window station assigned to the calling process.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateDesktop(System.String,System.String,System.IntPtr,Vanara.PInvoke.User32.CreateDesktopFlags,Vanara.PInvoke.ACCESS_MASK,Vanara.PInvoke.SECURITY_ATTRIBUTES)">
            <summary>
            <para>
            Creates a new desktop, associates it with the current window station of the calling process, and assigns it to the calling
            thread. The calling process must have an associated window station, either assigned by the system at process creation time or set
            by the SetProcessWindowStation function.
            </para>
            <para>To specify the size of the heap for the desktop, use the CreateDesktopEx function.</para>
            </summary>
            <param name="lpszDesktop">
            <para>The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters ().</para>
            </param>
            <param name="lpszDevice">
            <para>Reserved; must be <c>NULL</c>.</para>
            </param>
            <param name="pDevmode">
            <para>Reserved; must be <c>NULL</c>.</para>
            </param>
            <param name="dwFlags">
            <para>This parameter can be zero or the following value.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DF_ALLOWOTHERACCOUNTHOOK 0x0001</term>
            <term>Enables processes running in other accounts on the desktop to set hooks in this process.</term>
            </item>
            </list>
            </param>
            <param name="dwDesiredAccess">
            <para>The access to the desktop. For a list of values, see Desktop Security and Access Rights.</para>
            <para>
            This parameter must include the <c>DESKTOP_CREATEWINDOW</c> access right, because internally <c>CreateDesktop</c> uses the handle
            to create a window.
            </para>
            </param>
            <param name="lpsa">
            <para>
            A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by child processes. If
            lpsa is NULL, the handle cannot be inherited.
            </para>
            <para>
            The <c>lpSecurityDescriptor</c> member of the structure specifies a security descriptor for the new desktop. If this parameter is
            NULL, the desktop inherits its security descriptor from the parent window station.
            </para>
            </param>
            <returns>
            <para>
            If the function succeeds, the return value is a handle to the newly created desktop. If the specified desktop already exists, the
            function succeeds and returns a handle to the existing desktop. When you are finished using the handle, call the CloseDesktop
            function to close it.
            </para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the dwDesiredAccess parameter specifies the <c>READ_CONTROL</c>, <c>WRITE_DAC</c>, or <c>WRITE_OWNER</c> standard access
            rights, you must also request the <c>DESKTOP_READOBJECTS</c> and <c>DESKTOP_WRITEOBJECTS</c> access rights.
            </para>
            <para>
            The number of desktops that can be created is limited by the size of the system desktop heap, which is 48 MB. Desktop objects use
            the heap to store resources. You can increase the number of desktops that can be created by reducing the default heap reserved
            for each desktop in the interactive window station. This value is specified in the "SharedSection" substring of the following
            registry value: <c>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\SubSystems\Windows</c>. The default data
            for this registry value is as follows:
            </para>
            <para>
            "%SystemRoot%\system32\csrss.exe ObjectDirectory=\Windows SharedSection=1024,3072,512 Windows=On SubSystemType=Windows
            ServerDll=basesrv,1 ServerDll=winsrv:UserServerDllInitialization,3 ServerDll=winsrv:ConServerDllInitialization,2
            ProfileControl=Off MaxRequestThreads=16"
            </para>
            <para>The values for the "SharedSection" substring are described as follows:</para>
            <list type="bullet">
            <item>
            <term>The first "SharedSection" value is the size of the shared heap common to all desktops, in kilobytes.</term>
            </item>
            <item>
            <term>
            The second "SharedSection" value is the size of the desktop heap needed for each desktop that is created in the interactive
            window station, WinSta0, in kilobytes.
            </term>
            </item>
            <item>
            <term>
            The third "SharedSection" value is the size of the desktop heap needed for each desktop that is created in a noninteractive
            window station, in kilobytes.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateDesktopEx(System.String,System.String,System.IntPtr,Vanara.PInvoke.User32.CreateDesktopFlags,Vanara.PInvoke.ACCESS_MASK,Vanara.PInvoke.SECURITY_ATTRIBUTES,System.UInt32,System.IntPtr)">
            <summary>
            <para>
            Creates a new desktop with the specified heap, associates it with the current window station of the calling process, and assigns
            it to the calling thread. The calling process must have an associated window station, either assigned by the system at process
            creation time or set by the SetProcessWindowStation function.
            </para>
            </summary>
            <param name="lpszDesktop">
            <para>The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters ().</para>
            </param>
            <param name="lpszDevice">
            <para>This parameter is reserved and must be NULL.</para>
            </param>
            <param name="pDevmode">
            <para>This parameter is reserved and must be NULL.</para>
            </param>
            <param name="dwFlags">
            <para>This parameter can be zero or the following value.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DF_ALLOWOTHERACCOUNTHOOK 0x0001</term>
            <term>Enables processes running in other accounts on the desktop to set hooks in this process.</term>
            </item>
            </list>
            </param>
            <param name="dwDesiredAccess">
            <para>The requested access to the desktop. For a list of values, see Desktop Security and Access Rights.</para>
            <para>
            This parameter must include the DESKTOP_CREATEWINDOW access right, because internally CreateDesktop uses the handle to create a window.
            </para>
            </param>
            <param name="lpsa">
            <para>
            A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by child processes. If
            lpsa is NULL, the handle cannot be inherited.
            </para>
            <para>
            The <c>lpSecurityDescriptor</c> member of the structure specifies a security descriptor for the new desktop. If this parameter is
            NULL, the desktop inherits its security descriptor from the parent window station.
            </para>
            </param>
            <param name="ulHeapSize">
            <para>The size of the desktop heap, in kilobytes.</para>
            </param>
            <param name="pvoid">
            <para>This parameter is reserved and must be NULL.</para>
            </param>
            <returns>
            <para>
            If the function succeeds, the return value is a handle to the newly created desktop. If the specified desktop already exists, the
            function succeeds and returns a handle to the existing desktop. When you are finished using the handle, call the CloseDesktop
            function to close it.
            </para>
            <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the dwDesiredAccess parameter specifies the READ_CONTROL, WRITE_DAC, or WRITE_OWNER standard access rights, you must also
            request the DESKTOP_READOBJECTS and DESKTOP_WRITEOBJECTS access rights.
            </para>
            <para>
            The number of desktops that can be created is limited by the size of the system desktop heap. Desktop objects use the heap to
            store resources. You can increase the number of desktops that can be created by increasing the size of the desktop heap or by
            reducing the default heap reserved for each desktop in the interactive window station. This value is specified in the
            SharedSection substring of the following registry value: <c>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session
            Manager\SubSystems\Windows</c>. The default data for this registry value is as follows:
            </para>
            <para>
            %SystemRoot%\system32\csrss.exe ObjectDirectory=\Windows SharedSection=1024,3072,512 Windows=On SubSystemType=Windows
            ServerDll=basesrv,1 ServerDll=winsrv:UserServerDllInitialization,3 ServerDll=winsrv:ConServerDllInitialization,2
            ProfileControl=Off MaxRequestThreads=16
            </para>
            <para>The values for the SharedSection substring are described as follows:</para>
            <list type="bullet">
            <item>
            <term>The first SharedSection value is the size of the shared heap common to all desktops, in kilobytes.</term>
            </item>
            <item>
            <term>
            The second SharedSection value is the size of the desktop heap needed for each desktop that is created in the interactive window
            station, WinSta0, in kilobytes.
            </term>
            </item>
            <item>
            <term>
            The third SharedSection value is the size of the desktop heap needed for each desktop that is created in a noninteractive window
            station, in kilobytes.
            </term>
            </item>
            </list>
            <para>
            The default size of the desktop heap depends on factors such as hardware architecture. To retrieve the size of the desktop heap,
            call the GetUserObjectInformation function with UOI_HEAPSIZE.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateWindowStation(System.String,Vanara.PInvoke.User32.CreateWindowStationFlags,Vanara.PInvoke.ACCESS_MASK,Vanara.PInvoke.SECURITY_ATTRIBUTES)">
            <summary>
            <para>Creates a window station object, associates it with the calling process, and assigns it to the current session.</para>
            </summary>
            <param name="lpwinsta">
            <para>
            The name of the window station to be created. Window station names are case-insensitive and cannot contain backslash characters
            (). Only members of the Administrators group are allowed to specify a name. If lpwinsta is <c>NULL</c> or an empty string, the
            system forms a window station name using the logon session identifier for the calling process. To get this name, call the
            GetUserObjectInformation function.
            </para>
            </param>
            <param name="dwFlags">
            <para>
            If this parameter is <c>CWF_CREATE_ONLY</c> and the window station already exists, the call fails. If this flag is not specified
            and the window station already exists, the function succeeds and returns a new handle to the existing window station.
            </para>
            <para><c>Windows XP/2000:</c> This parameter is reserved and must be zero.</para>
            </param>
            <param name="dwDesiredAccess">
            <para>
            The type of access the returned handle has to the window station. In addition, you can specify any of the standard access rights,
            such as <c>READ_CONTROL</c> or <c>WRITE_DAC</c>, and a combination of the window station-specific access rights. For more
            information, see Window Station Security and Access Rights.
            </para>
            </param>
            <param name="lpsa">
            <para>
            A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by child processes. If
            lpsa is <c>NULL</c>, the handle cannot be inherited.
            </para>
            <para>
            The <c>lpSecurityDescriptor</c> member of the structure specifies a security descriptor for the new window station. If lpsa is
            <c>NULL</c>, the window station (and any desktops created within the window) gets a security descriptor that grants
            <c>GENERIC_ALL</c> access to all users.
            </para>
            </param>
            <returns>
            <para>
            If the function succeeds, the return value is a handle to the newly created window station. If the specified window station
            already exists, the function succeeds and returns a handle to the existing window station.
            </para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>After you are done with the handle, you must call CloseWindowStation to free the handle.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnumDesktops(Vanara.PInvoke.HWINSTA,Vanara.PInvoke.User32.EnumDesktopProc,System.IntPtr)">
            <summary>
            <para>
            Enumerates all desktops associated with the specified window station of the calling process. The function passes the name of each
            desktop, in turn, to an application-defined callback function.
            </para>
            </summary>
            <param name="hwinsta">
            <para>
            A handle to the window station whose desktops are to be enumerated. This handle is returned by the CreateWindowStation,
            GetProcessWindowStation, or OpenWindowStation function, and must have the WINSTA_ENUMDESKTOPS access right. For more information,
            see Window Station Security and Access Rights.
            </para>
            <para>If this parameter is NULL, the current window station is used.</para>
            </param>
            <param name="lpEnumFunc">
            <para>A pointer to an application-defined EnumDesktopProc callback function.</para>
            </param>
            <param name="lParam">
            <para>An application-defined value to be passed to the callback function.</para>
            </param>
            <returns>
            <para>If the function succeeds, it returns the nonzero value returned by the callback function that was pointed to by lpEnumFunc.</para>
            <para>
            If the function is unable to perform the enumeration, the return value is zero. Call GetLastError to get extended error information.
            </para>
            <para>
            If the callback function fails, the return value is zero. The callback function can call SetLastError to set an error code for
            the caller to retrieve by calling GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            The <c>EnumDesktops</c> function enumerates only those desktops for which the calling process has the DESKTOP_ENUMERATE access
            right. For more information, see Desktop Security and Access Rights.
            </para>
            <para>
            The <c>EnumDesktops</c> function repeatedly invokes the lpEnumFunc callback function until the last desktop is enumerated or the
            callback function returns FALSE.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnumDesktops(Vanara.PInvoke.HWINSTA)">
            <summary>Enumerates all desktops associated with the specified window station of the calling process.</summary>
            <param name="hwinsta">
            <para>
            A handle to the window station whose desktops are to be enumerated. This handle is returned by the CreateWindowStation,
            GetProcessWindowStation, or OpenWindowStation function, and must have the WINSTA_ENUMDESKTOPS access right. For more information,
            see Window Station Security and Access Rights.
            </para>
            <para>If this parameter is NULL, the current window station is used.</para>
            </param>
            <returns>The list of desktop names in the specified window station of the calling process.</returns>
            <remarks>
            <para>
            The <c>EnumDesktops</c> function enumerates only those desktops for which the calling process has the DESKTOP_ENUMERATE access
            right. For more information, see Desktop Security and Access Rights.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnumDesktopWindows(Vanara.PInvoke.HDESK,Vanara.PInvoke.User32.EnumWindowsProc,System.IntPtr)">
            <summary>
            <para>
            Enumerates all top-level windows associated with the specified desktop. It passes the handle to each window, in turn, to an
            application-defined callback function.
            </para>
            </summary>
            <param name="hDesktop">
            <para>
            A handle to the desktop whose top-level windows are to be enumerated. This handle is returned by the CreateDesktop,
            GetThreadDesktop, OpenDesktop, or OpenInputDesktop function, and must have the <c>DESKTOP_READOBJECTS</c> access right. For more
            information, see Desktop Security and Access Rights.
            </para>
            <para>If this parameter is NULL, the current desktop is used.</para>
            </param>
            <param name="lpfn">
            <para>A pointer to an application-defined EnumWindowsProc callback function.</para>
            </param>
            <param name="lParam">
            <para>An application-defined value to be passed to the callback function.</para>
            </param>
            <returns>
            <para>If the function fails or is unable to perform the enumeration, the return value is zero.</para>
            <para>To get extended error information, call GetLastError.</para>
            <para>You must ensure that the callback function sets SetLastError if it fails.</para>
            <para><c>Windows Server 2003 and Windows XP/2000:</c> If there are no windows on the desktop, GetLastError returns <c>ERROR_INVALID_HANDLE</c>.</para>
            </returns>
            <remarks>
            <para>
            The <c>EnumDesktopWindows</c> function repeatedly invokes the lpfn callback function until the last top-level window is
            enumerated or the callback function returns <c>FALSE</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnumWindowStations(Vanara.PInvoke.User32.EnumWindowStationProc,System.IntPtr)">
            <summary>
            <para>
            Enumerates all window stations in the current session. The function passes the name of each window station, in turn, to an
            application-defined callback function.
            </para>
            </summary>
            <param name="lpEnumFunc">
            <para>A pointer to an application-defined EnumWindowStationProc callback function.</para>
            </param>
            <param name="lParam">
            <para>An application-defined value to be passed to the callback function.</para>
            </param>
            <returns>
            <para>If the function succeeds, it returns the nonzero value returned by the callback function that was pointed to by lpEnumFunc.</para>
            <para>
            If the function is unable to perform the enumeration, the return value is zero. Call GetLastError to get extended error information.
            </para>
            <para>
            If the callback function fails, the return value is zero. The callback function can call SetLastError to set an error code for
            the caller to retrieve by calling GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            The <c>EnumWindowStations</c> function enumerates only those window stations for which the calling process has the
            WINSTA_ENUMERATE access right. For more information, see Window Station Security and Access Rights.
            </para>
            <para>
            <c>EnumWindowStations</c> repeatedly invokes the lpEnumFunc callback function until the last window station is enumerated or the
            callback function returns FALSE.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetProcessWindowStation">
            <summary>
            <para>Retrieves a handle to the current window station for the calling process.</para>
            </summary>
            <returns>
            <para>If the function succeeds, the return value is a handle to the window station.</para>
            <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The system associates a window station with a process when the process is created. A process can use the SetProcessWindowStation
            function to change its window station.
            </para>
            <para>
            The calling process can use the returned handle in calls to the GetUserObjectInformation, GetUserObjectSecurity,
            SetUserObjectInformation, and SetUserObjectSecurity functions.
            </para>
            <para>Do not close the handle returned by this function.</para>
            <para>
            A service application is created with an associated window station and desktop, so there is no need to call a USER or GDI
            function to connect the service to a window station and desktop.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetThreadDesktop(System.UInt32)">
            <summary>
            <para>Retrieves a handle to the desktop assigned to the specified thread.</para>
            </summary>
            <param name="dwThreadId">
            <para>The thread identifier. The GetCurrentThreadId and CreateProcess functions return thread identifiers.</para>
            </param>
            <returns>
            <para>
            If the function succeeds, the return value is a handle to the desktop associated with the specified thread. You do not need to
            call the CloseDesktop function to close the returned handle.
            </para>
            <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The system associates a desktop with a thread when that thread is created. A thread can use the SetThreadDesktop function to
            change its desktop. The desktop associated with a thread must be on the window station associated with the thread's process.
            </para>
            <para>
            The calling process can use the returned handle in calls to the GetUserObjectInformation, GetUserObjectSecurity,
            SetUserObjectInformation, and SetUserObjectSecurity functions.
            </para>
            <para>
            A service application is created with an associated window station and desktop, so there is no need to call a USER or GDI
            function to connect the service to a window station and desktop.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetUserObjectInformation(System.IntPtr,Vanara.PInvoke.User32.UserObjectInformationType,System.IntPtr,System.UInt32,System.UInt32@)">
            <summary>
            <para>Retrieves information about the specified window station or desktop object.</para>
            </summary>
            <param name="hObj">
            <para>
            A handle to the window station or desktop object. This handle is returned by the CreateWindowStation, OpenWindowStation,
            CreateDesktop, or OpenDesktop function.
            </para>
            </param>
            <param name="nIndex">
            <para>The information to be retrieved. The parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>UOI_FLAGS 1</term>
            <term>The handle flags. The pvInfo parameter must point to a USEROBJECTFLAGS structure.</term>
            </item>
            <item>
            <term>UOI_HEAPSIZE 5</term>
            <term>
            The size of the desktop heap, in KB, as a ULONG value. The hObj parameter must be a handle to a desktop object, otherwise, the
            function fails. Windows Server 2003 and Windows XP/2000: This value is not supported.
            </term>
            </item>
            <item>
            <term>UOI_IO 6</term>
            <term>
            TRUE if the hObj parameter is a handle to the desktop object that is receiving input from the user. FALSE otherwise. Windows
            Server 2003 and Windows XP/2000: This value is not supported.
            </term>
            </item>
            <item>
            <term>UOI_NAME 2</term>
            <term>The name of the object, as a string.</term>
            </item>
            <item>
            <term>UOI_TYPE 3</term>
            <term>The type name of the object, as a string.</term>
            </item>
            <item>
            <term>UOI_USER_SID 4</term>
            <term>
            The SID structure that identifies the user that is currently associated with the specified object. If no user is associated with
            the object, the value returned in the buffer pointed to by lpnLengthNeeded is zero. Note that SID is a variable length structure.
            You will usually make a call to GetUserObjectInformation to determine the length of the SID before retrieving its value.
            </term>
            </item>
            </list>
            </param>
            <param name="pvInfo">
            <para>A pointer to a buffer to receive the object information.</para>
            </param>
            <param name="nLength">
            <para>The size of the buffer pointed to by the pvInfo parameter, in bytes.</para>
            </param>
            <param name="lpnLengthNeeded">
            <para>
            A pointer to a variable receiving the number of bytes required to store the requested information. If this variable's value is
            greater than the value of the nLength parameter when the function returns, the function returns FALSE, and none of the
            information is copied to the pvInfo buffer. If the value of the variable pointed to by lpnLengthNeeded is less than or equal to
            the value of nLength, the entire information block is copied.
            </para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetUserObjectInformation``1(System.IntPtr,Vanara.PInvoke.User32.UserObjectInformationType)">
            <summary>
            <para>Retrieves information about the specified window station or desktop object.</para>
            </summary>
            <param name="hObj">
            <para>
            A handle to the window station or desktop object. This handle is returned by the CreateWindowStation, OpenWindowStation,
            CreateDesktop, or OpenDesktop function.
            </para>
            </param>
            <param name="nIndex">
            <para>The information to be retrieved. The parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>UOI_FLAGS 1</term>
            <term>The handle flags. The pvInfo parameter must point to a USEROBJECTFLAGS structure.</term>
            </item>
            <item>
            <term>UOI_HEAPSIZE 5</term>
            <term>
            The size of the desktop heap, in KB, as a ULONG value. The hObj parameter must be a handle to a desktop object, otherwise, the
            function fails. Windows Server 2003 and Windows XP/2000: This value is not supported.
            </term>
            </item>
            <item>
            <term>UOI_IO 6</term>
            <term>
            TRUE if the hObj parameter is a handle to the desktop object that is receiving input from the user. FALSE otherwise. Windows
            Server 2003 and Windows XP/2000: This value is not supported.
            </term>
            </item>
            <item>
            <term>UOI_NAME 2</term>
            <term>The name of the object, as a string.</term>
            </item>
            <item>
            <term>UOI_TYPE 3</term>
            <term>The type name of the object, as a string.</term>
            </item>
            <item>
            <term>UOI_USER_SID 4</term>
            <term>
            The SID structure that identifies the user that is currently associated with the specified object. If no user is associated with
            the object, the value returned in the buffer pointed to by lpnLengthNeeded is zero. Note that SID is a variable length structure.
            You will usually make a call to GetUserObjectInformation to determine the length of the SID before retrieving its value.
            </term>
            </item>
            </list>
            </param>
            <returns>The value specified by <typeparamref name="T"/> and <paramref name="nIndex"/>.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.OpenDesktop(System.String,Vanara.PInvoke.User32.CreateDesktopFlags,System.Boolean,Vanara.PInvoke.ACCESS_MASK)">
            <summary>
            <para>Opens the specified desktop object.</para>
            </summary>
            <param name="lpszDesktop">
            <para>The name of the desktop to be opened. Desktop names are case-insensitive.</para>
            <para>This desktop must belong to the current window station.</para>
            </param>
            <param name="dwFlags">
            <para>This parameter can be zero or the following value.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DF_ALLOWOTHERACCOUNTHOOK 0x0001</term>
            <term>Allows processes running in other accounts on the desktop to set hooks in this process.</term>
            </item>
            </list>
            </param>
            <param name="fInherit">
            <para>
            If this value is <c>TRUE</c>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit
            this handle.
            </para>
            </param>
            <param name="dwDesiredAccess">
            <para>The access to the desktop. For a list of access rights, see Desktop Security and Access Rights.</para>
            </param>
            <returns>
            <para>
            If the function succeeds, the return value is a handle to the opened desktop. When you are finished using the handle, call the
            CloseDesktop function to close it.
            </para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The calling process must have an associated window station, either assigned by the system at process creation time or set by the
            SetProcessWindowStation function.
            </para>
            <para>
            If the dwDesiredAccess parameter specifies the <c>READ_CONTROL</c>, <c>WRITE_DAC</c>, or <c>WRITE_OWNER</c> standard access
            rights, you must also request the <c>DESKTOP_READOBJECTS</c> and <c>DESKTOP_WRITEOBJECTS</c> access rights.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.OpenInputDesktop(Vanara.PInvoke.User32.CreateDesktopFlags,System.Boolean,Vanara.PInvoke.ACCESS_MASK)">
            <summary>
            <para>Opens the desktop that receives user input.</para>
            </summary>
            <param name="dwFlags">
            <para>This parameter can be zero or the following value.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DF_ALLOWOTHERACCOUNTHOOK 0x0001</term>
            <term>Allows processes running in other accounts on the desktop to set hooks in this process.</term>
            </item>
            </list>
            </param>
            <param name="fInherit">
            <para>
            If this value is <c>TRUE</c>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit
            this handle.
            </para>
            </param>
            <param name="dwDesiredAccess">
            <para>The access to the desktop. For a list of access rights, see Desktop Security and Access Rights.</para>
            </param>
            <returns>
            <para>
            If the function succeeds, the return value is a handle to the desktop that receives user input. When you are finished using the
            handle, call the CloseDesktop function to close it.
            </para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The calling process must have an associated window station, either assigned by the system when the process is created, or set by
            the SetProcessWindowStation function. The window station associated with the calling process must be capable of receiving input.
            </para>
            <para>
            If the calling process is running in a disconnected session, the function returns a handle to the desktop that becomes active
            when the user restores the connection.
            </para>
            <para>An application can use the SwitchDesktop function to change the input desktop.</para>
            <para>
            If the dwDesiredAccess parameter specifies the <c>READ_CONTROL</c>, <c>WRITE_DAC</c>, or <c>WRITE_OWNER</c> standard access
            rights, you must also request the <c>DESKTOP_READOBJECTS</c> and <c>DESKTOP_WRITEOBJECTS</c> access rights.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.OpenWindowStation(System.String,System.Boolean,Vanara.PInvoke.ACCESS_MASK)">
            <summary>
            <para>Opens the specified window station.</para>
            </summary>
            <param name="lpszWinSta">
            <para>The name of the window station to be opened. Window station names are case-insensitive.</para>
            <para>This window station must belong to the current session.</para>
            </param>
            <param name="fInherit">
            <para>
            If this value is <c>TRUE</c>, processes created by this process will inherit the handle. Otherwise, the processes do not inherit
            this handle.
            </para>
            </param>
            <param name="dwDesiredAccess">
            <para>The access to the window station. For a list of access rights, see Window Station Security and Access Rights.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is the handle to the specified window station.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>After you are done with the handle, you must call CloseWindowStation to free the handle.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetProcessWindowStation(Vanara.PInvoke.HWINSTA)">
            <summary>
            <para>
            Assigns the specified window station to the calling process. This enables the process to access objects in the window station
            such as desktops, the clipboard, and global atoms. All subsequent operations on the window station use the access rights granted
            to hWinSta.
            </para>
            </summary>
            <param name="hWinSta">
            <para>
            A handle to the window station. This can be a handle returned by the CreateWindowStation, OpenWindowStation, or
            GetProcessWindowStation function.
            </para>
            <para>This window station must be associated with the current session.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetThreadDesktop(Vanara.PInvoke.HDESK)">
            <summary>
            <para>
            Assigns the specified desktop to the calling thread. All subsequent operations on the desktop use the access rights granted to
            the desktop.
            </para>
            </summary>
            <param name="hDesktop">
            <para>
            A handle to the desktop to be assigned to the calling thread. This handle is returned by the CreateDesktop, GetThreadDesktop,
            OpenDesktop, or OpenInputDesktop function.
            </para>
            <para>This desktop must be associated with the current window station for the process.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>SetThreadDesktop</c> function will fail if the calling thread has any windows or hooks on its current desktop (unless the
            hDesktop parameter is a handle to the current desktop).
            </para>
            <para>
            <c>Warning</c> There is a significant security risk for any service that opens a window on the interactive desktop. By opening a
            desktop window, a service makes itself vulnerable to attack from the logged-on user, whose application could send malicious
            messages to the service's desktop window and affect its ability to function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetUserObjectInformation(System.IntPtr,Vanara.PInvoke.User32.UserObjectInformationType,System.IntPtr,System.UInt32)">
            <summary>
            <para>Sets information about the specified window station or desktop object.</para>
            </summary>
            <param name="hObj">
            <para>
            A handle to the window station, desktop object or a current process pseudo handle. This handle can be returned by the
            CreateWindowStation, OpenWindowStation, CreateDesktop, OpenDesktop or GetCurrentProcess function.
            </para>
            </param>
            <param name="nIndex">
            <para>The object information to be set. This parameter can be the following value.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>UOI_FLAGS 1</term>
            <term>Sets the object's handle flags. The pvInfo parameter must point to a USEROBJECTFLAGS structure.</term>
            </item>
            <item>
            <term>UOI_TIMERPROC_EXCEPTION_SUPPRESSION 7</term>
            <term>
            Sets the exception handling behavior when calling TimerProc. hObj must be the process handle returned by the GetCurrentProcess
            function. The pvInfo parameter must point to a BOOL. If TRUE, Windows will enclose its calls to TimerProc with an exception
            handler that consumes and discards all exceptions. This has been the default behavior since Windows 2000, although that may
            change in future versions of Windows. If pvInfo points to FALSE, Windows will not enclose its calls to TimerProc with an
            exception handler. A setting of FALSE is recommended. Otherwise, the application could behave unpredictably, and could be more
            vulnerable to security exploits.
            </term>
            </item>
            </list>
            </param>
            <param name="pvInfo">
            <para>A pointer to a buffer containing the object information, or a BOOL.</para>
            </param>
            <param name="nLength">
            <para>The size of the information contained in the buffer pointed to by pvInfo, in bytes.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetUserObjectInformation``1(System.IntPtr,Vanara.PInvoke.User32.UserObjectInformationType,``0)">
            <summary>Sets information about the specified window station or desktop object.</summary>
            <typeparam name="T">The type being set.</typeparam>
            <param name="hObj">
            A handle to the window station, desktop object or a current process pseudo handle. This handle can be returned by the
            CreateWindowStation, OpenWindowStation, CreateDesktop, OpenDesktop or GetCurrentProcess function.
            </param>
            <param name="nIndex">
            <para>The object information to be set. This parameter can be the following value.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>UOI_FLAGS 1</term>
            <term>Sets the object's handle flags. The pvInfo parameter must point to a USEROBJECTFLAGS structure.</term>
            </item>
            <item>
            <term>UOI_TIMERPROC_EXCEPTION_SUPPRESSION 7</term>
            <term>
            Sets the exception handling behavior when calling TimerProc. hObj must be the process handle returned by the GetCurrentProcess
            function. The pvInfo parameter must point to a BOOL. If TRUE, Windows will enclose its calls to TimerProc with an exception
            handler that consumes and discards all exceptions. This has been the default behavior since Windows 2000, although that may
            change in future versions of Windows. If pvInfo points to FALSE, Windows will not enclose its calls to TimerProc with an
            exception handler. A setting of FALSE is recommended. Otherwise, the application could behave unpredictably, and could be more
            vulnerable to security exploits.
            </term>
            </item>
            </list>
            </param>
            <param name="info">A buffer containing the object information, or a BOOL.</param>
            <exception cref="T:System.ArgumentException">Type mismatch</exception>
        </member>
        <member name="M:Vanara.PInvoke.User32.SwitchDesktop(Vanara.PInvoke.HDESK)">
            <summary>
            <para>
            Makes the specified desktop visible and activates it. This enables the desktop to receive input from the user. The calling
            process must have DESKTOP_SWITCHDESKTOP access to the desktop for the <c>SwitchDesktop</c> function to succeed.
            </para>
            </summary>
            <param name="hDesktop">
            <para>A handle to the desktop. This handle is returned by the CreateDesktop and OpenDesktop functions.</para>
            <para>This desktop must be associated with the current window station for the process.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>
            If the function fails, the return value is zero. To get extended error information, call GetLastError. However,
            <c>SwitchDesktop</c> only sets the last error for the following cases:
            </para>
            <list type="bullet">
            <item>
            <term>When the desktop belongs to an invisible window station</term>
            </item>
            <item>
            <term>
            When hDesktop is an invalid handle, refers to a destroyed desktop, or belongs to a different session than that of the calling process
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>SwitchDesktop</c> function fails if the desktop belongs to an invisible window station. <c>SwitchDesktop</c> also fails
            when called from a process that is associated with a secured desktop such as the WinLogon and ScreenSaver desktops. Processes
            that are associated with a secured desktop include custom UserInit processes. Such calls typically fail with an "access denied" error.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.USEROBJECTFLAGS">
            <summary>
            <para>Contains information about a window station or desktop handle.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.USEROBJECTFLAGS.fInherit">
            <summary>
            <para>If this member is TRUE, new processes inherit the handle. Otherwise, the handle is not inherited.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.USEROBJECTFLAGS.fReserved">
            <summary>
            <para>Reserved for future use. This member must be FALSE.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.USEROBJECTFLAGS.dwFlags">
            <summary>
            <para>For window stations, this member can contain the following window station attribute.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSF_VISIBLE 0x0001L</term>
            <term>Window station has visible display surfaces.</term>
            </item>
            </list>
            <para>For desktops, the <c>dwFlags</c> member can contain the following value.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DF_ALLOWOTHERACCOUNTHOOK 0x0001L</term>
            <term>Allows processes running in other accounts on the desktop to set hooks in this process.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SafeHDESK">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> to a that releases a created HDESK instance at disposal using CloseDesktop.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHDESK.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.HDESK"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHDESK.op_Implicit(Vanara.PInvoke.User32.SafeHDESK)~Vanara.PInvoke.HDESK">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.User32.SafeHDESK"/> to <see cref="T:Vanara.PInvoke.HDESK"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHDESK.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.SafeHWINSTA">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> to a that releases a created HWINSTA instance at disposal using CloseWindowStation.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHWINSTA.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.HWINSTA"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHWINSTA.op_Implicit(Vanara.PInvoke.User32.SafeHWINSTA)~Vanara.PInvoke.HWINSTA">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.User32.SafeHWINSTA"/> to <see cref="T:Vanara.PInvoke.HWINSTA"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHWINSTA.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.DialogProc">
            <summary>
            Application-defined callback function used with the <c>CreateDialog</c> and <c>DialogBox</c> families of functions. It processes
            messages sent to a modal or modeless dialog box. The <c>DLGPROC</c> type defines a pointer to this callback function. DialogProc
            is a placeholder for the application-defined function name.
            </summary>
            <param name="hwndDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box.</para>
            </param>
            <param name="uMsg">
            <para>Type: <c>UINT</c></para>
            <para>The message.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>INT_PTR</c></para>
            <para>
            Typically, the dialog box procedure should return <c>TRUE</c> if it processed the message, and <c>FALSE</c> if it did not. If the
            dialog box procedure returns <c>FALSE</c>, the dialog manager performs the default dialog operation in response to the message.
            </para>
            <para>
            If the dialog box procedure processes a message that requires a specific return value, the dialog box procedure should set the
            desired return value by calling <c>SetWindowLong</c>(hwndDlg, <c>DWL_MSGRESULT</c>, lResult) immediately before returning
            <c>TRUE</c>. Note that you must call <c>SetWindowLong</c> immediately before returning <c>TRUE</c>; doing so earlier may result
            in the <c>DWL_MSGRESULT</c> value being overwritten by a nested dialog box message.
            </para>
            <para>
            The following messages are exceptions to the general rules stated above. Consult the documentation for the specific message for
            details on the semantics of the return value.
            </para>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.User32.DialogBoxStyles">
            <summary>
            The following table lists the dialog box styles that you can specify when you create a dialog box. You can use these styles in
            calls to the CreateWindow and CreateWindowEx functions, in the style member of the DLGTEMPLATE and DLGTEMPLATEEX structures, and
            in the statement of a dialog box definition in a resource file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DialogBoxStyles.DS_ABSALIGN">
            <summary>
            Indicates that the coordinates of the dialog box are screen coordinates. If this style is not specified, the coordinates are
            client coordinates.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DialogBoxStyles.DS_SYSMODAL">
            <summary>
            This style is obsolete and is included for compatibility with 16-bit versions of Windows. If you specify this style, the
            system creates the dialog box with the WS_EX_TOPMOST style. This style does not prevent the user from accessing other windows
            on the desktop. Do not combine this style with the DS_CONTROL style.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DialogBoxStyles.DS_LOCALEDIT">
            <summary>
            Applies to 16-bit applications only. This style directs edit controls in the dialog box to allocate memory from the
            application's data segment. Otherwise, edit controls allocate storage from a global memory object.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DialogBoxStyles.DS_SETFONT">
            <summary>
            Indicates that the header of the dialog box template (either standard or extended) contains additional data specifying the
            font to use for text in the client area and controls of the dialog box. If possible, the system selects a font according to
            the specified font data. The system passes a handle to the font to the dialog box and to each control by sending them the
            WM_SETFONT message. For descriptions of the format of this font data, see DLGTEMPLATE and DLGTEMPLATEEX. If neither
            DS_SETFONT nor DS_SHELLFONT is specified, the dialog box template does not include the font data.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DialogBoxStyles.DS_MODALFRAME">
            <summary>
            Creates a dialog box with a modal dialog-box frame that can be combined with a title bar and window menu by specifying the
            WS_CAPTION and WS_SYSMENU styles.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DialogBoxStyles.DS_NOIDLEMSG">
            <summary>
            Suppresses WM_ENTERIDLE messages that the system would otherwise send to the owner of the dialog box while the dialog box is displayed.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DialogBoxStyles.DS_SETFOREGROUND">
            <summary>
            Causes the system to use the SetForegroundWindow function to bring the dialog box to the foreground. This style is useful for
            modal dialog boxes that require immediate attention from the user regardless of whether the owner window is the foreground
            window. The system restricts which processes can set the foreground window. For more information, see Foreground and
            Background Windows.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DialogBoxStyles.DS_3DLOOK">
            <summary>Obsolete. The system automatically applies the three-dimensional look to dialog boxes created by applications.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DialogBoxStyles.DS_FIXEDSYS">
            <summary>
            Causes the dialog box to use the SYSTEM_FIXED_FONT instead of the default SYSTEM_FONT. This is a monospace font compatible
            with the System font in 16-bit versions of Windows earlier than 3.0.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DialogBoxStyles.DS_NOFAILCREATE">
            <summary>
            Creates the dialog box even if errors occur for example, if a child window cannot be created or if the system cannot create a
            special data segment for an edit control.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DialogBoxStyles.DS_CONTROL">
            <summary>
            Creates a dialog box that works well as a child window of another dialog box, much like a page in a property sheet. This
            style allows the user to tab among the control windows of a child dialog box, use its accelerator keys, and so on.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DialogBoxStyles.DS_CENTER">
            <summary>
            Centers the dialog box in the working area of the monitor that contains the owner window. If no owner window is specified,
            the dialog box is centered in the working area of a monitor determined by the system. The working area is the area not
            obscured by the taskbar or any appbars.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DialogBoxStyles.DS_CENTERMOUSE">
            <summary>Centers the dialog box on the mouse cursor.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DialogBoxStyles.DS_CONTEXTHELP">
            <summary>
            Includes a question mark in the title bar of the dialog box. When the user clicks the question mark, the cursor changes to a
            question mark with a pointer. If the user then clicks a control in the dialog box, the control receives a WM_HELP message.
            The control should pass the message to the dialog box procedure, which should call the function using the HELP_WM_HELP
            command. The help application displays a pop-up window that typically contains help for the control. Note that DS_CONTEXTHELP
            is only a placeholder. When the dialog box is created, the system checks for DS_CONTEXTHELP and, if it is there, adds
            WS_EX_CONTEXTHELP to the extended style of the dialog box. WS_EX_CONTEXTHELP cannot be used with the WS_MAXIMIZEBOX or
            WS_MINIMIZEBOX styles.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DialogBoxStyles.DS_SHELLFONT">
            <summary>
            Indicates that the dialog box should use the system font. The typeface member of the extended dialog box template must be set
            to MS Shell Dlg. Otherwise, this style has no effect. It is also recommended that you use the DIALOGEX Resource, rather than
            the DIALOG Resource. For more information, see Dialog Box Fonts. The system selects a font using the font data specified in
            the pointsize, weight, and italic members. The system passes a handle to the font to the dialog box and to each control by
            sending them the WM_SETFONT message. For descriptions of the format of this font data, see DLGTEMPLATEEX. If neither
            DS_SHELLFONT nor DS_SETFONT is specified, the extended dialog box template does not include the font data.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DialogBoxStyles.DS_USEPIXELS">
            <summary/>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateDialog(Vanara.PInvoke.HINSTANCE,System.String,Vanara.PInvoke.HWND,Vanara.PInvoke.User32.DialogProc)">
            <summary>
            <para>
            Creates a modeless dialog box from a dialog box template resource. The <c>CreateDialog</c> macro uses the CreateDialogParam function.
            </para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>
            A handle to the module which contains the dialog box template. If this parameter is NULL, then the current executable is used.
            </para>
            </param>
            <param name="lpName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of
            the dialog box template or an integer value that specifies the resource identifier of the dialog box template. If the parameter
            specifies a resource identifier, its high-order word must be zero and its low-order word must contain the identifier. You can use
            the MAKEINTRESOURCE macro to create this value.
            </para>
            </param>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that owns the dialog box.</para>
            </param>
            <param name="lpDialogFunc">
            <para>Type: <c>DLGPROC</c></para>
            <para>A pointer to the dialog box procedure. For more information about the dialog box procedure, see DialogProc.</para>
            </param>
            <returns>
            <para>None</para>
            </returns>
            <remarks>
            <para>
            The <c>CreateDialog</c> function uses the CreateWindowEx function to create the dialog box. <c>CreateDialog</c> then sends a
            WM_INITDIALOG message (and a WM_SETFONT message if the template specifies the DS_SETFONT or <c>DS_SHELLFONT</c> style) to the
            dialog box procedure. The function displays the dialog box if the template specifies the <c>WS_VISIBLE</c> style. Finally,
            <c>CreateDialog</c> returns the window handle to the dialog box.
            </para>
            <para>
            After <c>CreateDialog</c> returns, the application displays the dialog box (if it is not already displayed) by using the
            ShowWindow function. The application destroys the dialog box by using the DestroyWindow function. To support keyboard navigation
            and other dialog box functionality, the message loop for the dialog box must call the IsDialogMessage function.
            </para>
            <para>Examples</para>
            <para>For an example, see Creating a Modeless Dialog Box.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateDialogIndirect(Vanara.PInvoke.HINSTANCE,System.IntPtr,Vanara.PInvoke.HWND,Vanara.PInvoke.User32.DialogProc)">
            <summary>
            <para>
            Creates a modeless dialog box from a dialog box template in memory. The <c>CreateDialogIndirect</c> macro uses the
            CreateDialogIndirectParam function.
            </para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to the module that creates the dialog box.</para>
            </param>
            <param name="lpTemplate">
            <para>Type: <c>LPCDLGTEMPLATE</c></para>
            <para>
            A template that <c>CreateDialogIndirect</c> uses to create the dialog box. A dialog box template consists of a header that
            describes the dialog box, followed by one or more additional blocks of data that describe each of the controls in the dialog box.
            The template can use either the standard format or the extended format.
            </para>
            <para>
            In a standard template, the header is a DLGTEMPLATE structure followed by additional variable-length arrays. The data for each
            control consists of a DLGITEMTEMPLATE structure followed by additional variable-length arrays.
            </para>
            <para>
            In an extended dialog box template, the header uses the DLGTEMPLATEEX format and the control definitions use the
            DLGITEMTEMPLATEEX format.
            </para>
            <para>After <c>CreateDialogIndirect</c> returns, you can free the template, which is only used to get the dialog box started.</para>
            </param>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that owns the dialog box.</para>
            </param>
            <param name="lpDialogFunc">
            <para>Type: <c>DLGPROC</c></para>
            <para>A pointer to the dialog box procedure. For more information about the dialog box procedure, see DialogProc.</para>
            </param>
            <returns>
            <para>None</para>
            </returns>
            <remarks>
            <para>
            The <c>CreateDialogIndirect</c> macro uses the CreateWindowEx function to create the dialog box. <c>CreateDialogIndirect</c> then
            sends a WM_INITDIALOG message to the dialog box procedure. If the template specifies the DS_SETFONT or DS_SHELLFONT style, the
            function also sends a WM_SETFONT message to the dialog box procedure. The function displays the dialog box if the template
            specifies the WS_VISIBLE style. Finally, <c>CreateDialogIndirect</c> returns the window handle to the dialog box.
            </para>
            <para>
            After <c>CreateDialogIndirect</c> returns, you can use the ShowWindow function to display the dialog box (if it is not already
            visible). To destroy the dialog box, use the DestroyWindow function. To support keyboard navigation and other dialog box
            functionality, the message loop for the dialog box must call the IsDialogMessage function.
            </para>
            <para>
            In a standard dialog box template, the DLGTEMPLATE structure and each of the DLGITEMTEMPLATE structures must be aligned on
            <c>DWORD</c> boundaries. The creation data array that follows a <c>DLGITEMTEMPLATE</c> structure must also be aligned on a
            <c>DWORD</c> boundary. All of the other variable-length arrays in the template must be aligned on <c>WORD</c> boundaries.
            </para>
            <para>
            In an extended dialog box template, the DLGTEMPLATEEX header and each of the DLGITEMTEMPLATEEX control definitions must be
            aligned on <c>DWORD</c> boundaries. The creation data array, if any, that follows a <c>DLGITEMTEMPLATEEX</c> structure must also
            be aligned on a <c>DWORD</c> boundary. All of the other variable-length arrays in the template must be aligned on <c>WORD</c> boundaries.
            </para>
            <para>
            All character strings in the dialog box template, such as titles for the dialog box and buttons, must be Unicode strings. Use the
            MultiByteToWideChar function to generate Unicode strings from ANSI strings.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateDialogIndirectParam(Vanara.PInvoke.HINSTANCE,System.IntPtr,Vanara.PInvoke.HWND,Vanara.PInvoke.User32.DialogProc,System.IntPtr)">
            <summary>
            <para>
            Creates a modeless dialog box from a dialog box template in memory. Before displaying the dialog box, the function passes an
            application-defined value to the dialog box procedure as the lParam parameter of the WM_INITDIALOG message. An application can
            use this value to initialize dialog box controls.
            </para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>
            A handle to the module which contains the dialog box template. If this parameter is NULL, then the current executable is used.
            </para>
            </param>
            <param name="lpTemplate">
            <para>Type: <c>LPCDLGTEMPLATE</c></para>
            <para>
            The template <c>CreateDialogIndirectParam</c> uses to create the dialog box. A dialog box template consists of a header that
            describes the dialog box, followed by one or more additional blocks of data that describe each of the controls in the dialog box.
            The template can use either the standard format or the extended format.
            </para>
            <para>
            In a standard template, the header is a DLGTEMPLATE structure followed by additional variable-length arrays. The data for each
            control consists of a DLGITEMTEMPLATE structure followed by additional variable-length arrays.
            </para>
            <para>
            In an extended dialog box template, the header uses the DLGTEMPLATEEX format and the control definitions use the
            DLGITEMTEMPLATEEX format.
            </para>
            <para>After <c>CreateDialogIndirectParam</c> returns, you can free the template, which is only used to get the dialog box started.</para>
            </param>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that owns the dialog box.</para>
            </param>
            <param name="lpDialogFunc">
            <para>Type: <c>DLGPROC</c></para>
            <para>A pointer to the dialog box procedure. For more information about the dialog box procedure, see DialogProc.</para>
            </param>
            <param name="dwInitParam">
            <para>Type: <c>LPARAM</c></para>
            <para>The value to pass to the dialog box in the lParam parameter of the WM_INITDIALOG message.</para>
            </param>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>If the function succeeds, the return value is the window handle to the dialog box.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>CreateDialogIndirectParam</c> function uses the CreateWindowEx function to create the dialog box.
            <c>CreateDialogIndirectParam</c> then sends a WM_INITDIALOG message to the dialog box procedure. If the template specifies the
            DS_SETFONT or DS_SHELLFONT style, the function also sends a WM_SETFONT message to the dialog box procedure. The function displays
            the dialog box if the template specifies the <c>WS_VISIBLE</c> style. Finally, <c>CreateDialogIndirectParam</c> returns the
            window handle to the dialog box.
            </para>
            <para>
            After <c>CreateDialogIndirectParam</c> returns, you can use the ShowWindow function to display the dialog box (if it is not
            already visible). To destroy the dialog box, use the DestroyWindow function. To support keyboard navigation and other dialog box
            functionality, the message loop for the dialog box must call the IsDialogMessage function.
            </para>
            <para>
            In a standard dialog box template, the DLGTEMPLATE structure and each of the DLGITEMTEMPLATE structures must be aligned on
            <c>DWORD</c> boundaries. The creation data array that follows a <c>DLGITEMTEMPLATE</c> structure must also be aligned on a
            <c>DWORD</c> boundary. All of the other variable-length arrays in the template must be aligned on <c>WORD</c> boundaries.
            </para>
            <para>
            In an extended dialog box template, the DLGTEMPLATEEX header and each of the DLGITEMTEMPLATEEX control definitions must be
            aligned on <c>DWORD</c> boundaries. The creation data array, if any, that follows a <c>DLGITEMTEMPLATEEX</c> structure must also
            be aligned on a <c>DWORD</c> boundary. All of the other variable-length arrays in the template must be aligned on <c>WORD</c> boundaries.
            </para>
            <para>All character strings in the dialog box template, such as titles for the dialog box and buttons, must be Unicode strings.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateDialogParam(Vanara.PInvoke.HINSTANCE,System.String,Vanara.PInvoke.HWND,Vanara.PInvoke.User32.DialogProc,System.IntPtr)">
            <summary>
            <para>
            Creates a modeless dialog box from a dialog box template resource. Before displaying the dialog box, the function passes an
            application-defined value to the dialog box procedure as the lParam parameter of the WM_INITDIALOG message. An application can
            use this value to initialize dialog box controls.
            </para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>
            A handle to the module which contains the dialog box template. If this parameter is NULL, then the current executable is used.
            </para>
            </param>
            <param name="lpTemplateName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of
            the dialog box template or an integer value that specifies the resource identifier of the dialog box template. If the parameter
            specifies a resource identifier, its high-order word must be zero and low-order word must contain the identifier. You can use the
            MAKEINTRESOURCE macro to create this value.
            </para>
            </param>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that owns the dialog box.</para>
            </param>
            <param name="lpDialogFunc">
            <para>Type: <c>DLGPROC</c></para>
            <para>A pointer to the dialog box procedure. For more information about the dialog box procedure, see DialogProc.</para>
            </param>
            <param name="dwInitParam">
            <para>Type: <c>LPARAM</c></para>
            <para>The value to be passed to the dialog box procedure in the lParam parameter in the WM_INITDIALOG message.</para>
            </param>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>If the function succeeds, the return value is the window handle to the dialog box.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>CreateDialogParam</c> function uses the CreateWindowEx function to create the dialog box. <c>CreateDialogParam</c> then
            sends a WM_INITDIALOG message (and a WM_SETFONT message if the template specifies the DS_SETFONT or DS_SHELLFONT style) to the
            dialog box procedure. The function displays the dialog box if the template specifies the <c>WS_VISIBLE</c> style. Finally,
            <c>CreateDialogParam</c> returns the window handle of the dialog box.
            </para>
            <para>
            After <c>CreateDialogParam</c> returns, the application displays the dialog box (if it is not already displayed) using the
            ShowWindow function. The application destroys the dialog box by using the DestroyWindow function. To support keyboard navigation
            and other dialog box functionality, the message loop for the dialog box must call the IsDialogMessage function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DefDlgProc(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            Calls the default dialog box window procedure to provide default processing for any window messages that a dialog box with a
            private window class does not process.
            </para>
            </summary>
            <param name="hDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box.</para>
            </param>
            <param name="Msg">
            <para>Type: <c>UINT</c></para>
            <para>The message.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing and depends on the message sent.</para>
            </returns>
            <remarks>
            <para>
            The <c>DefDlgProc</c> function is the window procedure for the predefined class of dialog box. This procedure provides internal
            processing for the dialog box by forwarding messages to the dialog box procedure and carrying out default processing for any
            messages that the dialog box procedure returns as <c>FALSE</c>. Applications that create custom window procedures for their
            custom dialog boxes often use <c>DefDlgProc</c> instead of the DefWindowProc function to carry out default message processing.
            </para>
            <para>
            Applications create custom dialog box classes by filling a WNDCLASS structure with appropriate information and registering the
            class with the RegisterClass function. Some applications fill the structure by using the GetClassInfo function, specifying the
            name of the predefined dialog box. In such cases, the applications modify at least the <c>lpszClassName</c> member before
            registering. In all cases, the <c>cbWndExtra</c> member of <c>WNDCLASS</c> for a custom dialog box class must be set to at least <c>DLGWINDOWEXTRA</c>.
            </para>
            <para>The <c>DefDlgProc</c> function must not be called by a dialog box procedure; doing so results in recursive execution.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DialogBox(Vanara.PInvoke.HINSTANCE,System.String,Vanara.PInvoke.HWND,Vanara.PInvoke.User32.DialogProc)">
            <summary>
            <para>
            Creates a modal dialog box from a dialog box template resource. <c>DialogBox</c> does not return control until the specified
            callback function terminates the modal dialog box by calling the EndDialog function.
            </para>
            <para><c>DialogBox</c> is implemented as a call to the DialogBoxParam function.</para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>
            A handle to the module which contains the dialog box template. If this parameter is NULL, then the current executable is used.
            </para>
            </param>
            <param name="lpTemplate">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of
            the dialog box template or an integer value that specifies the resource identifier of the dialog box template. If the parameter
            specifies a resource identifier, its high-order word must be zero and its low-order word must contain the identifier. You can use
            the MAKEINTRESOURCE macro to create this value.
            </para>
            </param>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that owns the dialog box.</para>
            </param>
            <param name="lpDialogFunc">
            <para>Type: <c>DLGPROC</c></para>
            <para>A pointer to the dialog box procedure. For more information about the dialog box procedure, see DialogProc.</para>
            </param>
            <returns>
            <para>None</para>
            </returns>
            <remarks>
            <para>
            The <c>DialogBox</c> macro uses the CreateWindowEx function to create the dialog box. <c>DialogBox</c> then sends a WM_INITDIALOG
            message (and a WM_SETFONT message if the template specifies the DS_SETFONT or DS_SHELLFONT style) to the dialog box procedure.
            The function displays the dialog box (regardless of whether the template specifies the <c>WS_VISIBLE</c> style), disables the
            owner window, and starts its own message loop to retrieve and dispatch messages for the dialog box.
            </para>
            <para>
            When the dialog box procedure calls the EndDialog function, <c>DialogBox</c> destroys the dialog box, ends the message loop,
            enables the owner window (if previously enabled), and returns the nResult parameter specified by the dialog box procedure when it
            called <c>EndDialog</c>.
            </para>
            <para>Examples</para>
            <para>For an example, see Creating a Modal Dialog Box.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DialogBox(Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.ResourceId,Vanara.PInvoke.HWND,Vanara.PInvoke.User32.DialogProc)">
            <summary>
            <para>
            Creates a modal dialog box from a dialog box template resource. <c>DialogBox</c> does not return control until the specified
            callback function terminates the modal dialog box by calling the EndDialog function.
            </para>
            <para><c>DialogBox</c> is implemented as a call to the DialogBoxParam function.</para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>
            A handle to the module which contains the dialog box template. If this parameter is NULL, then the current executable is used.
            </para>
            </param>
            <param name="lpTemplate">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of
            the dialog box template or an integer value that specifies the resource identifier of the dialog box template. If the parameter
            specifies a resource identifier, its high-order word must be zero and its low-order word must contain the identifier. You can
            use the MAKEINTRESOURCE macro to create this value.
            </para>
            </param>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that owns the dialog box.</para>
            </param>
            <param name="lpDialogFunc">
            <para>Type: <c>DLGPROC</c></para>
            <para>A pointer to the dialog box procedure. For more information about the dialog box procedure, see DialogProc.</para>
            </param>
            <returns>
            <para>None</para>
            </returns>
            <remarks>
            <para>
            The <c>DialogBox</c> macro uses the CreateWindowEx function to create the dialog box. <c>DialogBox</c> then sends a
            WM_INITDIALOG message (and a WM_SETFONT message if the template specifies the DS_SETFONT or DS_SHELLFONT style) to the dialog
            box procedure. The function displays the dialog box (regardless of whether the template specifies the <c>WS_VISIBLE</c> style),
            disables the owner window, and starts its own message loop to retrieve and dispatch messages for the dialog box.
            </para>
            <para>
            When the dialog box procedure calls the EndDialog function, <c>DialogBox</c> destroys the dialog box, ends the message loop,
            enables the owner window (if previously enabled), and returns the nResult parameter specified by the dialog box procedure when
            it called <c>EndDialog</c>.
            </para>
            <para>Examples</para>
            <para>For an example, see Creating a Modal Dialog Box.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DialogBoxIndirect(Vanara.PInvoke.HINSTANCE,System.IntPtr,Vanara.PInvoke.HWND,Vanara.PInvoke.User32.DialogProc)">
            <summary>
            <para>
            Creates a modal dialog box from a dialog box template in memory. <c>DialogBoxIndirect</c> does not return control until the
            specified callback function terminates the modal dialog box by calling the EndDialog function.
            </para>
            <para><c>DialogBoxIndirect</c> is implemented as a call to the DialogBoxIndirectParam function.</para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to the module that creates the dialog box.</para>
            </param>
            <param name="lpTemplate">
            <para>Type: <c>LPCDLGTEMPLATE</c></para>
            <para>
            The template that <c>DialogBoxIndirect</c> uses to create the dialog box. A dialog box template consists of a header that
            describes the dialog box, followed by one or more additional blocks of data that describe each of the controls in the dialog box.
            The template can use either the standard format or the extended format.
            </para>
            <para>
            In a standard template for a dialog box, the header is a DLGTEMPLATE structure followed by additional variable-length arrays. The
            data for each control consists of a DLGITEMTEMPLATE structure followed by additional variable-length arrays.
            </para>
            <para>
            In an extended template for a dialog box, the header uses the DLGTEMPLATEEX format and the control definitions use the
            DLGITEMTEMPLATEEX format.
            </para>
            </param>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that owns the dialog box.</para>
            </param>
            <param name="lpDialogFunc">
            <para>Type: <c>DLGPROC</c></para>
            <para>A pointer to the dialog box procedure. For more information about the dialog box procedure, see DialogProc.</para>
            </param>
            <returns>
            <para>None</para>
            </returns>
            <remarks>
            <para>
            The <c>DialogBoxIndirect</c> macro uses the CreateWindowEx function to create the dialog box. <c>DialogBoxIndirect</c> then sends
            a WM_INITDIALOG message to the dialog box procedure. If the template specifies the DS_SETFONT or DS_SHELLFONT style, the function
            also sends a WM_SETFONT message to the dialog box procedure. The function displays the dialog box (regardless of whether the
            template specifies the <c>WS_VISIBLE</c> style), disables the owner window, and starts its own message loop to retrieve and
            dispatch messages for the dialog box.
            </para>
            <para>
            When the dialog box procedure calls the EndDialog function, <c>DialogBoxIndirect</c> destroys the dialog box, ends the message
            loop, enables the owner window (if previously enabled), and returns the nResult parameter specified by the dialog box procedure
            when it called <c>EndDialog</c>.
            </para>
            <para>
            In a standard dialog box template, the DLGTEMPLATE structure and each of the DLGITEMTEMPLATE structures must be aligned on
            <c>DWORD</c> boundaries. The creation data array that follows a <c>DLGITEMTEMPLATE</c> structure must also be aligned on a
            <c>DWORD</c> boundary. All of the other variable-length arrays in the template must be aligned on <c>WORD</c> boundaries.
            </para>
            <para>
            In an extended dialog box template, the DLGTEMPLATEEX header and each of the DLGITEMTEMPLATEEX control definitions must be
            aligned on <c>DWORD</c> boundaries. The creation data array, if any, that follows a <c>DLGITEMTEMPLATEEX</c> structure must also
            be aligned on a <c>DWORD</c> boundary. All of the other variable-length arrays in the template must be aligned on <c>WORD</c> boundaries.
            </para>
            <para>
            All character strings in the dialog box template, such as titles for the dialog box and buttons, must be Unicode strings. Use the
            MultiByteToWideChar function to generate Unicode strings from ANSI strings.
            </para>
            <para>Examples</para>
            <para>For an example, see Creating a Template in Memory.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DialogBoxIndirectParam(Vanara.PInvoke.HINSTANCE,System.IntPtr,Vanara.PInvoke.HWND,Vanara.PInvoke.User32.DialogProc,System.IntPtr)">
            <summary>
            <para>
            Creates a modal dialog box from a dialog box template in memory. Before displaying the dialog box, the function passes an
            application-defined value to the dialog box procedure as the lParam parameter of the WM_INITDIALOG message. An application can
            use this value to initialize dialog box controls.
            </para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to the module that creates the dialog box.</para>
            </param>
            <param name="hDialogTemplate">
            <para>Type: <c>LPCDLGTEMPLATE</c></para>
            <para>
            The template that <c>DialogBoxIndirectParam</c> uses to create the dialog box. A dialog box template consists of a header that
            describes the dialog box, followed by one or more additional blocks of data that describe each of the controls in the dialog box.
            The template can use either the standard format or the extended format.
            </para>
            <para>
            In a standard template for a dialog box, the header is a DLGTEMPLATE structure followed by additional variable-length arrays. The
            data for each control consists of a DLGITEMTEMPLATE structure followed by additional variable-length arrays.
            </para>
            <para>
            In an extended template for a dialog box, the header uses the DLGTEMPLATEEX format and the control definitions use the
            DLGITEMTEMPLATEEX format.
            </para>
            </param>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that owns the dialog box.</para>
            </param>
            <param name="lpDialogFunc">
            <para>Type: <c>DLGPROC</c></para>
            <para>A pointer to the dialog box procedure. For more information about the dialog box procedure, see DialogProc.</para>
            </param>
            <param name="dwInitParam">
            <para>Type: <c>LPARAM</c></para>
            <para>The value to pass to the dialog box in the lParam parameter of the WM_INITDIALOG message.</para>
            </param>
            <returns>
            <para>Type: <c>INT_PTR</c></para>
            <para>
            If the function succeeds, the return value is the nResult parameter specified in the call to the EndDialog function that was used
            to terminate the dialog box.
            </para>
            <para>
            If the function fails because the hWndParent parameter is invalid, the return value is zero. The function returns zero in this
            case for compatibility with previous versions of Windows. If the function fails for any other reason, the return value is –1. To
            get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            The <c>DialogBoxIndirectParam</c> function uses the CreateWindowEx function to create the dialog box.
            <c>DialogBoxIndirectParam</c> then sends a WM_INITDIALOG message to the dialog box procedure. If the template specifies the
            DS_SETFONT or DS_SHELLFONT style, the function also sends a WM_SETFONT message to the dialog box procedure. The function displays
            the dialog box (regardless of whether the template specifies the <c>WS_VISIBLE</c> style), disables the owner window, and starts
            its own message loop to retrieve and dispatch messages for the dialog box.
            </para>
            <para>
            When the dialog box procedure calls the EndDialog function, <c>DialogBoxIndirectParam</c> destroys the dialog box, ends the
            message loop, enables the owner window (if previously enabled), and returns the nResult parameter specified by the dialog box
            procedure when it called <c>EndDialog</c>.
            </para>
            <para>
            In a standard dialog box template, the DLGTEMPLATE structure and each of the DLGITEMTEMPLATE structures must be aligned on
            <c>DWORD</c> boundaries. The creation data array that follows a <c>DLGITEMTEMPLATE</c> structure must also be aligned on a
            <c>DWORD</c> boundary. All of the other variable-length arrays in the template must be aligned on <c>WORD</c> boundaries.
            </para>
            <para>
            In an extended dialog box template, the DLGTEMPLATEEX header and each of the DLGITEMTEMPLATEEX control definitions must be
            aligned on <c>DWORD</c> boundaries. The creation data array, if any, that follows a <c>DLGITEMTEMPLATEEX</c> structure must also
            be aligned on a <c>DWORD</c> boundary. All of the other variable-length arrays in the template must be aligned on <c>WORD</c> boundaries.
            </para>
            <para>All character strings in the dialog box template, such as titles for the dialog box and buttons, must be Unicode strings.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DialogBoxParam(Vanara.PInvoke.HINSTANCE,System.String,Vanara.PInvoke.HWND,Vanara.PInvoke.User32.DialogProc,System.IntPtr)">
            <summary>
            <para>
            Creates a modal dialog box from a dialog box template resource. Before displaying the dialog box, the function passes an
            application-defined value to the dialog box procedure as the lParam parameter of the WM_INITDIALOG message. An application can
            use this value to initialize dialog box controls.
            </para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>
            A handle to the module which contains the dialog box template. If this parameter is NULL, then the current executable is used.
            </para>
            </param>
            <param name="lpTemplateName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of
            the dialog box template or an integer value that specifies the resource identifier of the dialog box template. If the parameter
            specifies a resource identifier, its high-order word must be zero and its low-order word must contain the identifier. You can use
            the MAKEINTRESOURCE macro to create this value.
            </para>
            </param>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that owns the dialog box.</para>
            </param>
            <param name="lpDialogFunc">
            <para>Type: <c>DLGPROC</c></para>
            <para>A pointer to the dialog box procedure. For more information about the dialog box procedure, see DialogProc.</para>
            </param>
            <param name="dwInitParam">
            <para>Type: <c>LPARAM</c></para>
            <para>The value to pass to the dialog box in the lParam parameter of the WM_INITDIALOG message.</para>
            </param>
            <returns>
            <para>Type: <c>INT_PTR</c></para>
            <para>
            If the function succeeds, the return value is the value of the nResult parameter specified in the call to the EndDialog function
            used to terminate the dialog box.
            </para>
            <para>
            If the function fails because the hWndParent parameter is invalid, the return value is zero. The function returns zero in this
            case for compatibility with previous versions of Windows. If the function fails for any other reason, the return value is –1. To
            get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            The <c>DialogBoxParam</c> function uses the CreateWindowEx function to create the dialog box. <c>DialogBoxParam</c> then sends a
            WM_INITDIALOG message (and a WM_SETFONT message if the template specifies the DS_SETFONT or DS_SHELLFONT style) to the dialog box
            procedure. The function displays the dialog box (regardless of whether the template specifies the <c>WS_VISIBLE</c> style),
            disables the owner window, and starts its own message loop to retrieve and dispatch messages for the dialog box.
            </para>
            <para>
            When the dialog box procedure calls the EndDialog function, <c>DialogBoxParam</c> destroys the dialog box, ends the message loop,
            enables the owner window (if previously enabled), and returns the nResult parameter specified by the dialog box procedure when it
            called <c>EndDialog</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DialogBoxParam(Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.ResourceId,Vanara.PInvoke.HWND,Vanara.PInvoke.User32.DialogProc,System.IntPtr)">
            <summary>
            <para>
            Creates a modal dialog box from a dialog box template resource. Before displaying the dialog box, the function passes an
            application-defined value to the dialog box procedure as the lParam parameter of the WM_INITDIALOG message. An application can
            use this value to initialize dialog box controls.
            </para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>
            A handle to the module which contains the dialog box template. If this parameter is NULL, then the current executable is used.
            </para>
            </param>
            <param name="lpTemplateName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of
            the dialog box template or an integer value that specifies the resource identifier of the dialog box template. If the parameter
            specifies a resource identifier, its high-order word must be zero and its low-order word must contain the identifier. You can use
            the MAKEINTRESOURCE macro to create this value.
            </para>
            </param>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that owns the dialog box.</para>
            </param>
            <param name="lpDialogFunc">
            <para>Type: <c>DLGPROC</c></para>
            <para>A pointer to the dialog box procedure. For more information about the dialog box procedure, see DialogProc.</para>
            </param>
            <param name="dwInitParam">
            <para>Type: <c>LPARAM</c></para>
            <para>The value to pass to the dialog box in the lParam parameter of the WM_INITDIALOG message.</para>
            </param>
            <returns>
            <para>Type: <c>INT_PTR</c></para>
            <para>
            If the function succeeds, the return value is the value of the nResult parameter specified in the call to the EndDialog function
            used to terminate the dialog box.
            </para>
            <para>
            If the function fails because the hWndParent parameter is invalid, the return value is zero. The function returns zero in this
            case for compatibility with previous versions of Windows. If the function fails for any other reason, the return value is –1. To
            get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            The <c>DialogBoxParam</c> function uses the CreateWindowEx function to create the dialog box. <c>DialogBoxParam</c> then sends a
            WM_INITDIALOG message (and a WM_SETFONT message if the template specifies the DS_SETFONT or DS_SHELLFONT style) to the dialog box
            procedure. The function displays the dialog box (regardless of whether the template specifies the <c>WS_VISIBLE</c> style),
            disables the owner window, and starts its own message loop to retrieve and dispatch messages for the dialog box.
            </para>
            <para>
            When the dialog box procedure calls the EndDialog function, <c>DialogBoxParam</c> destroys the dialog box, ends the message loop,
            enables the owner window (if previously enabled), and returns the nResult parameter specified by the dialog box procedure when it
            called <c>EndDialog</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DlgDirSelectComboBoxEx(Vanara.PInvoke.HWND,System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Retrieves the current selection from a combo box filled by using the DlgDirListComboBox function. The selection is interpreted as
            a drive letter, a file, or a directory name.
            </summary>
            <param name="hwndDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box that contains the combo box.</para>
            </param>
            <param name="lpString">
            <para>Type: <c>LPTSTR</c></para>
            <para>A pointer to the buffer that receives the selected path.</para>
            </param>
            <param name="cchOut">
            <para>Type: <c>int</c></para>
            <para>The length, in characters, of the buffer pointed to by the lpString parameter.</para>
            </param>
            <param name="idComboBox">
            <para>Type: <c>int</c></para>
            <para>The integer identifier of the combo box control in the dialog box.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the current selection is a directory name, the return value is nonzero.</para>
            <para>If the current selection is not a directory name, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the current selection specifies a directory name or drive letter, the <c>DlgDirSelectComboBoxEx</c> function removes the
            enclosing square brackets (and hyphens for drive letters) so the name or letter is ready to be inserted into a new path or file
            name. If there is no selection, the contents of the buffer pointed to by lpString do not change.
            </para>
            <para>The <c>DlgDirSelectComboBoxEx</c> function does not allow more than one file name to be returned from a combo box.</para>
            <para>If the string is as long or longer than the buffer, the buffer contains the truncated string with a terminating null character.</para>
            <para><c>DlgDirSelectComboBoxEx</c> sends CB_GETCURSEL and CB_GETLBTEXT messages to the combo box.</para>
            <para>You can use this function with all three types of combo boxes (CBS_SIMPLE, CBS_DROPDOWN, and CBS_DROPDOWNLIST).</para>
            <para>
            <c>Security Warning:</c> Improper use of this function can cause problems for your application. For instance, the nCount
            parameter should be set properly for both ANSI and Unicode versions. Failure to do so could lead to a buffer overflow. You should
            review Security Considerations: Microsoft Windows Controls before continuing.
            </para>
            <para>
            <c>Windows 95 or later</c>: <c>DlgDirSelectComboBoxExW</c> is supported by the Microsoft Layer for Unicode (MSLU). To use this,
            you must add certain files to your application, as outlined in Microsoft Layer for Unicode on Windows Me/98/95 Systems.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EndDialog(Vanara.PInvoke.HWND,System.IntPtr)">
            <summary>
            <para>Destroys a modal dialog box, causing the system to end any processing for the dialog box.</para>
            </summary>
            <param name="hDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box to be destroyed.</para>
            </param>
            <param name="nResult">
            <para>Type: <c>INT_PTR</c></para>
            <para>The value to be returned to the application from the function that created the dialog box.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Dialog boxes created by the DialogBox, DialogBoxParam, DialogBoxIndirect, and DialogBoxIndirectParam functions must be destroyed
            using the <c>EndDialog</c> function. An application calls <c>EndDialog</c> from within the dialog box procedure; the function
            must not be used for any other purpose.
            </para>
            <para>
            A dialog box procedure can call <c>EndDialog</c> at any time, even during the processing of the WM_INITDIALOG message. If your
            application calls the function while <c>WM_INITDIALOG</c> is being processed, the dialog box is destroyed before it is shown and
            before the input focus is set.
            </para>
            <para>
            <c>EndDialog</c> does not destroy the dialog box immediately. Instead, it sets a flag and allows the dialog box procedure to
            return control to the system. The system checks the flag before attempting to retrieve the next message from the application
            queue. If the flag is set, the system ends the message loop, destroys the dialog box, and uses the value in nResult as the return
            value from the function that created the dialog box.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetDialogBaseUnits">
            <summary>
            <para>
            Retrieves the system's dialog base units, which are the average width and height of characters in the system font. For dialog
            boxes that use the system font, you can use these values to convert between dialog template units, as specified in dialog box
            templates, and pixels. For dialog boxes that do not use the system font, the conversion from dialog template units to pixels
            depends on the font used by the dialog box.
            </para>
            <para>
            For either type of dialog box, it is easier to use the MapDialogRect function to perform the conversion. <c>MapDialogRect</c>
            takes the font into account and correctly converts a rectangle from dialog template units into pixels.
            </para>
            </summary>
            <returns>
            <para>Type: <c>LONG</c></para>
            <para>
            The function returns the dialog base units. The low-order word of the return value contains the horizontal dialog box base unit,
            and the high-order word contains the vertical dialog box base unit.
            </para>
            </returns>
            <remarks>
            <para>
            The horizontal base unit returned by <c>GetDialogBaseUnits</c> is equal to the average width, in pixels, of the characters in the
            system font; the vertical base unit is equal to the height, in pixels, of the font.
            </para>
            <para>
            The system font is used only if the dialog box template fails to specify a font. Most dialog box templates specify a font; as a
            result, this function is not useful for most dialog boxes.
            </para>
            <para>
            For a dialog box that does not use the system font, the base units are the average width and height, in pixels, of the characters
            in the dialog's font. You can use the GetTextMetrics and GetTextExtentPoint32 functions to calculate these values for a selected
            font. However, by using the MapDialogRect function, you can avoid errors that might result if your calculations differ from those
            performed by the system.
            </para>
            <para>
            Each horizontal base unit is equal to 4 horizontal dialog template units; each vertical base unit is equal to 8 vertical dialog
            template units. Therefore, to convert dialog template units to pixels, use the following formulas:
            </para>
            <para>Similarly, to convert from pixels to dialog template units, use the following formulas:</para>
            <para>Examples</para>
            <para>For an example, see "Creating a Combo Box Toolbar" in Using Combo Boxes.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetDlgCtrlID(Vanara.PInvoke.HWND)">
            <summary>
            <para>Retrieves the identifier of the specified control.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the control.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>If the function succeeds, the return value is the identifier of the control.</para>
            <para>
            If the function fails, the return value is zero. An invalid value for the hwndCtl parameter, for example, will cause the function
            to fail. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            <c>GetDlgCtrlID</c> accepts child window handles as well as handles of controls in dialog boxes. An application sets the
            identifier for a child window when it creates the window by assigning the identifier value to the hmenu parameter when calling
            the CreateWindow or CreateWindowEx function.
            </para>
            <para>
            Although <c>GetDlgCtrlID</c> may return a value if hwndCtl is a handle to a top-level window, top-level windows cannot have
            identifiers and such a return value is never valid.
            </para>
            <para>Examples</para>
            <para>For an example, see Initializing a Dialog Box.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetDlgItem(Vanara.PInvoke.HWND,System.Int32)">
            <summary>
            <para>Retrieves a handle to a control in the specified dialog box.</para>
            </summary>
            <param name="hDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box that contains the control.</para>
            </param>
            <param name="nIDDlgItem">
            <para>Type: <c>int</c></para>
            <para>The identifier of the control to be retrieved.</para>
            </param>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>If the function succeeds, the return value is the window handle of the specified control.</para>
            <para>
            If the function fails, the return value is <c>NULL</c>, indicating an invalid dialog box handle or a nonexistent control. To get
            extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            You can use the <c>GetDlgItem</c> function with any parent-child window pair, not just with dialog boxes. As long as the hDlg
            parameter specifies a parent window and the child window has a unique identifier (as specified by the hMenu parameter in the
            CreateWindow or CreateWindowEx function that created the child window), <c>GetDlgItem</c> returns a valid handle to the child window.
            </para>
            <para>Examples</para>
            <para>For an example, see Initializing a Dialog Box.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetDlgItemInt(Vanara.PInvoke.HWND,System.Int32,System.Boolean@,System.Boolean)">
            <summary>
            <para>Translates the text of a specified control in a dialog box into an integer value.</para>
            </summary>
            <param name="hDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box that contains the control of interest.</para>
            </param>
            <param name="nIDDlgItem">
            <para>Type: <c>int</c></para>
            <para>The identifier of the control whose text is to be translated.</para>
            </param>
            <param name="lpTranslated">
            <para>Type: <c>BOOL*</c></para>
            <para>Indicates success or failure ( <c>TRUE</c> indicates success, <c>FALSE</c> indicates failure).</para>
            <para>If this parameter is <c>NULL</c>, the function returns no information about success or failure.</para>
            </param>
            <param name="bSigned">
            <para>Type: <c>BOOL</c></para>
            <para>
            Indicates whether the function should examine the text for a minus sign at the beginning and return a signed integer value if it
            finds one ( <c>TRUE</c> specifies this should be done, <c>FALSE</c> that it should not).
            </para>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>
            If the function succeeds, the variable pointed to by lpTranslated is set to <c>TRUE</c>, and the return value is the translated
            value of the control text.
            </para>
            <para>
            If the function fails, the variable pointed to by lpTranslated is set to <c>FALSE</c>, and the return value is zero. Note that,
            because zero is a possible translated value, a return value of zero does not by itself indicate failure.
            </para>
            <para>If lpTranslated is <c>NULL</c>, the function returns no information about success or failure.</para>
            <para>
            Note that, if the bSigned parameter is <c>TRUE</c> and there is a minus sign (–) at the beginning of the text,
            <c>GetDlgItemInt</c> translates the text into a signed integer value. Otherwise, the function creates an unsigned integer value.
            To obtain the proper value in this case, cast the return value to an <c>int</c> type.
            </para>
            <para>To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>GetDlgItemInt</c> function retrieves the text of the specified control by sending the control a WM_GETTEXT message. The
            function translates the retrieved text by stripping any extra spaces at the beginning of the text and then converting the decimal
            digits. The function stops translating when it reaches the end of the text or encounters a nonnumeric character.
            </para>
            <para>
            The <c>GetDlgItemInt</c> function returns zero if the translated value is greater than <c>INT_MAX</c> (for signed numbers) or
            <c>UINT_MAX</c> (for unsigned numbers).
            </para>
            <para>Examples</para>
            <para>For an example, see Creating a Modeless Dialog Box.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetDlgItemText(Vanara.PInvoke.HWND,System.Int32,System.Text.StringBuilder,System.Int32)">
            <summary>
            <para>Retrieves the title or text associated with a control in a dialog box.</para>
            </summary>
            <param name="hDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box that contains the control.</para>
            </param>
            <param name="nIDDlgItem">
            <para>Type: <c>int</c></para>
            <para>The identifier of the control whose title or text is to be retrieved.</para>
            </param>
            <param name="lpString">
            <para>Type: <c>LPTSTR</c></para>
            <para>The buffer to receive the title or text.</para>
            </param>
            <param name="cchMax">
            <para>Type: <c>int</c></para>
            <para>
            The maximum length, in characters, of the string to be copied to the buffer pointed to by lpString. If the length of the string,
            including the null character, exceeds the limit, the string is truncated.
            </para>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>
            If the function succeeds, the return value specifies the number of characters copied to the buffer, not including the terminating
            null character.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the string is as long or longer than the buffer, the buffer will contain the truncated string with a terminating null character.
            </para>
            <para>The <c>GetDlgItemText</c> function sends a WM_GETTEXT message to the control.</para>
            <para>Examples</para>
            <para>For an example, see Creating a Modal Dialog Box.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetNextDlgGroupItem(Vanara.PInvoke.HWND,Vanara.PInvoke.HWND,System.Boolean)">
            <summary>
            <para>
            Retrieves a handle to the first control in a group of controls that precedes (or follows) the specified control in a dialog box.
            </para>
            </summary>
            <param name="hDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box to be searched.</para>
            </param>
            <param name="hCtl">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the control to be used as the starting point for the search. If this parameter is <c>NULL</c>, the function uses the
            last (or first) control in the dialog box as the starting point for the search.
            </para>
            </param>
            <param name="bPrevious">
            <para>Type: <c>BOOL</c></para>
            <para>
            Indicates how the function is to search the group of controls in the dialog box. If this parameter is <c>TRUE</c>, the function
            searches for the previous control in the group. If it is <c>FALSE</c>, the function searches for the next control in the group.
            </para>
            </param>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>If the function succeeds, the return value is a handle to the previous (or next) control in the group of controls.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>GetNextDlgGroupItem</c> function searches controls in the order (or reverse order) they were created in the dialog box
            template. The first control in the group must have the WS_GROUP style; all other controls in the group must have been
            consecutively created and must not have the <c>WS_GROUP</c> style.
            </para>
            <para>
            When searching for the previous control, the function returns the first control it locates that is visible and not disabled. If
            the control specified by hCtl has the <c>WS_GROUP</c> style, the function temporarily reverses the search to locate the first
            control having the <c>WS_GROUP</c> style, then resumes the search in the original direction, returning the first control it
            locates that is visible and not disabled, or returning hCtl if no such control is found.
            </para>
            <para>
            When searching for the next control, the function returns the first control it locates that is visible, not disabled, and does
            not have the <c>WS_GROUP</c> style. If it encounters a control having the <c>WS_GROUP</c> style, the function reverses the
            search, locates the first control having the <c>WS_GROUP</c> style, and returns this control if it is visible and not disabled.
            Otherwise, the function resumes the search in the original direction and returns the first control it locates that is visible and
            not disabled, or returns hCtl if no such control is found.
            </para>
            <para>
            If the search for the next control in the group encounters a window with the <c>WS_EX_CONTROLPARENT</c> style, the system
            recursively searches the window's children.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetNextDlgTabItem(Vanara.PInvoke.HWND,Vanara.PInvoke.HWND,System.Boolean)">
            <summary>
            <para>Retrieves a handle to the first control that has the WS_TABSTOP style that precedes (or follows) the specified control.</para>
            </summary>
            <param name="hDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box to be searched.</para>
            </param>
            <param name="hCtl">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the control to be used as the starting point for the search. If this parameter is <c>NULL</c>, the function fails.
            </para>
            </param>
            <param name="bPrevious">
            <para>Type: <c>BOOL</c></para>
            <para>
            Indicates how the function is to search the dialog box. If this parameter is <c>TRUE</c>, the function searches for the previous
            control in the dialog box. If this parameter is <c>FALSE</c>, the function searches for the next control in the dialog box.
            </para>
            </param>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>
            If the function succeeds, the return value is the window handle of the previous (or next) control that has the WS_TABSTOP style set.
            </para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>GetNextDlgTabItem</c> function searches controls in the order (or reverse order) they were created in the dialog box
            template. The function returns the first control it locates that is visible, not disabled, and has the WS_TABSTOP style. If no
            such control exists, the function returns hCtl.
            </para>
            <para>
            If the search for the next control with the <c>WS_TABSTOP</c> style encounters a window with the <c>WS_EX_CONTROLPARENT</c>
            style, the system recursively searches the window's children.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsDialogMessage(Vanara.PInvoke.HWND,Vanara.PInvoke.MSG@)">
            <summary>
            <para>Determines whether a message is intended for the specified dialog box and, if it is, processes the message.</para>
            </summary>
            <param name="hDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box.</para>
            </param>
            <param name="lpMsg">
            <para>Type: <c>LPMSG</c></para>
            <para>A pointer to an MSG structure that contains the message to be checked.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the message has been processed, the return value is nonzero.</para>
            <para>If the message has not been processed, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            Although the <c>IsDialogMessage</c> function is intended for modeless dialog boxes, you can use it with any window that contains
            controls, enabling the windows to provide the same keyboard selection as is used in a dialog box.
            </para>
            <para>
            When <c>IsDialogMessage</c> processes a message, it checks for keyboard messages and converts them into selections for the
            corresponding dialog box. For example, the TAB key, when pressed, selects the next control or group of controls, and the DOWN
            ARROW key, when pressed, selects the next control in a group.
            </para>
            <para>
            Because the <c>IsDialogMessage</c> function performs all necessary translating and dispatching of messages, a message processed
            by <c>IsDialogMessage</c> must not be passed to the TranslateMessage or DispatchMessage function.
            </para>
            <para><c>IsDialogMessage</c> sends WM_GETDLGCODE messages to the dialog box procedure to determine which keys should be processed.</para>
            <para>
            <c>IsDialogMessage</c> can send DM_GETDEFID and DM_SETDEFID messages to the window. These messages are defined in the Winuser.h
            header file as WM_USER and <c>WM_USER</c> + 1, so conflicts are possible with application-defined messages having the same values.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.MapDialogRect(Vanara.PInvoke.HWND,Vanara.PInvoke.RECT@)">
            <summary>
            <para>
            Converts the specified dialog box units to screen units (pixels). The function replaces the coordinates in the specified RECT
            structure with the converted coordinates, which allows the structure to be used to create a dialog box or position a control
            within a dialog box.
            </para>
            </summary>
            <param name="hDlg">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to a dialog box. This function accepts only handles returned by one of the dialog box creation functions; handles for
            other windows are not valid.
            </para>
            </param>
            <param name="lpRect">
            <para>Type: <c>LPRECT</c></para>
            <para>A pointer to a RECT structure that contains the dialog box coordinates to be converted.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>MapDialogRect</c> function assumes that the initial coordinates in the RECT structure represent dialog box units. To
            convert these coordinates from dialog box units to pixels, the function retrieves the current horizontal and vertical base units
            for the dialog box, then applies the following formulas:
            </para>
            <para>
            If the dialog box template has the DS_SETFONT or <c>DS_SHELLFONT</c> style, the base units are the average width and height, in
            pixels, of the characters in the font specified by the template.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendDlgItemMessage(Vanara.PInvoke.HWND,System.Int32,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            <para>Sends a message to the specified control in a dialog box.</para>
            </summary>
            <param name="hDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box that contains the control.</para>
            </param>
            <param name="nIDDlgItem">
            <para>Type: <c>int</c></para>
            <para>The identifier of the control that receives the message.</para>
            </param>
            <param name="Msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing and depends on the message sent.</para>
            </returns>
            <remarks>
            <para>The <c>SendDlgItemMessage</c> function does not return until the message has been processed.</para>
            <para>
            Using <c>SendDlgItemMessage</c> is identical to retrieving a handle to the specified control and calling the SendMessage function.
            </para>
            <para>Examples</para>
            <para>For an example, see Creating a Modeless Dialog Box.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetDlgItemInt(Vanara.PInvoke.HWND,System.Int32,System.UInt32,System.Boolean)">
            <summary>
            <para>Sets the text of a control in a dialog box to the string representation of a specified integer value.</para>
            </summary>
            <param name="hDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box that contains the control.</para>
            </param>
            <param name="nIDDlgItem">
            <para>Type: <c>int</c></para>
            <para>The control to be changed.</para>
            </param>
            <param name="uValue">
            <para>Type: <c>UINT</c></para>
            <para>The integer value used to generate the item text.</para>
            </param>
            <param name="bSigned">
            <para>Type: <c>BOOL</c></para>
            <para>
            Indicates whether the uValue parameter is signed or unsigned. If this parameter is <c>TRUE</c>, uValue is signed. If this
            parameter is <c>TRUE</c> and uValue is less than zero, a minus sign is placed before the first digit in the string. If this
            parameter is <c>FALSE</c>, uValue is unsigned.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>To set the new text, this function sends a WM_SETTEXT message to the specified control.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetDlgItemText(Vanara.PInvoke.HWND,System.Int32,System.String)">
            <summary>
            <para>Sets the title or text of a control in a dialog box.</para>
            </summary>
            <param name="hDlg">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the dialog box that contains the control.</para>
            </param>
            <param name="nIDDlgItem">
            <para>Type: <c>int</c></para>
            <para>The control with a title or text to be set.</para>
            </param>
            <param name="lpString">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The text to be copied to the control.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>The <c>SetDlgItemText</c> function sends a WM_SETTEXT message to the specified control.</para>
            <para>Examples</para>
            <para>For an example, see Using List Boxes.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.DLGITEMTEMPLATE">
            <summary>
            <para>
            Defines the dimensions and style of a control in a dialog box. One or more of these structures are combined with a DLGTEMPLATE
            structure to form a standard template for a dialog box.
            </para>
            </summary>
            <remarks>
            <para>
            In a standard template for a dialog box, the <c>DLGITEMTEMPLATE</c> structure is always immediately followed by three
            variable-length arrays specifying the class, title, and creation data for the control. Each array consists of one or more 16-bit elements.
            </para>
            <para>
            Each <c>DLGITEMTEMPLATE</c> structure in the template must be aligned on a <c>DWORD</c> boundary. The class and title arrays must
            be aligned on <c>WORD</c> boundaries. The creation data array must be aligned on a <c>WORD</c> boundary.
            </para>
            <para>
            Immediately following each <c>DLGITEMTEMPLATE</c> structure is a class array that specifies the window class of the control. If
            the first element of this array is any value other than 0xFFFF, the system treats the array as a null-terminated Unicode string
            that specifies the name of a registered window class. If the first element is 0xFFFF, the array has one additional element that
            specifies the ordinal value of a predefined system class. The ordinal can be one of the following atom values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0x0080</term>
            <term>Button</term>
            </item>
            <item>
            <term>0x0081</term>
            <term>Edit</term>
            </item>
            <item>
            <term>0x0082</term>
            <term>Static</term>
            </item>
            <item>
            <term>0x0083</term>
            <term>List box</term>
            </item>
            <item>
            <term>0x0084</term>
            <term>Scroll bar</term>
            </item>
            <item>
            <term>0x0085</term>
            <term>Combo box</term>
            </item>
            </list>
            <para>
            Following the class array is a title array that contains the initial text or resource identifier of the control. If the first
            element of this array is 0xFFFF, the array has one additional element that specifies an ordinal value of a resource, such as an
            icon, in an executable file. You can use a resource identifier for controls, such as static icon controls, that load and display
            an icon or other resource rather than text. If the first element is any value other than 0xFFFF, the system treats the array as a
            null-terminated Unicode string that specifies the initial text.
            </para>
            <para>
            The creation data array begins at the next <c>WORD</c> boundary after the title array. This creation data can be of any size and
            format. If the first word of the creation data array is nonzero, it indicates the size, in bytes, of the creation data (including
            the size word). The control's window procedure must be able to interpret the data. When the system creates the control, it passes
            a pointer to this data in the lParam parameter of the WM_CREATE message that it sends to the control.
            </para>
            <para>
            If you specify character strings in the class and title arrays, you must use Unicode strings. Use the MultiByteToWideChar
            function to generate Unicode strings from ANSI strings.
            </para>
            <para>
            The <c>x</c>, <c>y</c>, <c>cx</c>, and <c>cy</c> members specify values in dialog box units. You can convert these values to
            screen units (pixels) by using the MapDialogRect function.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.DLGITEMTEMPLATE.style">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            The style of the control. This member can be a combination of window style values (such as <c>WS_BORDER</c>) and one or more
            of the control style values (such as <c>BS_PUSHBUTTON</c> and <c>ES_LEFT</c>).
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DLGITEMTEMPLATE.dwExtendedStyle">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            The extended styles for a window. This member is not used to create controls in dialog boxes, but applications that use
            dialog box templates can use it to create other types of windows. For a list of values, see Extended Window Styles.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DLGITEMTEMPLATE.x">
            <summary>
            <para>Type: <c>short</c></para>
            <para>
            The x-coordinate, in dialog box units, of the upper-left corner of the control. This coordinate is always relative to the
            upper-left corner of the dialog box's client area.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DLGITEMTEMPLATE.y">
            <summary>
            <para>Type: <c>short</c></para>
            <para>
            The y-coordinate, in dialog box units, of the upper-left corner of the control. This coordinate is always relative to the
            upper-left corner of the dialog box's client area.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DLGITEMTEMPLATE.cx">
            <summary>
            <para>Type: <c>short</c></para>
            <para>The width, in dialog box units, of the control.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DLGITEMTEMPLATE.cy">
            <summary>
            <para>Type: <c>short</c></para>
            <para>The height, in dialog box units, of the control.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DLGITEMTEMPLATE.id">
            <summary>
            <para>Type: <c>WORD</c></para>
            <para>The control identifier.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DLGTEMPLATE">
            <summary>
            <para>
            Defines the dimensions and style of a dialog box. This structure, always the first in a standard template for a dialog box, also
            specifies the number of controls in the dialog box and therefore specifies the number of subsequent DLGITEMTEMPLATE structures in
            the template.
            </para>
            </summary>
            <remarks>
            <para>
            In a standard template for a dialog box, the <c>DLGTEMPLATE</c> structure is always immediately followed by three variable-length
            arrays that specify the menu, class, and title for the dialog box. When the DS_SETFONT style is specified, these arrays are also
            followed by a 16-bit value specifying point size and another variable-length array specifying a typeface name. Each array
            consists of one or more 16-bit elements. The menu, class, title, and font arrays must be aligned on <c>WORD</c> boundaries.
            </para>
            <para>
            Immediately following the <c>DLGTEMPLATE</c> structure is a menu array that identifies a menu resource for the dialog box. If the
            first element of this array is 0x0000, the dialog box has no menu and the array has no other elements. If the first element is
            0xFFFF, the array has one additional element that specifies the ordinal value of a menu resource in an executable file. If the
            first element has any other value, the system treats the array as a null-terminated Unicode string that specifies the name of a
            menu resource in an executable file.
            </para>
            <para>
            Following the menu array is a class array that identifies the window class of the control. If the first element of the array is
            0x0000, the system uses the predefined dialog box class for the dialog box and the array has no other elements. If the first
            element is 0xFFFF, the array has one additional element that specifies the ordinal value of a predefined system window class. If
            the first element has any other value, the system treats the array as a null-terminated Unicode string that specifies the name of
            a registered window class.
            </para>
            <para>
            Following the class array is a title array that specifies a null-terminated Unicode string that contains the title of the dialog
            box. If the first element of this array is 0x0000, the dialog box has no title and the array has no other elements.
            </para>
            <para>
            The 16-bit point size value and the typeface array follow the title array, but only if the <c>style</c> member specifies the
            DS_SETFONT style. The point size value specifies the point size of the font to use for the text in the dialog box and its
            controls. The typeface array is a null-terminated Unicode string specifying the name of the typeface for the font. When these
            values are specified, the system creates a font having the specified size and typeface (if possible) and sends a WM_SETFONT
            message to the dialog box procedure and the control window procedures as it creates the dialog box and controls.
            </para>
            <para>
            Following the <c>DLGTEMPLATE</c> header in a standard dialog box template are one or more DLGITEMTEMPLATE structures that define
            the dimensions and style of the controls in the dialog box. The <c>cdit</c> member specifies the number of <c>DLGITEMTEMPLATE</c>
            structures in the template. These <c>DLGITEMTEMPLATE</c> structures must be aligned on <c>DWORD</c> boundaries.
            </para>
            <para>If you specify character strings in the menu, class, title, or typeface arrays, you must use Unicode strings.</para>
            <para>
            The <c>x</c>, <c>y</c>, <c>cx</c>, and <c>cy</c> members specify values in dialog box units. You can convert these values to
            screen units (pixels) by using the MapDialogRect function.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.DLGTEMPLATE.style">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            The style of the dialog box. This member can be a combination of window style values (such as <c>WS_CAPTION</c> and
            <c>WS_SYSMENU</c>) and dialog box style values (such as <c>DS_CENTER</c>).
            </para>
            <para>
            If the style member includes the <c>DS_SETFONT</c> style, the header of the dialog box template contains additional data
            specifying the font to use for text in the client area and controls of the dialog box. The font data begins on the
            <c>WORD</c> boundary that follows the title array. The font data specifies a 16-bit point size value and a Unicode font name
            string. If possible, the system creates a font according to the specified values. Then the system sends a WM_SETFONT message
            to the dialog box and to each control to provide a handle to the font. If <c>DS_SETFONT</c> is not specified, the dialog box
            template does not include the font data.
            </para>
            <para>The <c>DS_SHELLFONT</c> style is not supported in the <c>DLGTEMPLATE</c> header.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DLGTEMPLATE.dwExtendedStyle">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            The extended styles for a window. This member is not used to create dialog boxes, but applications that use dialog box
            templates can use it to create other types of windows. For a list of values, see Extended Window Styles.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DLGTEMPLATE.cdit">
            <summary>
            <para>Type: <c>WORD</c></para>
            <para>The number of items in the dialog box.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DLGTEMPLATE.x">
            <summary>
            <para>Type: <c>short</c></para>
            <para>The x-coordinate, in dialog box units, of the upper-left corner of the dialog box.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DLGTEMPLATE.y">
            <summary>
            <para>Type: <c>short</c></para>
            <para>The y-coordinate, in dialog box units, of the upper-left corner of the dialog box.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DLGTEMPLATE.cx">
            <summary>
            <para>Type: <c>short</c></para>
            <para>The width, in dialog box units, of the dialog box.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DLGTEMPLATE.cy">
            <summary>
            <para>Type: <c>short</c></para>
            <para>The height, in dialog box units, of the dialog box.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.QDC">
            <summary>The type of information to retrieve.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QDC.QDC_ALL_PATHS">
            <summary>The caller requests the table sizes to hold all the possible path combinations.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QDC.QDC_ONLY_ACTIVE_PATHS">
            <summary>The caller requests the table sizes to hold only active paths.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QDC.QDC_DATABASE_CURRENT">
            <summary>
            The caller requests the table sizes to hold the active paths as defined in the persistence database for the currently
            connected monitors.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QDC.QDC_VIRTUAL_MODE_AWARE">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QDC.QDC_INCLUDE_HMD">
            <summary>Undocumented.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SDC">
            <summary>Flag values that indicates the behavior of SetDisplayConfig.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SDC.SDC_TOPOLOGY_INTERNAL">
            <summary>The caller requests the last internal configuration from the persistence database.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SDC.SDC_TOPOLOGY_CLONE">
            <summary>The caller requests the last clone configuration from the persistence database.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SDC.SDC_TOPOLOGY_EXTEND">
            <summary>The caller requests the last extended configuration from the persistence database.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SDC.SDC_TOPOLOGY_EXTERNAL">
            <summary>The caller requests the last external configuration from the persistence database.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SDC.SDC_TOPOLOGY_SUPPLIED">
            <summary>
            The caller provides the path data so the function only queries the persistence database to find and use the source and target mode.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SDC.SDC_USE_DATABASE_CURRENT">
            <summary>
            The caller requests a combination of all four SDC_TOPOLOGY_XXX configurations. This value informs the API to set the last
            known display configuration for the current connected monitors.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SDC.SDC_USE_SUPPLIED_DISPLAY_CONFIG">
            <summary>
            The topology, source, and target mode information that are supplied in the pathArray and the modeInfoArray parameters are
            used, rather than looking up the configuration in the database.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SDC.SDC_VALIDATE">
            <summary>
            The system tests for the requested topology, source, and target mode information to determine whether it can be set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SDC.SDC_APPLY">
            <summary>The resulting topology, source, and target mode is set.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SDC.SDC_NO_OPTIMIZATION">
            <summary>
            A modifier to the SDC_APPLY flag. This causes the change mode to be forced all the way down to the driver for each active display.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SDC.SDC_SAVE_TO_DATABASE">
            <summary>The resulting topology, source, and target mode are saved to the database.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SDC.SDC_ALLOW_CHANGES">
            <summary>
            If required, the function can modify the specified source and target mode information in order to create a functional display
            path set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SDC.SDC_PATH_PERSIST_IF_REQUIRED">
            <summary>
            When the function processes a SDC_TOPOLOGY_XXX request, it can force path persistence on a target to satisfy the request if
            necessary. For information about the other flags that this flag can be combined with, see the following list.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SDC.SDC_FORCE_MODE_ENUMERATION">
            <summary>
            The caller requests that the driver is given an opportunity to update the GDI mode list while SetDisplayConfig sets the new
            display configuration. This flag value is only valid when the SDC_USE_SUPPLIED_DISPLAY_CONFIG and SDC_APPLY flag values are
            also specified.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SDC.SDC_ALLOW_PATH_ORDER_CHANGES">
            <summary>
            A modifier to the SDC_TOPOLOGY_SUPPLIED flag that indicates that SetDisplayConfig should ignore the path order of the
            supplied topology when searching the database. When this flag is set, the topology set is the most recent topology that
            contains all the paths regardless of the path order.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SDC.SDC_VIRTUAL_MODE_AWARE">
            <summary>Undocumented.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.DisplayConfigGetDeviceInfo(System.IntPtr)">
            <summary>The <c>DisplayConfigGetDeviceInfo</c> function retrieves display configuration information about the device.</summary>
            <param name="requestPacket">
            A pointer to a DISPLAYCONFIG_DEVICE_INFO_HEADER structure. This structure contains information about the request, which includes
            the packet type in the <c>type</c> member. The type and size of additional data that <c>DisplayConfigGetDeviceInfo</c> returns
            after the header structure depend on the packet type.
            </param>
            <returns>
            <para>The function returns one of the following return codes.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ERROR_SUCCESS</term>
            <term>The function succeeded.</term>
            </item>
            <item>
            <term>ERROR_INVALID_PARAMETER</term>
            <term>The combination of parameters and flags specified are invalid.</term>
            </item>
            <item>
            <term>ERROR_NOT_SUPPORTED</term>
            <term>
            The system is not running a graphics driver that was written according to the Windows Display Driver Model (WDDM). The function
            is only supported on a system with a WDDM driver running.
            </term>
            </item>
            <item>
            <term>ERROR_ACCESS_DENIED</term>
            <term>
            The caller does not have access to the console session. This error occurs if the calling process does not have access to the
            current desktop or is running on a remote session.
            </term>
            </item>
            <item>
            <term>ERROR_INSUFFICIENT_BUFFER</term>
            <term>The size of the packet that the caller passes is not big enough for the information that the caller requests.</term>
            </item>
            <item>
            <term>ERROR_GEN_FAILURE</term>
            <term>An unspecified error occurred.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Use the <c>DisplayConfigGetDeviceInfo</c> function to obtain additional information about a source or target for an adapter, such
            as the display name, the preferred display mode, and source device name.
            </para>
            <para>
            The caller can call <c>DisplayConfigGetDeviceInfo</c> to obtain more friendly names to display in the user interface. The caller
            can obtain names for the adapter, the source, and the target. The caller can also call <c>DisplayConfigGetDeviceInfo</c> to
            obtain the best resolution of the connected display device.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DisplayConfigGetDeviceInfo``1(System.UInt64,System.UInt32,Vanara.PInvoke.Gdi32.DISPLAYCONFIG_DEVICE_INFO_TYPE)">
            <summary>The <c>DisplayConfigGetDeviceInfo</c> function retrieves display configuration information about the device.</summary>
            <typeparam name="T">The type of structure to return. This must match the type supported by <paramref name="type"/>.</typeparam>
            <param name="adapterId">
            A locally unique identifier (LUID) that identifies the adapter that the device information packet refers to.
            </param>
            <param name="id">
            The source or target identifier to get or set the device information for. The meaning of this identifier is related to the type
            of information being requested. For example, in the case of DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME, this is the source identifier.
            </param>
            <param name="type">
            A DISPLAYCONFIG_DEVICE_INFO_TYPE enumerated value that determines the type of device information to retrieve or set. The
            remainder of the packet for the retrieve or set operation follows immediately after the DISPLAYCONFIG_DEVICE_INFO_HEADER
            structure. Leave this value as the default (0) to have the value inferred from <typeparamref name="T"/>.
            </param>
            <returns>The value of type <typeparamref name="T"/> for the information provided.</returns>
            <exception cref="T:System.ArgumentException">Request type does not match type param value.</exception>
        </member>
        <member name="M:Vanara.PInvoke.User32.DisplayConfigSetDeviceInfo(System.IntPtr)">
            <summary>The <c>DisplayConfigSetDeviceInfo</c> function sets the properties of a target.</summary>
            <param name="setPacket">
            A pointer to a DISPLAYCONFIG_DEVICE_INFO_HEADER structure that contains information to set for the device. The type and size of
            additional data that <c>DisplayConfigSetDeviceInfo</c> uses for the configuration comes after the header structure. This
            additional data depends on the packet type, as specified by the <c>type</c> member of DISPLAYCONFIG_DEVICE_INFO_HEADER. For
            example, if the caller wants to change the boot persistence, that caller allocates and fills a
            DISPLAYCONFIG_SET_TARGET_PERSISTENCE structure and passes a pointer to this structure in setPacket. Note that the first member of
            the DISPLAYCONFIG_SET_TARGET_PERSISTENCE structure is the DISPLAYCONFIG_DEVICE_INFO_HEADER.
            </param>
            <returns>
            <para>The function returns one of the following return codes.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ERROR_SUCCESS</term>
            <term>The function succeeded.</term>
            </item>
            <item>
            <term>ERROR_INVALID_PARAMETER</term>
            <term>The combination of parameters and flags specified are invalid.</term>
            </item>
            <item>
            <term>ERROR_NOT_SUPPORTED</term>
            <term>
            The system is not running a graphics driver that was written according to the Windows Display Driver Model (WDDM). The function
            is only supported on a system with a WDDM driver running.
            </term>
            </item>
            <item>
            <term>ERROR_ACCESS_DENIED</term>
            <term>
            The caller does not have access to the console session. This error occurs if the calling process does not have access to the
            current desktop or is running on a remote session.
            </term>
            </item>
            <item>
            <term>ERROR_INSUFFICIENT_BUFFER</term>
            <term>The size of the packet that the caller passes is not big enough.</term>
            </item>
            <item>
            <term>ERROR_GEN_FAILURE</term>
            <term>An unspecified error occurred.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>DisplayConfigSetDeviceInfo</c> can currently only be used to start and stop boot persisted force projection on an analog
            target. For more information about boot persistence, see Forced Versus Connected Targets.
            </para>
            <para>
            <c>DisplayConfigSetDeviceInfo</c> can only be used to set DISPLAYCONFIG_DEVICE_INFO_SET_XXX type of information.
            <c>DisplayConfigSetDeviceInfo</c> fails if the <c>type</c> member of DISPLAYCONFIG_DEVICE_INFO_HEADER is set to one of the
            DISPLAYCONFIG_DEVICE_INFO_GET_XXX values.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DisplayConfigSetDeviceInfo``1(``0)">
            <summary>The <c>DisplayConfigSetDeviceInfo</c> function sets the properties of a target.</summary>
            <typeparam name="T">The type of the value to set.</typeparam>
            <param name="value">Contains information to set for the device.</param>
            <exception cref="T:System.ArgumentException">Supplied type does not match valid set value.</exception>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetDisplayConfigBufferSizes(Vanara.PInvoke.User32.QDC,System.UInt32@,System.UInt32@)">
            <summary>
            The <c>GetDisplayConfigBufferSizes</c> function retrieves the size of the buffers that are required to call the
            QueryDisplayConfig function.
            </summary>
            <param name="flags">
            <para>The type of information to retrieve. The value for the Flags parameter must be one of the following values.</para>
            <para>QDC_ALL_PATHS</para>
            <para>The caller requests the table sizes to hold all the possible path combinations.</para>
            <para>QDC_ONLY_ACTIVE_PATHS</para>
            <para>The caller requests the table sizes to hold only active paths.</para>
            <para>QDC_DATABASE_CURRENT</para>
            <para>
            The caller requests the table sizes to hold the active paths as defined in the persistence database for the currently connected monitors.
            </para>
            </param>
            <param name="numPathArrayElements">
            Pointer to a variable that receives the number of elements in the path information table. The pNumPathArrayElements parameter
            value is then used by a subsequent call to the QueryDisplayConfig function. This parameter cannot be <c>NULL</c>.
            </param>
            <param name="numModeInfoArrayElements">
            Pointer to a variable that receives the number of elements in the mode information table. The pNumModeInfoArrayElements parameter
            value is then used by a subsequent call to the QueryDisplayConfig function. This parameter cannot be <c>NULL</c>.
            </param>
            <returns>
            <para>The function returns one of the following return codes.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ERROR_SUCCESS</term>
            <term>The function succeeded.</term>
            </item>
            <item>
            <term>ERROR_INVALID_PARAMETER</term>
            <term>The combination of parameters and flags that are specified is invalid.</term>
            </item>
            <item>
            <term>ERROR_NOT_SUPPORTED</term>
            <term>
            The system is not running a graphics driver that was written according to the Windows Display Driver Model (WDDM). The function
            is only supported on a system with a WDDM driver running.
            </term>
            </item>
            <item>
            <term>ERROR_ACCESS_DENIED</term>
            <term>
            The caller does not have access to the console session. This error occurs if the calling process does not have access to the
            current desktop or is running on a remote session.
            </term>
            </item>
            <item>
            <term>ERROR_GEN_FAILURE</term>
            <term>An unspecified error occurred.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Given the current display path configuration and the requested flags, <c>GetDisplayConfigBufferSizes</c> returns the size of the
            path and mode tables that are required to store the information. <c>GetDisplayConfigBufferSizes</c> can return values that are
            slightly larger than are actually required because it determines that all source and target paths are valid; whereas, the driver
            might place some restrictions on the possible combinations.
            </para>
            <para>
            As <c>GetDisplayConfigBufferSizes</c> can only determine the required array size of that moment in time, it is possible that
            between calls to <c>GetDisplayConfigBufferSizes</c> and QueryDisplayConfig the system configuration has changed and the provided
            array sizes are no longer sufficient to store the new path data.
            </para>
            <para>
            If a caller is aware that it must enable additional sources and targets, the caller can allocate a larger mode information array
            than is returned from <c>GetDisplayConfigBufferSizes</c> so that it has the space to add the additional source and target modes
            after calling <c>QueryDisplayConfig</c> and before calling SetDisplayConfig.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.QueryDisplayConfig(Vanara.PInvoke.User32.QDC,System.UInt32@,Vanara.PInvoke.Gdi32.DISPLAYCONFIG_PATH_INFO[],System.UInt32@,Vanara.PInvoke.Gdi32.DISPLAYCONFIG_MODE_INFO[],System.IntPtr)">
            <summary>
            The <c>QueryDisplayConfig</c> function retrieves information about all possible display paths for all display devices, or views,
            in the current setting.
            </summary>
            <param name="flags">
            <para>The type of information to retrieve. The value for the Flags parameter must be one of the following values.</para>
            <para>QDC_ALL_PATHS</para>
            <para>All the possible path combinations of sources to targets.</para>
            <para>
            <c>Note</c> In the case of any temporary modes, the QDC_ALL_PATHS setting means the mode data returned may not be the same as
            that which is stored in the persistence database.
            </para>
            <para>QDC_ONLY_ACTIVE_PATHS</para>
            <para>Currently active paths only.</para>
            <para>
            <c>Note</c> In the case of any temporary modes, the QDC_ONLY_ACTIVE_PATHS setting means the mode data returned may not be the
            same as that which is stored in the persistence database.
            </para>
            <para>QDC_DATABASE_CURRENT</para>
            <para>Active path as defined in the CCD database for the currently connected displays.</para>
            </param>
            <param name="numPathArrayElements">
            Pointer to a variable that contains the number of elements in pPathInfoArray. This parameter cannot be <c>NULL</c>. If
            <c>QueryDisplayConfig</c> returns ERROR_SUCCESS, pNumPathInfoElements is updated with the number of valid entries in pPathInfoArray.
            </param>
            <param name="pathArray">
            Pointer to a variable that contains an array of DISPLAYCONFIG_PATH_INFO elements. Each element in pPathInfoArray describes a
            single path from a source to a target. The source and target mode information indexes are only valid in combination with the
            pmodeInfoArray tables that are returned for the API at the same time. This parameter cannot be <c>NULL</c>. The pPathInfoArray is
            always returned in path priority order. For more information about path priority order, see Path Priority Order.
            </param>
            <param name="numModeInfoArrayElements">
            Pointer to a variable that specifies the number in element of the mode information table. This parameter cannot be <c>NULL</c>.
            If <c>QueryDisplayConfig</c> returns ERROR_SUCCESS, pNumModeInfoArrayElements is updated with the number of valid entries in pModeInfoArray.
            </param>
            <param name="modeInfoArray">
            Pointer to a variable that contains an array of DISPLAYCONFIG_MODE_INFO elements. This parameter cannot be <c>NULL</c>.
            </param>
            <param name="currentTopologyId">
            <para>
            Pointer to a variable that receives the identifier of the currently active topology in the CCD database. For a list of possible
            values, see the DISPLAYCONFIG_TOPOLOGY_ID enumerated type.
            </para>
            <para>The pCurrentTopologyId parameter is only set when the Flags parameter value is QDC_DATABASE_CURRENT.</para>
            <para>
            If the Flags parameter value is set to QDC_DATABASE_CURRENT, the pCurrentTopologyId parameter must not be <c>NULL</c>. If the
            Flags parameter value is not set to QDC_DATABASE_CURRENT, the pCurrentTopologyId parameter value must be <c>NULL</c>.
            </para>
            </param>
            <returns>
            <para>The function returns one of the following return codes.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ERROR_SUCCESS</term>
            <term>The function succeeded.</term>
            </item>
            <item>
            <term>ERROR_INVALID_PARAMETER</term>
            <term>The combination of parameters and flags that are specified is invalid.</term>
            </item>
            <item>
            <term>ERROR_NOT_SUPPORTED</term>
            <term>
            The system is not running a graphics driver that was written according to the Windows Display Driver Model (WDDM). The function
            is only supported on a system with a WDDM driver running.
            </term>
            </item>
            <item>
            <term>ERROR_ACCESS_DENIED</term>
            <term>
            The caller does not have access to the console session. This error occurs if the calling process does not have access to the
            current desktop or is running on a remote session.
            </term>
            </item>
            <item>
            <term>ERROR_GEN_FAILURE</term>
            <term>An unspecified error occurred.</term>
            </item>
            <item>
            <term>ERROR_INSUFFICIENT_BUFFER</term>
            <term>The supplied path and mode buffer are too small.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            As the GetDisplayConfigBufferSizes function can only determine the required array size at a particular moment in time, it is
            possible that between calls to <c>GetDisplayConfigBufferSizes</c> and <c>QueryDisplayConfig</c> the system configuration will
            change and the provided array sizes will no longer be sufficient to store the new path data. In this situation,
            <c>QueryDisplayConfig</c> fails with ERROR_INSUFFICIENT_BUFFER, and the caller should call <c>GetDisplayConfigBufferSizes</c>
            again to get the new array sizes. The caller should then allocate the correct amount of memory.
            </para>
            <para>
            <c>QueryDisplayConfig</c> returns paths in the path array that the pPathInfoArray parameter specifies and the source and target
            modes in the mode array that the pModeInfoArray parameter specifies. <c>QueryDisplayConfig</c> always returns paths in path
            priority order. If QDC_ALL_PATHS is set in the Flags parameter, <c>QueryDisplayConfig</c> returns all the inactive paths after
            the active paths.
            </para>
            <para>
            Full path, source mode, and target mode information is available for all active paths. The <c>ModeInfoIdx</c> members in the
            DISPLAYCONFIG_PATH_SOURCE_INFO and DISPLAYCONFIG_PATH_TARGET_INFO structures for the source and target are set up for these
            active paths. For inactive paths, returned source and target mode information is not available; therefore, the target information
            in the path structure is set to default values, and the source and target mode indexes are marked as invalid. For database
            queries, if the current connect monitors have an entry, <c>QueryDisplayConfig</c> returns full path, source mode, and target mode
            information (same as for active paths). However, if the database does not have a entry, <c>QueryDisplayConfig</c> returns just
            the path information with the default target details (same as for inactive paths).
            </para>
            <para>
            For an example of how source and target mode information relates to path information, see Relationship of Mode Information to
            Path Information.
            </para>
            <para>
            The caller can use DisplayConfigGetDeviceInfo to obtain additional information about the source or target device, for example,
            the monitor names and monitor preferred mode and source device name.
            </para>
            <para>
            If a target is currently being force projected, the <c>statusFlags</c> member of the DISPLAYCONFIG_PATH_TARGET_INFO structure has
            one of the DISPLAYCONFIG_TARGET_FORCED_XXX flags set.
            </para>
            <para>
            If the QDC_DATABASE_CURRENT flag is set in the Flags parameter, <c>QueryDisplayConfig</c> returns the topology identifier of the
            active database topology in the variable that the pCurrentTopologyId parameter points to. If the QDC_ALL_PATHS or
            QDC_ONLY_ACTIVE_PATHS flag is set in the Flags parameter, the pCurrentTopologyId parameter must be set to <c>NULL</c>; otherwise,
            <c>QueryDisplayConfig</c> returns ERROR_INVALID_PARAMETER.
            </para>
            <para>
            If a caller calls <c>QueryDisplayConfig</c> with the QDC_DATABASE_CURRENT flag set in the Flags parameter,
            <c>QueryDisplayConfig</c> initializes the DISPLAYCONFIG_2DREGION structure that is specified in the <c>totalSize</c> member of
            the DISPLAYCONFIG_VIDEO_SIGNAL_INFO structure to zeros and does not complete DISPLAYCONFIG_2DREGION.
            </para>
            <para>
            The DEVMODE structure that is returned by the EnumDisplaySettings Win32 function (described in the Windows SDK documentation)
            contains information that relates to both the source and target modes. However, the CCD APIs explicitly separate the source and
            target mode components.
            </para>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. All sizes in the DEVMODE structure are in terms of physical pixels, and are
            not related to the calling context.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.QueryDisplayConfig(Vanara.PInvoke.User32.QDC,System.UInt32@,Vanara.PInvoke.Gdi32.DISPLAYCONFIG_PATH_INFO[],System.UInt32@,Vanara.PInvoke.Gdi32.DISPLAYCONFIG_MODE_INFO[],Vanara.PInvoke.Gdi32.DISPLAYCONFIG_TOPOLOGY_ID@)">
            <summary>
            The <c>QueryDisplayConfig</c> function retrieves information about all possible display paths for all display devices, or views,
            in the current setting.
            </summary>
            <param name="flags">
            <para>The type of information to retrieve. The value for the Flags parameter must be one of the following values.</para>
            <para>QDC_ALL_PATHS</para>
            <para>All the possible path combinations of sources to targets.</para>
            <para>
            <c>Note</c> In the case of any temporary modes, the QDC_ALL_PATHS setting means the mode data returned may not be the same as
            that which is stored in the persistence database.
            </para>
            <para>QDC_ONLY_ACTIVE_PATHS</para>
            <para>Currently active paths only.</para>
            <para>
            <c>Note</c> In the case of any temporary modes, the QDC_ONLY_ACTIVE_PATHS setting means the mode data returned may not be the
            same as that which is stored in the persistence database.
            </para>
            <para>QDC_DATABASE_CURRENT</para>
            <para>Active path as defined in the CCD database for the currently connected displays.</para>
            </param>
            <param name="numPathArrayElements">
            Pointer to a variable that contains the number of elements in pPathInfoArray. This parameter cannot be <c>NULL</c>. If
            <c>QueryDisplayConfig</c> returns ERROR_SUCCESS, pNumPathInfoElements is updated with the number of valid entries in pPathInfoArray.
            </param>
            <param name="pathArray">
            Pointer to a variable that contains an array of DISPLAYCONFIG_PATH_INFO elements. Each element in pPathInfoArray describes a
            single path from a source to a target. The source and target mode information indexes are only valid in combination with the
            pmodeInfoArray tables that are returned for the API at the same time. This parameter cannot be <c>NULL</c>. The pPathInfoArray is
            always returned in path priority order. For more information about path priority order, see Path Priority Order.
            </param>
            <param name="numModeInfoArrayElements">
            Pointer to a variable that specifies the number in element of the mode information table. This parameter cannot be <c>NULL</c>.
            If <c>QueryDisplayConfig</c> returns ERROR_SUCCESS, pNumModeInfoArrayElements is updated with the number of valid entries in pModeInfoArray.
            </param>
            <param name="modeInfoArray">
            Pointer to a variable that contains an array of DISPLAYCONFIG_MODE_INFO elements. This parameter cannot be <c>NULL</c>.
            </param>
            <param name="currentTopologyId">
            <para>
            Pointer to a variable that receives the identifier of the currently active topology in the CCD database. For a list of possible
            values, see the DISPLAYCONFIG_TOPOLOGY_ID enumerated type.
            </para>
            <para>The pCurrentTopologyId parameter is only set when the Flags parameter value is QDC_DATABASE_CURRENT.</para>
            <para>
            If the Flags parameter value is set to QDC_DATABASE_CURRENT, the pCurrentTopologyId parameter must not be <c>NULL</c>. If the
            Flags parameter value is not set to QDC_DATABASE_CURRENT, the pCurrentTopologyId parameter value must be <c>NULL</c>.
            </para>
            </param>
            <returns>
            <para>The function returns one of the following return codes.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ERROR_SUCCESS</term>
            <term>The function succeeded.</term>
            </item>
            <item>
            <term>ERROR_INVALID_PARAMETER</term>
            <term>The combination of parameters and flags that are specified is invalid.</term>
            </item>
            <item>
            <term>ERROR_NOT_SUPPORTED</term>
            <term>
            The system is not running a graphics driver that was written according to the Windows Display Driver Model (WDDM). The function
            is only supported on a system with a WDDM driver running.
            </term>
            </item>
            <item>
            <term>ERROR_ACCESS_DENIED</term>
            <term>
            The caller does not have access to the console session. This error occurs if the calling process does not have access to the
            current desktop or is running on a remote session.
            </term>
            </item>
            <item>
            <term>ERROR_GEN_FAILURE</term>
            <term>An unspecified error occurred.</term>
            </item>
            <item>
            <term>ERROR_INSUFFICIENT_BUFFER</term>
            <term>The supplied path and mode buffer are too small.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            As the GetDisplayConfigBufferSizes function can only determine the required array size at a particular moment in time, it is
            possible that between calls to <c>GetDisplayConfigBufferSizes</c> and <c>QueryDisplayConfig</c> the system configuration will
            change and the provided array sizes will no longer be sufficient to store the new path data. In this situation,
            <c>QueryDisplayConfig</c> fails with ERROR_INSUFFICIENT_BUFFER, and the caller should call <c>GetDisplayConfigBufferSizes</c>
            again to get the new array sizes. The caller should then allocate the correct amount of memory.
            </para>
            <para>
            <c>QueryDisplayConfig</c> returns paths in the path array that the pPathInfoArray parameter specifies and the source and target
            modes in the mode array that the pModeInfoArray parameter specifies. <c>QueryDisplayConfig</c> always returns paths in path
            priority order. If QDC_ALL_PATHS is set in the Flags parameter, <c>QueryDisplayConfig</c> returns all the inactive paths after
            the active paths.
            </para>
            <para>
            Full path, source mode, and target mode information is available for all active paths. The <c>ModeInfoIdx</c> members in the
            DISPLAYCONFIG_PATH_SOURCE_INFO and DISPLAYCONFIG_PATH_TARGET_INFO structures for the source and target are set up for these
            active paths. For inactive paths, returned source and target mode information is not available; therefore, the target information
            in the path structure is set to default values, and the source and target mode indexes are marked as invalid. For database
            queries, if the current connect monitors have an entry, <c>QueryDisplayConfig</c> returns full path, source mode, and target mode
            information (same as for active paths). However, if the database does not have a entry, <c>QueryDisplayConfig</c> returns just
            the path information with the default target details (same as for inactive paths).
            </para>
            <para>
            For an example of how source and target mode information relates to path information, see Relationship of Mode Information to
            Path Information.
            </para>
            <para>
            The caller can use DisplayConfigGetDeviceInfo to obtain additional information about the source or target device, for example,
            the monitor names and monitor preferred mode and source device name.
            </para>
            <para>
            If a target is currently being force projected, the <c>statusFlags</c> member of the DISPLAYCONFIG_PATH_TARGET_INFO structure has
            one of the DISPLAYCONFIG_TARGET_FORCED_XXX flags set.
            </para>
            <para>
            If the QDC_DATABASE_CURRENT flag is set in the Flags parameter, <c>QueryDisplayConfig</c> returns the topology identifier of the
            active database topology in the variable that the pCurrentTopologyId parameter points to. If the QDC_ALL_PATHS or
            QDC_ONLY_ACTIVE_PATHS flag is set in the Flags parameter, the pCurrentTopologyId parameter must be set to <c>NULL</c>; otherwise,
            <c>QueryDisplayConfig</c> returns ERROR_INVALID_PARAMETER.
            </para>
            <para>
            If a caller calls <c>QueryDisplayConfig</c> with the QDC_DATABASE_CURRENT flag set in the Flags parameter,
            <c>QueryDisplayConfig</c> initializes the DISPLAYCONFIG_2DREGION structure that is specified in the <c>totalSize</c> member of
            the DISPLAYCONFIG_VIDEO_SIGNAL_INFO structure to zeros and does not complete DISPLAYCONFIG_2DREGION.
            </para>
            <para>
            The DEVMODE structure that is returned by the EnumDisplaySettings Win32 function (described in the Windows SDK documentation)
            contains information that relates to both the source and target modes. However, the CCD APIs explicitly separate the source and
            target mode components.
            </para>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. All sizes in the DEVMODE structure are in terms of physical pixels, and are
            not related to the calling context.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.QueryDisplayConfig(Vanara.PInvoke.User32.QDC,Vanara.PInvoke.Gdi32.DISPLAYCONFIG_PATH_INFO[]@,Vanara.PInvoke.Gdi32.DISPLAYCONFIG_MODE_INFO[]@,Vanara.PInvoke.Gdi32.DISPLAYCONFIG_TOPOLOGY_ID@)">
            <summary>
            The <c>QueryDisplayConfig</c> function retrieves information about all possible display paths for all display devices, or views,
            in the current setting. This method also calls GetDisplayConfigBufferSizes to determine output sizing.
            </summary>
            <param name="flags">
            <para>The type of information to retrieve. The value for the Flags parameter must be one of the following values.</para>
            <para>QDC_ALL_PATHS</para>
            <para>All the possible path combinations of sources to targets.</para>
            <para>
            <c>Note</c> In the case of any temporary modes, the QDC_ALL_PATHS setting means the mode data returned may not be the same as
            that which is stored in the persistence database.
            </para>
            <para>QDC_ONLY_ACTIVE_PATHS</para>
            <para>Currently active paths only.</para>
            <para>
            <c>Note</c> In the case of any temporary modes, the QDC_ONLY_ACTIVE_PATHS setting means the mode data returned may not be the
            same as that which is stored in the persistence database.
            </para>
            <para>QDC_DATABASE_CURRENT</para>
            <para>Active path as defined in the CCD database for the currently connected displays.</para>
            </param>
            <param name="pathArray">
            The resulting array of DISPLAYCONFIG_PATH_INFO elements. Each element in pPathInfoArray describes a single path from a source to
            a target. The source and target mode information indexes are only valid in combination with the pmodeInfoArray tables that are
            returned for the API at the same time. This parameter cannot be <c>NULL</c>. The pPathInfoArray is always returned in path
            priority order. For more information about path priority order, see Path Priority Order.
            </param>
            <param name="modeInfoArray">The resulting array of DISPLAYCONFIG_MODE_INFO elements.</param>
            <param name="currentTopologyId">
            <para>
            Pointer to a variable that receives the identifier of the currently active topology in the CCD database. For a list of possible
            values, see the DISPLAYCONFIG_TOPOLOGY_ID enumerated type.
            </para>
            <para>The pCurrentTopologyId parameter is only set when the Flags parameter value is QDC_DATABASE_CURRENT.</para>
            <para>
            If the Flags parameter value is set to QDC_DATABASE_CURRENT, the pCurrentTopologyId parameter must not be <c>NULL</c>. If the
            Flags parameter value is not set to QDC_DATABASE_CURRENT, the pCurrentTopologyId parameter value must be <c>NULL</c>.
            </para>
            </param>
            <returns>
            <para>The function returns one of the following return codes.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ERROR_SUCCESS</term>
            <term>The function succeeded.</term>
            </item>
            <item>
            <term>ERROR_INVALID_PARAMETER</term>
            <term>The combination of parameters and flags that are specified is invalid.</term>
            </item>
            <item>
            <term>ERROR_NOT_SUPPORTED</term>
            <term>
            The system is not running a graphics driver that was written according to the Windows Display Driver Model (WDDM). The function
            is only supported on a system with a WDDM driver running.
            </term>
            </item>
            <item>
            <term>ERROR_ACCESS_DENIED</term>
            <term>
            The caller does not have access to the console session. This error occurs if the calling process does not have access to the
            current desktop or is running on a remote session.
            </term>
            </item>
            <item>
            <term>ERROR_GEN_FAILURE</term>
            <term>An unspecified error occurred.</term>
            </item>
            <item>
            <term>ERROR_INSUFFICIENT_BUFFER</term>
            <term>The supplied path and mode buffer are too small.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>QueryDisplayConfig</c> returns paths in the path array that the pPathInfoArray parameter specifies and the source and target
            modes in the mode array that the pModeInfoArray parameter specifies. <c>QueryDisplayConfig</c> always returns paths in path
            priority order. If QDC_ALL_PATHS is set in the Flags parameter, <c>QueryDisplayConfig</c> returns all the inactive paths after
            the active paths.
            </para>
            <para>
            Full path, source mode, and target mode information is available for all active paths. The <c>ModeInfoIdx</c> members in the
            DISPLAYCONFIG_PATH_SOURCE_INFO and DISPLAYCONFIG_PATH_TARGET_INFO structures for the source and target are set up for these
            active paths. For inactive paths, returned source and target mode information is not available; therefore, the target information
            in the path structure is set to default values, and the source and target mode indexes are marked as invalid. For database
            queries, if the current connect monitors have an entry, <c>QueryDisplayConfig</c> returns full path, source mode, and target mode
            information (same as for active paths). However, if the database does not have a entry, <c>QueryDisplayConfig</c> returns just
            the path information with the default target details (same as for inactive paths).
            </para>
            <para>
            For an example of how source and target mode information relates to path information, see Relationship of Mode Information to
            Path Information.
            </para>
            <para>
            The caller can use DisplayConfigGetDeviceInfo to obtain additional information about the source or target device, for example,
            the monitor names and monitor preferred mode and source device name.
            </para>
            <para>
            If a target is currently being force projected, the <c>statusFlags</c> member of the DISPLAYCONFIG_PATH_TARGET_INFO structure has
            one of the DISPLAYCONFIG_TARGET_FORCED_XXX flags set.
            </para>
            <para>
            If the QDC_DATABASE_CURRENT flag is set in the Flags parameter, <c>QueryDisplayConfig</c> returns the topology identifier of the
            active database topology in the variable that the pCurrentTopologyId parameter points to. If the QDC_ALL_PATHS or
            QDC_ONLY_ACTIVE_PATHS flag is set in the Flags parameter, the pCurrentTopologyId parameter must be set to <c>NULL</c>; otherwise,
            <c>QueryDisplayConfig</c> returns ERROR_INVALID_PARAMETER.
            </para>
            <para>
            If a caller calls <c>QueryDisplayConfig</c> with the QDC_DATABASE_CURRENT flag set in the Flags parameter,
            <c>QueryDisplayConfig</c> initializes the DISPLAYCONFIG_2DREGION structure that is specified in the <c>totalSize</c> member of
            the DISPLAYCONFIG_VIDEO_SIGNAL_INFO structure to zeros and does not complete DISPLAYCONFIG_2DREGION.
            </para>
            <para>
            The DEVMODE structure that is returned by the EnumDisplaySettings Win32 function (described in the Windows SDK documentation)
            contains information that relates to both the source and target modes. However, the CCD APIs explicitly separate the source and
            target mode components.
            </para>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. All sizes in the DEVMODE structure are in terms of physical pixels, and are
            not related to the calling context.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetDisplayConfig(System.UInt32,Vanara.PInvoke.Gdi32.DISPLAYCONFIG_PATH_INFO[],System.UInt32,Vanara.PInvoke.Gdi32.DISPLAYCONFIG_MODE_INFO[],Vanara.PInvoke.User32.SDC)">
            <summary>
            The <c>SetDisplayConfig</c> function modifies the display topology, source, and target modes by exclusively enabling the
            specified paths in the current session.
            </summary>
            <param name="numPathArrayElements">Number of elements in pathArray.</param>
            <param name="pathArray">
            Array of all display paths that are to be set. Only the paths within this array that have the DISPLAYCONFIG_PATH_ACTIVE flag set
            in the <c>flags</c> member of DISPLAYCONFIG_PATH_INFO are set. This parameter can be <c>NULL</c>. The order in which active paths
            appear in this array determines the path priority. For more information about path priority order, see Path Priority Order.
            </param>
            <param name="numModeInfoArrayElements">Number of elements in modeInfoArray.</param>
            <param name="modeInfoArray">
            Array of display source and target mode information (DISPLAYCONFIG_MODE_INFO) that is referenced by the <c>modeInfoIdx</c> member
            of DISPLAYCONFIG_PATH_SOURCE_INFO and DISPLAYCONFIG_PATH_TARGET_INFO element of path information from pathArray. This parameter
            can be <c>NULL</c>.
            </param>
            <param name="flags">
            <para>
            A bitwise OR of flag values that indicates the behavior of this function. This parameter can be one the following values, or a
            combination of the following values; 0 is not valid.
            </para>
            <para>SDC_APPLY</para>
            <para>The resulting topology, source, and target mode is set.</para>
            <para>SDC_NO_OPTIMIZATION</para>
            <para>
            A modifier to the SDC_APPLY flag. This causes the change mode to be forced all the way down to the driver for each active display.
            </para>
            <para>SDC_USE_SUPPLIED_DISPLAY_CONFIG</para>
            <para>
            The topology, source, and target mode information that are supplied in the pathArray and the modeInfoArray parameters are used,
            rather than looking up the configuration in the database.
            </para>
            <para>SDC_SAVE_TO_DATABASE</para>
            <para>The resulting topology, source, and target mode are saved to the database.</para>
            <para>SDC_VALIDATE</para>
            <para>The system tests for the requested topology, source, and target mode information to determine whether it can be set.</para>
            <para>SDC_ALLOW_CHANGES</para>
            <para>
            If required, the function can modify the specified source and target mode information in order to create a functional display
            path set.
            </para>
            <para>SDC_TOPOLOGY_CLONE</para>
            <para>The caller requests the last clone configuration from the persistence database.</para>
            <para>SDC_TOPOLOGY_EXTEND</para>
            <para>The caller requests the last extended configuration from the persistence database.</para>
            <para>SDC_TOPOLOGY_INTERNAL</para>
            <para>The caller requests the last internal configuration from the persistence database.</para>
            <para>SDC_TOPOLOGY_EXTERNAL</para>
            <para>The caller requests the last external configuration from the persistence database.</para>
            <para>SDC_TOPOLOGY_SUPPLIED</para>
            <para>
            The caller provides the path data so the function only queries the persistence database to find and use the source and target mode.
            </para>
            <para>SDC_USE_DATABASE_CURRENT</para>
            <para>
            The caller requests a combination of all four SDC_TOPOLOGY_XXX configurations. This value informs the API to set the last known
            display configuration for the current connected monitors.
            </para>
            <para>SDC_PATH_PERSIST_IF_REQUIRED</para>
            <para>
            When the function processes a SDC_TOPOLOGY_XXX request, it can force path persistence on a target to satisfy the request if
            necessary. For information about the other flags that this flag can be combined with, see the following list.
            </para>
            <para>SDC_FORCE_MODE_ENUMERATION</para>
            <para>
            The caller requests that the driver is given an opportunity to update the GDI mode list while <c>SetDisplayConfig</c> sets the
            new display configuration. This flag value is only valid when the SDC_USE_SUPPLIED_DISPLAY_CONFIG and SDC_APPLY flag values are
            also specified.
            </para>
            <para>SDC_ALLOW_PATH_ORDER_CHANGES</para>
            <para>
            A modifier to the SDC_TOPOLOGY_SUPPLIED flag that indicates that <c>SetDisplayConfig</c> should ignore the path order of the
            supplied topology when searching the database. When this flag is set, the topology set is the most recent topology that contains
            all the paths regardless of the path order.
            </para>
            <para>The following list contains valid combinations of values for the Flags parameter:</para>
            <list type="bullet">
            <item>
            <term>Either SDC_APPLY or SDC_VALIDATE must be set, but not both.</term>
            </item>
            <item>
            <term>
            Either SDC_USE_SUPPLIED_DISPLAY_CONFIG or any combinations of SDC_TOPOLOGY_XXX must be set. SDC_USE_SUPPLIED_DISPLAY_CONFIG
            cannot be set with any SDC_TOPOLOGY_XXX flag.
            </term>
            </item>
            <item>
            <term>SDC_NO_OPTIMIZATION can only be set with SDC_APPLY.</term>
            </item>
            <item>
            <term>SDC_ALLOW_CHANGES is allowed with any other valid combination.</term>
            </item>
            <item>
            <term>SDC_SAVE_TO_DATABASE can only be set with SDC_USE_SUPPLIED_DISPLAY_CONFIG.</term>
            </item>
            <item>
            <term>SDC_PATH_PERSIST_IF_REQUIRED cannot be used with SDC_USE_SUPPLIED_DISPLAY_CONFIG or SDC_TOPOLOGY_SUPPLIED.</term>
            </item>
            <item>
            <term>SDC_FORCE_MODE_ENUMERATION is only valid when SDC_APPLY and SDC_USE_SUPPLIED_DISPLAY_CONFIG are specified.</term>
            </item>
            <item>
            <term>SDC_ALLOW_PATH_ORDER_CHANGES is allowed only when SDC_TOPOLOGY_SUPPLIED is specified.</term>
            </item>
            <item>
            <term>
            SDC_TOPOLOGY_SUPPLIED cannot be used with any other SDC_TOPOLOGY_XXX flag. Because of a validation issue, if a caller violates
            this rule, <c>SetDisplayConfig</c> does not fail. However, <c>SetDisplayConfig</c> ignores the SDC_TOPOLOGY_SUPPLIED flag.
            </term>
            </item>
            </list>
            <para>
            SDC_TOPOLOGY_XXX flags can be used in combinations. For example, if SDC_TOPOLOGY_CLONE and SDC_TOPOLOGY_EXTEND are set, the API
            uses the most recent clone or extend topology, which every topology was set with most recently for the current connected monitors.
            </para>
            </param>
            <returns>
            <para>The function returns one of the following return codes.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ERROR_SUCCESS</term>
            <term>The function succeeded.</term>
            </item>
            <item>
            <term>ERROR_INVALID_PARAMETER</term>
            <term>The combination of parameters and flags specified is invalid.</term>
            </item>
            <item>
            <term>ERROR_NOT_SUPPORTED</term>
            <term>
            The system is not running a graphics driver that was written according to the Windows Display Driver Model (WDDM). The function
            is only supported on a system with a WDDM driver running.
            </term>
            </item>
            <item>
            <term>ERROR_ACCESS_DENIED</term>
            <term>
            The caller does not have access to the console session. This error occurs if the calling process does not have access to the
            current desktop or is running on a remote session.
            </term>
            </item>
            <item>
            <term>ERROR_GEN_FAILURE</term>
            <term>An unspecified error occurred.</term>
            </item>
            <item>
            <term>ERROR_BAD_CONFIGURATION</term>
            <term>The function could not find a workable solution for the source and target modes that the caller did not specify.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>SetDisplayConfig</c> function takes the active display paths with any specified source and target mode information and
            uses best mode logic to generate any missing source and target mode information. This function then sets the complete display path.
            </para>
            <para>
            The <c>ModeInfoIdx</c> members in the DISPLAYCONFIG_PATH_SOURCE_INFO and DISPLAYCONFIG_PATH_TARGET_INFO structures are used to
            indicate whether source and target mode are supplied for a given active path. If the index value is
            DISPLAYCONFIG_PATH_MODE_IDX_INVALID for either, this indicates the mode information is not being specified. It is valid for the
            path plus source mode or the path plus source and target mode information to be specified for a given path. However, it is not
            valid for the path plus target mode to be specified without the source mode.
            </para>
            <para>
            The source and target modes for each source and target identifiers can only appear in the modeInfoArray array once. For example,
            a source mode for source identifier S1 can only appear in the table once; if multiple paths reference the same source, they have
            to use the same <c>ModeInfoIdx</c>.
            </para>
            <para>
            The expectation is that most callers use QueryDisplayConfig to get the current configuration along with other valid possibilities
            and then use <c>SetDisplayConfig</c> to test and set the configuration.
            </para>
            <para>The order in which the active paths appear in the PathArray array determines the path priority.</para>
            <para>
            By default, <c>SetDisplayConfig</c> never changes any supplied path, source mode, or target mode information. If best mode logic
            cannot find a solution without changing the specified display path information, <c>SetDisplayConfig</c> fails with
            ERROR_BAD_CONFIGURATION. In this case, the caller should specify the SDC_ALLOW_CHANGES flag to allow the function to tweak some
            of the specified source and mode details to allow the display path change to be successful.
            </para>
            <para>
            If the specified or calculated source and target modes have the same dimensions, <c>SetDisplayConfig</c> automatically sets the
            path scaling to DISPLAYCONFIG_PPR_IDENTITY before setting the display path and saving it in the database. For information about
            how <c>SetDisplayConfig</c> handles scaling, see Scaling the Desktop Image.
            </para>
            <para>
            When the caller specifies the SDC_USE_SUPPLIED_DISPLAY_CONFIG flag to set a clone path and if any source mode indexes are invalid
            in the path array, <c>SetDisplayConfig</c> determines that all of the source mode indexes from that source are invalid.
            <c>SetDisplayConfig</c> uses the best mode logic to determine the source mode information.
            </para>
            <para>
            Except for the SDC_TOPOLOGY_SUPPLIED flag (for more information about SDC_TOPOLOGY_SUPPLIED, see the following paragraph), the
            SDC_TOPOLOGY_XXX flags set last display path settings, including the source and target mode information for that topology type.
            For information about valid SDC_TOPOLOGY_XXX flag combinations, see the Flags parameter description. The pathArray and
            modeInfoArray parameters must be <c>NULL</c>, and their associated sizes must be zero. For example, if SDC_TOPOLOGY_CLONE and
            SDC_TOPOLOGY_EXTEND are set, this function uses the most recent clone or extend display path configuration. If a single topology
            type is requested, the last configuration of that type is used. If that topology had never been set before,
            <c>SetDisplayConfig</c> uses the best topology logic to find the best topology, and then best mode logic to find the best source
            and target mode to use. If a combination of the topology flags had been set and none of them had database entries, the following
            priority is used. For laptops: clone, extend, internal, and then external; for desktops the priority is extend and then clone.
            </para>
            <para>
            The caller can specify the SDC_TOPOLOGY_SUPPLIED flag to indicate that it sets just the path information (topology) and requests
            that <c>SetDisplayConfig</c> obtains and then uses the source and target mode information from the persistence database. If the
            active paths that the caller supplies do not have an entry in the persistence database, <c>SetDisplayConfig</c> fails. In this
            case, if the caller calls <c>SetDisplayConfig</c> again with the same path data but with the SDC_USE_SUPPLIED_DISPLAY_CONFIG flag
            set, <c>SetDisplayConfig</c> uses best mode logic to create the source and target mode information. When the caller specifies
            SDC_TOPOLOGY_SUPPLIED, the caller must set the numModeInfoArrayElements parameter to zero and the modeInfoArray parameter to
            <c>NULL</c>; however, the caller must set the pathArray and numPathArrayElements parameters for the path information that the
            caller requires. The caller must mark all the source and target mode indexes as invalid (DISPLAYCONFIG_PATH_MODE_IDX_INVALID) in
            this path data.
            </para>
            <para>
            The following table provides some common scenarios where <c>SetDisplayConfig</c> is called along with the flag combinations that
            the caller passes to the Flags parameter to achieve the scenarios.
            </para>
            <list type="table">
            <listheader>
            <term>Scenario</term>
            <term>Flag combination</term>
            </listheader>
            <item>
            <term>Test whether a specified display configuration is supported on the computer</term>
            <term>SDC_VALIDATE | SDC_USE_SUPPLIED_DISPLAY_CONFIG</term>
            </item>
            <item>
            <term>Set a specified display configuration and save to the database</term>
            <term>SDC_APPLY | SDC_USE_SUPPLIED_DISPLAY_CONFIG | SDC_SAVE_TO_DATABASE</term>
            </item>
            <item>
            <term>Set a temporary display configuration (that is, the display configuration will not be saved)</term>
            <term>SDC_APPLY | SDC_USE_SUPPLIED_DISPLAY_CONFIG</term>
            </item>
            <item>
            <term>Test whether clone is supported on the computer</term>
            <term>SDC_VALIDATE | SDC_TOPOLOGY_CLONE</term>
            </item>
            <item>
            <term>Set clone topology</term>
            <term>SDC_APPLY | SDC_TOPOLOGY_CLONE</term>
            </item>
            <item>
            <term>Set clone topology and allow path persistence to be enabled if required to satisfy the request</term>
            <term>SDC_APPLY | SDC_TOPOLOGY_CLONE | SDC_PATH_PERSIST_IF_REQUIRED</term>
            </item>
            <item>
            <term>Return from a temporary mode to the last saved display configuration</term>
            <term>SDC_APPLY| SDC_USE_DATABASE_CURRENT</term>
            </item>
            <item>
            <term>
            Given only the path information, set the display configuration with the source and target information from the database for the
            paths and ignore the path order
            </term>
            <term>SDC_APPLY | SDC_TOPOLOGY_SUPPLIED | SDC_ALLOW_PATH_ORDER_CHANGES</term>
            </item>
            </list>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. All sizes in the DEVMODE structure are in terms of physical pixels, and are
            not related to the calling context.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.OCM_NOTIFY">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.User32.ChangeDisplaySettingsFlags">
            <summary>Flags used by <see cref="M:Vanara.PInvoke.User32.ChangeDisplaySettings(Vanara.PInvoke.DEVMODE@,Vanara.PInvoke.User32.ChangeDisplaySettingsFlags)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ChangeDisplaySettingsFlags.CDS_DEFAULT">
            <summary>The graphics mode for the current screen will be changed dynamically.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ChangeDisplaySettingsFlags.CDS_UPDATEREGISTRY">
            <summary>
            The graphics mode for the current screen will be changed dynamically and the graphics mode will be updated in the registry.
            The mode information is stored in the USER profile.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ChangeDisplaySettingsFlags.CDS_TEST">
            <summary>The system tests if the requested graphics mode could be set.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ChangeDisplaySettingsFlags.CDS_FULLSCREEN">
            <summary>The mode is temporary in nature. If you change to and from another desktop, this mode will not be reset.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ChangeDisplaySettingsFlags.CDS_GLOBAL">
            <summary>
            The settings will be saved in the global settings area so that they will affect all users on the machine. Otherwise, only the
            settings for the user are modified. This flag is only valid when specified with the CDS_UPDATEREGISTRY flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ChangeDisplaySettingsFlags.CDS_SET_PRIMARY">
            <summary>This device will become the primary device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ChangeDisplaySettingsFlags.CDS_VIDEOPARAMETERS">
            <summary>When set, the lParam parameter is a pointer to a VIDEOPARAMETERS structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ChangeDisplaySettingsFlags.CDS_ENABLE_UNSAFE_MODES">
            <summary>Enables settings changes to unsafe graphics modes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ChangeDisplaySettingsFlags.CDS_DISABLE_UNSAFE_MODES">
            <summary>Disables settings changes to unsafe graphics modes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ChangeDisplaySettingsFlags.CDS_RESET">
            <summary>The settings should be changed, even if the requested settings are the same as the current settings.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ChangeDisplaySettingsFlags.CDS_RESET_EX">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ChangeDisplaySettingsFlags.CDS_NORESET">
            <summary>
            The settings will be saved in the registry, but will not take effect. This flag is only valid when specified with the
            CDS_UPDATEREGISTRY flag.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.CopyImageOptions">
            <summary>Options for CopyImage.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CopyImageOptions.LR_COPYRETURNORG">
            <summary>
            Returns the original hImage if it satisfies the criteria for the copy—that is, correct dimensions and color depth—in which
            case the LR_COPYDELETEORG flag is ignored. If this flag is not specified, a new object is always created.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CopyImageOptions.LR_COPYDELETEORG">
            <summary>Deletes the original image after creating the copy.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CopyImageOptions.LR_COPYFROMRESOURCE">
            <summary>
            Tries to reload an icon or cursor resource from the original resource file rather than simply copying the current image. This
            is useful for creating a different-sized copy when the resource file contains multiple sizes of the resource. Without this
            flag, CopyImage stretches the original image to the new size. If this flag is set, CopyImage uses the size in the resource
            file closest to the desired size. This will succeed only if hImage was loaded by LoadIcon or LoadCursor, or by LoadImage with
            the LR_SHARED flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CopyImageOptions.LR_CREATEDIBSECTION">
            <summary>
            When the uType parameter specifies IMAGE_BITMAP, causes the function to return a DIB section bitmap rather than a compatible
            bitmap. This flag is useful for loading a bitmap without mapping it to the colors of the display device.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CopyImageOptions.LR_DEFAULTSIZE">
            <summary>
            Uses the width or height specified by the system metric values for cursors or icons, if the cxDesired or cyDesired values are
            set to zero. If this flag is not specified and cxDesired and cyDesired are set to zero, the function uses the actual resource
            size. If the resource contains multiple images, the function uses the size of the first image.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CopyImageOptions.LR_MONOCHROME">
            <summary>Loads the image in black and white.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DCX">
            <summary>Flags used by <see cref="M:Vanara.PInvoke.User32.GetDCEx(Vanara.PInvoke.HWND,Vanara.PInvoke.HRGN,Vanara.PInvoke.User32.DCX)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DCX.DCX_WINDOW">
            <summary>Returns a DC that corresponds to the window rectangle rather than the client rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DCX.DCX_CACHE">
            <summary>Returns a DC from the cache, rather than the OWNDC or CLASSDC window. Essentially overrides CS_OWNDC and CS_CLASSDC.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DCX.DCX_NORESETATTRS">
            <summary>This flag is ignored.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DCX.DCX_CLIPCHILDREN">
            <summary>Excludes the visible regions of all child windows below the window identified by hWnd.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DCX.DCX_CLIPSIBLINGS">
            <summary>Excludes the visible regions of all sibling windows above the window identified by hWnd.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DCX.DCX_PARENTCLIP">
            <summary>
            Uses the visible region of the parent window. The parent's WS_CLIPCHILDREN and CS_PARENTDC style bits are ignored. The origin
            is set to the upper-left corner of the window identified by hWnd.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DCX.DCX_EXCLUDERGN">
            <summary>The clipping region identified by hrgnClip is excluded from the visible region of the returned DC.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DCX.DCX_INTERSECTRGN">
            <summary>The clipping region identified by hrgnClip is intersected with the visible region of the returned DC.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DCX.DCX_EXCLUDEUPDATE">
            <summary>Returns a region that excludes the window's update region.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DCX.DCX_INTERSECTUPDATE">
            <summary>Returns a region that includes the window's update region.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DCX.DCX_LOCKWINDOWUPDATE">
            <summary>
            Allows drawing even if there is a LockWindowUpdate call in effect that would otherwise exclude this window. Used for drawing
            during tracking.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DCX.DCX_VALIDATE">
            <summary>
            When specified with DCX_INTERSECTUPDATE, causes the device context to be completely validated.
            <para>Using this function with both DCX_INTERSECTUPDATE and DCX_VALIDATE is identical to using the BeginPaint function.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.GR">
            <summary>Flags for <see cref="M:Vanara.PInvoke.User32.GetGuiResources(Vanara.PInvoke.HPROCESS,Vanara.PInvoke.User32.GR)"/></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GR.GR_GDIOBJECTS">
            <summary>Return the count of GDI objects.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GR.GR_GDIOBJECTS_PEAK">
            <summary>
            Return the peak count of GDI objects.
            <para>
            Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: This value is not supported until Windows 7 and
            Windows Server 2008 R2.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GR.GR_USEROBJECTS">
            <summary>Return the count of USER objects.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GR.GR_USEROBJECTS_PEAK">
            <summary>
            Return the peak count of USER objects.
            <para>
            Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: This value is not supported until Windows 7 and
            Windows Server 2008 R2.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.HitTestValues">
            <summary>Values to use a return codes when handling the WM_HCHITTEST message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTBORDER">
            <summary>In the border of a window that does not have a sizing border.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTBOTTOM">
            <summary>In the lower-horizontal border of a resizable window (the user can click the mouse to resize the window vertically).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTBOTTOMLEFT">
            <summary>
            In the lower-left corner of a border of a resizable window (the user can click the mouse to resize the window diagonally).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTBOTTOMRIGHT">
            <summary>
            In the lower-right corner of a border of a resizable window (the user can click the mouse to resize the window diagonally).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTCAPTION">
            <summary>In a title bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTCLIENT">
            <summary>In a client area.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTCLOSE">
            <summary>In a Close button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTERROR">
            <summary>
            On the screen background or on a dividing line between windows (same as HTNOWHERE, except that the DefWindowProc function
            produces a system beep to indicate an error).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTGROWBOX">
            <summary>In a size box (same as HTSIZE).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTHELP">
            <summary>In a Help button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTHSCROLL">
            <summary>In a horizontal scroll bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTLEFT">
            <summary>In the left border of a resizable window (the user can click the mouse to resize the window horizontally).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTMENU">
            <summary>In a menu.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTMAXBUTTON">
            <summary>In a Maximize button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTMINBUTTON">
            <summary>In a Minimize button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTNOWHERE">
            <summary>On the screen background or on a dividing line between windows.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTREDUCE">
            <summary>In a Minimize button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTRIGHT">
            <summary>In the right border of a resizable window (the user can click the mouse to resize the window horizontally).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTSIZE">
            <summary>In a size box (same as HTGROWBOX).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTSYSMENU">
            <summary>In a window menu or in a Close button in a child window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTTOP">
            <summary>In the upper-horizontal border of a window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTTOPLEFT">
            <summary>In the upper-left corner of a window border.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTTOPRIGHT">
            <summary>In the upper-right corner of a window border.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTTRANSPARENT">
            <summary>
            In a window currently covered by another window in the same thread (the message will be sent to underlying windows in the
            same thread until one of them returns a code that is not HTTRANSPARENT).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTVSCROLL">
            <summary>In the vertical scroll bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HitTestValues.HTZOOM">
            <summary>In a Maximize button.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.WindowLongFlags">
            <summary>
            Flags used for <see cref="M:Vanara.PInvoke.User32.GetWindowLong(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.WindowLongFlags)"/> and <see cref="M:Vanara.PInvoke.User32.SetWindowLong(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.WindowLongFlags,System.Int32)"/> methods to retrieve information about a window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.GWL_EXSTYLE">
            <summary>The extended window styles</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.GWL_HINSTANCE">
            <summary>The application instance handle</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.GWLP_HINSTANCE">
            <summary>The application instance handle</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.GWL_HWNDPARENT">
            <summary>The parent window handle</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.GWL_ID">
            <summary>The window identifier</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.GWLP_ID">
            <summary>The window identifier</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.GWL_STYLE">
            <summary>The window styles</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.GWL_USERDATA">
            <summary>The window user data</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.GWLP_USERDATA">
            <summary>The window user data</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.GWL_WNDPROC">
            <summary>The window procedure address or handle</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.GWLP_WNDPROC">
            <summary>The window procedure address or handle</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.DWLP_USER">
            <summary>The dialog user data</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.DWLP_MSGRESULT">
            <summary>The dialog procedure message result</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.DWLP_DLGPROC">
            <summary>The dialog procedure address or handle</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.DWL_USER">
            <summary>The dialog user data</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.DWL_MSGRESULT">
            <summary>The dialog procedure message result</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowLongFlags.DWL_DLGPROC">
            <summary>The dialog procedure address or handle</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.ChangeDisplaySettings(Vanara.PInvoke.DEVMODE@,Vanara.PInvoke.User32.ChangeDisplaySettingsFlags)">
            <summary>
            <para>
            The <c>ChangeDisplaySettings</c> function changes the settings of the default display device to the specified graphics mode.
            </para>
            <para>To change the settings of a specified display device, use the ChangeDisplaySettingsEx function.</para>
            <para>
            <c>Note</c> Apps that you design to target Windows 8 and later can no longer query or set display modes that are less than 32
            bits per pixel (bpp); these operations will fail. These apps have a compatibility manifest that targets Windows 8. Windows 8
            still supports 8-bit and 16-bit color modes for desktop apps that were built without a Windows 8 manifest; Windows 8 emulates
            these modes but still runs in 32-bit color mode.
            </para>
            </summary>
            <param name="lpDevMode">
            <para>
            A pointer to a DEVMODE structure that describes the new graphics mode. If lpDevMode is <c>NULL</c>, all the values currently in
            the registry will be used for the display setting. Passing <c>NULL</c> for the lpDevMode parameter and 0 for the dwFlags
            parameter is the easiest way to return to the default mode after a dynamic mode change.
            </para>
            <para>
            The <c>dmSize</c> member of DEVMODE must be initialized to the size, in bytes, of the <c>DEVMODE</c> structure. The
            <c>dmDriverExtra</c> member of <c>DEVMODE</c> must be initialized to indicate the number of bytes of private driver data
            following the <c>DEVMODE</c> structure. In addition, you can use any or all of the following members of the <c>DEVMODE</c> structure.
            </para>
            <list type="table">
            <listheader>
            <term>Member</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>dmBitsPerPel</term>
            <term>Bits per pixel</term>
            </item>
            <item>
            <term>dmPelsWidth</term>
            <term>Pixel width</term>
            </item>
            <item>
            <term>dmPelsHeight</term>
            <term>Pixel height</term>
            </item>
            <item>
            <term>dmDisplayFlags</term>
            <term>Mode flags</term>
            </item>
            <item>
            <term>dmDisplayFrequency</term>
            <term>Mode frequency</term>
            </item>
            <item>
            <term>dmPosition</term>
            <term>Position of the device in a multi-monitor configuration.</term>
            </item>
            </list>
            <para>
            In addition to using one or more of the preceding DEVMODE members, you must also set one or more of the following values in the
            <c>dmFields</c> member to change the display setting.
            </para>
            </param>
            <param name="dwFlags">
            <para>Indicates how the graphics mode should be changed. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The graphics mode for the current screen will be changed dynamically.</term>
            </item>
            <item>
            <term>CDS_FULLSCREEN</term>
            <term>The mode is temporary in nature. If you change to and from another desktop, this mode will not be reset.</term>
            </item>
            <item>
            <term>CDS_GLOBAL</term>
            <term>
            The settings will be saved in the global settings area so that they will affect all users on the machine. Otherwise, only the
            settings for the user are modified. This flag is only valid when specified with the CDS_UPDATEREGISTRY flag.
            </term>
            </item>
            <item>
            <term>CDS_NORESET</term>
            <term>
            The settings will be saved in the registry, but will not take effect. This flag is only valid when specified with the
            CDS_UPDATEREGISTRY flag.
            </term>
            </item>
            <item>
            <term>CDS_RESET</term>
            <term>The settings should be changed, even if the requested settings are the same as the current settings.</term>
            </item>
            <item>
            <term>CDS_SET_PRIMARY</term>
            <term>This device will become the primary device.</term>
            </item>
            <item>
            <term>CDS_TEST</term>
            <term>The system tests if the requested graphics mode could be set.</term>
            </item>
            <item>
            <term>CDS_UPDATEREGISTRY</term>
            <term>
            The graphics mode for the current screen will be changed dynamically and the graphics mode will be updated in the registry. The
            mode information is stored in the USER profile.
            </term>
            </item>
            </list>
            <para>
            Specifying CDS_TEST allows an application to determine which graphics modes are actually valid, without causing the system to
            change to that graphics mode.
            </para>
            <para>
            If CDS_UPDATEREGISTRY is specified and it is possible to change the graphics mode dynamically, the information is stored in the
            registry and DISP_CHANGE_SUCCESSFUL is returned. If it is not possible to change the graphics mode dynamically, the information
            is stored in the registry and DISP_CHANGE_RESTART is returned.
            </para>
            <para>
            If CDS_UPDATEREGISTRY is specified and the information could not be stored in the registry, the graphics mode is not changed and
            DISP_CHANGE_NOTUPDATED is returned.
            </para>
            </param>
            <returns>
            <para>The <c>ChangeDisplaySettings</c> function returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>DISP_CHANGE_SUCCESSFUL</term>
            <term>The settings change was successful.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADDUALVIEW</term>
            <term>The settings change was unsuccessful because the system is DualView capable.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADFLAGS</term>
            <term>An invalid set of flags was passed in.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADMODE</term>
            <term>The graphics mode is not supported.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADPARAM</term>
            <term>An invalid parameter was passed in. This can include an invalid flag or combination of flags.</term>
            </item>
            <item>
            <term>DISP_CHANGE_FAILED</term>
            <term>The display driver failed the specified graphics mode.</term>
            </item>
            <item>
            <term>DISP_CHANGE_NOTUPDATED</term>
            <term>Unable to write settings to the registry.</term>
            </item>
            <item>
            <term>DISP_CHANGE_RESTART</term>
            <term>The computer must be restarted for the graphics mode to work.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            To ensure that the DEVMODE structure passed to <c>ChangeDisplaySettings</c> is valid and contains only values supported by the
            display driver, use the <c>DEVMODE</c> returned by the EnumDisplaySettings function.
            </para>
            <para>
            When the display mode is changed dynamically, the WM_DISPLAYCHANGE message is sent to all running applications with the following
            message parameters.
            </para>
            <list type="table">
            <listheader>
            <term>Parameters</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>wParam</term>
            <term>New bits per pixel</term>
            </item>
            <item>
            <term>LOWORD(lParam)</term>
            <term>New pixel width</term>
            </item>
            <item>
            <term>HIWORD(lParam)</term>
            <term>New pixel height</term>
            </item>
            </list>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. The input given is always in terms of physical pixels, and is not related to
            the calling context.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ChangeDisplaySettings(System.IntPtr,Vanara.PInvoke.User32.ChangeDisplaySettingsFlags)">
            <summary>
            <para>
            The <c>ChangeDisplaySettings</c> function changes the settings of the default display device to the specified graphics mode.
            </para>
            <para>To change the settings of a specified display device, use the ChangeDisplaySettingsEx function.</para>
            <para>
            <c>Note</c> Apps that you design to target Windows 8 and later can no longer query or set display modes that are less than 32
            bits per pixel (bpp); these operations will fail. These apps have a compatibility manifest that targets Windows 8. Windows 8
            still supports 8-bit and 16-bit color modes for desktop apps that were built without a Windows 8 manifest; Windows 8 emulates
            these modes but still runs in 32-bit color mode.
            </para>
            </summary>
            <param name="lpDevMode">
            <para>
            A pointer to a DEVMODE structure that describes the new graphics mode. If lpDevMode is <c>NULL</c>, all the values currently in
            the registry will be used for the display setting. Passing <c>NULL</c> for the lpDevMode parameter and 0 for the dwFlags
            parameter is the easiest way to return to the default mode after a dynamic mode change.
            </para>
            <para>
            The <c>dmSize</c> member of DEVMODE must be initialized to the size, in bytes, of the <c>DEVMODE</c> structure. The
            <c>dmDriverExtra</c> member of <c>DEVMODE</c> must be initialized to indicate the number of bytes of private driver data
            following the <c>DEVMODE</c> structure. In addition, you can use any or all of the following members of the <c>DEVMODE</c> structure.
            </para>
            <list type="table">
            <listheader>
            <term>Member</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>dmBitsPerPel</term>
            <term>Bits per pixel</term>
            </item>
            <item>
            <term>dmPelsWidth</term>
            <term>Pixel width</term>
            </item>
            <item>
            <term>dmPelsHeight</term>
            <term>Pixel height</term>
            </item>
            <item>
            <term>dmDisplayFlags</term>
            <term>Mode flags</term>
            </item>
            <item>
            <term>dmDisplayFrequency</term>
            <term>Mode frequency</term>
            </item>
            <item>
            <term>dmPosition</term>
            <term>Position of the device in a multi-monitor configuration.</term>
            </item>
            </list>
            <para>
            In addition to using one or more of the preceding DEVMODE members, you must also set one or more of the following values in the
            <c>dmFields</c> member to change the display setting.
            </para>
            </param>
            <param name="dwFlags">
            <para>Indicates how the graphics mode should be changed. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The graphics mode for the current screen will be changed dynamically.</term>
            </item>
            <item>
            <term>CDS_FULLSCREEN</term>
            <term>The mode is temporary in nature. If you change to and from another desktop, this mode will not be reset.</term>
            </item>
            <item>
            <term>CDS_GLOBAL</term>
            <term>
            The settings will be saved in the global settings area so that they will affect all users on the machine. Otherwise, only the
            settings for the user are modified. This flag is only valid when specified with the CDS_UPDATEREGISTRY flag.
            </term>
            </item>
            <item>
            <term>CDS_NORESET</term>
            <term>
            The settings will be saved in the registry, but will not take effect. This flag is only valid when specified with the
            CDS_UPDATEREGISTRY flag.
            </term>
            </item>
            <item>
            <term>CDS_RESET</term>
            <term>The settings should be changed, even if the requested settings are the same as the current settings.</term>
            </item>
            <item>
            <term>CDS_SET_PRIMARY</term>
            <term>This device will become the primary device.</term>
            </item>
            <item>
            <term>CDS_TEST</term>
            <term>The system tests if the requested graphics mode could be set.</term>
            </item>
            <item>
            <term>CDS_UPDATEREGISTRY</term>
            <term>
            The graphics mode for the current screen will be changed dynamically and the graphics mode will be updated in the registry. The
            mode information is stored in the USER profile.
            </term>
            </item>
            </list>
            <para>
            Specifying CDS_TEST allows an application to determine which graphics modes are actually valid, without causing the system to
            change to that graphics mode.
            </para>
            <para>
            If CDS_UPDATEREGISTRY is specified and it is possible to change the graphics mode dynamically, the information is stored in the
            registry and DISP_CHANGE_SUCCESSFUL is returned. If it is not possible to change the graphics mode dynamically, the information
            is stored in the registry and DISP_CHANGE_RESTART is returned.
            </para>
            <para>
            If CDS_UPDATEREGISTRY is specified and the information could not be stored in the registry, the graphics mode is not changed and
            DISP_CHANGE_NOTUPDATED is returned.
            </para>
            </param>
            <returns>
            <para>The <c>ChangeDisplaySettings</c> function returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>DISP_CHANGE_SUCCESSFUL</term>
            <term>The settings change was successful.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADDUALVIEW</term>
            <term>The settings change was unsuccessful because the system is DualView capable.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADFLAGS</term>
            <term>An invalid set of flags was passed in.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADMODE</term>
            <term>The graphics mode is not supported.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADPARAM</term>
            <term>An invalid parameter was passed in. This can include an invalid flag or combination of flags.</term>
            </item>
            <item>
            <term>DISP_CHANGE_FAILED</term>
            <term>The display driver failed the specified graphics mode.</term>
            </item>
            <item>
            <term>DISP_CHANGE_NOTUPDATED</term>
            <term>Unable to write settings to the registry.</term>
            </item>
            <item>
            <term>DISP_CHANGE_RESTART</term>
            <term>The computer must be restarted for the graphics mode to work.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            To ensure that the DEVMODE structure passed to <c>ChangeDisplaySettings</c> is valid and contains only values supported by the
            display driver, use the <c>DEVMODE</c> returned by the EnumDisplaySettings function.
            </para>
            <para>
            When the display mode is changed dynamically, the WM_DISPLAYCHANGE message is sent to all running applications with the following
            message parameters.
            </para>
            <list type="table">
            <listheader>
            <term>Parameters</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>wParam</term>
            <term>New bits per pixel</term>
            </item>
            <item>
            <term>LOWORD(lParam)</term>
            <term>New pixel width</term>
            </item>
            <item>
            <term>HIWORD(lParam)</term>
            <term>New pixel height</term>
            </item>
            </list>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. The input given is always in terms of physical pixels, and is not related to
            the calling context.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ChangeDisplaySettingsEx(System.String,Vanara.PInvoke.DEVMODE@,Vanara.PInvoke.HWND,Vanara.PInvoke.User32.ChangeDisplaySettingsFlags,System.IntPtr)">
            <summary>
            <para>
            The <c>ChangeDisplaySettingsEx</c> function changes the settings of the specified display device to the specified graphics mode.
            </para>
            <para>
            <c>Note</c> Apps that you design to target Windows 8 and later can no longer query or set display modes that are less than 32
            bits per pixel (bpp); these operations will fail. These apps have a compatibility manifest that targets Windows 8. Windows 8
            still supports 8-bit and 16-bit color modes for desktop apps that were built without a Windows 8 manifest; Windows 8 emulates
            these modes but still runs in 32-bit color mode.
            </para>
            </summary>
            <param name="lpszDeviceName">
            <para>
            A pointer to a null-terminated string that specifies the display device whose graphics mode will change. Only display device
            names as returned by EnumDisplayDevices are valid. See <c>EnumDisplayDevices</c> for further information on the names associated
            with these display devices.
            </para>
            <para>
            The lpszDeviceName parameter can be <c>NULL</c>. A <c>NULL</c> value specifies the default display device. The default device can
            be determined by calling EnumDisplayDevices and checking for the DISPLAY_DEVICE_PRIMARY_DEVICE flag.
            </para>
            </param>
            <param name="lpDevMode">
            <para>
            A pointer to a DEVMODE structure that describes the new graphics mode. If lpDevMode is <c>NULL</c>, all the values currently in
            the registry will be used for the display setting. Passing <c>NULL</c> for the lpDevMode parameter and 0 for the dwFlags
            parameter is the easiest way to return to the default mode after a dynamic mode change.
            </para>
            <para>
            The <c>dmSize</c> member must be initialized to the size, in bytes, of the DEVMODE structure. The <c>dmDriverExtra</c> member
            must be initialized to indicate the number of bytes of private driver data following the <c>DEVMODE</c> structure. In addition,
            you can use any of the following members of the <c>DEVMODE</c> structure.
            </para>
            <list type="table">
            <listheader>
            <term>Member</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>dmBitsPerPel</term>
            <term>Bits per pixel</term>
            </item>
            <item>
            <term>dmPelsWidth</term>
            <term>Pixel width</term>
            </item>
            <item>
            <term>dmPelsHeight</term>
            <term>Pixel height</term>
            </item>
            <item>
            <term>dmDisplayFlags</term>
            <term>Mode flags</term>
            </item>
            <item>
            <term>dmDisplayFrequency</term>
            <term>Mode frequency</term>
            </item>
            <item>
            <term>dmPosition</term>
            <term>Position of the device in a multi-monitor configuration.</term>
            </item>
            </list>
            <para>
            In addition to using one or more of the preceding DEVMODE members, you must also set one or more of the following values in the
            <c>dmFields</c> member to change the display settings.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DM_BITSPERPEL</term>
            <term>Use the dmBitsPerPel value.</term>
            </item>
            <item>
            <term>DM_PELSWIDTH</term>
            <term>Use the dmPelsWidth value.</term>
            </item>
            <item>
            <term>DM_PELSHEIGHT</term>
            <term>Use the dmPelsHeight value.</term>
            </item>
            <item>
            <term>DM_DISPLAYFLAGS</term>
            <term>Use the dmDisplayFlags value.</term>
            </item>
            <item>
            <term>DM_DISPLAYFREQUENCY</term>
            <term>Use the dmDisplayFrequency value.</term>
            </item>
            <item>
            <term>DM_POSITION</term>
            <term>Use the dmPosition value.</term>
            </item>
            </list>
            </param>
            <param name="hwnd">Reserved; must be <c>NULL</c>.</param>
            <param name="dwflags">
            <para>Indicates how the graphics mode should be changed. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The graphics mode for the current screen will be changed dynamically.</term>
            </item>
            <item>
            <term>CDS_FULLSCREEN</term>
            <term>The mode is temporary in nature. If you change to and from another desktop, this mode will not be reset.</term>
            </item>
            <item>
            <term>CDS_GLOBAL</term>
            <term>
            The settings will be saved in the global settings area so that they will affect all users on the machine. Otherwise, only the
            settings for the user are modified. This flag is only valid when specified with the CDS_UPDATEREGISTRY flag.
            </term>
            </item>
            <item>
            <term>CDS_NORESET</term>
            <term>
            The settings will be saved in the registry, but will not take effect. This flag is only valid when specified with the
            CDS_UPDATEREGISTRY flag.
            </term>
            </item>
            <item>
            <term>CDS_RESET</term>
            <term>The settings should be changed, even if the requested settings are the same as the current settings.</term>
            </item>
            <item>
            <term>CDS_SET_PRIMARY</term>
            <term>This device will become the primary device.</term>
            </item>
            <item>
            <term>CDS_TEST</term>
            <term>The system tests if the requested graphics mode could be set.</term>
            </item>
            <item>
            <term>CDS_UPDATEREGISTRY</term>
            <term>
            The graphics mode for the current screen will be changed dynamically and the graphics mode will be updated in the registry. The
            mode information is stored in the USER profile.
            </term>
            </item>
            <item>
            <term>CDS_VIDEOPARAMETERS</term>
            <term>When set, the lParam parameter is a pointer to a VIDEOPARAMETERS structure.</term>
            </item>
            <item>
            <term>CDS_ENABLE_UNSAFE_MODES</term>
            <term>Enables settings changes to unsafe graphics modes.</term>
            </item>
            <item>
            <term>CDS_DISABLE_UNSAFE_MODES</term>
            <term>Disables settings changes to unsafe graphics modes.</term>
            </item>
            </list>
            <para>
            Specifying CDS_TEST allows an application to determine which graphics modes are actually valid, without causing the system to
            change to them.
            </para>
            <para>
            If CDS_UPDATEREGISTRY is specified and it is possible to change the graphics mode dynamically, the information is stored in the
            registry and DISP_CHANGE_SUCCESSFUL is returned. If it is not possible to change the graphics mode dynamically, the information
            is stored in the registry and DISP_CHANGE_RESTART is returned.
            </para>
            <para>
            If CDS_UPDATEREGISTRY is specified and the information could not be stored in the registry, the graphics mode is not changed and
            DISP_CHANGE_NOTUPDATED is returned.
            </para>
            </param>
            <param name="lParam">
            If dwFlags is <c>CDS_VIDEOPARAMETERS</c>, lParam is a pointer to a VIDEOPARAMETERS structure. Otherwise lParam must be <c>NULL</c>.
            </param>
            <returns>
            <para>The <c>ChangeDisplaySettingsEx</c> function returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>DISP_CHANGE_SUCCESSFUL</term>
            <term>The settings change was successful.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADDUALVIEW</term>
            <term>The settings change was unsuccessful because the system is DualView capable.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADFLAGS</term>
            <term>An invalid set of flags was passed in.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADMODE</term>
            <term>The graphics mode is not supported.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADPARAM</term>
            <term>An invalid parameter was passed in. This can include an invalid flag or combination of flags.</term>
            </item>
            <item>
            <term>DISP_CHANGE_FAILED</term>
            <term>The display driver failed the specified graphics mode.</term>
            </item>
            <item>
            <term>DISP_CHANGE_NOTUPDATED</term>
            <term>Unable to write settings to the registry.</term>
            </item>
            <item>
            <term>DISP_CHANGE_RESTART</term>
            <term>The computer must be restarted for the graphics mode to work.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            To ensure that the DEVMODE structure passed to <c>ChangeDisplaySettingsEx</c> is valid and contains only values supported by the
            display driver, use the <c>DEVMODE</c> returned by the EnumDisplaySettings function.
            </para>
            <para>
            When adding a display monitor to a multiple-monitor system programmatically, set <c>DEVMODE.dmFields</c> to DM_POSITION and
            specify a position (in <c>DEVMODE.dmPosition</c>) for the monitor you are adding that is adjacent to at least one pixel of the
            display area of an existing monitor. To detach the monitor, set <c>DEVMODE.dmFields</c> to DM_POSITION but set
            <c>DEVMODE.dmPelsWidth</c> and <c>DEVMODE.dmPelsHeight</c> to zero. For more information, see Multiple Display Monitors.
            </para>
            <para>
            When the display mode is changed dynamically, the WM_DISPLAYCHANGE message is sent to all running applications with the following
            message parameters.
            </para>
            <list type="table">
            <listheader>
            <term>Parameters</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>wParam</term>
            <term>New bits per pixel</term>
            </item>
            <item>
            <term>LOWORD(lParam)</term>
            <term>New pixel width</term>
            </item>
            <item>
            <term>HIWORD(lParam)</term>
            <term>New pixel height</term>
            </item>
            </list>
            <para>
            To change the settings for more than one display at the same time, first call <c>ChangeDisplaySettingsEx</c> for each device
            individually to update the registry without applying the changes. Then call <c>ChangeDisplaySettingsEx</c> once more, with a
            <c>NULL</c> device, to apply the changes. For example, to change the settings for two displays, do the following:
            </para>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. The input given is always in terms of physical pixels, and is not related to
            the calling context.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ChangeDisplaySettingsEx(System.String,System.IntPtr,Vanara.PInvoke.HWND,Vanara.PInvoke.User32.ChangeDisplaySettingsFlags,System.IntPtr)">
            <summary>
            <para>
            The <c>ChangeDisplaySettingsEx</c> function changes the settings of the specified display device to the specified graphics mode.
            </para>
            <para>
            <c>Note</c> Apps that you design to target Windows 8 and later can no longer query or set display modes that are less than 32
            bits per pixel (bpp); these operations will fail. These apps have a compatibility manifest that targets Windows 8. Windows 8
            still supports 8-bit and 16-bit color modes for desktop apps that were built without a Windows 8 manifest; Windows 8 emulates
            these modes but still runs in 32-bit color mode.
            </para>
            </summary>
            <param name="lpszDeviceName">
            <para>
            A pointer to a null-terminated string that specifies the display device whose graphics mode will change. Only display device
            names as returned by EnumDisplayDevices are valid. See <c>EnumDisplayDevices</c> for further information on the names associated
            with these display devices.
            </para>
            <para>
            The lpszDeviceName parameter can be <c>NULL</c>. A <c>NULL</c> value specifies the default display device. The default device can
            be determined by calling EnumDisplayDevices and checking for the DISPLAY_DEVICE_PRIMARY_DEVICE flag.
            </para>
            </param>
            <param name="lpDevMode">
            <para>
            A pointer to a DEVMODE structure that describes the new graphics mode. If lpDevMode is <c>NULL</c>, all the values currently in
            the registry will be used for the display setting. Passing <c>NULL</c> for the lpDevMode parameter and 0 for the dwFlags
            parameter is the easiest way to return to the default mode after a dynamic mode change.
            </para>
            <para>
            The <c>dmSize</c> member must be initialized to the size, in bytes, of the DEVMODE structure. The <c>dmDriverExtra</c> member
            must be initialized to indicate the number of bytes of private driver data following the <c>DEVMODE</c> structure. In addition,
            you can use any of the following members of the <c>DEVMODE</c> structure.
            </para>
            <list type="table">
            <listheader>
            <term>Member</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>dmBitsPerPel</term>
            <term>Bits per pixel</term>
            </item>
            <item>
            <term>dmPelsWidth</term>
            <term>Pixel width</term>
            </item>
            <item>
            <term>dmPelsHeight</term>
            <term>Pixel height</term>
            </item>
            <item>
            <term>dmDisplayFlags</term>
            <term>Mode flags</term>
            </item>
            <item>
            <term>dmDisplayFrequency</term>
            <term>Mode frequency</term>
            </item>
            <item>
            <term>dmPosition</term>
            <term>Position of the device in a multi-monitor configuration.</term>
            </item>
            </list>
            <para>
            In addition to using one or more of the preceding DEVMODE members, you must also set one or more of the following values in the
            <c>dmFields</c> member to change the display settings.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DM_BITSPERPEL</term>
            <term>Use the dmBitsPerPel value.</term>
            </item>
            <item>
            <term>DM_PELSWIDTH</term>
            <term>Use the dmPelsWidth value.</term>
            </item>
            <item>
            <term>DM_PELSHEIGHT</term>
            <term>Use the dmPelsHeight value.</term>
            </item>
            <item>
            <term>DM_DISPLAYFLAGS</term>
            <term>Use the dmDisplayFlags value.</term>
            </item>
            <item>
            <term>DM_DISPLAYFREQUENCY</term>
            <term>Use the dmDisplayFrequency value.</term>
            </item>
            <item>
            <term>DM_POSITION</term>
            <term>Use the dmPosition value.</term>
            </item>
            </list>
            </param>
            <param name="hwnd">Reserved; must be <c>NULL</c>.</param>
            <param name="dwflags">
            <para>Indicates how the graphics mode should be changed. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The graphics mode for the current screen will be changed dynamically.</term>
            </item>
            <item>
            <term>CDS_FULLSCREEN</term>
            <term>The mode is temporary in nature. If you change to and from another desktop, this mode will not be reset.</term>
            </item>
            <item>
            <term>CDS_GLOBAL</term>
            <term>
            The settings will be saved in the global settings area so that they will affect all users on the machine. Otherwise, only the
            settings for the user are modified. This flag is only valid when specified with the CDS_UPDATEREGISTRY flag.
            </term>
            </item>
            <item>
            <term>CDS_NORESET</term>
            <term>
            The settings will be saved in the registry, but will not take effect. This flag is only valid when specified with the
            CDS_UPDATEREGISTRY flag.
            </term>
            </item>
            <item>
            <term>CDS_RESET</term>
            <term>The settings should be changed, even if the requested settings are the same as the current settings.</term>
            </item>
            <item>
            <term>CDS_SET_PRIMARY</term>
            <term>This device will become the primary device.</term>
            </item>
            <item>
            <term>CDS_TEST</term>
            <term>The system tests if the requested graphics mode could be set.</term>
            </item>
            <item>
            <term>CDS_UPDATEREGISTRY</term>
            <term>
            The graphics mode for the current screen will be changed dynamically and the graphics mode will be updated in the registry. The
            mode information is stored in the USER profile.
            </term>
            </item>
            <item>
            <term>CDS_VIDEOPARAMETERS</term>
            <term>When set, the lParam parameter is a pointer to a VIDEOPARAMETERS structure.</term>
            </item>
            <item>
            <term>CDS_ENABLE_UNSAFE_MODES</term>
            <term>Enables settings changes to unsafe graphics modes.</term>
            </item>
            <item>
            <term>CDS_DISABLE_UNSAFE_MODES</term>
            <term>Disables settings changes to unsafe graphics modes.</term>
            </item>
            </list>
            <para>
            Specifying CDS_TEST allows an application to determine which graphics modes are actually valid, without causing the system to
            change to them.
            </para>
            <para>
            If CDS_UPDATEREGISTRY is specified and it is possible to change the graphics mode dynamically, the information is stored in the
            registry and DISP_CHANGE_SUCCESSFUL is returned. If it is not possible to change the graphics mode dynamically, the information
            is stored in the registry and DISP_CHANGE_RESTART is returned.
            </para>
            <para>
            If CDS_UPDATEREGISTRY is specified and the information could not be stored in the registry, the graphics mode is not changed and
            DISP_CHANGE_NOTUPDATED is returned.
            </para>
            </param>
            <param name="lParam">
            If dwFlags is <c>CDS_VIDEOPARAMETERS</c>, lParam is a pointer to a VIDEOPARAMETERS structure. Otherwise lParam must be <c>NULL</c>.
            </param>
            <returns>
            <para>The <c>ChangeDisplaySettingsEx</c> function returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>DISP_CHANGE_SUCCESSFUL</term>
            <term>The settings change was successful.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADDUALVIEW</term>
            <term>The settings change was unsuccessful because the system is DualView capable.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADFLAGS</term>
            <term>An invalid set of flags was passed in.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADMODE</term>
            <term>The graphics mode is not supported.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADPARAM</term>
            <term>An invalid parameter was passed in. This can include an invalid flag or combination of flags.</term>
            </item>
            <item>
            <term>DISP_CHANGE_FAILED</term>
            <term>The display driver failed the specified graphics mode.</term>
            </item>
            <item>
            <term>DISP_CHANGE_NOTUPDATED</term>
            <term>Unable to write settings to the registry.</term>
            </item>
            <item>
            <term>DISP_CHANGE_RESTART</term>
            <term>The computer must be restarted for the graphics mode to work.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            To ensure that the DEVMODE structure passed to <c>ChangeDisplaySettingsEx</c> is valid and contains only values supported by the
            display driver, use the <c>DEVMODE</c> returned by the EnumDisplaySettings function.
            </para>
            <para>
            When adding a display monitor to a multiple-monitor system programmatically, set <c>DEVMODE.dmFields</c> to DM_POSITION and
            specify a position (in <c>DEVMODE.dmPosition</c>) for the monitor you are adding that is adjacent to at least one pixel of the
            display area of an existing monitor. To detach the monitor, set <c>DEVMODE.dmFields</c> to DM_POSITION but set
            <c>DEVMODE.dmPelsWidth</c> and <c>DEVMODE.dmPelsHeight</c> to zero. For more information, see Multiple Display Monitors.
            </para>
            <para>
            When the display mode is changed dynamically, the WM_DISPLAYCHANGE message is sent to all running applications with the following
            message parameters.
            </para>
            <list type="table">
            <listheader>
            <term>Parameters</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>wParam</term>
            <term>New bits per pixel</term>
            </item>
            <item>
            <term>LOWORD(lParam)</term>
            <term>New pixel width</term>
            </item>
            <item>
            <term>HIWORD(lParam)</term>
            <term>New pixel height</term>
            </item>
            </list>
            <para>
            To change the settings for more than one display at the same time, first call <c>ChangeDisplaySettingsEx</c> for each device
            individually to update the registry without applying the changes. Then call <c>ChangeDisplaySettingsEx</c> once more, with a
            <c>NULL</c> device, to apply the changes. For example, to change the settings for two displays, do the following:
            </para>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. The input given is always in terms of physical pixels, and is not related to
            the calling context.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ChangeDisplaySettingsEx(System.String,Vanara.PInvoke.DEVMODE@,Vanara.PInvoke.HWND,Vanara.PInvoke.User32.ChangeDisplaySettingsFlags,Vanara.PInvoke.User32.VIDEOPARAMETERS@)">
            <summary>
            <para>
            The <c>ChangeDisplaySettingsEx</c> function changes the settings of the specified display device to the specified graphics mode.
            </para>
            <para>
            <c>Note</c> Apps that you design to target Windows 8 and later can no longer query or set display modes that are less than 32
            bits per pixel (bpp); these operations will fail. These apps have a compatibility manifest that targets Windows 8. Windows 8
            still supports 8-bit and 16-bit color modes for desktop apps that were built without a Windows 8 manifest; Windows 8 emulates
            these modes but still runs in 32-bit color mode.
            </para>
            </summary>
            <param name="lpszDeviceName">
            <para>
            A pointer to a null-terminated string that specifies the display device whose graphics mode will change. Only display device
            names as returned by EnumDisplayDevices are valid. See <c>EnumDisplayDevices</c> for further information on the names associated
            with these display devices.
            </para>
            <para>
            The lpszDeviceName parameter can be <c>NULL</c>. A <c>NULL</c> value specifies the default display device. The default device can
            be determined by calling EnumDisplayDevices and checking for the DISPLAY_DEVICE_PRIMARY_DEVICE flag.
            </para>
            </param>
            <param name="lpDevMode">
            <para>
            A pointer to a DEVMODE structure that describes the new graphics mode. If lpDevMode is <c>NULL</c>, all the values currently in
            the registry will be used for the display setting. Passing <c>NULL</c> for the lpDevMode parameter and 0 for the dwFlags
            parameter is the easiest way to return to the default mode after a dynamic mode change.
            </para>
            <para>
            The <c>dmSize</c> member must be initialized to the size, in bytes, of the DEVMODE structure. The <c>dmDriverExtra</c> member
            must be initialized to indicate the number of bytes of private driver data following the <c>DEVMODE</c> structure. In addition,
            you can use any of the following members of the <c>DEVMODE</c> structure.
            </para>
            <list type="table">
            <listheader>
            <term>Member</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>dmBitsPerPel</term>
            <term>Bits per pixel</term>
            </item>
            <item>
            <term>dmPelsWidth</term>
            <term>Pixel width</term>
            </item>
            <item>
            <term>dmPelsHeight</term>
            <term>Pixel height</term>
            </item>
            <item>
            <term>dmDisplayFlags</term>
            <term>Mode flags</term>
            </item>
            <item>
            <term>dmDisplayFrequency</term>
            <term>Mode frequency</term>
            </item>
            <item>
            <term>dmPosition</term>
            <term>Position of the device in a multi-monitor configuration.</term>
            </item>
            </list>
            <para>
            In addition to using one or more of the preceding DEVMODE members, you must also set one or more of the following values in the
            <c>dmFields</c> member to change the display settings.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DM_BITSPERPEL</term>
            <term>Use the dmBitsPerPel value.</term>
            </item>
            <item>
            <term>DM_PELSWIDTH</term>
            <term>Use the dmPelsWidth value.</term>
            </item>
            <item>
            <term>DM_PELSHEIGHT</term>
            <term>Use the dmPelsHeight value.</term>
            </item>
            <item>
            <term>DM_DISPLAYFLAGS</term>
            <term>Use the dmDisplayFlags value.</term>
            </item>
            <item>
            <term>DM_DISPLAYFREQUENCY</term>
            <term>Use the dmDisplayFrequency value.</term>
            </item>
            <item>
            <term>DM_POSITION</term>
            <term>Use the dmPosition value.</term>
            </item>
            </list>
            </param>
            <param name="hwnd">Reserved; must be <c>NULL</c>.</param>
            <param name="dwflags">
            <para>Indicates how the graphics mode should be changed. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The graphics mode for the current screen will be changed dynamically.</term>
            </item>
            <item>
            <term>CDS_FULLSCREEN</term>
            <term>The mode is temporary in nature. If you change to and from another desktop, this mode will not be reset.</term>
            </item>
            <item>
            <term>CDS_GLOBAL</term>
            <term>
            The settings will be saved in the global settings area so that they will affect all users on the machine. Otherwise, only the
            settings for the user are modified. This flag is only valid when specified with the CDS_UPDATEREGISTRY flag.
            </term>
            </item>
            <item>
            <term>CDS_NORESET</term>
            <term>
            The settings will be saved in the registry, but will not take effect. This flag is only valid when specified with the
            CDS_UPDATEREGISTRY flag.
            </term>
            </item>
            <item>
            <term>CDS_RESET</term>
            <term>The settings should be changed, even if the requested settings are the same as the current settings.</term>
            </item>
            <item>
            <term>CDS_SET_PRIMARY</term>
            <term>This device will become the primary device.</term>
            </item>
            <item>
            <term>CDS_TEST</term>
            <term>The system tests if the requested graphics mode could be set.</term>
            </item>
            <item>
            <term>CDS_UPDATEREGISTRY</term>
            <term>
            The graphics mode for the current screen will be changed dynamically and the graphics mode will be updated in the registry. The
            mode information is stored in the USER profile.
            </term>
            </item>
            <item>
            <term>CDS_VIDEOPARAMETERS</term>
            <term>When set, the lParam parameter is a pointer to a VIDEOPARAMETERS structure.</term>
            </item>
            <item>
            <term>CDS_ENABLE_UNSAFE_MODES</term>
            <term>Enables settings changes to unsafe graphics modes.</term>
            </item>
            <item>
            <term>CDS_DISABLE_UNSAFE_MODES</term>
            <term>Disables settings changes to unsafe graphics modes.</term>
            </item>
            </list>
            <para>
            Specifying CDS_TEST allows an application to determine which graphics modes are actually valid, without causing the system to
            change to them.
            </para>
            <para>
            If CDS_UPDATEREGISTRY is specified and it is possible to change the graphics mode dynamically, the information is stored in the
            registry and DISP_CHANGE_SUCCESSFUL is returned. If it is not possible to change the graphics mode dynamically, the information
            is stored in the registry and DISP_CHANGE_RESTART is returned.
            </para>
            <para>
            If CDS_UPDATEREGISTRY is specified and the information could not be stored in the registry, the graphics mode is not changed and
            DISP_CHANGE_NOTUPDATED is returned.
            </para>
            </param>
            <param name="lParam">
            If dwFlags is <c>CDS_VIDEOPARAMETERS</c>, lParam is a pointer to a VIDEOPARAMETERS structure. Otherwise lParam must be <c>NULL</c>.
            </param>
            <returns>
            <para>The <c>ChangeDisplaySettingsEx</c> function returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>DISP_CHANGE_SUCCESSFUL</term>
            <term>The settings change was successful.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADDUALVIEW</term>
            <term>The settings change was unsuccessful because the system is DualView capable.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADFLAGS</term>
            <term>An invalid set of flags was passed in.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADMODE</term>
            <term>The graphics mode is not supported.</term>
            </item>
            <item>
            <term>DISP_CHANGE_BADPARAM</term>
            <term>An invalid parameter was passed in. This can include an invalid flag or combination of flags.</term>
            </item>
            <item>
            <term>DISP_CHANGE_FAILED</term>
            <term>The display driver failed the specified graphics mode.</term>
            </item>
            <item>
            <term>DISP_CHANGE_NOTUPDATED</term>
            <term>Unable to write settings to the registry.</term>
            </item>
            <item>
            <term>DISP_CHANGE_RESTART</term>
            <term>The computer must be restarted for the graphics mode to work.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            To ensure that the DEVMODE structure passed to <c>ChangeDisplaySettingsEx</c> is valid and contains only values supported by the
            display driver, use the <c>DEVMODE</c> returned by the EnumDisplaySettings function.
            </para>
            <para>
            When adding a display monitor to a multiple-monitor system programmatically, set <c>DEVMODE.dmFields</c> to DM_POSITION and
            specify a position (in <c>DEVMODE.dmPosition</c>) for the monitor you are adding that is adjacent to at least one pixel of the
            display area of an existing monitor. To detach the monitor, set <c>DEVMODE.dmFields</c> to DM_POSITION but set
            <c>DEVMODE.dmPelsWidth</c> and <c>DEVMODE.dmPelsHeight</c> to zero. For more information, see Multiple Display Monitors.
            </para>
            <para>
            When the display mode is changed dynamically, the WM_DISPLAYCHANGE message is sent to all running applications with the following
            message parameters.
            </para>
            <list type="table">
            <listheader>
            <term>Parameters</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>wParam</term>
            <term>New bits per pixel</term>
            </item>
            <item>
            <term>LOWORD(lParam)</term>
            <term>New pixel width</term>
            </item>
            <item>
            <term>HIWORD(lParam)</term>
            <term>New pixel height</term>
            </item>
            </list>
            <para>
            To change the settings for more than one display at the same time, first call <c>ChangeDisplaySettingsEx</c> for each device
            individually to update the registry without applying the changes. Then call <c>ChangeDisplaySettingsEx</c> once more, with a
            <c>NULL</c> device, to apply the changes. For example, to change the settings for two displays, do the following:
            </para>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. The input given is always in terms of physical pixels, and is not related to
            the calling context.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CopyImage(Vanara.PInvoke.HANDLE,Vanara.PInvoke.User32.LoadImageType,System.Int32,System.Int32,Vanara.PInvoke.User32.CopyImageOptions)">
            <summary>
            Creates a new image (icon, cursor, or bitmap) and copies the attributes of the specified image to the new one. If necessary, the
            function stretches the bits to fit the desired size of the new image.
            </summary>
            <param name="h">
            <para>Type: <c>HANDLE</c></para>
            <para>A handle to the image to be copied.</para>
            </param>
            <param name="type">
            <para>Type: <c>UINT</c></para>
            <para>The type of image to be copied. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IMAGE_BITMAP 0</term>
            <term>Copies a bitmap.</term>
            </item>
            <item>
            <term>IMAGE_CURSOR 2</term>
            <term>Copies a cursor.</term>
            </item>
            <item>
            <term>IMAGE_ICON 1</term>
            <term>Copies an icon.</term>
            </item>
            </list>
            </param>
            <param name="cx">
            <para>Type: <c>int</c></para>
            <para>
            The desired width, in pixels, of the image. If this is zero, then the returned image will have the same width as the original hImage.
            </para>
            </param>
            <param name="cy">
            <para>Type: <c>int</c></para>
            <para>
            The desired height, in pixels, of the image. If this is zero, then the returned image will have the same height as the original hImage.
            </para>
            </param>
            <param name="flags">
            <para>Type: <c>UINT</c></para>
            <para>This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>LR_COPYDELETEORG 0x00000008</term>
            <term>Deletes the original image after creating the copy.</term>
            </item>
            <item>
            <term>LR_COPYFROMRESOURCE 0x00004000</term>
            <term>
            Tries to reload an icon or cursor resource from the original resource file rather than simply copying the current image. This is
            useful for creating a different-sized copy when the resource file contains multiple sizes of the resource. Without this flag,
            CopyImage stretches the original image to the new size. If this flag is set, CopyImage uses the size in the resource file closest
            to the desired size. This will succeed only if hImage was loaded by LoadIcon or LoadCursor, or by LoadImage with the LR_SHARED flag.
            </term>
            </item>
            <item>
            <term>LR_COPYRETURNORG 0x00000004</term>
            <term>
            Returns the original hImage if it satisfies the criteria for the copy—that is, correct dimensions and color depth—in which case
            the LR_COPYDELETEORG flag is ignored. If this flag is not specified, a new object is always created.
            </term>
            </item>
            <item>
            <term>LR_CREATEDIBSECTION 0x00002000</term>
            <term>
            If this is set and a new bitmap is created, the bitmap is created as a DIB section. Otherwise, the bitmap image is created as a
            device-dependent bitmap. This flag is only valid if uType is IMAGE_BITMAP.
            </term>
            </item>
            <item>
            <term>LR_DEFAULTSIZE 0x00000040</term>
            <term>
            Uses the width or height specified by the system metric values for cursors or icons, if the cxDesired or cyDesired values are set
            to zero. If this flag is not specified and cxDesired and cyDesired are set to zero, the function uses the actual resource size.
            If the resource contains multiple images, the function uses the size of the first image.
            </term>
            </item>
            <item>
            <term>LR_MONOCHROME 0x00000001</term>
            <term>Creates a new monochrome image.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>HANDLE</c></para>
            <para>If the function succeeds, the return value is the handle to the newly created image.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            When you are finished using the resource, you can release its associated memory by calling one of the functions in the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Resource</term>
            <term>Release function</term>
            </listheader>
            <item>
            <term>Bitmap</term>
            <term>DeleteObject</term>
            </item>
            <item>
            <term>Cursor</term>
            <term>DestroyCursor</term>
            </item>
            <item>
            <term>Icon</term>
            <term>DestroyIcon</term>
            </item>
            </list>
            <para>
            The system automatically deletes the resource when its process terminates, however, calling the appropriate function saves memory
            and decreases the size of the process's working set.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DrawText(Vanara.PInvoke.HDC,System.String,System.Int32,Vanara.PInvoke.RECT@,Vanara.PInvoke.DrawTextFlags)">
            <summary>
            The DrawText function draws formatted text in the specified rectangle. It formats the text according to the specified method
            (expanding tabs, justifying characters, breaking lines, and so forth).
            </summary>
            <param name="hDC">A handle to the device context.</param>
            <param name="lpchText">
            A pointer to the string that specifies the text to be drawn. If the nCount parameter is -1, the string must be null-terminated.
            If uFormat includes DT_MODIFYSTRING, the function could add up to four additional characters to this string. The buffer
            containing the string should be large enough to accommodate these extra characters.
            </param>
            <param name="nCount">
            The length, in characters, of the string. If nCount is -1, then the lpchText parameter is assumed to be a pointer to a
            null-terminated string and DrawText computes the character count automatically.
            </param>
            <param name="lpRect">
            A pointer to a RECT structure that contains the rectangle (in logical coordinates) in which the text is to be formatted.
            </param>
            <param name="uFormat">The method of formatting the text.</param>
            <returns>
            If the function succeeds, the return value is the height of the text in logical units. If DT_VCENTER or DT_BOTTOM is specified,
            the return value is the offset from lpRect-&gt;top to the bottom of the drawn text. If the function fails, the return value is zero.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.DrawText(Vanara.PInvoke.HDC,System.Text.StringBuilder,System.Int32,Vanara.PInvoke.RECT@,Vanara.PInvoke.DrawTextFlags)">
            <summary>
            The DrawText function draws formatted text in the specified rectangle. It formats the text according to the specified method
            (expanding tabs, justifying characters, breaking lines, and so forth).
            </summary>
            <param name="hDC">A handle to the device context.</param>
            <param name="lpchText">
            A pointer to the string that specifies the text to be drawn. If the nCount parameter is -1, the string must be null-terminated.
            If uFormat includes DT_MODIFYSTRING, the function could add up to four additional characters to this string. The buffer
            containing the string should be large enough to accommodate these extra characters.
            </param>
            <param name="nCount">
            The length, in characters, of the string. If nCount is -1, then the lpchText parameter is assumed to be a pointer to a
            null-terminated string and DrawText computes the character count automatically.
            </param>
            <param name="lpRect">
            A pointer to a RECT structure that contains the rectangle (in logical coordinates) in which the text is to be formatted.
            </param>
            <param name="uFormat">The method of formatting the text.</param>
            <returns>
            If the function succeeds, the return value is the height of the text in logical units. If DT_VCENTER or DT_BOTTOM is specified,
            the return value is the offset from lpRect-&gt;top to the bottom of the drawn text. If the function fails, the return value is zero.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.DrawTextEx(Vanara.PInvoke.HDC,System.String,System.Int32,Vanara.PInvoke.RECT@,Vanara.PInvoke.DrawTextFlags,Vanara.PInvoke.User32.DRAWTEXTPARAMS)">
            <summary>The <c>DrawTextEx</c> function draws formatted text in the specified rectangle.</summary>
            <param name="hdc">A handle to the device context in which to draw.</param>
            <param name="lpchText">
            <para>A pointer to the string that contains the text to draw. If the cchText parameter is -1, the string must be null-terminated.</para>
            <para>
            If dwDTFormat includes DT_MODIFYSTRING, the function could add up to four additional characters to this string. The buffer
            containing the string should be large enough to accommodate these extra characters.
            </para>
            </param>
            <param name="cchText">
            The length of the string pointed to by lpchText. If cchText is -1, then the lpchText parameter is assumed to be a pointer to a
            null-terminated string and <c>DrawTextEx</c> computes the character count automatically.
            </param>
            <param name="lprc">
            A pointer to a RECT structure that contains the rectangle, in logical coordinates, in which the text is to be formatted.
            </param>
            <param name="format">
            <para>The formatting options. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DT_BOTTOM</term>
            <term>Justifies the text to the bottom of the rectangle. This value is used only with the DT_SINGLELINE value.</term>
            </item>
            <item>
            <term>DT_CALCRECT</term>
            <term>
            Determines the width and height of the rectangle. If there are multiple lines of text, DrawTextEx uses the width of the rectangle
            pointed to by the lprc parameter and extends the base of the rectangle to bound the last line of text. If there is only one line
            of text, DrawTextEx modifies the right side of the rectangle so that it bounds the last character in the line. In either case,
            DrawTextEx returns the height of the formatted text, but does not draw the text.
            </term>
            </item>
            <item>
            <term>DT_CENTER</term>
            <term>Centers text horizontally in the rectangle.</term>
            </item>
            <item>
            <term>DT_EDITCONTROL</term>
            <term>
            Duplicates the text-displaying characteristics of a multiline edit control. Specifically, the average character width is
            calculated in the same manner as for an edit control, and the function does not display a partially visible last line.
            </term>
            </item>
            <item>
            <term>DT_END_ELLIPSIS</term>
            <term>
            For displayed text, replaces the end of a string with ellipses so that the result fits in the specified rectangle. Any word (not
            at the end of the string) that goes beyond the limits of the rectangle is truncated without ellipses. The string is not modified
            unless the DT_MODIFYSTRING flag is specified. Compare with DT_PATH_ELLIPSIS and DT_WORD_ELLIPSIS.
            </term>
            </item>
            <item>
            <term>DT_EXPANDTABS</term>
            <term>Expands tab characters. The default number of characters per tab is eight.</term>
            </item>
            <item>
            <term>DT_EXTERNALLEADING</term>
            <term>
            Includes the font external leading in line height. Normally, external leading is not included in the height of a line of text.
            </term>
            </item>
            <item>
            <term>DT_HIDEPREFIX</term>
            <term>
            Ignores the ampersand (&amp;) prefix character in the text. The letter that follows will not be underlined, but other
            mnemonic-prefix characters are still processed. Example: input string: "A&amp;bc&amp;&amp;d" normal: "Ac&amp;d" DT_HIDEPREFIX:
            "Abc&amp;d" Compare with DT_NOPREFIX and DT_PREFIXONLY.
            </term>
            </item>
            <item>
            <term>DT_INTERNAL</term>
            <term>Uses the system font to calculate text metrics.</term>
            </item>
            <item>
            <term>DT_LEFT</term>
            <term>Aligns text to the left.</term>
            </item>
            <item>
            <term>DT_MODIFYSTRING</term>
            <term>
            Modifies the specified string to match the displayed text. This value has no effect unless DT_END_ELLIPSIS or DT_PATH_ELLIPSIS is specified.
            </term>
            </item>
            <item>
            <term>DT_NOCLIP</term>
            <term>Draws without clipping. DrawTextEx is somewhat faster when DT_NOCLIP is used.</term>
            </item>
            <item>
            <term>DT_NOFULLWIDTHCHARBREAK</term>
            <term>
            Prevents a line break at a DBCS (double-wide character string), so that the line-breaking rule is equivalent to SBCS strings. For
            example, this can be used in Korean windows, for more readability of icon labels. This value has no effect unless DT_WORDBREAK is specified.
            </term>
            </item>
            <item>
            <term>DT_NOPREFIX</term>
            <term>
            Turns off processing of prefix characters. Normally, DrawTextEx interprets the ampersand (&amp;) mnemonic-prefix character as a
            directive to underscore the character that follows, and the double-ampersand (&amp;&amp;) mnemonic-prefix characters as a
            directive to print a single ampersand. By specifying DT_NOPREFIX, this processing is turned off. Compare with DT_HIDEPREFIX and DT_PREFIXONLY
            </term>
            </item>
            <item>
            <term>DT_PATH_ELLIPSIS</term>
            <term>
            For displayed text, replaces characters in the middle of the string with ellipses so that the result fits in the specified
            rectangle. If the string contains backslash (\) characters, DT_PATH_ELLIPSIS preserves as much as possible of the text after the
            last backslash. The string is not modified unless the DT_MODIFYSTRING flag is specified. Compare with DT_END_ELLIPSIS and DT_WORD_ELLIPSIS.
            </term>
            </item>
            <item>
            <term>DT_PREFIXONLY</term>
            <term>
            Draws only an underline at the position of the character following the ampersand (&amp;) prefix character. Does not draw any
            character in the string. Example: input string: "A&amp;bc&amp;&amp;d" normal: "Ac&amp;d" PREFIXONLY: " _ " Compare with
            DT_NOPREFIX and DT_HIDEPREFIX.
            </term>
            </item>
            <item>
            <term>DT_RIGHT</term>
            <term>Aligns text to the right.</term>
            </item>
            <item>
            <term>DT_RTLREADING</term>
            <term>
            Layout in right-to-left reading order for bidirectional text when the font selected into the hdc is a Hebrew or Arabic font. The
            default reading order for all text is left-to-right.
            </term>
            </item>
            <item>
            <term>DT_SINGLELINE</term>
            <term>Displays text on a single line only. Carriage returns and line feeds do not break the line.</term>
            </item>
            <item>
            <term>DT_TABSTOP</term>
            <term>
            Sets tab stops. The DRAWTEXTPARAMS structure pointed to by the lpDTParams parameter specifies the number of average character
            widths per tab stop.
            </term>
            </item>
            <item>
            <term>DT_TOP</term>
            <term>Justifies the text to the top of the rectangle.</term>
            </item>
            <item>
            <term>DT_VCENTER</term>
            <term>Centers text vertically. This value is used only with the DT_SINGLELINE value.</term>
            </item>
            <item>
            <term>DT_WORDBREAK</term>
            <term>
            Breaks words. Lines are automatically broken between words if a word extends past the edge of the rectangle specified by the lprc
            parameter. A carriage return-line feed sequence also breaks the line.
            </term>
            </item>
            <item>
            <term>DT_WORD_ELLIPSIS</term>
            <term>Truncates any word that does not fit in the rectangle and adds ellipses. Compare with DT_END_ELLIPSIS and DT_PATH_ELLIPSIS.</term>
            </item>
            </list>
            </param>
            <param name="lpdtp">
            A pointer to a DRAWTEXTPARAMS structure that specifies additional formatting options. This parameter can be <c>NULL</c>.
            </param>
            <returns>
            <para>
            If the function succeeds, the return value is the text height in logical units. If DT_VCENTER or DT_BOTTOM is specified, the
            return value is the offset from to the bottom of the drawn text
            </para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>The <c>DrawTextEx</c> function supports only fonts whose escapement and orientation are both zero.</para>
            <para>The text alignment mode for the device context must include the TA_LEFT, TA_TOP, and TA_NOUPDATECP flags.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DrawTextEx(Vanara.PInvoke.HDC,System.Text.StringBuilder,System.Int32,Vanara.PInvoke.RECT@,Vanara.PInvoke.DrawTextFlags,Vanara.PInvoke.User32.DRAWTEXTPARAMS)">
            <summary>The <c>DrawTextEx</c> function draws formatted text in the specified rectangle.</summary>
            <param name="hdc">A handle to the device context in which to draw.</param>
            <param name="lpchText">
            <para>A pointer to the string that contains the text to draw. If the cchText parameter is -1, the string must be null-terminated.</para>
            <para>
            If dwDTFormat includes DT_MODIFYSTRING, the function could add up to four additional characters to this string. The buffer
            containing the string should be large enough to accommodate these extra characters.
            </para>
            </param>
            <param name="cchText">
            The length of the string pointed to by lpchText. If cchText is -1, then the lpchText parameter is assumed to be a pointer to a
            null-terminated string and <c>DrawTextEx</c> computes the character count automatically.
            </param>
            <param name="lprc">
            A pointer to a RECT structure that contains the rectangle, in logical coordinates, in which the text is to be formatted.
            </param>
            <param name="format">
            <para>The formatting options. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DT_BOTTOM</term>
            <term>Justifies the text to the bottom of the rectangle. This value is used only with the DT_SINGLELINE value.</term>
            </item>
            <item>
            <term>DT_CALCRECT</term>
            <term>
            Determines the width and height of the rectangle. If there are multiple lines of text, DrawTextEx uses the width of the rectangle
            pointed to by the lprc parameter and extends the base of the rectangle to bound the last line of text. If there is only one line
            of text, DrawTextEx modifies the right side of the rectangle so that it bounds the last character in the line. In either case,
            DrawTextEx returns the height of the formatted text, but does not draw the text.
            </term>
            </item>
            <item>
            <term>DT_CENTER</term>
            <term>Centers text horizontally in the rectangle.</term>
            </item>
            <item>
            <term>DT_EDITCONTROL</term>
            <term>
            Duplicates the text-displaying characteristics of a multiline edit control. Specifically, the average character width is
            calculated in the same manner as for an edit control, and the function does not display a partially visible last line.
            </term>
            </item>
            <item>
            <term>DT_END_ELLIPSIS</term>
            <term>
            For displayed text, replaces the end of a string with ellipses so that the result fits in the specified rectangle. Any word (not
            at the end of the string) that goes beyond the limits of the rectangle is truncated without ellipses. The string is not modified
            unless the DT_MODIFYSTRING flag is specified. Compare with DT_PATH_ELLIPSIS and DT_WORD_ELLIPSIS.
            </term>
            </item>
            <item>
            <term>DT_EXPANDTABS</term>
            <term>Expands tab characters. The default number of characters per tab is eight.</term>
            </item>
            <item>
            <term>DT_EXTERNALLEADING</term>
            <term>
            Includes the font external leading in line height. Normally, external leading is not included in the height of a line of text.
            </term>
            </item>
            <item>
            <term>DT_HIDEPREFIX</term>
            <term>
            Ignores the ampersand (&amp;) prefix character in the text. The letter that follows will not be underlined, but other
            mnemonic-prefix characters are still processed. Example: input string: "A&amp;bc&amp;&amp;d" normal: "Ac&amp;d" DT_HIDEPREFIX:
            "Abc&amp;d" Compare with DT_NOPREFIX and DT_PREFIXONLY.
            </term>
            </item>
            <item>
            <term>DT_INTERNAL</term>
            <term>Uses the system font to calculate text metrics.</term>
            </item>
            <item>
            <term>DT_LEFT</term>
            <term>Aligns text to the left.</term>
            </item>
            <item>
            <term>DT_MODIFYSTRING</term>
            <term>
            Modifies the specified string to match the displayed text. This value has no effect unless DT_END_ELLIPSIS or DT_PATH_ELLIPSIS is specified.
            </term>
            </item>
            <item>
            <term>DT_NOCLIP</term>
            <term>Draws without clipping. DrawTextEx is somewhat faster when DT_NOCLIP is used.</term>
            </item>
            <item>
            <term>DT_NOFULLWIDTHCHARBREAK</term>
            <term>
            Prevents a line break at a DBCS (double-wide character string), so that the line-breaking rule is equivalent to SBCS strings. For
            example, this can be used in Korean windows, for more readability of icon labels. This value has no effect unless DT_WORDBREAK is specified.
            </term>
            </item>
            <item>
            <term>DT_NOPREFIX</term>
            <term>
            Turns off processing of prefix characters. Normally, DrawTextEx interprets the ampersand (&amp;) mnemonic-prefix character as a
            directive to underscore the character that follows, and the double-ampersand (&amp;&amp;) mnemonic-prefix characters as a
            directive to print a single ampersand. By specifying DT_NOPREFIX, this processing is turned off. Compare with DT_HIDEPREFIX and DT_PREFIXONLY
            </term>
            </item>
            <item>
            <term>DT_PATH_ELLIPSIS</term>
            <term>
            For displayed text, replaces characters in the middle of the string with ellipses so that the result fits in the specified
            rectangle. If the string contains backslash (\) characters, DT_PATH_ELLIPSIS preserves as much as possible of the text after the
            last backslash. The string is not modified unless the DT_MODIFYSTRING flag is specified. Compare with DT_END_ELLIPSIS and DT_WORD_ELLIPSIS.
            </term>
            </item>
            <item>
            <term>DT_PREFIXONLY</term>
            <term>
            Draws only an underline at the position of the character following the ampersand (&amp;) prefix character. Does not draw any
            character in the string. Example: input string: "A&amp;bc&amp;&amp;d" normal: "Ac&amp;d" PREFIXONLY: " _ " Compare with
            DT_NOPREFIX and DT_HIDEPREFIX.
            </term>
            </item>
            <item>
            <term>DT_RIGHT</term>
            <term>Aligns text to the right.</term>
            </item>
            <item>
            <term>DT_RTLREADING</term>
            <term>
            Layout in right-to-left reading order for bidirectional text when the font selected into the hdc is a Hebrew or Arabic font. The
            default reading order for all text is left-to-right.
            </term>
            </item>
            <item>
            <term>DT_SINGLELINE</term>
            <term>Displays text on a single line only. Carriage returns and line feeds do not break the line.</term>
            </item>
            <item>
            <term>DT_TABSTOP</term>
            <term>
            Sets tab stops. The DRAWTEXTPARAMS structure pointed to by the lpDTParams parameter specifies the number of average character
            widths per tab stop.
            </term>
            </item>
            <item>
            <term>DT_TOP</term>
            <term>Justifies the text to the top of the rectangle.</term>
            </item>
            <item>
            <term>DT_VCENTER</term>
            <term>Centers text vertically. This value is used only with the DT_SINGLELINE value.</term>
            </item>
            <item>
            <term>DT_WORDBREAK</term>
            <term>
            Breaks words. Lines are automatically broken between words if a word extends past the edge of the rectangle specified by the lprc
            parameter. A carriage return-line feed sequence also breaks the line.
            </term>
            </item>
            <item>
            <term>DT_WORD_ELLIPSIS</term>
            <term>Truncates any word that does not fit in the rectangle and adds ellipses. Compare with DT_END_ELLIPSIS and DT_PATH_ELLIPSIS.</term>
            </item>
            </list>
            </param>
            <param name="lpdtp">
            A pointer to a DRAWTEXTPARAMS structure that specifies additional formatting options. This parameter can be <c>NULL</c>.
            </param>
            <returns>
            <para>
            If the function succeeds, the return value is the text height in logical units. If DT_VCENTER or DT_BOTTOM is specified, the
            return value is the offset from to the bottom of the drawn text
            </para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>The <c>DrawTextEx</c> function supports only fonts whose escapement and orientation are both zero.</para>
            <para>The text alignment mode for the device context must include the TA_LEFT, TA_TOP, and TA_NOUPDATECP flags.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetDC(Vanara.PInvoke.HWND)">
            <summary>
            The GetDC function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire
            screen. You can use the returned handle in subsequent GDI functions to draw in the DC. The device context is an opaque data
            structure, whose values are used internally by GDI.
            </summary>
            <param name="ptr">
            A handle to the window whose DC is to be retrieved. If this value is NULL, GetDC retrieves the DC for the entire screen.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the DC for the specified window's client area. If the function fails,
            the return value is NULL.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetDCEx(Vanara.PInvoke.HWND,Vanara.PInvoke.HRGN,Vanara.PInvoke.User32.DCX)">
            <summary>
            <para>
            The <c>GetDCEx</c> function retrieves a handle to a device context (DC) for the client area of a specified window or for the
            entire screen. You can use the returned handle in subsequent GDI functions to draw in the DC. The device context is an opaque
            data structure, whose values are used internally by GDI.
            </para>
            <para>
            This function is an extension to the GetDC function, which gives an application more control over how and whether clipping occurs
            in the client area.
            </para>
            </summary>
            <param name="hWnd">
            A handle to the window whose DC is to be retrieved. If this value is <c>NULL</c>, <c>GetDCEx</c> retrieves the DC for the entire screen.
            </param>
            <param name="hrgnClip">
            A clipping region that may be combined with the visible region of the DC. If the value of flags is DCX_INTERSECTRGN or
            DCX_EXCLUDERGN, then the operating system assumes ownership of the region and will automatically delete it when it is no longer
            needed. In this case, the application should not use or delete the region after a successful call to <c>GetDCEx</c>.
            </param>
            <param name="flags">
            <para>Specifies how the DC is created. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DCX_WINDOW</term>
            <term>Returns a DC that corresponds to the window rectangle rather than the client rectangle.</term>
            </item>
            <item>
            <term>DCX_CACHE</term>
            <term>Returns a DC from the cache, rather than the OWNDC or CLASSDC window. Essentially overrides CS_OWNDC and CS_CLASSDC.</term>
            </item>
            <item>
            <term>DCX_PARENTCLIP</term>
            <term>
            Uses the visible region of the parent window. The parent's WS_CLIPCHILDREN and CS_PARENTDC style bits are ignored. The origin is
            set to the upper-left corner of the window identified by hWnd.
            </term>
            </item>
            <item>
            <term>DCX_CLIPSIBLINGS</term>
            <term>Excludes the visible regions of all sibling windows above the window identified by hWnd.</term>
            </item>
            <item>
            <term>DCX_CLIPCHILDREN</term>
            <term>Excludes the visible regions of all child windows below the window identified by hWnd.</term>
            </item>
            <item>
            <term>DCX_NORESETATTRS</term>
            <term>This flag is ignored.</term>
            </item>
            <item>
            <term>DCX_LOCKWINDOWUPDATE</term>
            <term>
            Allows drawing even if there is a LockWindowUpdate call in effect that would otherwise exclude this window. Used for drawing
            during tracking.
            </term>
            </item>
            <item>
            <term>DCX_EXCLUDERGN</term>
            <term>The clipping region identified by hrgnClip is excluded from the visible region of the returned DC.</term>
            </item>
            <item>
            <term>DCX_INTERSECTRGN</term>
            <term>The clipping region identified by hrgnClip is intersected with the visible region of the returned DC.</term>
            </item>
            <item>
            <term>DCX_INTERSECTUPDATE</term>
            <term>Reserved; do not use.</term>
            </item>
            <item>
            <term>DCX_VALIDATE</term>
            <term>Reserved; do not use.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>If the function succeeds, the return value is the handle to the DC for the specified window.</para>
            <para>
            If the function fails, the return value is <c>NULL</c>. An invalid value for the hWnd parameter will cause the function to fail.
            </para>
            </returns>
            <remarks>
            <para>
            Unless the display DC belongs to a window class, the ReleaseDC function must be called to release the DC after painting. Also,
            <c>ReleaseDC</c> must be called from the same thread that called <c>GetDCEx</c>. The number of DCs is limited only by available memory.
            </para>
            <para>
            The function returns a handle to a DC that belongs to the window's class if CS_CLASSDC, CS_OWNDC or CS_PARENTDC was specified as
            a style in the WNDCLASS structure when the class was registered.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetGuiResources(Vanara.PInvoke.HPROCESS,Vanara.PInvoke.User32.GR)">
            <summary>Retrieves the count of handles to graphical user interface (GUI) objects in use by the specified process.</summary>
            <param name="hProcess">
            A handle to the process. The handle must have the <c>PROCESS_QUERY_INFORMATION</c> access right. For more information, see
            Process Security and Access Rights.
            </param>
            <param name="uiFlags">
            <para>The GUI object type. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>GR_GDIOBJECTS 0</term>
            <term>Return the count of GDI objects.</term>
            </item>
            <item>
            <term>GR_GDIOBJECTS_PEAK 2</term>
            <term>
            Return the peak count of GDI objects. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: This value is not
            supported until Windows 7 and Windows Server 2008 R2.
            </term>
            </item>
            <item>
            <term>GR_USEROBJECTS 1</term>
            <term>Return the count of USER objects.</term>
            </item>
            <item>
            <term>GR_USEROBJECTS_PEAK 4</term>
            <term>
            Return the peak count of USER objects. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: This value is not
            supported until Windows 7 and Windows Server 2008 R2.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>
            If the function succeeds, the return value is the count of handles to GUI objects in use by the process. If no GUI objects are in
            use, the return value is zero.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            A process without a graphical user interface does not use GUI resources, therefore, <c>GetGuiResources</c> will return zero.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetSysColor(Vanara.PInvoke.SystemColorIndex)">
            <summary>
            Retrieves the current color of the specified display element. Display elements are the parts of a window and the display that
            appear on the system display screen.
            </summary>
            <param name="nIndex">The display element whose color is to be retrieved.</param>
            <returns>
            The function returns the red, green, blue (RGB) color value of the given element.
            <para>
            If the nIndex parameter is out of range, the return value is zero.Because zero is also a valid RGB value, you cannot use
            GetSysColor to determine whether a system color is supported by the current platform.Instead, use the GetSysColorBrush function,
            which returns NULL if the color is not supported.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetSysColorBrush(Vanara.PInvoke.SystemColorIndex)">
            <summary>
            The GetSysColorBrush function retrieves a handle identifying a logical brush that corresponds to the specified color index.
            </summary>
            <param name="nIndex">
            A color index. This value corresponds to the color used to paint one of the window elements. See GetSysColor for system color
            index values.
            </param>
            <returns>
            he return value identifies a logical brush if the nIndex parameter is supported by the current platform. Otherwise, it returns NULL.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetTabbedTextExtent(Vanara.PInvoke.HDC,System.String,System.Int32,System.Int32,System.Int32[])">
            <summary>
            The <c>GetTabbedTextExtent</c> function computes the width and height of a character string. If the string contains one or more
            tab characters, the width of the string is based upon the specified tab stops. The <c>GetTabbedTextExtent</c> function uses the
            currently selected font to compute the dimensions of the string.
            </summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="lpString">A pointer to a character string.</param>
            <param name="chCount">
            The length of the text string. For the ANSI function it is a BYTE count and for the Unicode function it is a WORD count. Note
            that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two
            bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one
            WORD while Unicode surrogates are two WORDs.
            </param>
            <param name="nTabPositions">The number of tab-stop positions in the array pointed to by the lpnTabStopPositions parameter.</param>
            <param name="lpnTabStopPositions">
            A pointer to an array containing the tab-stop positions, in device units. The tab stops must be sorted in increasing order; the
            smallest x-value should be the first item in the array.
            </param>
            <returns>
            <para>
            If the function succeeds, the return value is the dimensions of the string in logical units. The height is in the high-order word
            and the width is in the low-order word.
            </para>
            <para>
            If the function fails, the return value is 0. <c>GetTabbedTextExtent</c> will fail if hDC is invalid and if nTabPositions is less
            than 0.
            </para>
            </returns>
            <remarks>
            <para>The current clipping region does not affect the width and height returned by the <c>GetTabbedTextExtent</c> function.</para>
            <para>
            Because some devices do not place characters in regular cell arrays (that is, they kern the characters), the sum of the extents
            of the characters in a string may not be equal to the extent of the string.
            </para>
            <para>
            If the nTabPositions parameter is zero and the lpnTabStopPositions parameter is <c>NULL</c>, tabs are expanded to eight times the
            average character width.
            </para>
            <para>
            If nTabPositions is 1, the tab stops are separated by the distance specified by the first value in the array to which
            lpnTabStopPositions points.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetTabbedTextExtent(Vanara.PInvoke.HDC,System.String,System.Int32[])">
            <summary>
            The <c>GetTabbedTextExtent</c> function computes the width and height of a character string. If the string contains one or more
            tab characters, the width of the string is based upon the specified tab stops. The <c>GetTabbedTextExtent</c> function uses the
            currently selected font to compute the dimensions of the string.
            </summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="lpString">A pointer to a character string.</param>
            <param name="lpnTabStopPositions">
            A pointer to an array containing the tab-stop positions, in device units. The tab stops must be sorted in increasing order; the
            smallest x-value should be the first item in the array.
            </param>
            <returns>
            <para>If the function succeeds, the return value is the dimensions of the string in logical units.</para>
            <para>
            If the function fails, the return value is Size.Empty. <c>GetTabbedTextExtent</c> will fail if hDC is invalid and if
            nTabPositions is less than 0.
            </para>
            </returns>
            <remarks>
            <para>The current clipping region does not affect the width and height returned by the <c>GetTabbedTextExtent</c> function.</para>
            <para>
            Because some devices do not place characters in regular cell arrays (that is, they kern the characters), the sum of the extents
            of the characters in a string may not be equal to the extent of the string.
            </para>
            <para>
            If the nTabPositions parameter is zero and the lpnTabStopPositions parameter is <c>NULL</c>, tabs are expanded to eight times the
            average character width.
            </para>
            <para>
            If nTabPositions is 1, the tab stops are separated by the distance specified by the first value in the array to which
            lpnTabStopPositions points.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetUserObjectSecurity(Vanara.PInvoke.HANDLE,Vanara.PInvoke.SECURITY_INFORMATION@,Vanara.PInvoke.PSECURITY_DESCRIPTOR,System.UInt32,System.UInt32@)">
            <summary>The <c>GetUserObjectSecurity</c> function retrieves security information for the specified user object.</summary>
            <param name="hObj">A handle to the user object for which to return security information.</param>
            <param name="pSIRequested">A pointer to a SECURITY_INFORMATION value that specifies the security information being requested.</param>
            <param name="pSID">
            A pointer to a SECURITY_DESCRIPTOR structure in self-relative format that contains the requested information when the function
            returns. This buffer must be aligned on a 4-byte boundary.
            </param>
            <param name="nLength">The length, in bytes, of the buffer pointed to by the pSD parameter.</param>
            <param name="lpnLengthNeeded">
            A pointer to a variable to receive the number of bytes required to store the complete security descriptor. If this variable's
            value is greater than the value of the nLength parameter when the function returns, the function returns <c>FALSE</c> and none of
            the security descriptor is copied to the buffer. Otherwise, the entire security descriptor is copied.
            </param>
            <returns>
            <para>If the function succeeds, the function returns nonzero.</para>
            <para>If the function fails, it returns zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            To read the owner, group, or discretionary access control list (DACL) from the user object's security descriptor, the calling
            process must have been granted READ_CONTROL access when the handle was opened.
            </para>
            <para>
            To read the system access control list (SACL) from the security descriptor, the calling process must have been granted
            ACCESS_SYSTEM_SECURITY access when the handle was opened. The correct way to get this access is to enable the SE_SECURITY_NAME
            privilege in the caller's current token, open the handle for ACCESS_SYSTEM_SECURITY access, and then disable the privilege.
            </para>
            <para>Examples</para>
            <para>For an example that uses this function, see Starting an Interactive Client Process.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowLong(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.WindowLongFlags)">
            <summary>
            Retrieves information about the specified window. The function also retrieves the value at a specified offset into the extra
            window memory.
            </summary>
            <param name="hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
            <param name="nIndex">
            The zero-based offset to the value to be retrieved. Valid values are in the range zero through the number of bytes of extra
            window memory, minus four; for example, if you specified 12 or more bytes of extra memory, a value of 8 would be an index to the
            third 32-bit integer. To retrieve any other value, specify one of the following values.
            </param>
            <returns>
            If the function succeeds, the return value is the requested value. If the function fails, the return value is zero.To get
            extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowLongAuto(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.WindowLongFlags)">
            <summary>
            Retrieves information about the specified window. The function also retrieves the value at a specified offset into the extra
            window memory.
            </summary>
            <param name="hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
            <param name="nIndex">
            The zero-based offset to the value to be retrieved. Valid values are in the range zero through the number of bytes of extra
            window memory, minus the size of an integer. To retrieve any other value, specify one of the following values.
            </param>
            <returns>
            If the function succeeds, the return value is the requested value. If the function fails, the return value is zero.To get
            extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowLongPtr(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.WindowLongFlags)">
            <summary>
            Retrieves information about the specified window. The function also retrieves the value at a specified offset into the extra
            window memory.
            </summary>
            <param name="hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
            <param name="nIndex">
            The zero-based offset to the value to be retrieved. Valid values are in the range zero through the number of bytes of extra
            window memory, minus the size of an integer. To retrieve any other value, specify one of the following values.
            </param>
            <returns>
            If the function succeeds, the return value is the requested value. If the function fails, the return value is zero.To get
            extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadBitmap(Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.SafeResourceId)">
            <summary>
            <para>
            [ <c>LoadBitmap</c> is available for use in the operating systems specified in the Requirements section. It may be altered or
            unavailable in subsequent versions. Instead, use LoadImage and DrawFrameControl.]
            </para>
            <para>The <c>LoadBitmap</c> function loads the specified bitmap resource from a module's executable file.</para>
            </summary>
            <param name="hInstance">A handle to the instance of the module whose executable file contains the bitmap to be loaded.</param>
            <param name="lpBitmapName">
            A pointer to a null-terminated string that contains the name of the bitmap resource to be loaded. Alternatively, this parameter
            can consist of the resource identifier in the low-order word and zero in the high-order word. The MAKEINTRESOURCE macro can be
            used to create this value.
            </param>
            <returns>
            <para>If the function succeeds, the return value is the handle to the specified bitmap.</para>
            <para>If the function fails, the return value is <c>NULL</c>.</para>
            </returns>
            <remarks>
            <para>
            If the bitmap pointed to by the lpBitmapName parameter does not exist or there is insufficient memory to load the bitmap, the
            function fails.
            </para>
            <para>
            <c>LoadBitmap</c> creates a compatible bitmap of the display, which cannot be selected to a printer. To load a bitmap that you
            can select to a printer, call LoadImage and specify LR_CREATEDIBSECTION to create a DIB section. A DIB section can be selected to
            any device.
            </para>
            <para>
            An application can use the <c>LoadBitmap</c> function to access predefined bitmaps. To do so, the application must set the
            hInstance parameter to <c>NULL</c> and the lpBitmapName parameter to one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Bitmap name</term>
            <term>Bitmap name</term>
            </listheader>
            <item>
            <term>OBM_BTNCORNERS</term>
            <term>OBM_OLD_RESTORE</term>
            </item>
            <item>
            <term>OBM_BTSIZE</term>
            <term>OBM_OLD_RGARROW</term>
            </item>
            <item>
            <term>OBM_CHECK</term>
            <term>OBM_OLD_UPARROW</term>
            </item>
            <item>
            <term>OBM_CHECKBOXES</term>
            <term>OBM_OLD_ZOOM</term>
            </item>
            <item>
            <term>OBM_CLOSE</term>
            <term>OBM_REDUCE</term>
            </item>
            <item>
            <term>OBM_COMBO</term>
            <term>OBM_REDUCED</term>
            </item>
            <item>
            <term>OBM_DNARROW</term>
            <term>OBM_RESTORE</term>
            </item>
            <item>
            <term>OBM_DNARROWD</term>
            <term>OBM_RESTORED</term>
            </item>
            <item>
            <term>OBM_DNARROWI</term>
            <term>OBM_RGARROW</term>
            </item>
            <item>
            <term>OBM_LFARROW</term>
            <term>OBM_RGARROWD</term>
            </item>
            <item>
            <term>OBM_LFARROWD</term>
            <term>OBM_RGARROWI</term>
            </item>
            <item>
            <term>OBM_LFARROWI</term>
            <term>OBM_SIZE</term>
            </item>
            <item>
            <term>OBM_MNARROW</term>
            <term>OBM_UPARROW</term>
            </item>
            <item>
            <term>OBM_OLD_CLOSE</term>
            <term>OBM_UPARROWD</term>
            </item>
            <item>
            <term>OBM_OLD_DNARROW</term>
            <term>OBM_UPARROWI</term>
            </item>
            <item>
            <term>OBM_OLD_LFARROW</term>
            <term>OBM_ZOOM</term>
            </item>
            <item>
            <term>OBM_OLD_REDUCE</term>
            <term>OBM_ZOOMD</term>
            </item>
            </list>
            <para>Bitmap names that begin with OBM_OLD represent bitmaps used by 16-bit versions of Windows earlier than 3.0.</para>
            <para>
            For an application to use any of the OBM_ constants, the constant OEMRESOURCE must be defined before the Windows.h header file is included.
            </para>
            <para>The application must call the DeleteObject function to delete each bitmap handle returned by the <c>LoadBitmap</c> function.</para>
            <para>Examples</para>
            <para>For an example, see Example of Menu-Item Bitmaps in Using Menus.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ReleaseDC(Vanara.PInvoke.HWND,Vanara.PInvoke.HDC)">
            <summary>
            The <c>ReleaseDC</c> function releases a device context (DC), freeing it for use by other applications. The effect of the
            <c>ReleaseDC</c> function depends on the type of DC. It frees only common and window DCs. It has no effect on class or private DCs.
            </summary>
            <param name="hWnd">A handle to the window whose DC is to be released.</param>
            <param name="hDC">A handle to the DC to be released.</param>
            <returns>
            <para>The return value indicates whether the DC was released. If the DC was released, the return value is 1.</para>
            <para>If the DC was not released, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            The application must call the <c>ReleaseDC</c> function for each call to the GetWindowDC function and for each call to the GetDC
            function that retrieves a common DC.
            </para>
            <para>
            An application cannot use the <c>ReleaseDC</c> function to release a DC that was created by calling the CreateDC function;
            instead, it must use the DeleteDC function. <c>ReleaseDC</c> must be called from the same thread that called GetDC.
            </para>
            <para>Examples</para>
            <para>For an example, see Scaling an Image.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetSysColors(System.Int32,Vanara.PInvoke.SystemColorIndex[],Vanara.PInvoke.COLORREF[])">
            <summary>
            <para>
            Sets the colors for the specified display elements. Display elements are the various parts of a window and the display that
            appear on the system display screen.
            </para>
            </summary>
            <param name="cElements">
            <para>Type: <c>int</c></para>
            <para>The number of display elements in the lpaElements array.</para>
            </param>
            <param name="lpaElements">
            <para>Type: <c>const INT*</c></para>
            <para>An array of integers that specify the display elements to be changed. For a list of display elements, see GetSysColor.</para>
            </param>
            <param name="lpaRgbValues">
            <para>Type: <c>const COLORREF*</c></para>
            <para>
            An array of COLORREF values that contain the new red, green, blue (RGB) color values for the display elements in the array
            pointed to by the lpaElements parameter.
            </para>
            <para>To generate a COLORREF, use the RGB macro.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is a nonzero value.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>SetSysColors</c> function sends a WM_SYSCOLORCHANGE message to all windows to inform them of the change in color. It also
            directs the system to repaint the affected portions of all currently visible windows.
            </para>
            <para>
            It is best to respect the color settings specified by the user. If you are writing an application to enable the user to change
            the colors, then it is appropriate to use this function. However, this function affects only the current session. The new colors
            are not saved when the system terminates.
            </para>
            <para>Examples</para>
            <para>
            The following example demonstrates the use of the GetSysColor and <c>SetSysColors</c> functions. First, the example uses
            <c>GetSysColor</c> to retrieve the colors of the window background and active caption and displays the red, green, blue (RGB)
            values in hexadecimal notation. Next, example uses <c>SetSysColors</c> to change the color of the window background to light gray
            and the active title bars to dark purple. After a 10-second delay, the example restores the previous colors for these elements
            using SetSysColors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetWindowLong(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.WindowLongFlags,System.IntPtr)">
            <summary>
            Changes an attribute of the specified window. The function also sets a value at the specified offset in the extra window memory.
            </summary>
            <param name="hWnd">
            A handle to the window and, indirectly, the class to which the window belongs. The SetWindowLongPtr function fails if the process
            that owns the window specified by the hWnd parameter is at a higher process privilege in the UIPI hierarchy than the process the
            calling thread resides in.
            </param>
            <param name="nIndex">
            The zero-based offset to the value to be set. Valid values are in the range zero through the number of bytes of extra window
            memory, minus the size of an integer. Alternately, this can be a value from <see cref="T:Vanara.PInvoke.User32.WindowLongFlags"/>.
            </param>
            <param name="dwNewLong">The replacement value.</param>
            <returns>
            If the function succeeds, the return value is the previous value of the specified offset. If the function fails, the return value
            is zero. To get extended error information, call GetLastError.
            <para>
            If the previous value is zero and the function succeeds, the return value is zero, but the function does not clear the last error
            information. To determine success or failure, clear the last error information by calling SetLastError with 0, then call
            SetWindowLongPtr. Function failure will be indicated by a return value of zero and a GetLastError result that is nonzero.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetWindowLong(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.WindowLongFlags,System.Int32)">
            <summary>
            Changes an attribute of the specified window. The function also sets a value at the specified offset in the extra window memory.
            </summary>
            <param name="hWnd">
            A handle to the window and, indirectly, the class to which the window belongs. The SetWindowLongPtr function fails if the process
            that owns the window specified by the hWnd parameter is at a higher process privilege in the UIPI hierarchy than the process the
            calling thread resides in.
            </param>
            <param name="nIndex">
            The zero-based offset to the value to be set. Valid values are in the range zero through the number of bytes of extra window
            memory, minus the size of an integer. Alternately, this can be a value from <see cref="T:Vanara.PInvoke.User32.WindowLongFlags"/>.
            </param>
            <param name="dwNewLong">The replacement value.</param>
            <returns>
            If the function succeeds, the return value is the previous value of the specified offset. If the function fails, the return value
            is zero. To get extended error information, call GetLastError.
            <para>
            If the previous value is zero and the function succeeds, the return value is zero, but the function does not clear the last error
            information. To determine success or failure, clear the last error information by calling SetLastError with 0, then call
            SetWindowLongPtr. Function failure will be indicated by a return value of zero and a GetLastError result that is nonzero.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.TabbedTextOut(Vanara.PInvoke.HDC,System.Int32,System.Int32,System.String,System.Int32,System.Int32,System.Int32[],System.Int32)">
            <summary>
            The <c>TabbedTextOut</c> function writes a character string at a specified location, expanding tabs to the values specified in an
            array of tab-stop positions. Text is written in the currently selected font, background color, and text color.
            </summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="x">The x-coordinate of the starting point of the string, in logical units.</param>
            <param name="y">The y-coordinate of the starting point of the string, in logical units.</param>
            <param name="lpString">
            A pointer to the character string to draw. The string does not need to be zero-terminated, since nCount specifies the length of
            the string.
            </param>
            <param name="chCount">The length of the string pointed to by lpString.</param>
            <param name="nTabPositions">The number of values in the array of tab-stop positions.</param>
            <param name="lpnTabStopPositions">
            A pointer to an array containing the tab-stop positions, in logical units. The tab stops must be sorted in increasing order; the
            smallest x-value should be the first item in the array.
            </param>
            <param name="nTabOrigin">The x-coordinate of the starting position from which tabs are expanded, in logical units.</param>
            <returns>
            <para>
            If the function succeeds, the return value is the dimensions, in logical units, of the string. The height is in the high-order
            word and the width is in the low-order word.
            </para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            If the nTabPositions parameter is zero and the lpnTabStopPositions parameter is <c>NULL</c>, tabs are expanded to eight times the
            average character width.
            </para>
            <para>
            If nTabPositions is 1, the tab stops are separated by the distance specified by the first value in the lpnTabStopPositions array.
            </para>
            <para>
            If the lpnTabStopPositions array contains more than one value, a tab stop is set for each value in the array, up to the number
            specified by nTabPositions.
            </para>
            <para>
            The nTabOrigin parameter allows an application to call the <c>TabbedTextOut</c> function several times for a single line. If the
            application calls <c>TabbedTextOut</c> more than once with the nTabOrigin set to the same value each time, the function expands
            all tabs relative to the position specified by nTabOrigin.
            </para>
            <para>
            By default, the current position is not used or updated by the <c>TabbedTextOut</c> function. If an application needs to update
            the current position when it calls <c>TabbedTextOut</c>, the application can call the SetTextAlign function with the wFlags
            parameter set to TA_UPDATECP. When this flag is set, the system ignores the X and Y parameters on subsequent calls to the
            <c>TabbedTextOut</c> function, using the current position instead.
            </para>
            <para><c>Note</c> For Windows Vista and later, <c>TabbedTextOut</c> ignores text alignment when it draws text.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.WindowFromDC(Vanara.PInvoke.HDC)">
            <summary>
            The <c>WindowFromDC</c> function returns a handle to the window associated with the specified display device context (DC). Output
            functions that use the specified device context draw into this window.
            </summary>
            <param name="hDC">Handle to the device context from which a handle to the associated window is to be retrieved.</param>
            <returns>
            The return value is a handle to the window associated with the specified DC. If no window is associated with the specified DC,
            the return value is <c>NULL</c>.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessageUnmanaged``3(Vanara.PInvoke.HWND,``0,``1@,``2@)">
            <summary>
            Sends the specified message to a window or windows. The SendMessage function calls the window procedure for the specified window
            and does not return until the window procedure has processed the message.
            </summary>
            <typeparam name="TEnum">The type of the <paramref name="msg"/> value.</typeparam>
            <typeparam name="TWP">The type of the <paramref name="wParam"/> value.</typeparam>
            <typeparam name="TLP">The type of the <paramref name="lParam"/> value.</typeparam>
            <param name="hWnd">
            A handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the
            message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and
            pop-up windows; but the message is not sent to child windows.
            </param>
            <param name="msg">The message to be sent.</param>
            <param name="wParam">Additional message-specific information.</param>
            <param name="lParam">Additional message-specific information.</param>
            <returns>The return value specifies the result of the message processing; it depends on the message sent.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetUserObjectSecurity(Vanara.PInvoke.HANDLE,Vanara.PInvoke.SECURITY_INFORMATION@,Vanara.PInvoke.PSECURITY_DESCRIPTOR)">
            <summary>
            The <c>SetUserObjectSecurity</c> function sets the security of a user object. This can be, for example, a window or a DDE conversation.
            </summary>
            <param name="hObj">A handle to a user object for which security information is set.</param>
            <param name="pSIRequested">
            <para>
            A pointer to a value that indicates the components of the security descriptor to set. This parameter can be a combination of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DACL_SECURITY_INFORMATION</term>
            <term>
            Sets the discretionary access control list (DACL) of the object. The handle specified by hObj must have WRITE_DAC access, or the
            calling process must be the owner of the object.
            </term>
            </item>
            <item>
            <term>GROUP_SECURITY_INFORMATION</term>
            <term>Sets the primary group security identifier (SID) of the object.</term>
            </item>
            <item>
            <term>OWNER_SECURITY_INFORMATION</term>
            <term>
            Sets the SID of the owner of the object. The handle specified by hObj must have WRITE_OWNER access, or the calling process must
            be the owner of the object or have the SE_TAKE_OWNERSHIP_NAME privilege enabled.
            </term>
            </item>
            <item>
            <term>SACL_SECURITY_INFORMATION</term>
            <term>
            Sets the system access control list (SACL) of the object. The handle specified by hObj must have ACCESS_SYSTEM_SECURITY access.
            To obtain ACCESS_SYSTEM_SECURITY access
            </term>
            </item>
            </list>
            </param>
            <param name="pSID">
            <para>A pointer to a SECURITY_DESCRIPTOR structure that contains the new security information.</para>
            <para>This buffer must be aligned on a 4-byte boundary.</para>
            </param>
            <returns>
            <para>If the function succeeds, the function returns nonzero.</para>
            <para>If the function fails, it returns zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>SetUserObjectSecurity</c> function applies changes specified in a security descriptor to the security descriptor assigned
            to a user object. The security descriptor of the object must be in self-relative form. If necessary, this function allocates
            additional memory to increase the size of the security descriptor.
            </para>
            <para>Examples</para>
            <para>For an example that uses this function, see Starting an Interactive Client Process.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetWindowLongPtr32(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.WindowLongFlags,System.IntPtr)">
            <summary>
            Changes an attribute of the specified window. The function also sets a value at the specified offset in the extra window memory.
            </summary>
            <param name="hWnd">
            A handle to the window and, indirectly, the class to which the window belongs. The SetWindowLongPtr function fails if the process
            that owns the window specified by the hWnd parameter is at a higher process privilege in the UIPI hierarchy than the process the
            calling thread resides in.
            </param>
            <param name="nIndex">
            The zero-based offset to the value to be set. Valid values are in the range zero through the number of bytes of extra window
            memory, minus the size of an integer. Alternately, this can be a value from <see cref="T:Vanara.PInvoke.User32.WindowLongFlags"/>.
            </param>
            <param name="dwNewLong">The replacement value.</param>
            <returns>
            If the function succeeds, the return value is the previous value of the specified offset. If the function fails, the return value
            is zero. To get extended error information, call GetLastError.
            <para>
            If the previous value is zero and the function succeeds, the return value is zero, but the function does not clear the last error
            information. To determine success or failure, clear the last error information by calling SetLastError with 0, then call
            SetWindowLongPtr. Function failure will be indicated by a return value of zero and a GetLastError result that is nonzero.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetWindowLongPtr64(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.WindowLongFlags,System.IntPtr)">
            <summary>
            Changes an attribute of the specified window. The function also sets a value at the specified offset in the extra window memory.
            </summary>
            <param name="hWnd">
            A handle to the window and, indirectly, the class to which the window belongs. The SetWindowLongPtr function fails if the process
            that owns the window specified by the hWnd parameter is at a higher process privilege in the UIPI hierarchy than the process the
            calling thread resides in.
            </param>
            <param name="nIndex">
            The zero-based offset to the value to be set. Valid values are in the range zero through the number of bytes of extra window
            memory, minus the size of an integer. Alternately, this can be a value from <see cref="T:Vanara.PInvoke.User32.WindowLongFlags"/>.
            </param>
            <param name="dwNewLong">The replacement value.</param>
            <returns>
            If the function succeeds, the return value is the previous value of the specified offset. If the function fails, the return value
            is zero. To get extended error information, call GetLastError.
            <para>
            If the previous value is zero and the function succeeds, the return value is zero, but the function does not clear the last error
            information. To determine success or failure, clear the last error information by calling SetLastError with 0, then call
            SetWindowLongPtr. Function failure will be indicated by a return value of zero and a GetLastError result that is nonzero.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.UserHandleGrantAccess(Vanara.PInvoke.HANDLE,Vanara.PInvoke.HANDLE,System.Boolean)">
            <summary>
            Grants or denies access to a handle to a User object to a job that has a user-interface restriction. When access is granted, all
            processes associated with the job can subsequently recognize and use the handle. When access is denied, the processes can no
            longer use the handle. For more information see User Objects.
            </summary>
            <param name="hUserHandle">A handle to the User object.</param>
            <param name="hJob">
            A handle to the job to be granted access to the User handle. The CreateJobObject or OpenJobObject function returns this handle.
            </param>
            <param name="bGrant">
            If this parameter is TRUE, all processes associated with the job can recognize and use the handle. If the parameter is FALSE, the
            processes cannot use the handle.
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>UserHandleGrantAccess</c> function can be called only from a process not associated with the job specified by the hJob
            parameter. The User handle must not be owned by a process or thread associated with the job.
            </para>
            <para>
            To create user-interface restrictions, call the SetInformationJobObject function with the JobObjectBasicUIRestrictions job
            information class.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.MINMAXINFO">
            <summary>Contains information about a window's maximized size and position and its minimum and maximum tracking size.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MINMAXINFO.reserved">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MINMAXINFO.maxSize">
            <summary>
            The maximized width (x member) and the maximized height (y member) of the window. For top-level windows, this value is based
            on the width of the primary monitor.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MINMAXINFO.maxPosition">
            <summary>
            The position of the left side of the maximized window (x member) and the position of the top of the maximized window (y
            member). For top-level windows, this value is based on the position of the primary monitor.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MINMAXINFO.minTrackSize">
            <summary>
            The minimum tracking width (x member) and the minimum tracking height (y member) of the window. This value can be obtained
            programmatically from the system metrics SM_CXMINTRACK and SM_CYMINTRACK (see the GetSystemMetrics function).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MINMAXINFO.maxTrackSize">
            <summary>
            The maximum tracking width (x member) and the maximum tracking height (y member) of the window. This value is based on the
            size of the virtual screen and can be obtained programmatically from the system metrics SM_CXMAXTRACK and SM_CYMAXTRACK (see
            the GetSystemMetrics function).
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.WINDOWPOS">
            <summary>Contains information about the size and position of a window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWPOS.hwnd">
            <summary>A handle to the window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWPOS.hwndInsertAfter">
            <summary>
            The position of the window in Z order (front-to-back position). This member can be a handle to the window behind which this
            window is placed, or can be one of the special values listed with the SetWindowPos function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWPOS.x">
            <summary>The position of the left edge of the window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWPOS.y">
            <summary>The position of the top edge of the window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWPOS.cx">
            <summary>The window width, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWPOS.cy">
            <summary>The window height, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWPOS.flags">
            <summary>The window position. This member can be one or more of the following values.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.WINDOWPOS.FromLParam(System.IntPtr)">
            <summary>Creates a <see cref="T:Vanara.PInvoke.User32.WINDOWPOS"/> structure from an LPARAM value.</summary>
            <param name="lParam">The LPARAM value.</param>
            <returns>A <see cref="T:Vanara.PInvoke.User32.WINDOWPOS"/> structure.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.WINDOWPOS.UpdateLParam(System.IntPtr)">
            <summary>Updates the <see cref="T:Vanara.PInvoke.User32.WINDOWPOS"/> value pointed to by an LPARAM value from this instance.</summary>
            <param name="lParam">The LPARAM value to update.</param>
        </member>
        <member name="T:Vanara.PInvoke.User32.SpecialWindowHandles">
            <summary>Special window handles</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SpecialWindowHandles.HWND_BOTTOM">
            <summary>
            Places the window at the bottom of the Z order. If the hWnd parameter identifies a topmost window, the window loses its
            topmost status and is placed at the bottom of all other windows.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SpecialWindowHandles.HWND_NOTOPMOST">
            <summary>
            Places the window above all non-topmost windows (that is, behind all topmost windows). This flag has no effect if the window
            is already a non-topmost window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SpecialWindowHandles.HWND_TOP">
            <summary>Places the window at the top of the Z order.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SpecialWindowHandles.HWND_TOPMOST">
            <summary>Places the window above all non-topmost windows. The window maintains its topmost position even when it is deactivated.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DRAWTEXTPARAMS">
            <summary>The <c>DRAWTEXTPARAMS</c> structure contains extended formatting options for the DrawTextEx function.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.DRAWTEXTPARAMS.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.DRAWTEXTPARAMS"/> class.</summary>
            <param name="tabLength">The size of each tab stop, in units equal to the average character width.</param>
            <param name="leftMargin">The left margin, in units equal to the average character width.</param>
            <param name="rightMargin">The right margin, in units equal to the average character width.</param>
        </member>
        <member name="F:Vanara.PInvoke.User32.DRAWTEXTPARAMS.cbSize">
            <summary>The structure size, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DRAWTEXTPARAMS.iTabLength">
            <summary>The size of each tab stop, in units equal to the average character width.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DRAWTEXTPARAMS.iLeftMargin">
            <summary>The left margin, in units equal to the average character width.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DRAWTEXTPARAMS.iRightMargin">
            <summary>The right margin, in units equal to the average character width.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DRAWTEXTPARAMS.uiLengthDrawn">
            <summary>
            Receives the number of characters processed by DrawTextEx, including white-space characters. The number can be the length of
            the string or the index of the first line that falls below the drawing area. Note that <c>DrawTextEx</c> always processes the
            entire string if the DT_NOCLIP formatting flag is specified.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.HelpCmd">
            <summary>Flags used by <see cref="M:Vanara.PInvoke.User32.WinHelp(Vanara.PInvoke.HWND,System.String,Vanara.PInvoke.User32.HelpCmd,System.IntPtr)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_CONTEXT">
            <summary>Displays the topic identified by the specified context identifier defined in the [MAP] section of the .hpj file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_QUIT">
            <summary>
            Informs Windows Help that it is no longer needed. If no other applications have asked for help, Windows closes Windows Help.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_INDEX">
            <summary>
            Displays the topic specified by the Contents option in the [OPTIONS] section of the .hpj file. This command is for backward
            compatibility. New applications should use the HELP_FINDER command.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_CONTENTS">
            <summary>
            Displays the topic specified by the Contents option in the [OPTIONS] section of the .hpj file. This command is for backward
            compatibility. New applications should provide a .cnt file and use the HELP_FINDER command.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_HELPONHELP">
            <summary>Displays help on how to use Windows Help, if the Winhlp32.hlp file is available.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_SETINDEX">
            <summary>
            Displays the index of the specified help file. An application should use this value only for help files with a single index.
            It should not use this value with HELP_SETINDEX.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_SETCONTENTS">
            <summary>
            Specifies the Contents topic. Windows Help displays this topic when the user clicks the Contents button if the Help file does
            not have an associated .cnt file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_CONTEXTPOPUP">
            <summary>
            Displays the topic identified by the specified context identifier defined in the [MAP] section of the .hpj file in a pop-up window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_FORCEFILE">
            <summary>
            Ensures that Windows Help is displaying the correct Help file. If the incorrect Help file is being displayed, Windows Help
            opens the correct one; otherwise, there is no action.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_KEY">
            <summary>
            Displays the topic in the keyword table that matches the specified keyword, if there is an exact match. If there is more than
            one match, displays the Index with the topics listed in the Topics Found list box.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_COMMAND">
            <summary>Executes a Help macro or macro string.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_PARTIALKEY">
            <summary>
            Displays the topic in the keyword table that matches the specified keyword, if there is an exact match. If there is more than
            one match, displays the Topics Found dialog box. To display the index without passing a keyword, use a pointer to an empty string.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_MULTIKEY">
            <summary>Displays the topic specified by a keyword in an alternative keyword table.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_SETWINPOS">
            <summary>Displays the Windows Help window, if it is minimized or in memory, and sets its size and position as specified.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_CONTEXTMENU">
            <summary>
            Displays the Help menu for the selected window, then displays the topic for the selected control in a pop-up window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_FINDER">
            <summary>Displays the Help Topics dialog box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_WM_HELP">
            <summary>Displays the topic for the control identified by the hWndMain parameter in a pop-up window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_SETPOPUP_POS">
            <summary>Sets the position of the subsequent pop-up window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_TCARD">
            <summary>
            Indicates that a command is for a training card instance of Windows Help. Combine this command with other commands using the
            bitwise OR operator.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_TCARD_DATA">
            <summary>
            The user clicked an authorable button. The dwActionData parameter contains a long integer specified by the Help author.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HelpCmd.HELP_TCARD_OTHER_CALLER">
            <summary>Another application has requested training cards.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.WinHelp(Vanara.PInvoke.HWND,System.String,Vanara.PInvoke.User32.HelpCmd,System.IntPtr)">
            <summary>
            Launches Windows Help (Winhelp.exe) and passes additional data that indicates the nature of the help requested by the application.
            </summary>
            <param name="hWndMain">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window requesting help. The <c>WinHelp</c> function uses this handle to keep track of which applications have
            requested help. If the uCommand parameter specifies <c>HELP_CONTEXTMENU</c> or <c>HELP_WM_HELP</c>, hWndMain identifies the
            control requesting help.
            </para>
            </param>
            <param name="lpszHelp">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The address of a null-terminated string containing the path, if necessary, and the name of the Help file that <c>WinHelp</c> is
            to display.
            </para>
            <para>
            The file name can be followed by an angle bracket (&gt;) and the name of a secondary window if the topic is to be displayed in a
            secondary window rather than in the primary window. You must define the name of the secondary window in the [WINDOWS] section of
            the Help project (.hpj) file.
            </para>
            </param>
            <param name="uCommand">
            <para>Type: <c>UINT</c></para>
            <para>
            The type of help requested. For a list of possible values and how they affect the value to place in the dwData parameter, see the
            Remarks section.
            </para>
            </param>
            <param name="dwData">
            <para>Type: <c>ULONG_PTR</c></para>
            <para>
            Additional data. The value used depends on the value of the uCommand parameter. For a list of possible dwData values, see the
            Remarks section.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns nonzero if successful, or zero otherwise. To retrieve extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Before closing the window that requested help, the application must call <c>WinHelp</c> with the uCommand parameter set to
            HELP_QUIT. Until all applications have done this, Windows Help will not terminate. Note that calling Windows Help with the
            HELP_QUIT command is not necessary if you used the HELP_CONTEXTPOPUP command to start Windows Help.
            </para>
            <para>This function fails if called from any context but the current user.</para>
            <para>The following table shows the possible values for the uCommand parameter and the corresponding formats of the dwData parameter.</para>
            <list type="table">
            <listheader>
            <term>uCommand</term>
            <term>Action</term>
            <term>dwData</term>
            </listheader>
            <item>
            <term>HELP_COMMAND</term>
            <term>Executes a Help macro or macro string.</term>
            <term>
            Address of a string that specifies the name of the Help macro(s) to run. If the string specifies multiple macro names, the names
            must be separated by semicolons. You must use the short form of the macro name for some macros because Windows Help does not
            support the long name.
            </term>
            </item>
            <item>
            <term>HELP_CONTENTS</term>
            <term>
            Displays the topic specified by the Contents option in the [OPTIONS] section of the .hpj file. This command is for backward
            compatibility. New applications should provide a .cnt file and use the HELP_FINDER command.
            </term>
            <term>Ignored; set to 0.</term>
            </item>
            <item>
            <term>HELP_CONTEXT</term>
            <term>Displays the topic identified by the specified context identifier defined in the [MAP] section of the .hpj file.</term>
            <term>Contains the context identifier for the topic.</term>
            </item>
            <item>
            <term>HELP_CONTEXTMENU</term>
            <term>Displays the Help menu for the selected window, then displays the topic for the selected control in a pop-up window.</term>
            <term>
            Address of an array of DWORD pairs. The first DWORD in each pair is the control identifier, and the second is the context
            identifier for the topic. The array must be terminated by a pair of zeros {0,0}. If you do not want to add Help to a particular
            control, set its context identifier to -1.
            </term>
            </item>
            <item>
            <term>HELP_CONTEXTPOPUP</term>
            <term>
            Displays the topic identified by the specified context identifier defined in the [MAP] section of the .hpj file in a pop-up window.
            </term>
            <term>Contains the context identifier for a topic.</term>
            </item>
            <item>
            <term>HELP_FINDER</term>
            <term>Displays the Help Topics dialog box.</term>
            <term>Ignored; set to 0.</term>
            </item>
            <item>
            <term>HELP_FORCEFILE</term>
            <term>
            Ensures that Windows Help is displaying the correct Help file. If the incorrect Help file is being displayed, Windows Help opens
            the correct one; otherwise, there is no action.
            </term>
            <term>Ignored; set to 0.</term>
            </item>
            <item>
            <term>HELP_HELPONHELP</term>
            <term>Displays help on how to use Windows Help, if the Winhlp32.hlp file is available.</term>
            <term>Ignored; set to 0.</term>
            </item>
            <item>
            <term>HELP_INDEX</term>
            <term>
            Displays the topic specified by the Contents option in the [OPTIONS] section of the .hpj file. This command is for backward
            compatibility. New applications should use the HELP_FINDER command.
            </term>
            <term>Ignored; set to 0.</term>
            </item>
            <item>
            <term>HELP_KEY</term>
            <term>
            Displays the topic in the keyword table that matches the specified keyword, if there is an exact match. If there is more than one
            match, displays the Index with the topics listed in the Topics Found list box.
            </term>
            <term>Address of a keyword string. Multiple keywords must be separated by semicolons.</term>
            </item>
            <item>
            <term>HELP_MULTIKEY</term>
            <term>Displays the topic specified by a keyword in an alternative keyword table.</term>
            <term>Address of a MULTIKEYHELP structure that specifies a table footnote character and a keyword.</term>
            </item>
            <item>
            <term>HELP_PARTIALKEY</term>
            <term>
            Displays the topic in the keyword table that matches the specified keyword, if there is an exact match. If there is more than one
            match, displays the Topics Found dialog box. To display the index without passing a keyword, use a pointer to an empty string.
            </term>
            <term>Address of a keyword string. Multiple keywords must be separated by semicolons.</term>
            </item>
            <item>
            <term>HELP_QUIT</term>
            <term>
            Informs Windows Help that it is no longer needed. If no other applications have asked for help, Windows closes Windows Help.
            </term>
            <term>Ignored; set to 0.</term>
            </item>
            <item>
            <term>HELP_SETCONTENTS</term>
            <term>
            Specifies the Contents topic. Windows Help displays this topic when the user clicks the Contents button if the Help file does not
            have an associated .cnt file.
            </term>
            <term>Contains the context identifier for the Contents topic.</term>
            </item>
            <item>
            <term>HELP_SETPOPUP_POS</term>
            <term>Sets the position of the subsequent pop-up window.</term>
            <term>
            Contains the position data. Use MAKELONG to concatenate the horizontal and vertical coordinates into a single value. The pop-up
            window is positioned as if the mouse cursor were at the specified point when the pop-up window was invoked.
            </term>
            </item>
            <item>
            <term>HELP_SETWINPOS</term>
            <term>Displays the Windows Help window, if it is minimized or in memory, and sets its size and position as specified.</term>
            <term>Address of a HELPWININFO structure that specifies the size and position of either a primary or secondary Help window.</term>
            </item>
            <item>
            <term>HELP_TCARD</term>
            <term>
            Indicates that a command is for a training card instance of Windows Help. Combine this command with other commands using the
            bitwise OR operator.
            </term>
            <term>Depends on the command with which this command is combined.</term>
            </item>
            <item>
            <term>HELP_WM_HELP</term>
            <term>Displays the topic for the control identified by the hWndMain parameter in a pop-up window.</term>
            <term>
            Address of an array of DWORD pairs. The first DWORD in each pair is a control identifier, and the second is a context identifier
            for a topic. The array must be terminated by a pair of zeros {0,0}. If you do not want to add Help to a particular control, set
            its context identifier to -1.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.HELPWININFO">
            <summary>
            Contains the size and position of either a primary or secondary Help window. An application can set this information by calling
            the WinHelp function with the HELP_SETWINPOS value.
            </summary>
            <remarks>
            <para>
            Windows Help divides the display into 1024 units in both the X and Y directions. To create a secondary window that fills the
            upper-left quadrant of the display, for example, an application would specify zero for the <c>x</c> and <c>y</c> members and 512
            for the <c>dx</c> and <c>dy</c> members.
            </para>
            <para>
            To calculate <c>wStructSize</c> properly, the actual size of the string to be stored at <c>rgchMember</c> must be known. Since
            sizeof(HELPWININFO) includes two <c>TCHARs</c> by definition, they must be taken into account in the final total. The following
            example shows the proper calculation of an instance of <c>wStructSize</c>.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.HELPWININFO.wStructSize">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The size of this structure, in bytes.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HELPWININFO.x">
            <summary>
            <para>Type: <c>int</c></para>
            <para>X-coordinate of the upper-left corner of the window, in screen coordinates.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HELPWININFO.y">
            <summary>
            <para>Type: <c>int</c></para>
            <para>Y-coordinate of the upper-left corner of the window, in screen coordinates.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HELPWININFO.dx">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The width of the window, in pixels.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HELPWININFO.dy">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The height of the window, in pixels.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HELPWININFO.wMax">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            Options for display of the window. Several values also determine the activation (focus) state of the window or other windows.
            This member must be one of the following values.
            </para>
            <para>SW_HIDE</para>
            <para>Hides the window and passes activation to another window.</para>
            <para>SW_MINIMIZE</para>
            <para>Minimizes the specified window and activates the top-level window in the z-order.</para>
            <para>SW_RESTORE</para>
            <para>Same as <c>SW_SHOWNORMAL</c>.</para>
            <para>SW_SHOW</para>
            <para>Activates a window and displays it in its current size and position.</para>
            <para>SW_SHOWMAXIMIZED</para>
            <para>Activates the window and displays it as a maximized window.</para>
            <para>SW_SHOWMINIMIZED</para>
            <para>Activates the window and displays it as an icon.</para>
            <para>SW_SHOWMINNOACTIVE</para>
            <para>Displays the window as an icon. The window that is currently active remains active.</para>
            <para>SW_SHOWNA</para>
            <para>Displays the window in its current state. The window that is currently active remains active.</para>
            <para>SW_SHOWNOACTIVATE</para>
            <para>Displays a window in its most recent size and position. The window that is currently active remains active.</para>
            <para>SW_SHOWNORMAL</para>
            <para>
            Activates and displays the window. Whether the window is minimized or maximized, Windows restores it to its original size and position.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HELPWININFO.rgchMember">
            <summary>
            <para>Type: <c>TCHAR[2]</c></para>
            <para>The name of the window.</para>
            </summary>
            <value>The <see cref="T:System.Byte"/>.</value>
            <returns></returns>
        </member>
        <member name="T:Vanara.PInvoke.User32.MULTIKEYHELP">
            <summary>Specifies a keyword to search for and the keyword table to be searched by Windows Help.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MULTIKEYHELP.mkSize">
            <summary>The mk size</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MULTIKEYHELP.mkKeylist">
            <summary>
            <para>Type: <c>TCHAR</c></para>
            <para>A single character that identifies the keyword table to search.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MULTIKEYHELP.szKeyphrase">
            <summary>
            <para>Type: <c>TCHAR[1]</c></para>
            <para>A null-terminated text string that specifies the keyword to locate in the keyword table.</para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetDpiForSystem">
            <summary>Returns the system DPI.</summary>
            <returns>The system DPI value.</returns>
            <remarks>
            <para>
            The return value will be dependent based upon the calling context. If the current thread has a DPI_AWARENESS value of
            <c>DPI_AWARENESS_UNAWARE</c>, the return value will be 96. That is because the current context always assumes a DPI of 96. For
            any other <c>DPI_AWARENESS</c> value, the return value will be the actual system DPI.
            </para>
            <para>You should not cache the system DPI, but should use <c>GetDpiForSystem</c> whenever you need the system DPI value.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetSystemDpiForProcess(Vanara.PInvoke.HPROCESS)">
            <summary>
            Retrieves the system DPI associated with a given process. This is useful for avoiding compatibility issues that arise from
            sharing DPI-sensitive information between multiple system-aware processes with different system DPI values.
            </summary>
            <param name="hProcess">The handle for the process to examine. If this value is null, this API behaves identically to GetDpiForSystem.</param>
            <returns>The process's system DPI value.</returns>
            <remarks>
            The return value will be dependent based upon the process passed as a parameter. If the specified process has a DPI_AWARENESS
            value of <c>DPI_AWARENESS_UNAWARE</c>, the return value will be 96. That is because the current context always assumes a DPI of
            96. For any other <c>DPI_AWARENESS</c> value, the return value will be the actual system DPI of the given process.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetSystemMetricsForDpi(Vanara.PInvoke.User32.SystemMetric,System.UInt32)">
            <summary>Retrieves the specified system metric or system configuration setting taking into account a provided DPI.</summary>
            <param name="nIndex">The system metric or configuration setting to be retrieved. See GetSystemMetrics for the possible values.</param>
            <param name="dpi">The DPI to use for scaling the metric.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            This function returns the same result as GetSystemMetrics but scales it according to an arbitrary DPI you provide if appropriate.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SystemParametersInfoForDpi(Vanara.PInvoke.User32.SPI,System.UInt32,System.IntPtr,System.UInt32,System.UInt32)">
            <summary>Retrieves the value of one of the system-wide parameters, taking into account the provided DPI value.</summary>
            <param name="uiAction">
            The system-wide parameter to be retrieved. This function is only intended for use with <c>SPI_GETICONTITLELOGFONT</c>,
            <c>SPI_GETICONMETRICS</c>, or <c>SPI_GETNONCLIENTMETRICS</c>. See SystemParametersInfo for more information on these values.
            </param>
            <param name="uiParam">
            A parameter whose usage and format depends on the system parameter being queried. For more information about system-wide
            parameters, see the uiAction parameter. If not otherwise indicated, you must specify zero for this parameter.
            </param>
            <param name="pvParam">
            A parameter whose usage and format depends on the system parameter being queried. For more information about system-wide
            parameters, see the uiAction parameter. If not otherwise indicated, you must specify <c>NULL</c> for this parameter. For
            information on the <c>PVOID</c> datatype, see Windows Data Types.
            </param>
            <param name="fWinIni">Has no effect for with this API. This parameter only has an effect if you're setting parameter.</param>
            <param name="dpi">The DPI to use for scaling the metric.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            This function returns a similar result as SystemParametersInfo, but scales it according to an arbitrary DPI you provide (if
            appropriate). It only scales with the following possible values for uiAction: <c>SPI_GETICONTITLELOGFONT</c>,
            <c>SPI_GETICONMETRICS</c>, <c>SPI_GETNONCLIENTMETRICS</c>. Other possible uiAction values do not provide ForDPI behavior, and
            therefore this function returns 0 if called with them.
            </para>
            <para>
            For uiAction values that contain strings within their associated structures, only Unicode (LOGFONTW) strings are supported in
            this function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetThreadCursorCreationScaling(System.UInt32)">
            <summary>Sets the DPI scale for which the cursors being created on this thread are intended. This value is taken into account when scaling the cursor for the specific monitor on which it is being shown.</summary>
            <param name="cursorDpi">
            <para>The 96-based DPI scale of the cursors that the application will be creating. For example, a 96 DPI value corresponds to 100% monitor scale factor, 144 DPI corresponds to 150%, and so on.</para>
            <para>There are two special values:</para>
            <para>CURSOR_CREATION_SCALING_DEFAULT – resets cursor scaling to default system behavior (as if SetThreadCursorCreationScaling was never called on this thread).</para>
            <para>CURSOR_CREATION_SCALING_NONE – disables all cursor scaling (the cursors created after calling SetThreadCursorCreationScaling with this parameter will never be scaled up or down on any monitor).</para>
            </param>
            <returns>The previous value set for the thread before calling this API.</returns>
        </member>
        <member name="T:Vanara.PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS">
            <summary>
            Describes per-monitor DPI scaling behavior overrides for child windows within dialogs. The values in this enumeration are
            bitfields and can be combined.
            </summary>
            <remarks>
            <para>
            This enum is used with SetDialogControlDpiChangeBehavior in order to override the default per-monitor DPI scaling behavior for a
            child window within a dialog.
            </para>
            <para>
            These settings only apply to individual controls within dialogs. The dialog-wide per-monitor DPI scaling behavior of a dialog is
            controlled by DIALOG_DPI_CHANGE_BEHAVIORS.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DEFAULT">
            <summary>
            The default behavior of the dialog manager. The dialog managed will update the font, size, and position of the child window
            on DPI changes.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DISABLE_FONT_UPDATE">
            <summary>
            Prevents the dialog manager from sending an updated font to the child window via WM_SETFONT in response to a DPI change.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DISABLE_RELAYOUT">
            <summary>Prevents the dialog manager from resizing and repositioning the child window in response to a DPI change.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS">
            <summary>
            <para>
            In Per Monitor v2 contexts, dialogs will automatically respond to DPI changes by resizing themselves and re-computing the
            positions of their child windows (here referred to as re-layouting). This enum works in conjunction with
            SetDialogDpiChangeBehavior in order to override the default DPI scaling behavior for dialogs.
            </para>
            <para>
            This does not affect DPI scaling behavior for the child windows of dialogs (beyond re-layouting), which is controlled by DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DEFAULT">
            <summary>
            The default behavior of the dialog manager. In response to a DPI change, the dialog manager will re-layout each control,
            update the font on each control, resize the dialog, and update the dialog's own font.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_ALL">
            <summary>
            Prevents the dialog manager from responding to WM_GETDPISCALEDSIZE and WM_DPICHANGED, disabling all default DPI scaling behavior.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_RESIZE">
            <summary>Prevents the dialog manager from resizing the dialog in response to a DPI change.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_CONTROL_RELAYOUT">
            <summary>
            Prevents the dialog manager from re-layouting all of the dialogue's immediate children HWNDs in response to a DPI change.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DPI_AWARENESS">
            <summary>
            <para>Identifies the dots per inch (dpi) setting for a thread, process, or window.</para>
            </summary>
            <remarks>
            <para>
            In previous versions of Windows, DPI values were only set once for an entire application. For those apps, the
            PROCESS_DPI_AWARENESS type determined the type of DPI awareness for the entire application. Currently, the DPI awareness is
            defined on an individual thread, window, or process level and is indicated by the <c>DPI_AWARENESS</c> type. While the focus
            shifted from a process level to a thread level, the different kinds of DPI awareness are the same: unaware, system aware, and per
            monitor aware. For detailed descriptions and some examples of the different DPI kinds, see <c>PROCESS_DPI_AWARENESS</c>.
            </para>
            <para>
            The old recommendation was to define the DPI awareness level in the application manifest using the setting dpiAware as explained
            in PROCESS_DPI_AWARENESS. Now that the DPI awareness is tied to threads and windows instead of an entire application, a new
            windows setting is added to the app manifest. This setting is dpiAwareness and will override any dpiAware setting if both of them
            are present in the manifest. While it is still recommended to use the manifest, you can now change the DPI awareness while the
            app is running by using SetThreadDpiAwarenessContext.
            </para>
            <para>
            It is important to note that if your application has a <c>DPI_AWARENESS_PER_MONITOR_AWARE</c> window, you are responsible for
            keeping track of the DPI by responding to WM_DPICHANGED messages.
            </para>
            <para>Examples</para>
            <para>This snippet demonstrates how to set a value of <c>DPI_AWARENESS_SYSTEM_AWARE</c> in your application manifest.</para>
            <para>This snippet demonstrates how to set a value of <c>DPI_AWARENESS_PER_MONITOR_AWARE</c> in your application manifest.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.DPI_AWARENESS.DPI_AWARENESS_INVALID">
            <summary>Invalid DPI awareness. This is an invalid DPI awareness value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DPI_AWARENESS.DPI_AWARENESS_UNAWARE">
            <summary>
            DPI unaware. This process does not scale for DPI changes and is always assumed to have a scale factor of 100% (96 DPI). It
            will be automatically scaled by the system on any other DPI setting.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DPI_AWARENESS.DPI_AWARENESS_SYSTEM_AWARE">
            <summary>
            System DPI aware. This process does not scale for DPI changes. It will query for the DPI once and use that value for the
            lifetime of the process. If the DPI changes, the process will not adjust to the new DPI value. It will be automatically
            scaled up or down by the system when the DPI changes from the system value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DPI_AWARENESS.DPI_AWARENESS_PER_MONITOR_AWARE">
            <summary>
            Per monitor DPI aware. This process checks for the DPI when it is created and adjusts the scale factor whenever the DPI
            changes. These processes are not automatically scaled by the system.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DPI_HOSTING_BEHAVIOR">
            <summary>
            Identifies the DPI hosting behavior for a window. This behavior allows windows created in the thread to host child windows with a
            different <c>DPI_AWARENESS_CONTEXT</c>
            </summary>
            <remarks>
            <para>
            <c>DPI_HOSTING_BEHAVIOR</c> enables a mixed content hosting behavior, which allows parent windows created in the thread to host
            child windows with a different DPI_AWARENESS_CONTEXT value. This property only effects new windows created within this thread
            while the mixed hosting behavior is active. A parent window with this hosting behavior is able to host child windows with
            different <c>DPI_AWARENESS_CONTEXT</c> values, regardless of whether the child windows have mixed hosting behavior enabled.
            </para>
            <para>
            This hosting behavior does not allow for windows with per-monitor <c>DPI_AWARENESS_CONTEXT</c> values to be hosted until windows
            with <c>DPI_AWARENESS_CONTEXT</c> values of system or unaware.
            </para>
            <para>
            To avoid unexpected outcomes, a thread's <c>DPI_HOSTING_BEHAVIOR</c> should be changed to support mixed hosting behaviors only
            when creating a new window which needs to support those behaviors. Once that window is created, the hosting behavior should be
            switched back to its default value.
            </para>
            <para>
            Enabling mixed hosting behavior will not automatically adjust the thread's <c>DPI_AWARENESS_CONTEXT</c> to be compatible with
            legacy content. The thread's awareness context must still be manually changed before new windows are created to host such content.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_INVALID">
            <summary>
            Invalid DPI hosting behavior. This usually occurs if the previous SetThreadDpiHostingBehavior call used an invalid parameter.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_DEFAULT">
            <summary>
            Default DPI hosting behavior. The associated window behaves as normal, and cannot create or re-parent child windows with a
            different DPI_AWARENESS_CONTEXT.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_MIXED">
            <summary>
            Mixed DPI hosting behavior. This enables the creation and re-parenting of child windows with different DPI_AWARENESS_CONTEXT.
            These child windows will be independently scaled by the OS.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.AdjustWindowRectExForDpi(Vanara.PInvoke.RECT@,Vanara.PInvoke.User32.WindowStyles,System.Boolean,Vanara.PInvoke.User32.WindowStylesEx,System.UInt32)">
            <summary>
            Calculates the required size of the window rectangle, based on the desired size of the client rectangle and the provided DPI.
            This window rectangle can then be passed to the CreateWindowEx function to create a window with a client area of the desired size.
            </summary>
            <param name="lpRect">
            A pointer to a <c>RECT</c> structure that contains the coordinates of the top-left and bottom-right corners of the desired client
            area. When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to
            accommodate the desired client area.
            </param>
            <param name="dwStyle">
            The Window Style of the window whose required size is to be calculated. Note that you cannot specify the <c>WS_OVERLAPPED</c> style.
            </param>
            <param name="bMenu">Indicates whether the window has a menu.</param>
            <param name="dwExStyle">The Extended Window Style of the window whose required size is to be calculated.</param>
            <param name="dpi">The DPI to use for scaling.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            This function returns the same result as AdjustWindowRectEx but scales it according to an arbitrary DPI you provide if appropriate.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.AreDpiAwarenessContextsEqual(Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT,Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT)">
            <summary>Determines whether two <c>DPI_AWARENESS_CONTEXT</c> values are identical.</summary>
            <param name="dpiContextA">The first value to compare.</param>
            <param name="dpiContextB">The second value to compare.</param>
            <returns>Returns <c>TRUE</c> if the values are equal, otherwise <c>FALSE</c>.</returns>
            <remarks>
            A <c>DPI_AWARENESS_CONTEXT</c> contains multiple pieces of information. For example, it includes both the current and the
            inherited DPI_AWARENESS values. <c>AreDpiAwarenessContextsEqual</c> ignores informational flags and determines if the values are
            equal. You can't use a direct bitwise comparison because of these informational flags.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnableNonClientDpiScaling(Vanara.PInvoke.HWND)">
            <summary>
            In high-DPI displays, enables automatic display scaling of the non-client area portions of the specified top-level window. Must
            be called during the initialization of that window.
            </summary>
            <param name="hwnd">The window that should have automatic scaling enabled.</param>
            <returns>
            If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error
            information, call GetLastError.
            </returns>
            <remarks>
            <para>
            Calling this function will enable non-client scaling for an individual top-level window with DPI_AWARENESS_CONTEXT of
            <c>DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE</c>. If instead you are not using per-window awareness, and your entire process is
            running in <c>DPI_AWARENESS_PER_MONITOR_AWARE</c> mode, calling this function will enable non-client scaling in top-level windows
            in your process.
            </para>
            <para>
            If neither of those are true, or if you call this method from any other window, then it will fail and return a value of zero.
            </para>
            <para>
            Non-client scaling for top-level windows is not enabled by default. You must call this API to enable it for each individual
            top-level window for which you wish to have the non-client area scale automatically. Once you do, there is no way to disable it.
            Enabling non-client scaling means that all the areas drawn by the system for the window will automatically scale in response to
            DPI changes on the window. That includes areas like the caption bar, the scrollbars, and the menu bar. You want to call
            <c>EnableNonClientDpiScaling</c> when you want the operating system to be responsible for rendering these areas automatically at
            the correct size based on the API of the monitor.
            </para>
            <para>Calling this function enables non-client scaling for top-level windows only. Child windows are unaffected.</para>
            <para>
            This function must be called from WM_NCCREATE during the initialization of a new window. An example call might look like this:
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetAwarenessFromDpiAwarenessContext(Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT)">
            <summary>Retrieves the DPI_AWARENESS value from a <c>DPI_AWARENESS_CONTEXT</c>.</summary>
            <param name="value">The <c>DPI_AWARENESS_CONTEXT</c> you want to examine.</param>
            <returns>The DPI_AWARENESS. If the provided value is <c>null</c> or invalid, this method will return <c>DPI_AWARENESS_INVALID</c>.</returns>
            <remarks>
            A DPI_AWARENESS_CONTEXT contains multiple pieces of information. For example, it includes both the current and the inherited
            DPI_AWARENESS. This method retrieves the <c>DPI_AWARENESS</c> from the structure.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetDialogControlDpiChangeBehavior(Vanara.PInvoke.HWND)">
            <summary>Retrieves and per-monitor DPI scaling behavior overrides of a child window in a dialog.</summary>
            <param name="hWnd">The handle for the window to examine.</param>
            <returns>
            The flags set on the given window. If passed an invalid handle, this function will return zero, and set its last error to <c>ERROR_INVALID_HANDLE</c>.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetDialogDpiChangeBehavior(Vanara.PInvoke.HWND)">
            <summary>
            <para>Returns the flags that might have been set on a given dialog by an earlier call to SetDialogDpiChangeBehavior.</para>
            <para>If that function was never called on the dialog, the return value will be zero.</para>
            </summary>
            <param name="hDlg">The handle for the dialog to examine.</param>
            <returns>
            The flags set on the given dialog. If passed an invalid handle, this function will return zero, and set its last error to <c>ERROR_INVALID_HANDLE</c>.
            </returns>
            <remarks>
            It can be difficult to distinguish between a return value of <c>DDC_DEFAULT</c> and the error case, which is zero. To determine
            between the two, it is recommended that you call GetLastError() to check the error.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetDpiForWindow(Vanara.PInvoke.HWND)">
            <summary>Returns the dots per inch (dpi) value for the associated window.</summary>
            <param name="hwnd">The window you want to get information about.</param>
            <returns>
            The DPI for the window which depends on the DPI_AWARENESS of the window. See the Remarks for more information. An invalid hwnd
            value will result in a return value of 0.
            </returns>
            <remarks>
            <para>The following table indicates the return value of <c>GetDpiForWindow</c> based on the DPI_AWARENESS of the provided hwnd.</para>
            <list type="table">
            <listheader>
            <term>DPI_AWARENESS</term>
            <term>Return value</term>
            </listheader>
            <item>
            <term>DPI_AWARENESS_UNAWARE</term>
            <term>96</term>
            </item>
            <item>
            <term>DPI_AWARENESS_SYSTEM_AWARE</term>
            <term>The system DPI.</term>
            </item>
            <item>
            <term>DPI_AWARENESS_PER_MONITOR_AWARE</term>
            <term>The DPI of the monitor where the window is located.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetDpiFromDpiAwarenessContext(Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT)">
            <summary>
            Retrieves the DPI from a given DPI_AWARENESS_CONTEXT handle. This enables you to determine the DPI of a thread without needed to
            examine a window created within that thread.
            </summary>
            <param name="value">The <c>DPI_AWARENESS_CONTEXT</c> handle to examine.</param>
            <returns>The DPI value associated with the <c>DPI_AWARENESS_CONTEXT</c> handle.</returns>
            <remarks>
            DPI_AWARENESS_CONTEXT handles associated with values of <c>DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE</c> and
            <c>DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2</c> will return a value of 0 for their DPI. This is because the DPI of a
            per-monitor-aware window can change, and the actual DPI cannot be returned without the window's HWND.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetThreadDpiAwarenessContext">
            <summary>Gets the DPI_AWARENESS_CONTEXT for the current thread.</summary>
            <returns>The current DPI_AWARENESS_CONTEXT for the thread.</returns>
            <remarks>
            This method will return the latest DPI_AWARENESS_CONTEXT sent to SetThreadDpiAwarenessContext. If
            <c>SetThreadDpiAwarenessContext</c> was never called for this thread, then the return value will equal the default
            <c>DPI_AWARENESS_CONTEXT</c> for the process.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetThreadDpiHostingBehavior">
            <summary>Retrieves the DPI_HOSTING_BEHAVIOR from the current thread.</summary>
            <returns>The DPI_HOSTING_BEHAVIOR of the current thread.</returns>
            <remarks>
            This API returns the hosting behavior set by an earlier call of SetThreadDpiHostingBehavior, or
            <c>DPI_HOSTING_BEHAVIOR_DEFAULT</c> if no earlier call has been made.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowDpiAwarenessContext(Vanara.PInvoke.HWND)">
            <summary>Returns the DPI_AWARENESS_CONTEXT associated with a window.</summary>
            <param name="hwnd">The window to query.</param>
            <returns>The DPI_AWARENESS_CONTEXT for the provided window. If the window is not valid, the return value is <c>NULL</c>.</returns>
            <remarks>
            <c>Important</c> The return value of <c>GetWindowDpiAwarenessContext</c> is not affected by the DPI_AWARENESS of the current
            thread. It only indicates the context of the window specified by the hwnd input parameter.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowDpiHostingBehavior(Vanara.PInvoke.HWND)">
            <summary>Returns the DPI_HOSTING_BEHAVIOR of the specified window.</summary>
            <param name="hwnd">The handle for the window to examine.</param>
            <returns>The DPI_HOSTING_BEHAVIOR of the specified window.</returns>
            <remarks>
            This API allows you to examine the hosting behavior of a window after it has been created. A window's hosting behavior is the
            hosting behavior of the thread in which the window was created, as set by a call to SetThreadDpiHostingBehavior. This is a
            permanent value and cannot be changed after the window is created, even if the thread's hosting behavior is changed.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsValidDpiAwarenessContext(Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT)">
            <summary>Determines if a specified <c>DPI_AWARENESS_CONTEXT</c> is valid and supported by the current system.</summary>
            <param name="value">The context that you want to determine if it is supported.</param>
            <returns><c>TRUE</c> if the provided context is supported, otherwise <c>FALSE</c>.</returns>
            <remarks>
            <para>
            <c>IsValidDpiAwarenessContext</c> determines the validity of any provided <c>DPI_AWARENESS_CONTEXT</c>. You should make sure a
            context is valid before using SetThreadDpiAwarenessContext to that context.
            </para>
            <para>An input value of <c>NULL</c> is considered to be an invalid context and will result in a return value of <c>FALSE.</c></para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.LogicalToPhysicalPointForPerMonitorDPI(Vanara.PInvoke.HWND,Vanara.PInvoke.POINT@)">
            <summary>
            Converts a point in a window from logical coordinates into physical coordinates, regardless of the dots per inch (dpi) awareness
            of the caller. For more information about DPI awareness levels, see PROCESS_DPI_AWARENESS.
            </summary>
            <param name="hWnd">A handle to the window whose transform is used for the conversion.</param>
            <param name="lpPoint">
            A pointer to a POINT structure that specifies the logical coordinates to be converted. The new physical coordinates are copied
            into this structure if the function succeeds.
            </param>
            <returns>Returns <c>TRUE</c> if successful, or <c>FALSE</c> otherwise.</returns>
            <remarks>
            <para>
            In Windows 8, system–DPI aware applications translated between physical and logical space using PhysicalToLogicalPoint and
            LogicalToPhysicalPoint. In Windows 8.1, the additional virtualization of the system and inter-process communications means that
            for the majority of applications, you do not need these APIs. As a result, in Windows 8.1, these APIs no longer transform points.
            The system returns all points to an application in its own coordinate space. This behavior preserves functionality for the
            majority of applications, but there are some exceptions in which you must make changes to ensure that the application works as expected.
            </para>
            <para>
            For example, an application might need to walk the entire window tree of another process and ask the system for DPI-dependent
            information about the window. By default, the system will return the information based on the DPI awareness of the caller. This
            is ideal for most applications. However, the caller might need the information based on the DPI awareness of the application
            associated with the window. This might be necessary because the two applications send DPI-dependent information between each
            other directly. In this case, the application can use <c>LogicalToPhysicalPointForPerMonitorDPI</c> to get physical coordinates
            and then use PhysicalToLogicalPointForPerMonitorDPI to convert the physical coordinates into logical coordinates based on the
            DPI-awareness of the provided <c>HWND</c>.
            </para>
            <para>
            Consider two applications, one has a PROCESS_DPI_AWARENESS value of <c>PROCESS_DPI_UNAWARE</c> and the other has a value of
            <c>PROCESS_PER_MONITOR_AWARE</c>. The <c>PROCESS_DPI_UNAWARE</c> app creates a window on a single monitor where the scale factor
            is 200% (192 DPI). If both apps call GetWindowRect on this window, they will receive different values. The
            <c>PROCESS_DPI_UNAWARE</c> app will receive a rect based on 96 DPI coordinates, while the <c>PROCESS_PER_MONITOR_AWARE</c> app
            will receive coordinates matching the actual DPI of the monitor. If the <c>PROCESS_PER_MONITOR_AWARE</c> needs the rect that the
            system returned to the <c>PROCESS_DPI_UNAWARE</c> app, it could call <c>LogicalToPhysicalPointForPerMonitorDPI</c> for the
            corners of its rect and pass in the handle to the <c>PROCESS_DPI_UNAWARE</c> app's window. This will return points based on the
            other app's awareness that can be used to create a rect.
            </para>
            <para>
            <c>Tip</c> Since an application with a PROCESS_DPI_AWARENESS value of <c>PROCESS_PER_MONITOR_AWARE</c> uses the actual DPI of the
            monitor, physical and logical coordinates are the same for this app.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.PhysicalToLogicalPointForPerMonitorDPI(Vanara.PInvoke.HWND,Vanara.PInvoke.POINT@)">
            <summary>
            Converts a point in a window from logical coordinates into physical coordinates, regardless of the dots per inch (dpi) awareness
            of the caller. For more information about DPI awareness levels, see PROCESS_DPI_AWARENESS.
            </summary>
            <param name="hWnd">A handle to the window whose transform is used for the conversion.</param>
            <param name="lpPoint">
            A pointer to a POINT structure that specifies the physical/screen coordinates to be converted. The new logical coordinates are
            copied into this structure if the function succeeds.
            </param>
            <returns>Returns <c>TRUE</c> if successful, or <c>FALSE</c> otherwise.</returns>
            <remarks>
            <para>
            In Windows 8, system–DPI aware applications translate between physical and logical space using PhysicalToLogicalPoint and
            LogicalToPhysicalPoint. In Windows 8.1, the additional virtualization of the system and inter-process communications means that
            for the majority of applications, you do not need these APIs. As a result, in Windows 8.1, these APIs no longer transform points.
            The system returns all points to an application in its own coordinate space. This behavior preserves functionality for the
            majority of applications, but there are some exceptions in which you must make changes to ensure that the application works as expected.
            </para>
            <para>
            For example, an application might need to walk the entire window tree of another process and ask the system for DPI-dependent
            information about the window. By default, the system will return the information based on the DPI awareness of the caller. This
            is ideal for most applications. However, the caller might need the information based on the DPI awareness of the application
            associated with the window. This might be necessary because the two applications send DPI-dependent information between each
            other directly. In this case, the application can use LogicalToPhysicalPointForPerMonitorDPI to get physical coordinates and then
            use <c>PhysicalToLogicalPointForPerMonitorDPI</c> to convert the physical coordinates into logical coordinates based on the
            DPI-awareness of the provided <c>HWND</c>.
            </para>
            <para>
            Consider two applications, one has a PROCESS_DPI_AWARENESS value of <c>PROCESS_DPI_UNAWARE</c> and the other has a value of
            <c>PROCESS_PER_MONITOR_AWARE</c>. The <c>PROCESS_PER_MONITOR_AWARE</c> app creates a window on a single monitor where the scale
            factor is 200% (192 DPI). If both apps call GetWindowRect on this window, they will receive different values. The
            <c>PROCESS_DPI_UNAWARE</c> app will receive a rect based on 96 DPI coordinates, while the <c>PROCESS_PER_MONITOR_AWARE</c> app
            will receive coordinates matching the actual DPI of the monitor. If the <c>PROCESS_DPI_UNAWARE</c> needs the rect that the system
            returned to the <c>PROCESS_PER_MONITOR_AWARE</c> app, it could call LogicalToPhysicalPointForPerMonitorDPI for the corners of its
            rect and pass in a handle to the <c>PROCESS_PER_MONITOR_AWARE</c> app's window. This will return points based on the other app's
            awareness that can be used to create a rect. This works because since a <c>PROCESS_PER_MONITOR_AWARE</c> uses the actual DPI of
            the monitor, logical and physical coordinates are identical.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetDialogControlDpiChangeBehavior(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS,Vanara.PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS)">
            <summary>Overrides the default per-monitor DPI scaling behavior of a child window in a dialog.</summary>
            <param name="hWnd">A handle for the window whose behavior will be modified.</param>
            <param name="mask">A mask specifying the subset of flags to be changed.</param>
            <param name="values">The desired value to be set for the specified subset of flags.</param>
            <returns>
            <para>
            This function returns TRUE if the operation was successful, and FALSE otherwise. To get extended error information, call GetLastError.
            </para>
            <para>
            Possible errors are <c>ERROR_INVALID_HANDLE</c> if passed an invalid HWND, and <c>ERROR_ACCESS_DENIED</c> if the windows belongs
            to another process.
            </para>
            </returns>
            <remarks>
            <para>
            The behaviors are specified as values from the DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS enum. This function follows the typical
            two-parameter approach to setting flags, where a mask specifies the subset of the flags to be changed.
            </para>
            <para>
            It is valid to set these behaviors on any window. It does not matter if the window is currently a child of a dialog at the point
            in time that SetDialogControlDpiChangeBehavior is called. The behaviors are retained and will take effect only when the window is
            an immediate child of a dialog that has per-monitor DPI scaling enabled.
            </para>
            <para>
            This API influences individual controls within dialogs. The dialog-wide per-monitor DPI scaling behavior is controlled by SetDialogDpiChangeBehavior.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetDialogDpiChangeBehavior(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS,Vanara.PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS)">
            <summary>
            <para>Dialogs in Per-Monitor v2 contexts are automatically DPI scaled. This method lets you customize their DPI change behavior.</para>
            <para>
            This function works in conjunction with the DIALOG_DPI_CHANGE_BEHAVIORS enum in order to override the default DPI scaling
            behavior for dialogs. This function is called on a specified dialog, for which the specified flags are individually saved.
            </para>
            <para>
            This function does not affect the DPI scaling behavior for the child windows of the dialog in question - that is done with SetDialogControlDpiChangeBehavior.
            </para>
            </summary>
            <param name="hDlg">A handle for the dialog whose behavior will be modified.</param>
            <param name="mask">A mask specifying the subset of flags to be changed.</param>
            <param name="values">The desired value to be set for the specified subset of flags.</param>
            <returns>
            <para>
            This function returns TRUE if the operation was successful, and FALSE otherwise. To get extended error information, call GetLastError.
            </para>
            <para>
            Possible errors are <c>ERROR_INVALID_HANDLE</c> if passed an invalid dialog HWND, and <c>ERROR_ACCESS_DENIED</c> if the dialog
            belongs to another process.
            </para>
            </returns>
            <remarks>
            <para>
            For extensibility, DIALOG_DPI_CHANGE_BEHAVIORS was modeled as a set of bit-flags representing separate behaviors. This function
            follows the typical two-parameter approach to setting flags, where a mask specifies the subset of the flags to be changed.
            </para>
            <para>
            It is not an error to call this API outside of Per Monitor v2 contexts, though the flags will have no effect on the behavior of
            the specified dialog until the context is changed to Per Monitor v2.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetProcessDpiAwarenessContext(Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT)">
            <summary>
            <para>
            It is recommended that you set the process-default DPI awareness via application manifest. See Setting the default DPI awareness
            for a process for more information. Setting the process-default DPI awareness via API call can lead to unexpected application behavior.
            </para>
            <para>
            Sets the current process to a specified dots per inch (dpi) awareness context. The DPI awareness contexts are from the
            DPI_AWARENESS_CONTEXT value.
            </para>
            </summary>
            <param name="value">A DPI_AWARENESS_CONTEXT handle to set.</param>
            <returns>
            <para>
            This function returns TRUE if the operation was successful, and FALSE otherwise. To get extended error information, call GetLastError.
            </para>
            <para>
            Possible errors are <c>ERROR_INVALID_PARAMETER</c> for an invalid input, and <c>ERROR_ACCESS_DENIED</c> if the default API
            awareness mode for the process has already been set (via a previous API call or within the application manifest).
            </para>
            </returns>
            <remarks>
            <para>
            This API is a more advanced version of the previously existing SetProcessDpiAwareness API, allowing for the process default to be
            set to the finer-grained DPI_AWARENESS_CONTEXT values. Most importantly, this allows you to programmatically set <c>Per Monitor
            v2</c> as the process default value, which is not possible with the previous API.
            </para>
            <para>
            This method sets the default DPI_AWARENESS_CONTEXT for all threads within an application. Individual threads can have their DPI
            awareness changed from the default with the SetThreadDpiAwarenessContext method.
            </para>
            <para>
            <c>Important</c> In general, it is recommended to not use <c>SetProcessDpiAwarenessContext</c> to set the DPI awareness for your
            application. If possible, you should declare the DPI awareness for your application in the application manifest. For more
            information, see Setting the default DPI awareness for a process.
            </para>
            <para>
            You must call this API before you call any APIs that depend on the DPI awareness (including before creating any UI in your
            process). Once API awareness is set for an app, any future calls to this API will fail. This is true regardless of whether you
            set the DPI awareness in the manifest or by using this API.
            </para>
            <para>If the DPI awareness level is not set, the default value is <c>DPI_AWARENESS_CONTEXT_UNAWARE</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetThreadDpiAwarenessContext(Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT)">
            <summary>Set the DPI awareness for the current thread to the provided value.</summary>
            <param name="dpiContext">The new DPI_AWARENESS_CONTEXT for the current thread. This context includes the DPI_AWARENESS value.</param>
            <returns>
            The old DPI_AWARENESS_CONTEXT for the thread. If the dpiContext is invalid, the thread will not be updated and the return value
            will be <c>NULL</c>. You can use this value to restore the old <c>DPI_AWARENESS_CONTEXT</c> after overriding it with a predefined value.
            </returns>
            <remarks>Use this API to change the DPI_AWARENESS_CONTEXT for the thread from the default value for the app.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetThreadDpiHostingBehavior(Vanara.PInvoke.User32.DPI_HOSTING_BEHAVIOR)">
            <summary>
            Sets the thread's DPI_HOSTING_BEHAVIOR. This behavior allows windows created in the thread to host child windows with a different <c>DPI_AWARENESS_CONTEXT</c>.
            </summary>
            <param name="value">The new DPI_HOSTING_BEHAVIOR value for the current thread.</param>
            <returns>
            The previous DPI_HOSTING_BEHAVIOR for the thread. If the hosting behavior passed in is invalid, the thread will not be updated
            and the return value will be <c>DPI_HOSTING_BEHAVIOR_INVALID</c>. You can use this value to restore the old
            <c>DPI_HOSTING_BEHAVIOR</c> after overriding it with a predefined value.
            </returns>
            <remarks>
            <para>
            DPI_HOSTING_BEHAVIOR enables a mixed content hosting behavior, which allows parent windows created in the thread to host child
            windows with a different DPI_AWARENESS_CONTEXT value. This property only effects new windows created within this thread while the
            mixed hosting behavior is active. A parent window with this hosting behavior is able to host child windows with different
            <c>DPI_AWARENESS_CONTEXT</c> values, regardless of whether the child windows have mixed hosting behavior enabled.
            </para>
            <para>
            This hosting behavior does not allow for windows with per-monitor <c>DPI_AWARENESS_CONTEXT</c> values to be hosted until windows
            with <c>DPI_AWARENESS_CONTEXT</c> values of system or unaware.
            </para>
            <para>
            To avoid unexpected outcomes, a thread's <c>DPI_HOSTING_BEHAVIOR</c> should be changed to support mixed hosting behaviors only
            when creating a new window which needs to support those behaviors. Once that window is created, the hosting behavior should be
            switched back to its default value.
            </para>
            <para>
            This API is used to change the thread's <c>DPI_HOSTING_BEHAVIOR</c> from its default value. This is only necessary if your app
            needs to host child windows from plugins and third-party components that do not support per-monitor-aware context. This is most
            likely to occur if you are updating complex applications to support per-monitor <c>DPI_AWARENESS_CONTEXT</c> behaviors.
            </para>
            <para>
            Enabling mixed hosting behavior will not automatically adjust the thread's <c>DPI_AWARENESS_CONTEXT</c> to be compatible with
            legacy content. The thread's awareness context must still be manually changed before new windows are created to host such content.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT">
            <summary>Provides a handle to a DPI awareness context.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT.op_Explicit(Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT.op_Implicit(System.IntPtr)~Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT.op_Inequality(Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT,Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT.op_Equality(Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT,Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.DPI_AWARENESS_CONTEXT.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.HookProc">
            <summary>The delegate for a hook procedure set by SetWindowsHookEx.</summary>
            <param name="nCode">
            A hook code that the hook procedure uses to determine the action to perform. The value of the hook code depends on the type of
            the hook; each type has its own characteristic set of hook codes.
            </param>
            <param name="wParam">
            The value depends on the hook code, but typically contains information about a message that was sent or posted.
            </param>
            <param name="lParam">
            The value depends on the hook code, but typically contains information about a message that was sent or posted.
            </param>
            <returns>The value depends on the hook code.</returns>
        </member>
        <member name="T:Vanara.PInvoke.User32.WinEventProc">
            <summary>
            <para>
            An application-defined callback (or hook) function that the system calls in response to events generated by an accessible
            object. The hook function processes the event notifications as required. Clients install the hook function and request specific
            types of event notifications by calling SetWinEventHook.
            </para>
            <para>
            The WINEVENTPROC type defines a pointer to this callback function. WinEventProc is a placeholder for the application-defined
            function name.
            </para>
            </summary>
            <param name="hWinEventHook">
            <para>Type: <c>HWINEVENTHOOK</c></para>
            <para>
            Handle to an event hook function. This value is returned by SetWinEventHook when the hook function is installed and is specific
            to each instance of the hook function.
            </para>
            </param>
            <param name="winEvent">
            <para>Type: <c>DWORD</c></para>
            <para>Specifies the event that occurred. This value is one of the event constants.</para>
            </param>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>
            Handle to the window that generates the event, or <c>NULL</c> if no window is associated with the event. For example, the mouse
            pointer is not associated with a window.
            </para>
            </param>
            <param name="idObject">
            <para>Type: <c>LONG</c></para>
            <para>Identifies the object associated with the event. This is one of the object identifiers or a custom object ID.</para>
            </param>
            <param name="idChild">
            <para>Type: <c>LONG</c></para>
            <para>
            Identifies whether the event was triggered by an object or a child element of the object. If this value is CHILDID_SELF, the
            event was triggered by the object; otherwise, this value is the child ID of the element that triggered the event.
            </para>
            </param>
            <param name="idEventThread">The identifier event thread.</param>
            <param name="dwmsEventTime">
            <para>Type: <c>DWORD</c></para>
            <para>Specifies the time, in milliseconds, that the event was generated.</para>
            </param>
            <remarks>
            <para>Within the hook function, the parameters hwnd, idObject, and idChild are used when calling AccessibleObjectFromEvent.</para>
            <para>Servers generate events by calling NotifyWinEvent.</para>
            <para>Create multiple callback functions to handle different events. For more information, see Registering a Hook Function.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.HC">
            <summary>Hook codes used in the <c>nCode</c> paramter of <see cref="T:Vanara.PInvoke.User32.HookProc"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HC.HC_ACTION">
            <summary>The hook procedure must process the message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HC.HC_GETNEXT">
            <summary>
            The hook procedure must copy the current mouse or keyboard message to the EVENTMSG structure pointed to by the lParam parameter.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HC.HC_SKIP">
            <summary>
            The hook procedure must prepare to copy the next mouse or keyboard message to the EVENTMSG structure pointed to by lParam.
            Upon receiving the HC_GETNEXT code, the hook procedure must copy the message to the structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HC.HC_NOREMOVE">
            <summary>
            The wParam and lParam parameters contain information about a message, and the message has not been removed from the message
            queue. (An application called the PeekMessage function, specifying the PM_NOREMOVE flag.)
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HC.HC_NOREM">
            <summary>HC_NOREMOVE</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HC.HC_SYSMODALON">
            <summary>
            A system-modal dialog box is being displayed. Until the dialog box is destroyed, the hook procedure must stop playing back messages.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HC.HC_SYSMODALOFF">
            <summary>A system-modal dialog box has been destroyed. The hook procedure must resume playing back the messages.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.HCBT">
            <summary>Hook codes used in the <c>nCode</c> paramter of <see cref="T:Vanara.PInvoke.User32.HookProc"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HCBT.HCBT_ACTIVATE">
            <summary>The system is about to activate a window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HCBT.HCBT_CLICKSKIPPED">
            <summary>
            The system has removed a mouse message from the system message queue. Upon receiving this hook code, a CBT application must
            install a WH_JOURNALPLAYBACK hook procedure in response to the mouse message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HCBT.HCBT_CREATEWND">
            <summary>
            A window is about to be created. The system calls the hook procedure before sending the WM_CREATE or WM_NCCREATE message to
            the window. If the hook procedure returns a nonzero value, the system destroys the window; the CreateWindow function returns
            NULL, but the WM_DESTROY message is not sent to the window. If the hook procedure returns zero, the window is created normally.
            <para>
            At the time of the HCBT_CREATEWND notification, the window has been created, but its final size and position may not have
            been determined and its parent window may not have been established. It is possible to send messages to the newly created
            window, although it has not yet received WM_NCCREATE or WM_CREATE messages. It is also possible to change the position in the
            z-order of the newly created window by modifying the hwndInsertAfter member of the CBT_CREATEWND structure.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HCBT.HCBT_DESTROYWND">
            <summary>A window is about to be destroyed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HCBT.HCBT_KEYSKIPPED">
            <summary>
            The system has removed a keyboard message from the system message queue. Upon receiving this hook code, a CBT application
            must install a WH_JOURNALPLAYBACK hook procedure in response to the keyboard message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HCBT.HCBT_MINMAX">
            <summary>A window is about to be minimized or maximized.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HCBT.HCBT_MOVESIZE">
            <summary>A window is about to be moved or sized.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HCBT.HCBT_QS">
            <summary>The system has retrieved a WM_QUEUESYNC message from the system message queue.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HCBT.HCBT_SETFOCUS">
            <summary>A window is about to receive the keyboard focus.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HCBT.HCBT_SYSCOMMAND">
            <summary>
            A system command is about to be carried out. This allows a CBT application to prevent task switching by means of hot keys.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.HookType">
            <summary>The type of hook procedure to be installed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HookType.WH_MSGFILTER">
            <summary>
            Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu,
            or scroll bar. For more information, see the MessageProc hook procedure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HookType.WH_JOURNALRECORD">
            <summary>
            Installs a hook procedure that records input messages posted to the system message queue. This hook is useful for recording
            macros. For more information, see the JournalRecordProc hook procedure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HookType.WH_JOURNALPLAYBACK">
            <summary>
            Installs a hook procedure that posts messages previously recorded by a WH_JOURNALRECORD hook procedure. For more
            information, see the JournalPlaybackProc hook procedure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HookType.WH_KEYBOARD">
            <summary>
            Installs a hook procedure that monitors keystroke messages. For more information, see the KeyboardProc hook procedure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HookType.WH_GETMESSAGE">
            <summary>
            Installs a hook procedure that monitors messages posted to a message queue. For more information, see the GetMsgProc hook procedure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HookType.WH_CALLWNDPROC">
            <summary>
            Installs a hook procedure that monitors messages before the system sends them to the destination window procedure. For more
            information, see the CallWndProc hook procedure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HookType.WH_CBT">
            <summary>
            Installs a hook procedure that receives notifications useful to a CBT application. For more information, see the CBTProc
            hook procedure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HookType.WH_SYSMSGFILTER">
            <summary>
            Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu,
            or scroll bar. The hook procedure monitors these messages for all applications in the same desktop as the calling thread.
            For more information, see the SysMsgProc hook procedure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HookType.WH_MOUSE">
            <summary>Installs a hook procedure that monitors mouse messages. For more information, see the MouseProc hook procedure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HookType.WH_HARDWARE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HookType.WH_DEBUG">
            <summary>
            Installs a hook procedure useful for debugging other hook procedures. For more information, see the DebugProc hook procedure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HookType.WH_SHELL">
            <summary>
            Installs a hook procedure that receives notifications useful to shell applications. For more information, see the ShellProc
            hook procedure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HookType.WH_FOREGROUNDIDLE">
            <summary>
            Installs a hook procedure that will be called when the application's foreground thread is about to become idle. This hook is
            useful for performing low priority tasks during idle time. For more information, see the ForegroundIdleProc hook procedure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HookType.WH_CALLWNDPROCRET">
            <summary>
            Installs a hook procedure that monitors messages after they have been processed by the destination window procedure. For
            more information, see the CallWndRetProc hook procedure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HookType.WH_KEYBOARD_LL">
            <summary>
            Installs a hook procedure that monitors low-level keyboard input events. For more information, see the LowLevelKeyboardProc
            hook procedure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HookType.WH_MOUSE_LL">
            <summary>
            Installs a hook procedure that monitors low-level mouse input events. For more information, see the LowLevelMouseProc hook procedure.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.WINEVENT">
            <summary>Flags for <see cref="M:Vanara.PInvoke.User32.SetWinEventHook(System.UInt32,System.UInt32,Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.User32.WinEventProc,System.UInt32,System.UInt32,Vanara.PInvoke.User32.WINEVENT)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINEVENT.WINEVENT_OUTOFCONTEXT">
            <summary>
            The callback function is not mapped into the address space of the process that generates the event. Because the hook
            function is called across process boundaries, the system must queue events. Although this method is asynchronous, events are
            guaranteed to be in sequential order. For more information, see Out-of-Context Hook Functions.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINEVENT.WINEVENT_SKIPOWNTHREAD">
            <summary>
            Prevents this instance of the hook from receiving the events that are generated by the thread that is registering this hook.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINEVENT.WINEVENT_SKIPOWNPROCESS">
            <summary>
            Prevents this instance of the hook from receiving the events that are generated by threads in this process. This flag does
            not prevent threads from generating events.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINEVENT.WINEVENT_INCONTEXT">
            <summary>
            The DLL that contains the callback function is mapped into the address space of the process that generates the event. With
            this flag, the system sends event notifications to the callback function as they occur. The hook function must be in a DLL
            when this flag is specified. This flag has no effect when both the calling process and the generating process are not 32-bit
            or 64-bit processes, or when the generating process is a console application. For more information, see In-Context Hook Functions.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.CallMsgFilter(Vanara.PInvoke.MSG@,System.Int32)">
            <summary>
            <para>
            Passes the specified message and hook code to the hook procedures associated with the WH_SYSMSGFILTER and WH_MSGFILTER hooks. A
            <c>WH_SYSMSGFILTER</c> or <c>WH_MSGFILTER</c> hook procedure is an application-defined callback function that examines and,
            optionally, modifies messages for a dialog box, message box, menu, or scroll bar.
            </para>
            </summary>
            <param name="lpMsg">
            <para>Type: <c>LPMSG</c></para>
            <para>A pointer to an MSG structure that contains the message to be passed to the hook procedures.</para>
            </param>
            <param name="nCode">
            <para>Type: <c>int</c></para>
            <para>
            An application-defined code used by the hook procedure to determine how to process the message. The code must not have the same
            value as system-defined hook codes (MSGF_ and HC_) associated with the WH_SYSMSGFILTER and <c>WH_MSGFILTER</c> hooks.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the application should process the message further, the return value is zero.</para>
            <para>If the application should not process the message further, the return value is nonzero.</para>
            </returns>
            <remarks>
            <para>
            The system calls <c>CallMsgFilter</c> to enable applications to examine and control the flow of messages during internal
            processing of dialog boxes, message boxes, menus, and scroll bars, or when the user activates a different window by pressing the
            ALT+TAB key combination.
            </para>
            <para>Install this hook procedure by using the SetWindowsHookEx function.</para>
            <para>Examples</para>
            <para>For an example, see WH_MSGFILTER and WH_SYSMSGFILTER Hooks.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CallNextHookEx(Vanara.PInvoke.User32.HHOOK,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            Passes the hook information to the next hook procedure in the current hook chain. A hook procedure can call this function either
            before or after processing the hook information.
            </para>
            </summary>
            <param name="hhk">
            <para>Type: <c>HHOOK</c></para>
            <para>This parameter is ignored.</para>
            </param>
            <param name="nCode">
            <para>Type: <c>int</c></para>
            <para>
            The hook code passed to the current hook procedure. The next hook procedure uses this code to determine how to process the hook information.
            </para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>
            The wParam value passed to the current hook procedure. The meaning of this parameter depends on the type of hook associated with
            the current hook chain.
            </para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>
            The lParam value passed to the current hook procedure. The meaning of this parameter depends on the type of hook associated with
            the current hook chain.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>LRESULT</c></c></para>
            <para>
            This value is returned by the next hook procedure in the chain. The current hook procedure must also return this value. The
            meaning of the return value depends on the hook type. For more information, see the descriptions of the individual hook procedures.
            </para>
            </returns>
            <remarks>
            <para>Hook procedures are installed in chains for particular hook types. <c>CallNextHookEx</c> calls the next hook in the chain.</para>
            <para>
            Calling <c>CallNextHookEx</c> is optional, but it is highly recommended; otherwise, other applications that have installed hooks
            will not receive hook notifications and may behave incorrectly as a result. You should call <c>CallNextHookEx</c> unless you
            absolutely need to prevent the notification from being seen by other applications.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsWinEventHookInstalled(System.UInt32)">
            <summary>Determines whether there is an installed WinEvent hook that might be notified of a specified event.</summary>
            <param name="winEvent">
            <para>Type: <c>DWORD</c></para>
            <para>
            The event constant that hooks might be notified of. The function checks whether there is an installed hook for this event constant.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If there is a hook to be notified of the specified event, the return value is <c>TRUE</c>.</para>
            <para>If there are no hooks to be notified of the specified event, the return value is <c>FALSE</c>.</para>
            </returns>
            <remarks>
            <para>
            This method is guaranteed to never return a false negative. If this method returns <c>FALSE</c>, it means that no hooks in the
            system would be notified of the event. However, this method may return a false positive. In other words, it may return
            <c>TRUE</c> even though there are no hooks that would be notified. Thus, it is safe for components to circumvent some work if
            this method returns <c>FALSE</c>.
            </para>
            <para>Event hooks can be installed at any time, so server developers should not cache the return value for long periods of time.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetWindowsHookEx(Vanara.PInvoke.User32.HookType,Vanara.PInvoke.User32.HookProc,Vanara.PInvoke.HINSTANCE,System.Int32)">
            <summary>
            <para>
            Installs an application-defined hook procedure into a hook chain. You would install a hook procedure to monitor the system for
            certain types of events. These events are associated either with a specific thread or with all threads in the same desktop as
            the calling thread.
            </para>
            </summary>
            <param name="idHook">
            <para>Type: <c>int</c></para>
            <para>The type of hook procedure to be installed. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WH_CALLWNDPROC 4</term>
            <term>
            Installs a hook procedure that monitors messages before the system sends them to the destination window procedure. For more
            information, see the CallWndProc hook procedure.
            </term>
            </item>
            <item>
            <term>WH_CALLWNDPROCRET 12</term>
            <term>
            Installs a hook procedure that monitors messages after they have been processed by the destination window procedure. For more
            information, see the CallWndRetProc hook procedure.
            </term>
            </item>
            <item>
            <term>WH_CBT 5</term>
            <term>
            Installs a hook procedure that receives notifications useful to a CBT application. For more information, see the CBTProc hook procedure.
            </term>
            </item>
            <item>
            <term>WH_DEBUG 9</term>
            <term>Installs a hook procedure useful for debugging other hook procedures. For more information, see the DebugProc hook procedure.</term>
            </item>
            <item>
            <term>WH_FOREGROUNDIDLE 11</term>
            <term>
            Installs a hook procedure that will be called when the application's foreground thread is about to become idle. This hook is
            useful for performing low priority tasks during idle time. For more information, see the ForegroundIdleProc hook procedure.
            </term>
            </item>
            <item>
            <term>WH_GETMESSAGE 3</term>
            <term>
            Installs a hook procedure that monitors messages posted to a message queue. For more information, see the GetMsgProc hook procedure.
            </term>
            </item>
            <item>
            <term>WH_JOURNALPLAYBACK 1</term>
            <term>
            Installs a hook procedure that posts messages previously recorded by a WH_JOURNALRECORD hook procedure. For more information,
            see the JournalPlaybackProc hook procedure.
            </term>
            </item>
            <item>
            <term>WH_JOURNALRECORD 0</term>
            <term>
            Installs a hook procedure that records input messages posted to the system message queue. This hook is useful for recording
            macros. For more information, see the JournalRecordProc hook procedure.
            </term>
            </item>
            <item>
            <term>WH_KEYBOARD 2</term>
            <term>Installs a hook procedure that monitors keystroke messages. For more information, see the KeyboardProc hook procedure.</term>
            </item>
            <item>
            <term>WH_KEYBOARD_LL 13</term>
            <term>
            Installs a hook procedure that monitors low-level keyboard input events. For more information, see the LowLevelKeyboardProc hook procedure.
            </term>
            </item>
            <item>
            <term>WH_MOUSE 7</term>
            <term>Installs a hook procedure that monitors mouse messages. For more information, see the MouseProc hook procedure.</term>
            </item>
            <item>
            <term>WH_MOUSE_LL 14</term>
            <term>
            Installs a hook procedure that monitors low-level mouse input events. For more information, see the LowLevelMouseProc hook procedure.
            </term>
            </item>
            <item>
            <term>WH_MSGFILTER -1</term>
            <term>
            Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or
            scroll bar. For more information, see the MessageProc hook procedure.
            </term>
            </item>
            <item>
            <term>WH_SHELL 10</term>
            <term>
            Installs a hook procedure that receives notifications useful to shell applications. For more information, see the ShellProc hook procedure.
            </term>
            </item>
            <item>
            <term>WH_SYSMSGFILTER 6</term>
            <term>
            Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or
            scroll bar. The hook procedure monitors these messages for all applications in the same desktop as the calling thread. For more
            information, see the SysMsgProc hook procedure.
            </term>
            </item>
            </list>
            </param>
            <param name="lpfn">
            <para>Type: <c>HOOKPROC</c></para>
            <para>
            A pointer to the hook procedure. If the dwThreadId parameter is zero or specifies the identifier of a thread created by a
            different process, the lpfn parameter must point to a hook procedure in a DLL. Otherwise, lpfn can point to a hook procedure in
            the code associated with the current process.
            </para>
            </param>
            <param name="hmod">
            <para>Type: <c>HINSTANCE</c></para>
            <para>
            A handle to the DLL containing the hook procedure pointed to by the lpfn parameter. The hMod parameter must be set to
            <c>NULL</c> if the dwThreadId parameter specifies a thread created by the current process and if the hook procedure is within
            the code associated with the current process.
            </para>
            </param>
            <param name="dwThreadId">
            <para>Type: <c>DWORD</c></para>
            <para>
            The identifier of the thread with which the hook procedure is to be associated. For desktop apps, if this parameter is zero, the
            hook procedure is associated with all existing threads running in the same desktop as the calling thread. For Windows Store
            apps, see the Remarks section.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HHOOK</c></c></para>
            <para>If the function succeeds, the return value is the handle to the hook procedure.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            <c>SetWindowsHookEx</c> can be used to inject a DLL into another process. A 32-bit DLL cannot be injected into a 64-bit process,
            and a 64-bit DLL cannot be injected into a 32-bit process. If an application requires the use of hooks in other processes, it is
            required that a 32-bit application call <c>SetWindowsHookEx</c> to inject a 32-bit DLL into 32-bit processes, and a 64-bit
            application call <c>SetWindowsHookEx</c> to inject a 64-bit DLL into 64-bit processes. The 32-bit and 64-bit DLLs must have
            different names.
            </para>
            <para>
            Because hooks run in the context of an application, they must match the "bitness" of the application. If a 32-bit application
            installs a global hook on 64-bit Windows, the 32-bit hook is injected into each 32-bit process (the usual security boundaries
            apply). In a 64-bit process, the threads are still marked as "hooked." However, because a 32-bit application must run the hook
            code, the system executes the hook in the hooking app's context; specifically, on the thread that called
            <c>SetWindowsHookEx</c>. This means that the hooking application must continue to pump messages or it might block the normal
            functioning of the 64-bit processes.
            </para>
            <para>
            If a 64-bit application installs a global hook on 64-bit Windows, the 64-bit hook is injected into each 64-bit process, while
            all 32-bit processes use a callback to the hooking application.
            </para>
            <para>
            To hook all applications on the desktop of a 64-bit Windows installation, install a 32-bit global hook and a 64-bit global hook,
            each from appropriate processes, and be sure to keep pumping messages in the hooking application to avoid blocking normal
            functioning. If you already have a 32-bit global hooking application and it doesn't need to run in each application's context,
            you may not need to create a 64-bit version.
            </para>
            <para>
            An error may occur if the hMod parameter is <c>NULL</c> and the dwThreadId parameter is zero or specifies the identifier of a
            thread created by another process.
            </para>
            <para>
            Calling the CallNextHookEx function to chain to the next hook procedure is optional, but it is highly recommended; otherwise,
            other applications that have installed hooks will not receive hook notifications and may behave incorrectly as a result. You
            should call <c>CallNextHookEx</c> unless you absolutely need to prevent the notification from being seen by other applications.
            </para>
            <para>
            Before terminating, an application must call the UnhookWindowsHookEx function to free system resources associated with the hook.
            </para>
            <para>
            The scope of a hook depends on the hook type. Some hooks can be set only with global scope; others can also be set for only a
            specific thread, as shown in the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Hook</term>
            <term>Scope</term>
            </listheader>
            <item>
            <term>WH_CALLWNDPROC</term>
            <term>Thread or global</term>
            </item>
            <item>
            <term>WH_CALLWNDPROCRET</term>
            <term>Thread or global</term>
            </item>
            <item>
            <term>WH_CBT</term>
            <term>Thread or global</term>
            </item>
            <item>
            <term>WH_DEBUG</term>
            <term>Thread or global</term>
            </item>
            <item>
            <term>WH_FOREGROUNDIDLE</term>
            <term>Thread or global</term>
            </item>
            <item>
            <term>WH_GETMESSAGE</term>
            <term>Thread or global</term>
            </item>
            <item>
            <term>WH_JOURNALPLAYBACK</term>
            <term>Global only</term>
            </item>
            <item>
            <term>WH_JOURNALRECORD</term>
            <term>Global only</term>
            </item>
            <item>
            <term>WH_KEYBOARD</term>
            <term>Thread or global</term>
            </item>
            <item>
            <term>WH_KEYBOARD_LL</term>
            <term>Global only</term>
            </item>
            <item>
            <term>WH_MOUSE</term>
            <term>Thread or global</term>
            </item>
            <item>
            <term>WH_MOUSE_LL</term>
            <term>Global only</term>
            </item>
            <item>
            <term>WH_MSGFILTER</term>
            <term>Thread or global</term>
            </item>
            <item>
            <term>WH_SHELL</term>
            <term>Thread or global</term>
            </item>
            <item>
            <term>WH_SYSMSGFILTER</term>
            <term>Global only</term>
            </item>
            </list>
            <para>
            For a specified hook type, thread hooks are called first, then global hooks. Be aware that the WH_MOUSE, WH_KEYBOARD,
            WH_JOURNAL*, WH_SHELL, and low-level hooks can be called on the thread that installed the hook rather than the thread processing
            the hook. For these hooks, it is possible that both the 32-bit and 64-bit hooks will be called if a 32-bit hook is ahead of a
            64-bit hook in the hook chain.
            </para>
            <para>
            The global hooks are a shared resource, and installing one affects all applications in the same desktop as the calling thread.
            All global hook functions must be in libraries. Global hooks should be restricted to special-purpose applications or to use as a
            development aid during application debugging. Libraries that no longer need a hook should remove its hook procedure.
            </para>
            <para>
            <c>Windows Store app development</c> If dwThreadId is zero, then window hook DLLs are not loaded in-process for the Windows
            Store app processes and the Windows Runtime broker process unless they are installed by either UIAccess processes (accessibility
            tools). The notification is delivered on the installer's thread for these hooks:
            </para>
            <list type="bullet">
            <item>
            <term>WH_JOURNALPLAYBACK</term>
            </item>
            <item>
            <term>WH_JOURNALRECORD</term>
            </item>
            <item>
            <term>WH_KEYBOARD</term>
            </item>
            <item>
            <term>WH_KEYBOARD_LL</term>
            </item>
            <item>
            <term>WH_MOUSE</term>
            </item>
            <item>
            <term>WH_MOUSE_LL</term>
            </item>
            </list>
            <para>
            This behavior is similar to what happens when there is an architecture mismatch between the hook DLL and the target application
            process, for example, when the hook DLL is 32-bit and the application process 64-bit.
            </para>
            <para>Examples</para>
            <para>For an example, see Installing and Releasing Hook Procedures.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetWinEventHook(System.UInt32,System.UInt32,Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.User32.WinEventProc,System.UInt32,System.UInt32,Vanara.PInvoke.User32.WINEVENT)">
            <summary>Sets an event hook function for a range of events.</summary>
            <param name="eventMin">
            <para>Type: <c>UINT</c></para>
            <para>
            Specifies the event constant for the lowest event value in the range of events that are handled by the hook function. This
            parameter can be set to <c>EVENT_MIN</c> to indicate the lowest possible event value. See <see cref="T:Vanara.PInvoke.User32.EventConstants"/> for
            defined values.
            </para>
            </param>
            <param name="eventMax">
            <para>Type: <c>UINT</c></para>
            <para>
            Specifies the event constant for the highest event value in the range of events that are handled by the hook function. This
            parameter can be set to EVENT_MAX to indicate the highest possible event value. See <see cref="T:Vanara.PInvoke.User32.EventConstants"/> for defined values.
            </para>
            </param>
            <param name="hmodWinEventProc">
            <para>Type: <c>HMODULE</c></para>
            <para>
            Handle to the DLL that contains the hook function at lpfnWinEventProc, if the WINEVENT_INCONTEXT flag is specified in the
            dwFlags parameter. If the hook function is not located in a DLL, or if the WINEVENT_OUTOFCONTEXT flag is specified, this
            parameter is <c>NULL</c>.
            </para>
            </param>
            <param name="pfnWinEventProc">
            <para>Type: <c>WINEVENTPROC</c></para>
            <para>Pointer to the event hook function. For more information about this function, see WinEventProc.</para>
            </param>
            <param name="idProcess">
            <para>Type: <c>DWORD</c></para>
            <para>
            Specifies the ID of the process from which the hook function receives events. Specify zero (0) to receive events from all
            processes on the current desktop.
            </para>
            </param>
            <param name="idThread">
            <para>Type: <c>DWORD</c></para>
            <para>
            Specifies the ID of the thread from which the hook function receives events. If this parameter is zero, the hook function is
            associated with all existing threads on the current desktop.
            </para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>UINT</c></para>
            <para>Flag values that specify the location of the hook function and of the events to be skipped. The following flags are valid:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WINEVENT_INCONTEXT</term>
            <term>
            The DLL that contains the callback function is mapped into the address space of the process that generates the event. With this
            flag, the system sends event notifications to the callback function as they occur. The hook function must be in a DLL when this
            flag is specified. This flag has no effect when both the calling process and the generating process are not 32-bit or 64-bit
            processes, or when the generating process is a console application. For more information, see In-Context Hook Functions.
            </term>
            </item>
            <item>
            <term>WINEVENT_OUTOFCONTEXT</term>
            <term>
            The callback function is not mapped into the address space of the process that generates the event. Because the hook function is
            called across process boundaries, the system must queue events. Although this method is asynchronous, events are guaranteed to
            be in sequential order. For more information, see Out-of-Context Hook Functions.
            </term>
            </item>
            <item>
            <term>WINEVENT_SKIPOWNPROCESS</term>
            <term>
            Prevents this instance of the hook from receiving the events that are generated by threads in this process. This flag does not
            prevent threads from generating events.
            </term>
            </item>
            <item>
            <term>WINEVENT_SKIPOWNTHREAD</term>
            <term>
            Prevents this instance of the hook from receiving the events that are generated by the thread that is registering this hook.
            </term>
            </item>
            </list>
            <para>The following flag combinations are valid:</para>
            <list type="bullet">
            <item>
            <term>WINEVENT_INCONTEXT | WINEVENT_SKIPOWNPROCESS</term>
            </item>
            <item>
            <term>WINEVENT_INCONTEXT | WINEVENT_SKIPOWNTHREAD</term>
            </item>
            <item>
            <term>WINEVENT_OUTOFCONTEXT | WINEVENT_SKIPOWNPROCESS</term>
            </item>
            <item>
            <term>WINEVENT_OUTOFCONTEXT | WINEVENT_SKIPOWNTHREAD</term>
            </item>
            </list>
            <para>Additionally, client applications can specify WINEVENT_INCONTEXT, or WINEVENT_OUTOFCONTEXT alone.</para>
            <para>See Remarks section for information on Windows Store app development.</para>
            </param>
            <returns>
            <para>Type: <c>HWINEVENTHOOK</c></para>
            <para>
            If successful, returns an HWINEVENTHOOK value that identifies this event hook instance. Applications save this return value to
            use it with the UnhookWinEvent function.
            </para>
            <para>If unsuccessful, returns zero.</para>
            </returns>
            <remarks>
            <para>This function allows clients to specify which processes and threads they are interested in.</para>
            <para>
            If the idProcess parameter is nonzero and idThread is zero, the hook function receives the specified events from all threads in
            that process. If the idProcess parameter is zero and idThread is nonzero, the hook function receives the specified events only
            from the thread specified by idThread. If both are zero, the hook function receives the specified events from all threads and processes.
            </para>
            <para>
            Clients can call <c>SetWinEventHook</c> multiple times if they want to register additional hook functions or listen for
            additional events.
            </para>
            <para>The client thread that calls <c>SetWinEventHook</c> must have a message loop in order to receive events.</para>
            <para>
            When you use <c>SetWinEventHook</c> to set a callback in managed code, you should use the GCHandle structure to avoid
            exceptions. This tells the garbage collector not to move the callback.
            </para>
            <para>
            For out-of-context events, the event is delivered on the same thread that called <c>SetWinEventHook</c>. In some situations,
            even if you request WINEVENT_INCONTEXT events, the events will still be delivered out-of-context. These scenarios include events
            from console windows and events from processes that have a different bit-depth (64 bit versus 32 bits) than the caller.
            </para>
            <para>
            While a hook function processes an event, additional events may be triggered, which may cause the hook function to reenter
            before the processing for the original event is finished. The problem with reentrancy in hook functions is that events are
            completed out of sequence unless the hook function handles this situation. For more information, see Guarding Against Reentrancy.
            </para>
            <para>
            <c>Windows Store app development</c> If dwFlags is WINEVENT_INCONTEXT AND (idProcess = 0 | idThread = 0), then window hook DLLs
            are not loaded in-process for the Windows Store app processes and the Windows Runtime broker process unless they are installed
            by UIAccess processes (accessibility tools). The notification is delivered on the installer's thread.
            </para>
            <para>
            This behavior is similar to what happens when there is an architecture mismatch between the hook DLL and the target application
            process, for example, when the hook DLL is 32-bit and the application process 64-bit.
            </para>
            <para>Examples</para>
            <para>
            The following example code shows how a client application might listen for menu-start and menu-end events. For simplicity, the
            event handler just sends some information to the standard output.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.UnhookWindowsHookEx(Vanara.PInvoke.User32.HHOOK)">
            <summary>
            <para>Removes a hook procedure installed in a hook chain by the SetWindowsHookEx function.</para>
            </summary>
            <param name="hhk">
            <para>Type: <c>HHOOK</c></para>
            <para>A handle to the hook to be removed. This parameter is a hook handle obtained by a previous call to SetWindowsHookEx.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The hook procedure can be in the state of being called by another thread even after <c>UnhookWindowsHookEx</c> returns. If the
            hook procedure is not being called concurrently, the hook procedure is removed immediately before <c>UnhookWindowsHookEx</c> returns.
            </para>
            <para>Examples</para>
            <para>For an example, see Monitoring System Events.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.UnhookWinEvent(Vanara.PInvoke.User32.HWINEVENTHOOK)">
            <summary>Removes an event hook function created by a previous call to SetWinEventHook.</summary>
            <param name="hWinEventHook">
            <para>Type: <c>HWINEVENTHOOK</c></para>
            <para>Handle to the event hook returned in the previous call to SetWinEventHook.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If successful, returns <c>TRUE</c>; otherwise, returns <c>FALSE</c>.</para>
            <para>Three common errors cause this function to fail:</para>
            <list type="bullet">
            <item>
            <term>The hWinEventHook parameter is <c>NULL</c> or not valid.</term>
            </item>
            <item>
            <term>The event hook specified by hWinEventHook was already removed.</term>
            </item>
            <item>
            <term><c>UnhookWinEvent</c> is called from a thread that is different from the original call to SetWinEventHook.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function removes the event hook specified by hWinEventHook that prevents the corresponding callback function from receiving
            further event notifications. If the client's thread ends, the system automatically calls this function.
            </para>
            <para>
            Call this function from the same thread that installed the event hook. <c>UnhookWinEvent</c> fails if called from a thread
            different from the call that corresponds to SetWinEventHook.
            </para>
            <para>
            If WINEVENT_INCONTEXT was specified when this event hook was installed, the system attempts to unload the corresponding DLL from
            all processes that loaded it. Although unloading does not occur immediately, the hook function is not called after
            <c>UnhookWinEvent</c> returns. For more information on WINEVENT_INCONTEXT, see In-Context Hook Functions.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.CBT_CREATEWND">
            <summary>
            <para>Contains information passed to a <c>WH_CBT</c> hook procedure, CBTProc, before a window is created.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CBT_CREATEWND.lpcs">
            <summary>
            <para>Type: <c>LPCREATESTRUCT</c></para>
            <para>A pointer to a CREATESTRUCT structure that contains initialization parameters for the window about to be created.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CBT_CREATEWND.hwndInsertAfter">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose position in the Z order precedes that of the window being created. This member can also be <c>NULL</c>.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.CBTACTIVATESTRUCT">
            <summary>
            <para>Contains information passed to a <c>WH_CBT</c> hook procedure, CBTProc, before a window is activated.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CBTACTIVATESTRUCT.fMouse">
            <summary>
            <para>Type: <c>BOOL</c></para>
            <para>This member is <c>TRUE</c> if a mouse click is causing the activation or <c>FALSE</c> if it is not.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CBTACTIVATESTRUCT.hWndActive">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the active window.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.CWPRETSTRUCT">
            <summary>
            <para>Defines the message parameters passed to a <c>WH_CALLWNDPROCRET</c> hook procedure, CallWndRetProc.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CWPRETSTRUCT.lResult">
            <summary>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value of the window procedure that processed the message specified by the <c>message</c> value.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CWPRETSTRUCT.lParam">
            <summary>
            <para>Type: <c>LPARAM</c></para>
            <para>Additional information about the message. The exact meaning depends on the <c>message</c> value.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CWPRETSTRUCT.wParam">
            <summary>
            <para>Type: <c>WPARAM</c></para>
            <para>Additional information about the message. The exact meaning depends on the <c>message</c> value.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CWPRETSTRUCT.message">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CWPRETSTRUCT.hwnd">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that processed the message specified by the <c>message</c> value.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.CWPSTRUCT">
            <summary>
            <para>Defines the message parameters passed to a <c>WH_CALLWNDPROC</c> hook procedure, CallWndProc.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CWPSTRUCT.lParam">
            <summary>
            <para>Type: <c>LPARAM</c></para>
            <para>Additional information about the message. The exact meaning depends on the <c>message</c> value.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CWPSTRUCT.wParam">
            <summary>
            <para>Type: <c>WPARAM</c></para>
            <para>Additional information about the message. The exact meaning depends on the <c>message</c> value.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CWPSTRUCT.message">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CWPSTRUCT.hwnd">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to receive the message.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DEBUGHOOKINFO">
            <summary>
            <para>Contains debugging information passed to a <c>WH_DEBUG</c> hook procedure, DebugProc.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEBUGHOOKINFO.idThread">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>A handle to the thread containing the filter function.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEBUGHOOKINFO.idThreadInstaller">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>A handle to the thread that installed the debugging filter function.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEBUGHOOKINFO.lParam">
            <summary>
            <para>Type: <c>LPARAM</c></para>
            <para>The value to be passed to the hook in the lParam parameter of the DebugProc callback function.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEBUGHOOKINFO.wParam">
            <summary>
            <para>Type: <c>WPARAM</c></para>
            <para>The value to be passed to the hook in the wParam parameter of the DebugProc callback function.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DEBUGHOOKINFO.code">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The value to be passed to the hook in the nCode parameter of the DebugProc callback function.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.EVENTMSG">
            <summary>
            <para>
            Contains information about a hardware message sent to the system message queue. This structure is used to store message
            information for the JournalPlaybackProc callback function.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EVENTMSG.message">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EVENTMSG.paramL">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>Additional information about the message. The exact meaning depends on the <c>message</c> value.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EVENTMSG.paramH">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>Additional information about the message. The exact meaning depends on the <c>message</c> value.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EVENTMSG.time">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The time at which the message was posted.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EVENTMSG.hwnd">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to which the message was posted.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.HHOOK">
            <summary>Provides a handle to a hook.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.HHOOK.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.HHOOK"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.User32.HHOOK.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.User32.HHOOK"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.HHOOK.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.HHOOK.op_Explicit(Vanara.PInvoke.User32.HHOOK)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.User32.HHOOK"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HHOOK.op_Implicit(System.IntPtr)~Vanara.PInvoke.User32.HHOOK">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.User32.HHOOK"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HHOOK.op_Inequality(Vanara.PInvoke.User32.HHOOK,Vanara.PInvoke.User32.HHOOK)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HHOOK.op_Equality(Vanara.PInvoke.User32.HHOOK,Vanara.PInvoke.User32.HHOOK)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HHOOK.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.HHOOK.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.HHOOK.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.HWINEVENTHOOK">
            <summary>Provides a handle to a Windows Event Hook.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.HWINEVENTHOOK.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.HWINEVENTHOOK"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.User32.HWINEVENTHOOK.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.User32.HWINEVENTHOOK"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.HWINEVENTHOOK.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.HWINEVENTHOOK.op_Explicit(Vanara.PInvoke.User32.HWINEVENTHOOK)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.User32.HWINEVENTHOOK"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HWINEVENTHOOK.op_Implicit(System.IntPtr)~Vanara.PInvoke.User32.HWINEVENTHOOK">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.User32.HWINEVENTHOOK"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HWINEVENTHOOK.op_Inequality(Vanara.PInvoke.User32.HWINEVENTHOOK,Vanara.PInvoke.User32.HWINEVENTHOOK)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HWINEVENTHOOK.op_Equality(Vanara.PInvoke.User32.HWINEVENTHOOK,Vanara.PInvoke.User32.HWINEVENTHOOK)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HWINEVENTHOOK.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.HWINEVENTHOOK.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.HWINEVENTHOOK.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.KBDLLHOOKSTRUCT">
            <summary>
            <para>Contains information about a low-level keyboard input event.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KBDLLHOOKSTRUCT.vkCode">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>A virtual-key code. The code must be a value in the range 1 to 254.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KBDLLHOOKSTRUCT.scanCode">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>A hardware scan code for the key.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KBDLLHOOKSTRUCT.flags">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            The extended-key flag, event-injected flags, context code, and transition-state flag. This member is specified as follows.
            An application can use the following values to test the keystroke flags. Testing LLKHF_INJECTED (bit 4) will tell you
            whether the event was injected. If it was, then testing LLKHF_LOWER_IL_INJECTED (bit 1) will tell you whether or not the
            event was injected from a process running at lower integrity level.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>LLKHF_EXTENDED (KF_EXTENDED &gt;&gt; 8)</term>
            <term>Test the extended-key flag.</term>
            </item>
            <item>
            <term>LLKHF_LOWER_IL_INJECTED 0x00000002</term>
            <term>Test the event-injected (from a process running at lower integrity level) flag.</term>
            </item>
            <item>
            <term>LLKHF_INJECTED 0x00000010</term>
            <term>Test the event-injected (from any process) flag.</term>
            </item>
            <item>
            <term>LLKHF_ALTDOWN (KF_ALTDOWN &gt;&gt; 8)</term>
            <term>Test the context code.</term>
            </item>
            <item>
            <term>LLKHF_UP (KF_UP &gt;&gt; 8)</term>
            <term>Test the transition-state flag.</term>
            </item>
            </list>
            <para>The following table describes the layout of this value.</para>
            <list type="table">
            <listheader>
            <term>Bits</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>0</term>
            <term>
            Specifies whether the key is an extended key, such as a function key or a key on the numeric keypad. The value is 1 if the
            key is an extended key; otherwise, it is 0.
            </term>
            </item>
            <item>
            <term>1</term>
            <term>
            Specifies whether the event was injected from a process running at lower integrity level. The value is 1 if that is the
            case; otherwise, it is 0. Note that bit 4 is also set whenever bit 1 is set.
            </term>
            </item>
            <item>
            <term>2-3</term>
            <term>Reserved.</term>
            </item>
            <item>
            <term>4</term>
            <term>
            Specifies whether the event was injected. The value is 1 if that is the case; otherwise, it is 0. Note that bit 1 is not
            necessarily set when bit 4 is set.
            </term>
            </item>
            <item>
            <term>5</term>
            <term>The context code. The value is 1 if the ALT key is pressed; otherwise, it is 0.</term>
            </item>
            <item>
            <term>6</term>
            <term>Reserved.</term>
            </item>
            <item>
            <term>7</term>
            <term>The transition state. The value is 0 if the key is pressed and 1 if it is being released.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KBDLLHOOKSTRUCT.time">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The time stamp for this message, equivalent to what GetMessageTime would return for this message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KBDLLHOOKSTRUCT.dwExtraInfo">
            <summary>
            <para>Type: <c>ULONG_PTR</c></para>
            <para>Additional information associated with the message.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MOUSEHOOKSTRUCT">
            <summary>
            <para>Contains information about a mouse event passed to a <c>WH_MOUSE</c> hook procedure, MouseProc.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEHOOKSTRUCT.pt">
            <summary>
            <para>Type: <c>POINT</c></para>
            <para>The x- and y-coordinates of the cursor, in screen coordinates.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEHOOKSTRUCT.hwnd">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that will receive the mouse message corresponding to the mouse event.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEHOOKSTRUCT.wHitTestCode">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The hit-test value. For a list of hit-test values, see the description of the WM_NCHITTEST message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEHOOKSTRUCT.dwExtraInfo">
            <summary>
            <para>Type: <c>ULONG_PTR</c></para>
            <para>Additional information associated with the message.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MOUSEHOOKSTRUCTEX">
            <summary>
            <para>Contains information about a mouse event passed to a <c>WH_MOUSE</c> hook procedure, MouseProc.</para>
            <para>
            This is an extension of the MOUSEHOOKSTRUCT structure that includes information about wheel movement or the use of the X button.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEHOOKSTRUCTEX.pt">
            <summary>
            <para>Type: <c>POINT</c></para>
            <para>The x- and y-coordinates of the cursor, in screen coordinates.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEHOOKSTRUCTEX.hwnd">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that will receive the mouse message corresponding to the mouse event.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEHOOKSTRUCTEX.wHitTestCode">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The hit-test value. For a list of hit-test values, see the description of the WM_NCHITTEST message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEHOOKSTRUCTEX.dwExtraInfo">
            <summary>
            <para>Type: <c>ULONG_PTR</c></para>
            <para>Additional information associated with the message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEHOOKSTRUCTEX.mouseData">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            If the message is WM_MOUSEWHEEL, the HIWORD of this member is the wheel delta. The LOWORD is undefined and reserved. A
            positive value indicates that the wheel was rotated forward, away from the user; a negative value indicates that the wheel
            was rotated backward, toward the user. One wheel click is defined as WHEEL_DELTA, which is 120.
            </para>
            <para>
            If the message is WM_XBUTTONDOWN, WM_XBUTTONUP, WM_XBUTTONDBLCLK, WM_NCXBUTTONDOWN, WM_NCXBUTTONUP, or WM_NCXBUTTONDBLCLK,
            the HIWORD of <c>mouseData</c> specifies which X button was pressed or released, and the LOWORD is undefined and reserved.
            This member can be one or more of the following values. Otherwise, <c>mouseData</c> is not used.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>XBUTTON1 0x0001</term>
            <term>The first X button was pressed or released.</term>
            </item>
            <item>
            <term>XBUTTON2 0x0002</term>
            <term>The second X button was pressed or released.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MSLLHOOKSTRUCT">
            <summary>
            <para>Contains information about a low-level mouse input event.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MSLLHOOKSTRUCT.pt">
            <summary>
            <para>Type: <c>POINT</c></para>
            <para>The x- and y-coordinates of the cursor, in per-monitor-aware screen coordinates.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MSLLHOOKSTRUCT.mouseData">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            If the message is WM_MOUSEWHEEL, the high-order word of this member is the wheel delta. The low-order word is reserved. A
            positive value indicates that the wheel was rotated forward, away from the user; a negative value indicates that the wheel
            was rotated backward, toward the user. One wheel click is defined as <c>WHEEL_DELTA</c>, which is 120.
            </para>
            <para>
            If the message is WM_XBUTTONDOWN, WM_XBUTTONUP, WM_XBUTTONDBLCLK, WM_NCXBUTTONDOWN, WM_NCXBUTTONUP, or WM_NCXBUTTONDBLCLK,
            the high-order word specifies which X button was pressed or released, and the low-order word is reserved. This value can be
            one or more of the following values. Otherwise, <c>mouseData</c> is not used.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>XBUTTON1 0x0001</term>
            <term>The first X button was pressed or released.</term>
            </item>
            <item>
            <term>XBUTTON2 0x0002</term>
            <term>The second X button was pressed or released.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MSLLHOOKSTRUCT.flags">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            The event-injected flags. An application can use the following values to test the flags. Testing LLMHF_INJECTED (bit 0) will
            tell you whether the event was injected. If it was, then testing LLMHF_LOWER_IL_INJECTED (bit 1) will tell you whether or
            not the event was injected from a process running at lower integrity level.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>LLMHF_INJECTED 0x00000001</term>
            <term>Test the event-injected (from any process) flag.</term>
            </item>
            <item>
            <term>LLMHF_LOWER_IL_INJECTED 0x00000002</term>
            <term>Test the event-injected (from a process running at lower integrity level) flag.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MSLLHOOKSTRUCT.time">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The time stamp for this message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MSLLHOOKSTRUCT.dwExtraInfo">
            <summary>
            <para>Type: <c>ULONG_PTR</c></para>
            <para>Additional information associated with the message.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.EventConstants">
            <summary>
            <para>
            This topic describes the events that are generated by the operating system and by server applications. The constants are listed
            in alphabetical order.
            </para>
            <para>
            Prior to using these events, client applications should use Accessible Event Watcher to verify that these events are used by UI elements.
            </para>
            <para>
            For more information about events in general, see What Are WinEvents? and System Level and Object Level Events. For more
            information about the events sent by the system, see Appendix A: Supported User Interface Elements Reference.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_AIA_END">
            <summary>
            The range of WinEvent constant values specified by the Accessibility Interoperability Alliance (AIA) for use across the
            industry. For more information, see Allocation of WinEvent IDs.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_AIA_START">
            <summary>
            The range of WinEvent constant values specified by the Accessibility Interoperability Alliance (AIA) for use across the
            industry. For more information, see Allocation of WinEvent IDs.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_CONSOLE_CARET">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_CONSOLE_END">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_CONSOLE_END_APPLICATION">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_CONSOLE_LAYOUT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_CONSOLE_START_APPLICATION">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_CONSOLE_UPDATE_REGION">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_CONSOLE_UPDATE_SCROLL">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_CONSOLE_UPDATE_SIMPLE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_MAX">
            <summary>The highest possible event values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_MIN">
            <summary>The lowest possible event values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_ACCELERATORCHANGE">
            <summary>
            An object's KeyboardShortcut property has changed. Server applications send this event for their accessible objects.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_CLOAKED">
            <summary>Sent when a window is cloaked. A cloaked window still exists, but is invisible to the user.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_CONTENTSCROLLED">
            <summary>
            A window object's scrolling has ended. Unlike EVENT_SYSTEM_SCROLLEND, this event is associated with the scrolling window.
            Whether the scrolling is horizontal or vertical scrolling, this event should be sent whenever the scroll action is completed.
            <para>
            The hwnd parameter of the WinEventProc callback function describes the scrolling window; the idObject parameter is
            OBJID_CLIENT, and the idChild parameter is CHILDID_SELF.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_CREATE">
            <summary>
            An object has been created. The system sends this event for the following user interface elements: caret, header control,
            list-view control, tab control, toolbar control, tree view control, and window object. Server applications send this event
            for their accessible objects.
            <para>
            Before sending the event for the parent object, servers must send it for all of an object's child objects. Servers must
            ensure that all child objects are fully created and ready to accept IAccessible calls from clients before the parent object
            sends this event.
            </para>
            <para>
            Because a parent object is created after its child objects, clients must make sure that an object's parent has been created
            before calling IAccessible::get_accParent, particularly if in-context hook functions are used.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_DEFACTIONCHANGE">
            <summary>
            An object's DefaultAction property has changed. The system sends this event for dialog boxes. Server applications send this
            event for their accessible objects.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_DESCRIPTIONCHANGE">
            <summary>An object's Description property has changed. Server applications send this event for their accessible objects.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_DESTROY">
            <summary>
            An object has been destroyed. The system sends this event for the following user interface elements: caret, header control,
            list-view control, tab control, toolbar control, tree view control, and window object. Server applications send this event
            for their accessible objects.
            <para>Clients assume that all of an object's children are destroyed when the parent object sends this event.</para>
            <para>
            After receiving this event, clients do not call an object's IAccessible properties or methods. However, the interface
            pointer must remain valid as long as there is a reference count on it (due to COM rules), but the UI element may no longer
            be present. Further calls on the interface pointer may return failure errors; to prevent this, servers create proxy objects
            and monitor their life spans.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_DRAGCANCEL">
            <summary>
            The user has ended a drag operation before dropping the dragged element on a drop target. The hwnd, idObject, and idChild
            parameters of the WinEventProc callback function identify the object being dragged.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_DRAGCOMPLETE">
            <summary>
            The user dropped an element on a drop target. The hwnd, idObject, and idChild parameters of the WinEventProc callback
            function identify the object being dragged.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_DRAGDROPPED">
            <summary>
            The user dropped an element on a drop target. The hwnd, idObject, and idChild parameters of the WinEventProc callback
            function identify the drop target.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_DRAGENTER">
            <summary>
            The user dragged an element into a drop target's boundary. The hwnd, idObject, and idChild parameters of the WinEventProc
            callback function identify the drop target.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_DRAGLEAVE">
            <summary>
            The user dragged an element out of a drop target's boundary. The hwnd, idObject, and idChild parameters of the WinEventProc
            callback function identify the drop target.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_DRAGSTART">
            <summary>
            The user started to drag an element. The hwnd, idObject, and idChild parameters of the WinEventProc callback function
            identify the object being dragged.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_END">
            <summary>The highest object event value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_FOCUS">
            <summary>
            An object has received the keyboard focus. The system sends this event for the following user interface elements: list-view
            control, menu bar, pop-up menu, switch window, tab control, tree view control, and window object. Server applications send
            this event for their accessible objects.
            <para>The hwnd parameter of the WinEventProc callback function identifies the window that receives the keyboard focus.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_HELPCHANGE">
            <summary>An object's Help property has changed. Server applications send this event for their accessible objects.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_HIDE">
            <summary>
            An object is hidden. The system sends this event for the following user interface elements: caret and cursor. Server
            applications send this event for their accessible objects.
            <para>
            When this event is generated for a parent object, all child objects are already hidden. Server applications do not send this
            event for the child objects.
            </para>
            <para>
            Hidden objects include the STATE_SYSTEM_INVISIBLE flag; shown objects do not include this flag. The EVENT_OBJECT_HIDE event
            also indicates that the STATE_SYSTEM_INVISIBLE flag is set. Therefore, servers do not send the EVENT_STATE_CHANGE event in
            this case.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_HOSTEDOBJECTSINVALIDATED">
            <summary>
            A window that hosts other accessible objects has changed the hosted objects. A client might need to query the host window to
            discover the new hosted objects, especially if the client has been monitoring events from the window. A hosted object is an
            object from an accessibility framework (MSAA or UI Automation) that is different from that of the host. Changes in hosted
            objects that are from the same framework as the host should be handed with the structural change events, such as
            EVENT_OBJECT_CREATE for MSAA. For more info see comments within winuser.h.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_IME_CHANGE">
            <summary>The size or position of an IME window has changed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_IME_HIDE">
            <summary>An IME window has become hidden.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_IME_SHOW">
            <summary>An IME window has become visible.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_INVOKED">
            <summary>
            An object has been invoked; for example, the user has clicked a button. This event is supported by common controls and is
            used by UI Automation.
            <para>
            For this event, the hwnd, ID, and idChild parameters of the WinEventProc callback function identify the item that is invoked.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_LIVEREGIONCHANGED">
            <summary>
            An object that is part of a live region has changed. A live region is an area of an application that changes frequently
            and/or asynchronously.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_LOCATIONCHANGE">
            <summary>
            An object has changed location, shape, or size. The system sends this event for the following user interface elements: caret
            and window objects. Server applications send this event for their accessible objects.
            <para>
            This event is generated in response to a change in the top-level object within the object hierarchy; it is not generated for
            any children that the object might have. For example, if the user resizes a window, the system sends this notification for
            the window, but not for the menu bar, title bar, scroll bar, or other objects that have also changed.
            </para>
            <para>
            The system does not send this event for every non-floating child window when the parent moves. However, if an application
            explicitly resizes child windows as a result of resizing the parent window, the system sends multiple events for the resized children.
            </para>
            <para>
            If an object's State property is set to STATE_SYSTEM_FLOATING, the server sends EVENT_OBJECT_LOCATIONCHANGE whenever the
            object changes location. If an object does not have this state, servers only trigger this event when the object moves in
            relation to its parent. For this event notification, the idChild parameter of the WinEventProc callback function identifies
            the child object that has changed.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_NAMECHANGE">
            <summary>
            An object's Name property has changed. The system sends this event for the following user interface elements: check box,
            cursor, list-view control, push button, radio button, status bar control, tree view control, and window object. Server
            applications send this event for their accessible objects.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_PARENTCHANGE">
            <summary>An object has a new parent object. Server applications send this event for their accessible objects.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_REORDER">
            <summary>
            A container object has added, removed, or reordered its children. The system sends this event for the following user
            interface elements: header control, list-view control, toolbar control, and window object. Server applications send this
            event as appropriate for their accessible objects.
            <para>
            For example, this event is generated by a list-view object when the number of child elements or the order of the elements
            changes. This event is also sent by a parent window when the Z-order for the child windows changes.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_SELECTION">
            <summary>
            The selection within a container object has changed. The system sends this event for the following user interface elements:
            list-view control, tab control, tree view control, and window object. Server applications send this event for their
            accessible objects.
            <para>
            This event signals a single selection: either a child is selected in a container that previously did not contain any
            selected children, or the selection has changed from one child to another.
            </para>
            <para>
            The hwnd and idObject parameters of the WinEventProc callback function describe the container; the idChild parameter
            identifies the object that is selected. If the selected child is a window that also contains objects, the idChild parameter
            is OBJID_WINDOW.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_SELECTIONADD">
            <summary>
            A child within a container object has been added to an existing selection. The system sends this event for the following
            user interface elements: list box, list-view control, and tree view control. Server applications send this event for their
            accessible objects.
            <para>
            The hwnd and idObject parameters of the WinEventProc callback function describe the container. The idChild parameter is the
            child that is added to the selection.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_SELECTIONREMOVE">
            <summary>
            An item within a container object has been removed from the selection. The system sends this event for the following user
            interface elements: list box, list-view control, and tree view control. Server applications send this event for their
            accessible objects.
            <para>This event signals that a child is removed from an existing selection.</para>
            <para>
            The hwnd and idObject parameters of the WinEventProc callback function describe the container; the idChild parameter
            identifies the child that has been removed from the selection.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_SELECTIONWITHIN">
            <summary>
            Numerous selection changes have occurred within a container object. The system sends this event for list boxes; server
            applications send it for their accessible objects.
            <para>
            This event is sent when the selected items within a control have changed substantially. The event informs the client that
            many selection changes have occurred, and it is sent instead of several EVENT_OBJECT_SELECTIONADD or
            EVENT_OBJECT_SELECTIONREMOVE events. The client queries for the selected items by calling the container object's
            IAccessible::get_accSelection method and enumerating the selected items.
            </para>
            <para>
            For this event notification, the hwnd and idObject parameters of the WinEventProc callback function describe the container
            in which the changes occurred.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_SHOW">
            <summary>
            A hidden object is shown. The system sends this event for the following user interface elements: caret, cursor, and window
            object. Server applications send this event for their accessible objects.
            <para>
            Clients assume that when this event is sent by a parent object, all child objects are already displayed. Therefore, server
            applications do not send this event for the child objects.
            </para>
            <para>
            Hidden objects include the STATE_SYSTEM_INVISIBLE flag; shown objects do not include this flag. The EVENT_OBJECT_SHOW event
            also indicates that the STATE_SYSTEM_INVISIBLE flag is cleared. Therefore, servers do not send the EVENT_STATE_CHANGE event
            in this case.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_STATECHANGE">
            <summary>
            An object's state has changed. The system sends this event for the following user interface elements: check box, combo box,
            header control, push button, radio button, scroll bar, toolbar control, tree view control, up-down control, and window
            object. Server applications send this event for their accessible objects.
            <para>For example, a state change occurs when a button object is clicked or released, or when an object is enabled or disabled.</para>
            <para>
            For this event notification, the idChild parameter of the WinEventProc callback function identifies the child object whose
            state has changed.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_TEXTEDIT_CONVERSIONTARGETCHANGED">
            <summary>
            The conversion target within an IME composition has changed. The conversion target is the subset of the IME composition
            which is actively selected as the target for user-initiated conversions.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_TEXTSELECTIONCHANGED">
            <summary>
            An object's text selection has changed. This event is supported by common controls and is used by UI Automation.
            <para>
            The hwnd, ID, and idChild parameters of the WinEventProc callback function describe the item that is contained in the
            updated text selection.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_UNCLOAKED">
            <summary>Sent when a window is uncloaked. A cloaked window still exists, but is invisible to the user.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OBJECT_VALUECHANGE">
            <summary>
            An object's Value property has changed. The system sends this event for the user interface elements that include the scroll
            bar and the following controls: edit, header, hot key, progress bar, slider, and up-down. Server applications send this
            event for their accessible objects.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OEM_DEFINED_END">
            <summary>The range of event constant values reserved for OEMs. For more information, see Allocation of WinEvent IDs.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_OEM_DEFINED_START">
            <summary>The range of event constant values reserved for OEMs. For more information, see Allocation of WinEvent IDs.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_ALERT">
            <summary>An alert has been generated. Server applications should not send this event.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_ARRANGMENTPREVIEW">
            <summary>A preview rectangle is being displayed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_CAPTUREEND">
            <summary>A window has lost mouse capture. This event is sent by the system, never by servers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_CAPTURESTART">
            <summary>A window has received mouse capture. This event is sent by the system, never by servers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_CONTEXTHELPEND">
            <summary>A window has exited context-sensitive Help mode. This event is not sent consistently by the system.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_CONTEXTHELPSTART">
            <summary>A window has entered context-sensitive Help mode. This event is not sent consistently by the system.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_DESKTOPSWITCH">
            <summary>The active desktop has been switched.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_DIALOGEND">
            <summary>
            A dialog box has been closed. The system sends this event for standard dialog boxes; servers send it for custom dialog
            boxes. This event is not sent consistently by the system.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_DIALOGSTART">
            <summary>
            A dialog box has been displayed. The system sends this event for standard dialog boxes, which are created using resource
            templates or Win32 dialog box functions. Servers send this event for custom dialog boxes, which are windows that function as
            dialog boxes but are not created in the standard way.
            <para>This event is not sent consistently by the system.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_DRAGDROPEND">
            <summary>
            An application is about to exit drag-and-drop mode. Applications that support drag-and-drop operations must send this event;
            the system does not send this event.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_DRAGDROPSTART">
            <summary>
            An application is about to enter drag-and-drop mode. Applications that support drag-and-drop operations must send this event
            because the system does not send it.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_END">
            <summary>The highest system event value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_FOREGROUND">
            <summary>
            The foreground window has changed. The system sends this event even if the foreground window has changed to another window
            in the same thread. Server applications never send this event.
            <para>
            For this event, the WinEventProc callback function's hwnd parameter is the handle to the window that is in the foreground,
            the idObject parameter is OBJID_WINDOW, and the idChild parameter is CHILDID_SELF.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_IME_KEY_NOTIFICATION">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_MENUEND">
            <summary>
            A menu from the menu bar has been closed. The system sends this event for standard menus; servers send it for custom menus.
            <para>
            For this event, the WinEventProc callback function's hwnd, idObject, and idChild parameters refer to the control that
            contains the menu bar or the control that activates the context menu. The hwnd parameter is the handle to the window that is
            related to the event. The idObject parameter is OBJID_MENU or OBJID_SYSMENU for a menu, or OBJID_WINDOW for a pop-up menu.
            The idChild parameter is CHILDID_SELF.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_MENUPOPUPEND">
            <summary>
            A pop-up menu has been closed. The system sends this event for standard menus; servers send it for custom menus.
            <para>When a pop-up menu is closed, the client receives this message, and then the EVENT_SYSTEM_MENUEND event.</para>
            <para>This event is not sent consistently by the system.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_MENUPOPUPSTART">
            <summary>
            A pop-up menu has been displayed. The system sends this event for standard menus, which are identified by HMENU, and are
            created using menu-template resources or Win32 menu functions. Servers send this event for custom menus, which are user
            interface elements that function as menus but are not created in the standard way. This event is not sent consistently by
            the system.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_MENUSTART">
            <summary>
            A menu item on the menu bar has been selected. The system sends this event for standard menus, which are identified by
            HMENU, created using menu-template resources or Win32 menu API elements. Servers send this event for custom menus, which are
            user interface elements that function as menus but are not created in the standard way.
            <para>
            For this event, the WinEventProc callback function's hwnd, idObject, and idChild parameters refer to the control that
            contains the menu bar or the control that activates the context menu. The hwnd parameter is the handle to the window related
            to the event. The idObject parameter is OBJID_MENU or OBJID_SYSMENU for a menu, or OBJID_WINDOW for a pop-up menu. The
            idChild parameter is CHILDID_SELF.
            </para>
            <para>
            The system triggers more than one EVENT_SYSTEM_MENUSTART event that does not always correspond with the EVENT_SYSTEM_MENUEND event.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_MINIMIZEEND">
            <summary>A window object is about to be restored. This event is sent by the system, never by servers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_MINIMIZESTART">
            <summary>A window object is about to be minimized. This event is sent by the system, never by servers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_MOVESIZEEND">
            <summary>The movement or resizing of a window has finished. This event is sent by the system, never by servers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_MOVESIZESTART">
            <summary>A window is being moved or resized. This event is sent by the system, never by servers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_SCROLLINGEND">
            <summary>
            Scrolling has ended on a scroll bar. This event is sent by the system for standard scroll bar controls and for scroll bars
            that are attached to a window. Servers send this event for custom scroll bars, which are user interface elements that
            function as scroll bars but are not created in the standard way.
            <para>
            The idObject parameter that is sent to the WinEventProc callback function is OBJID_HSCROLL for horizontal scroll bars, and
            OBJID_VSCROLL for vertical scroll bars.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_SCROLLINGSTART">
            <summary>
            Scrolling has started on a scroll bar. The system sends this event for standard scroll bar controls and for scroll bars
            attached to a window. Servers send this event for custom scroll bars, which are user interface elements that function as
            scroll bars but are not created in the standard way.
            <para>
            The idObject parameter that is sent to the WinEventProc callback function is OBJID_HSCROLL for horizontal scrolls bars, and
            OBJID_VSCROLL for vertical scroll bars.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_SOUND">
            <summary>
            A sound has been played. The system sends this event when a system sound, such as one for a menu, is played even if no sound
            is audible (for example, due to the lack of a sound file or a sound card). Servers send this event whenever a custom UI
            element generates a sound.
            <para>For this event, the WinEventProc callback function receives the OBJID_SOUND value as the idObject parameter.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_SWITCHEND">
            <summary>
            The user has released ALT+TAB. This event is sent by the system, never by servers. The hwnd parameter of the WinEventProc
            callback function identifies the window to which the user has switched.
            <para>
            If only one application is running when the user presses ALT+TAB, the system sends this event without a corresponding
            EVENT_SYSTEM_SWITCHSTART event.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_SWITCHER_APPDROPPED">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_SWITCHER_APPGRABBED">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_SWITCHER_APPOVERTARGET">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_SWITCHER_CANCELLED">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_SYSTEM_SWITCHSTART">
            <summary>
            The user has pressed ALT+TAB, which activates the switch window. This event is sent by the system, never by servers. The
            hwnd parameter of the WinEventProc callback function identifies the window to which the user is switching.
            <para>
            If only one application is running when the user presses ALT+TAB, the system sends an EVENT_SYSTEM_SWITCHEND event without a
            corresponding EVENT_SYSTEM_SWITCHSTART event.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_UIA_EVENTID_END">
            <summary>
            The range of event constant values reserved for UI Automation event identifiers. For more information, see Allocation of
            WinEvent IDs.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_UIA_EVENTID_START">
            <summary>
            The range of event constant values reserved for UI Automation event identifiers. For more information, see Allocation of
            WinEvent IDs.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_UIA_PROPID_END">
            <summary>
            The range of event constant values reserved for UI Automation property-changed event identifiers. For more information, see
            Allocation of WinEvent IDs.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EventConstants.EVENT_UIA_PROPID_START">
            <summary>
            The range of event constant values reserved for UI Automation property-changed event identifiers. For more information, see
            Allocation of WinEvent IDs.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ObjectIdentifiers">
            <summary>
            <para>
            This topic describes the Microsoft Active Accessibility object identifiers, 32-bit values that identify categories of accessible
            objects within a window. Microsoft Active Accessibility servers and Microsoft UI Automation providers use the object identifiers
            to determine the object to which a <c>WM_GETOBJECT</c> message request refers.
            </para>
            <para>
            Clients receive these values in their WinEventProc callback function and use them to identify parts of a window. Servers use
            these values to identify the corresponding parts of a window when calling <c>NotifyWinEvent</c> or when responding to the
            <c>WM_GETOBJECT</c> message.
            </para>
            <para>
            Servers can define custom object IDs to identify other categories of objects within their applications. Custom object IDs must
            be assigned positive values because Microsoft Active Accessibility reserves zero and all negative values for the following
            standard object identifiers.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectIdentifiers.OBJID_WINDOW">
            <summary>The window itself rather than a child object.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectIdentifiers.OBJID_SYSMENU">
            <summary>The window's system menu.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectIdentifiers.OBJID_TITLEBAR">
            <summary>The window's title bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectIdentifiers.OBJID_MENU">
            <summary>The window's menu bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectIdentifiers.OBJID_CLIENT">
            <summary>
            The window's client area. In most cases, the operating system controls the frame elements and the client object contains all
            elements that are controlled by the application. Servers only process the WM_GETOBJECT messages in which the lParam is
            OBJID_CLIENT, OBJID_WINDOW, or a custom object identifier.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectIdentifiers.OBJID_VSCROLL">
            <summary>The window's vertical scroll bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectIdentifiers.OBJID_HSCROLL">
            <summary>The window's horizontal scroll bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectIdentifiers.OBJID_SIZEGRIP">
            <summary>The window's size grip: an optional frame component located at the lower-right corner of the window frame.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectIdentifiers.OBJID_CARET">
            <summary>The text insertion bar (caret) in the window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectIdentifiers.OBJID_CURSOR">
            <summary>The mouse pointer. There is only one mouse pointer in the system, and it is not a child of any window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectIdentifiers.OBJID_ALERT">
            <summary>
            An alert that is associated with a window or an application. System provided message boxes are the only UI elements that
            send events with this object identifier. Server applications cannot use the AccessibleObjectFromX functions with this object
            identifier. This is a known issue with Microsoft Active Accessibility.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectIdentifiers.OBJID_SOUND">
            <summary>
            A sound object. Sound objects do not have screen locations or children, but they do have name and state attributes. They are
            children of the application that is playing the sound.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectIdentifiers.OBJID_QUERYCLASSNAMEIDX">
            <summary>
            An object identifier that Oleacc.dll uses internally. For more information, see Appendix F: Object Identifier Values for OBJID_QUERYCLASSNAMEIDX.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectIdentifiers.OBJID_NATIVEOM">
            <summary>
            In response to this object identifier, third-party applications can expose their own object model. Third-party applications
            can return any COM interface in response to this object identifier.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SafeHHOOK">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <see cref="T:Vanara.PInvoke.User32.HHOOK"/> that is disposed using <see cref="M:Vanara.PInvoke.User32.UnhookWindowsHookEx(Vanara.PInvoke.User32.HHOOK)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHHOOK.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHHOOK"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHHOOK.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHHOOK"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHHOOK.op_Implicit(Vanara.PInvoke.User32.SafeHHOOK)~Vanara.PInvoke.User32.HHOOK">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.User32.SafeHHOOK"/> to <see cref="T:Vanara.PInvoke.User32.HHOOK"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHHOOK.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDI_APPLICATION">
            <summary>Default application icon.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDI_HAND">
            <summary>Hand-shaped icon. Same as IDI_ERROR.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDI_QUESTION">
            <summary>Question mark icon.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDI_EXCLAMATION">
            <summary>Exclamation point icon. Same as IDI_WARNING.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDI_ASTERISK">
            <summary>Asterisk icon. Same as IDI_INFORMATION.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDI_WINLOGO">
            <summary>Default application icon. Windows 2000: Windows logo icon.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDI_SHIELD">
            <summary>Security Shield icon.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDI_WARNING">
            <summary>Exclamation point icon.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDI_ERROR">
            <summary>Hand-shaped icon.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDI_INFORMATION">
            <summary>Asterisk icon.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DrawIconExFlags">
            <summary>Flags used by <see cref="M:Vanara.PInvoke.User32.DrawIconEx(Vanara.PInvoke.HDC,System.Int32,System.Int32,Vanara.PInvoke.HICON,System.Int32,System.Int32,System.UInt32,Vanara.PInvoke.HBRUSH,Vanara.PInvoke.User32.DrawIconExFlags)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawIconExFlags.DI_MASK">
            <summary>Draws the icon or cursor using the mask.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawIconExFlags.DI_IMAGE">
            <summary>Draws the icon or cursor using the image.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawIconExFlags.DI_NORMAL">
            <summary>Combination of DI_IMAGE and DI_MASK.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawIconExFlags.DI_COMPAT">
            <summary>This flag is ignored.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawIconExFlags.DI_DEFAULTSIZE">
            <summary>
            Draws the icon or cursor using the width and height specified by the system metric values for icons, if the cxWidth and
            cyWidth parameters are set to zero. If this flag is not specified and cxWidth and cyWidth are set to zero, the function uses
            the actual resource size.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawIconExFlags.DI_NOMIRROR">
            <summary>Draws the icon as an unmirrored icon. By default, the icon is drawn as a mirrored icon if hdc is mirrored.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.CopyIcon(Vanara.PInvoke.HICON)">
            <summary>
            <para>Copies the specified icon from another module to the current module.</para>
            </summary>
            <param name="hIcon">
            <para>Type: <c>HICON</c></para>
            <para>A handle to the icon to be copied.</para>
            </param>
            <returns>
            <para>Type: <c>HICON</c></para>
            <para>If the function succeeds, the return value is a handle to the duplicate icon.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>CopyIcon</c> function enables an application or DLL to get its own handle to an icon owned by another module. If the other
            module is freed, the application icon will still be able to use the icon.
            </para>
            <para>Before closing, an application must call the DestroyIcon function to free any system resources associated with the icon.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CopyIcon(Vanara.PInvoke.HICON,Vanara.PInvoke.SIZE,Vanara.PInvoke.User32.CopyImageOptions)">
            <summary>
            Creates a new cursor and copies the attributes of the specified image to the new one. If necessary, the function stretches the
            bits to fit the desired size of the new image.
            </summary>
            <param name="h">
            <para>A handle to the image to be copied.</para>
            </param>
            <param name="desiredSize">
            The desired size, in pixels, of the image. If this is Size.Empty, then the returned image will have the same size as the original hImage.
            </param>
            <param name="options">
            <para>This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>LR_COPYDELETEORG 0x00000008</term>
            <term>Deletes the original image after creating the copy.</term>
            </item>
            <item>
            <term>LR_COPYFROMRESOURCE 0x00004000</term>
            <term>
            Tries to reload an icon or cursor resource from the original resource file rather than simply copying the current image. This is
            useful for creating a different-sized copy when the resource file contains multiple sizes of the resource. Without this flag,
            CopyImage stretches the original image to the new size. If this flag is set, CopyImage uses the size in the resource file closest
            to the desired size. This will succeed only if hImage was loaded by LoadIcon or LoadCursor, or by LoadImage with the LR_SHARED flag.
            </term>
            </item>
            <item>
            <term>LR_COPYRETURNORG 0x00000004</term>
            <term>
            Returns the original hImage if it satisfies the criteria for the copy—that is, correct dimensions and color depth—in which case
            the LR_COPYDELETEORG flag is ignored. If this flag is not specified, a new object is always created.
            </term>
            </item>
            <item>
            <term>LR_CREATEDIBSECTION 0x00002000</term>
            <term>
            If this is set and a new bitmap is created, the bitmap is created as a DIB section. Otherwise, the bitmap image is created as a
            device-dependent bitmap. This flag is only valid if uType is IMAGE_BITMAP.
            </term>
            </item>
            <item>
            <term>LR_DEFAULTSIZE 0x00000040</term>
            <term>
            Uses the width or height specified by the system metric values for cursors or icons, if the cxDesired or cyDesired values are set
            to zero. If this flag is not specified and cxDesired and cyDesired are set to zero, the function uses the actual resource size.
            If the resource contains multiple images, the function uses the size of the first image.
            </term>
            </item>
            <item>
            <term>LR_MONOCHROME 0x00000001</term>
            <term>Creates a new monochrome image.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>The return value is a safe handle to the newly created image.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateIcon(Vanara.PInvoke.HINSTANCE,System.Int32,System.Int32,System.Byte,System.Byte,System.Byte[],System.Byte[])">
            <summary>
            <para>Creates an icon that has the specified size, colors, and bit patterns.</para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to the instance of the module creating the icon.</para>
            </param>
            <param name="nWidth">
            <para>Type: <c>int</c></para>
            <para>The width, in pixels, of the icon.</para>
            </param>
            <param name="nHeight">
            <para>Type: <c>int</c></para>
            <para>The height, in pixels, of the icon.</para>
            </param>
            <param name="cPlanes">
            <para>Type: <c>BYTE</c></para>
            <para>The number of planes in the XOR bitmask of the icon.</para>
            </param>
            <param name="cBitsPixel">
            <para>Type: <c>BYTE</c></para>
            <para>The number of bits-per-pixel in the XOR bitmask of the icon.</para>
            </param>
            <param name="lpbANDbits">
            <para>Type: <c>const BYTE*</c></para>
            <para>An array of bytes that contains the bit values for the AND bitmask of the icon. This bitmask describes a monochrome bitmap.</para>
            </param>
            <param name="lpbXORbits">
            <para>Type: <c>const BYTE*</c></para>
            <para>
            An array of bytes that contains the bit values for the XOR bitmask of the icon. This bitmask describes a monochrome or
            device-dependent color bitmap.
            </para>
            </param>
            <returns>
            <para>Type: <c>HICON</c></para>
            <para>If the function succeeds, the return value is a handle to an icon.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The nWidth and nHeight parameters must specify a width and height supported by the current display driver, because the system
            cannot create icons of other sizes. To determine the width and height supported by the display driver, use the GetSystemMetrics
            function, specifying the <c>SM_CXICON</c> or <c>SM_CYICON</c> value.
            </para>
            <para><c>CreateIcon</c> applies the following truth table to the AND and XOR bitmasks.</para>
            <list type="table">
            <listheader>
            <term>AND bitmask</term>
            <term>XOR bitmask</term>
            <term>Display</term>
            </listheader>
            <item>
            <term>0</term>
            <term>0</term>
            <term>Black</term>
            </item>
            <item>
            <term>0</term>
            <term>1</term>
            <term>White</term>
            </item>
            <item>
            <term>1</term>
            <term>0</term>
            <term>Screen</term>
            </item>
            <item>
            <term>1</term>
            <term>1</term>
            <term>Reverse screen</term>
            </item>
            </list>
            <para>When you are finished using the icon, destroy it using the DestroyIcon function.</para>
            <para>Examples</para>
            <para>For an example, see Creating an Icon.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateIconFromResource(System.Byte[],System.UInt32,System.Boolean,System.UInt32)">
            <summary>
            <para>Creates an icon or cursor from resource bits describing the icon.</para>
            <para>To specify a desired height or width, use the CreateIconFromResourceEx function.</para>
            </summary>
            <param name="presbits">
            <para>Type: <c>PBYTE</c></para>
            <para>
            The buffer containing the icon or cursor resource bits. These bits are typically loaded by calls to the
            LookupIconIdFromDirectory, LookupIconIdFromDirectoryEx, and LoadResource functions.
            </para>
            </param>
            <param name="dwResSize">
            <para>Type: <c>DWORD</c></para>
            <para>The size, in bytes, of the set of bits pointed to by the presbits parameter.</para>
            </param>
            <param name="fIcon">
            <para>Type: <c>BOOL</c></para>
            <para>
            Indicates whether an icon or a cursor is to be created. If this parameter is <c>TRUE</c>, an icon is to be created. If it is
            <c>FALSE</c>, a cursor is to be created.
            </para>
            </param>
            <param name="dwVer">
            <para>Type: <c>DWORD</c></para>
            <para>
            The version number of the icon or cursor format for the resource bits pointed to by the presbits parameter. The value must be
            greater than or equal to 0x00020000 and less than or equal to 0x00030000. This parameter is generally set to 0x00030000.
            </para>
            </param>
            <returns>
            <para>Type: <c>HICON</c></para>
            <para>If the function succeeds, the return value is a handle to the icon or cursor.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>CreateIconFromResource</c>, CreateIconFromResourceEx, CreateIconIndirect, GetIconInfo, LookupIconIdFromDirectory, and
            LookupIconIdFromDirectoryEx functions allow shell applications and icon browsers to examine and use resources throughout the system.
            </para>
            <para>The <c>CreateIconFromResource</c> function calls CreateIconFromResourceEx passing as flags.</para>
            <para>When you are finished using the icon, destroy it using the DestroyIcon function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateIconFromResourceEx(System.Byte[],System.UInt32,System.Boolean,System.UInt32,System.Int32,System.Int32,Vanara.PInvoke.User32.LoadImageOptions)">
            <summary>
            <para>Creates an icon or cursor from resource bits describing the icon.</para>
            </summary>
            <param name="presbits">
            <para>Type: <c>PBYTE</c></para>
            <para>
            The icon or cursor resource bits. These bits are typically loaded by calls to the LookupIconIdFromDirectoryEx and LoadResource functions.
            </para>
            </param>
            <param name="dwResSize">
            <para>Type: <c>DWORD</c></para>
            <para>The size, in bytes, of the set of bits pointed to by the pbIconBits parameter.</para>
            </param>
            <param name="fIcon">
            <para>Type: <c>BOOL</c></para>
            <para>
            Indicates whether an icon or a cursor is to be created. If this parameter is <c>TRUE</c>, an icon is to be created. If it is
            <c>FALSE</c>, a cursor is to be created.
            </para>
            </param>
            <param name="dwVer">
            <para>Type: <c>DWORD</c></para>
            <para>
            The version number of the icon or cursor format for the resource bits pointed to by the pbIconBits parameter. The value must be
            greater than or equal to 0x00020000 and less than or equal to 0x00030000. This parameter is generally set to 0x00030000.
            </para>
            </param>
            <param name="cxDesired">
            <para>Type: <c>int</c></para>
            <para>
            The desired width, in pixels, of the icon or cursor. If this parameter is zero, the function uses the <c>SM_CXICON</c> or
            <c>SM_CXCURSOR</c> system metric value to set the width.
            </para>
            </param>
            <param name="cyDesired">
            <para>Type: <c>int</c></para>
            <para>
            The desired height, in pixels, of the icon or cursor. If this parameter is zero, the function uses the <c>SM_CYICON</c> or
            <c>SM_CYCURSOR</c> system metric value to set the height.
            </para>
            </param>
            <param name="Flags">
            <para>Type: <c>UINT</c></para>
            <para>A combination of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>LR_DEFAULTCOLOR 0x00000000</term>
            <term>Uses the default color format.</term>
            </item>
            <item>
            <term>LR_DEFAULTSIZE 0x00000040</term>
            <term>
            Uses the width or height specified by the system metric values for cursors or icons, if the cxDesired or cyDesired values are set
            to zero. If this flag is not specified and cxDesired and cyDesired are set to zero, the function uses the actual resource size.
            If the resource contains multiple images, the function uses the size of the first image.
            </term>
            </item>
            <item>
            <term>LR_MONOCHROME 0x00000001</term>
            <term>Creates a monochrome icon or cursor.</term>
            </item>
            <item>
            <term>LR_SHARED 0x00008000</term>
            <term>
            Shares the icon or cursor handle if the icon or cursor is created multiple times. If LR_SHARED is not set, a second call to
            CreateIconFromResourceEx for the same resource will create the icon or cursor again and return a different handle. When you use
            this flag, the system will destroy the resource when it is no longer needed. Do not use LR_SHARED for icons or cursors that have
            non-standard sizes, that may change after loading, or that are loaded from a file. When loading a system icon or cursor, you must
            use LR_SHARED or the function will fail to load the resource.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>HICON</c></para>
            <para>If the function succeeds, the return value is a handle to the icon or cursor.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The CreateIconFromResource, <c>CreateIconFromResourceEx</c>, CreateIconIndirect, GetIconInfo, and LookupIconIdFromDirectoryEx
            functions allow shell applications and icon browsers to examine and use resources throughout the system.
            </para>
            <para>You should call DestroyIcon for icons created with <c>CreateIconFromResourceEx</c>.</para>
            <para>Examples</para>
            <para>For an example, see Sharing Icon Resources.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateIconIndirect(Vanara.PInvoke.User32.ICONINFO)">
            <summary>
            <para>Creates an icon or cursor from an ICONINFO structure.</para>
            </summary>
            <param name="piconinfo">
            <para>Type: <c>PICONINFO</c></para>
            <para>A pointer to an ICONINFO structure the function uses to create the icon or cursor.</para>
            </param>
            <returns>
            <para>Type: <c>HICON</c></para>
            <para>If the function succeeds, the return value is a handle to the icon or cursor that is created.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The system copies the bitmaps in the ICONINFO structure before creating the icon or cursor. Because the system may temporarily
            select the bitmaps in a device context, the <c>hbmMask</c> and <c>hbmColor</c> members of the <c>ICONINFO</c> structure should
            not already be selected into a device context. The application must continue to manage the original bitmaps and delete them when
            they are no longer necessary.
            </para>
            <para>When you are finished using the icon, destroy it using the DestroyIcon function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DestroyIcon(Vanara.PInvoke.HICON)">
            <summary>
            <para>Destroys an icon and frees any memory the icon occupied.</para>
            </summary>
            <param name="hIcon">
            <para>Type: <c>HICON</c></para>
            <para>A handle to the icon to be destroyed. The icon must not be in use.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            It is only necessary to call <c>DestroyIcon</c> for icons and cursors created with the following functions:
            CreateIconFromResourceEx (if called without the <c>LR_SHARED</c> flag), CreateIconIndirect, and CopyIcon. Do not use this
            function to destroy a shared icon. A shared icon is valid as long as the module from which it was loaded remains in memory. The
            following functions obtain a shared icon.
            </para>
            <list type="bullet">
            <item>
            <term>LoadIcon</term>
            </item>
            <item>
            <term>LoadImage (if you use the <c>LR_SHARED</c> flag)</term>
            </item>
            <item>
            <term>CopyImage (if you use the <c>LR_COPYRETURNORG</c> flag and the hImage parameter is a shared icon)</term>
            </item>
            <item>
            <term>CreateIconFromResource</term>
            </item>
            <item>
            <term>CreateIconFromResourceEx (if you use the <c>LR_SHARED</c> flag)</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DrawIcon(Vanara.PInvoke.HDC,System.Int32,System.Int32,Vanara.PInvoke.HICON)">
            <summary>
            <para>Draws an icon or cursor into the specified device context.</para>
            <para>To specify additional drawing options, use the DrawIconEx function.</para>
            </summary>
            <param name="hDC">
            <para>Type: <c>HDC</c></para>
            <para>A handle to the device context into which the icon or cursor will be drawn.</para>
            </param>
            <param name="X">
            <para>Type: <c>int</c></para>
            <para>The logical x-coordinate of the upper-left corner of the icon.</para>
            </param>
            <param name="Y">
            <para>Type: <c>int</c></para>
            <para>The logical y-coordinate of the upper-left corner of the icon.</para>
            </param>
            <param name="hIcon">
            <para>Type: <c>HICON</c></para>
            <para>A handle to the icon to be drawn.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            <c>DrawIcon</c> places the icon's upper-left corner at the location specified by the X and Y parameters. The location is subject
            to the current mapping mode of the device context.
            </para>
            <para>
            <c>DrawIcon</c> draws the icon or cursor using the width and height specified by the system metric values for icons; for more
            information, see GetSystemMetrics.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying an Icon.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DrawIconEx(Vanara.PInvoke.HDC,System.Int32,System.Int32,Vanara.PInvoke.HICON,System.Int32,System.Int32,System.UInt32,Vanara.PInvoke.HBRUSH,Vanara.PInvoke.User32.DrawIconExFlags)">
            <summary>
            <para>
            Draws an icon or cursor into the specified device context, performing the specified raster operations, and stretching or
            compressing the icon or cursor as specified.
            </para>
            </summary>
            <param name="hdc">
            <para>Type: <c>HDC</c></para>
            <para>A handle to the device context into which the icon or cursor will be drawn.</para>
            </param>
            <param name="xLeft">
            <para>Type: <c>int</c></para>
            <para>The logical x-coordinate of the upper-left corner of the icon or cursor.</para>
            </param>
            <param name="yTop">
            <para>Type: <c>int</c></para>
            <para>The logical y-coordinate of the upper-left corner of the icon or cursor.</para>
            </param>
            <param name="hIcon">
            <para>Type: <c>HICON</c></para>
            <para>A handle to the icon or cursor to be drawn. This parameter can identify an animated cursor.</para>
            </param>
            <param name="cxWidth">
            <para>Type: <c>int</c></para>
            <para>
            The logical width of the icon or cursor. If this parameter is zero and the diFlags parameter is <c>DI_DEFAULTSIZE</c>, the
            function uses the <c>SM_CXICON</c> system metric value to set the width. If this parameter is zero and <c>DI_DEFAULTSIZE</c> is
            not used, the function uses the actual resource width.
            </para>
            </param>
            <param name="cyWidth">
            <para>Type: <c>int</c></para>
            <para>
            The logical height of the icon or cursor. If this parameter is zero and the diFlags parameter is <c>DI_DEFAULTSIZE</c>, the
            function uses the <c>SM_CYICON</c> system metric value to set the width. If this parameter is zero and <c>DI_DEFAULTSIZE</c> is
            not used, the function uses the actual resource height.
            </para>
            </param>
            <param name="istepIfAniCur">
            <para>Type: <c>UINT</c></para>
            <para>
            The index of the frame to draw, if hIcon identifies an animated cursor. This parameter is ignored if hIcon does not identify an
            animated cursor.
            </para>
            </param>
            <param name="hbrFlickerFreeDraw">
            <para>Type: <c>HBRUSH</c></para>
            <para>
            A handle to a brush that the system uses for flicker-free drawing. If hbrFlickerFreeDraw is a valid brush handle, the system
            creates an offscreen bitmap using the specified brush for the background color, draws the icon or cursor into the bitmap, and
            then copies the bitmap into the device context identified by hdc. If hbrFlickerFreeDraw is <c>NULL</c>, the system draws the icon
            or cursor directly into the device context.
            </para>
            </param>
            <param name="diFlags">
            <para>Type: <c>UINT</c></para>
            <para>The drawing flags. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DI_COMPAT 0x0004</term>
            <term>This flag is ignored.</term>
            </item>
            <item>
            <term>DI_DEFAULTSIZE 0x0008</term>
            <term>
            Draws the icon or cursor using the width and height specified by the system metric values for icons, if the cxWidth and cyWidth
            parameters are set to zero. If this flag is not specified and cxWidth and cyWidth are set to zero, the function uses the actual
            resource size.
            </term>
            </item>
            <item>
            <term>DI_IMAGE 0x0002</term>
            <term>Draws the icon or cursor using the image.</term>
            </item>
            <item>
            <term>DI_MASK 0x0001</term>
            <term>Draws the icon or cursor using the mask.</term>
            </item>
            <item>
            <term>DI_NOMIRROR 0x0010</term>
            <term>Draws the icon as an unmirrored icon. By default, the icon is drawn as a mirrored icon if hdc is mirrored.</term>
            </item>
            <item>
            <term>DI_NORMAL 0x0003</term>
            <term>Combination of DI_IMAGE and DI_MASK.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>DrawIconEx</c> function places the icon's upper-left corner at the location specified by the xLeft and yTop parameters.
            The location is subject to the current mapping mode of the device context.
            </para>
            <para>To duplicate , call <c>DrawIconEx</c> as follows:</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetIconInfo(Vanara.PInvoke.HICON,Vanara.PInvoke.User32.ICONINFO)">
            <summary>
            <para>Retrieves information about the specified icon or cursor.</para>
            </summary>
            <param name="hIcon">
            <para>Type: <c>HICON</c></para>
            <para>
            A handle to the icon or cursor. To retrieve information about a standard icon or cursor, specify one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IDC_APPSTARTING MAKEINTRESOURCE(32650)</term>
            <term>Standard arrow and small hourglass cursor.</term>
            </item>
            <item>
            <term>IDC_ARROW MAKEINTRESOURCE(32512)</term>
            <term>Standard arrow cursor.</term>
            </item>
            <item>
            <term>IDC_CROSS MAKEINTRESOURCE(32515)</term>
            <term>Crosshair cursor.</term>
            </item>
            <item>
            <term>IDC_HAND MAKEINTRESOURCE(32649)</term>
            <term>Hand cursor.</term>
            </item>
            <item>
            <term>IDC_HELP MAKEINTRESOURCE(32651)</term>
            <term>Arrow and question mark cursor.</term>
            </item>
            <item>
            <term>IDC_IBEAM MAKEINTRESOURCE(32513)</term>
            <term>I-beam cursor.</term>
            </item>
            <item>
            <term>IDC_NO MAKEINTRESOURCE(32648)</term>
            <term>Slashed circle cursor.</term>
            </item>
            <item>
            <term>IDC_SIZEALL MAKEINTRESOURCE(32646)</term>
            <term>Four-pointed arrow cursor pointing north, south, east, and west.</term>
            </item>
            <item>
            <term>IDC_SIZENESW MAKEINTRESOURCE(32643)</term>
            <term>Double-pointed arrow cursor pointing northeast and southwest.</term>
            </item>
            <item>
            <term>IDC_SIZENS MAKEINTRESOURCE(32645)</term>
            <term>Double-pointed arrow cursor pointing north and south.</term>
            </item>
            <item>
            <term>IDC_SIZENWSE MAKEINTRESOURCE(32642)</term>
            <term>Double-pointed arrow cursor pointing northwest and southeast.</term>
            </item>
            <item>
            <term>IDC_SIZEWE MAKEINTRESOURCE(32644)</term>
            <term>Double-pointed arrow cursor pointing west and east.</term>
            </item>
            <item>
            <term>IDC_UPARROW MAKEINTRESOURCE(32516)</term>
            <term>Vertical arrow cursor.</term>
            </item>
            <item>
            <term>IDC_WAIT MAKEINTRESOURCE(32514)</term>
            <term>Hourglass cursor.</term>
            </item>
            <item>
            <term>IDI_APPLICATION MAKEINTRESOURCE(32512)</term>
            <term>Application icon.</term>
            </item>
            <item>
            <term>IDI_ASTERISK MAKEINTRESOURCE(32516)</term>
            <term>Asterisk icon.</term>
            </item>
            <item>
            <term>IDI_EXCLAMATION MAKEINTRESOURCE(32515)</term>
            <term>Exclamation point icon.</term>
            </item>
            <item>
            <term>IDI_HAND MAKEINTRESOURCE(32513)</term>
            <term>Stop sign icon.</term>
            </item>
            <item>
            <term>IDI_QUESTION MAKEINTRESOURCE(32514)</term>
            <term>Question-mark icon.</term>
            </item>
            <item>
            <term>IDI_WINLOGO MAKEINTRESOURCE(32517)</term>
            <term>Application icon. Windows 2000: Windows logo icon.</term>
            </item>
            </list>
            </param>
            <param name="piconinfo">
            <para>Type: <c>PICONINFO</c></para>
            <para>A pointer to an ICONINFO structure. The function fills in the structure's members.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            If the function succeeds, the return value is nonzero and the function fills in the members of the specified ICONINFO structure.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            <c>GetIconInfo</c> creates bitmaps for the <c>hbmMask</c> and <c>hbmCol</c> or members of ICONINFO. The calling application must
            manage these bitmaps and delete them when they are no longer necessary.
            </para>
            <para>DPI Virtualization</para>
            <para>This API does not participate in DPI virtualization. The output returned is not affected by the DPI of the calling thread.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetIconInfoEx(Vanara.PInvoke.HICON,Vanara.PInvoke.User32.ICONINFOEX@)">
            <summary>
            <para>
            Retrieves information about the specified icon or cursor. <c>GetIconInfoEx</c> extends GetIconInfo by using the newer ICONINFOEX structure.
            </para>
            </summary>
            <param name="hicon">
            <para>Type: <c>HICON</c></para>
            <para>
            A handle to the icon or cursor. To retrieve information about a standard icon or cursor, specify one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IDC_APPSTARTING MAKEINTRESOURCE(32650)</term>
            <term>Standard arrow and small hourglass cursor.</term>
            </item>
            <item>
            <term>IDC_ARROW MAKEINTRESOURCE(32512)</term>
            <term>Standard arrow cursor.</term>
            </item>
            <item>
            <term>IDC_CROSS MAKEINTRESOURCE(32515)</term>
            <term>Crosshair cursor.</term>
            </item>
            <item>
            <term>IDC_HAND MAKEINTRESOURCE(32649)</term>
            <term>Hand cursor.</term>
            </item>
            <item>
            <term>IDC_HELP MAKEINTRESOURCE(32651)</term>
            <term>Arrow and question mark cursor.</term>
            </item>
            <item>
            <term>IDC_IBEAM MAKEINTRESOURCE(32513)</term>
            <term>I-beam cursor.</term>
            </item>
            <item>
            <term>IDC_NO MAKEINTRESOURCE(32648)</term>
            <term>Slashed circle cursor.</term>
            </item>
            <item>
            <term>IDC_SIZEALL MAKEINTRESOURCE(32646)</term>
            <term>Four-pointed arrow cursor pointing north, south, east, and west.</term>
            </item>
            <item>
            <term>IDC_SIZENESW MAKEINTRESOURCE(32643)</term>
            <term>Double-pointed arrow cursor pointing northeast and southwest.</term>
            </item>
            <item>
            <term>IDC_SIZENS MAKEINTRESOURCE(32645)</term>
            <term>Double-pointed arrow cursor pointing north and south.</term>
            </item>
            <item>
            <term>IDC_SIZENWSE MAKEINTRESOURCE(32642)</term>
            <term>Double-pointed arrow cursor pointing northwest and southeast.</term>
            </item>
            <item>
            <term>IDC_SIZEWE MAKEINTRESOURCE(32644)</term>
            <term>Double-pointed arrow cursor pointing west and east.</term>
            </item>
            <item>
            <term>IDC_UPARROW MAKEINTRESOURCE(32516)</term>
            <term>Vertical arrow cursor.</term>
            </item>
            <item>
            <term>IDC_WAIT MAKEINTRESOURCE(32514)</term>
            <term>Hourglass cursor.</term>
            </item>
            <item>
            <term>IDI_APPLICATION MAKEINTRESOURCE(32512)</term>
            <term>Application icon.</term>
            </item>
            <item>
            <term>IDI_ASTERISK MAKEINTRESOURCE(32516)</term>
            <term>Asterisk icon.</term>
            </item>
            <item>
            <term>IDI_EXCLAMATION MAKEINTRESOURCE(32515)</term>
            <term>Exclamation point icon.</term>
            </item>
            <item>
            <term>IDI_HAND MAKEINTRESOURCE(32513)</term>
            <term>Stop sign icon.</term>
            </item>
            <item>
            <term>IDI_QUESTION MAKEINTRESOURCE(32514)</term>
            <term>Question-mark icon.</term>
            </item>
            <item>
            <term>IDI_WINLOGO MAKEINTRESOURCE(32517)</term>
            <term>Application icon. Windows 2000: Windows logo icon.</term>
            </item>
            </list>
            </param>
            <param name="piconinfo">
            <para>Type: <c>PICONINFOEX</c></para>
            <para>When this method returns, contains a pointer to an ICONINFOEX structure. The function fills in the structure's members.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para><c>TRUE</c> indicates success, <c>FALSE</c> indicates failure.</para>
            </returns>
            <remarks>
            <para>
            <c>GetIconInfoEx</c> creates bitmaps for the <c>hbmMask</c> and <c>hbmCol</c> or members of ICONINFOEX. The calling application
            must manage these bitmaps and delete them when they are no longer necessary.
            </para>
            <para>DPI Virtualization</para>
            <para>This API does not participate in DPI virtualization. The output returned is not affected by the DPI of the calling thread.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetSize(Vanara.PInvoke.HICON)">
            <summary>Gets the size of an icon from its handle.</summary>
            <param name="hIcon">The icon handle.</param>
            <returns>The size of the icon in pixels.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadIcon(Vanara.PInvoke.HINSTANCE,System.String)">
            <summary>
            <para>Loads the specified icon resource from the executable (.exe) file associated with an application instance.</para>
            <para><c>Note</c> This function has been superseded by the LoadImage function.</para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>
            A handle to an instance of the module whose executable file contains the icon to be loaded. This parameter must be <c>NULL</c>
            when a standard icon is being loaded.
            </para>
            </param>
            <param name="lpIconName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The name of the icon resource to be loaded. Alternatively, this parameter can contain the resource identifier in the low-order
            word and zero in the high-order word. Use the MAKEINTRESOURCE macro to create this value.
            </para>
            <para>
            To use one of the predefined icons, set the hInstance parameter to <c>NULL</c> and the lpIconName parameter to one of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IDI_APPLICATION MAKEINTRESOURCE(32512)</term>
            <term>Default application icon.</term>
            </item>
            <item>
            <term>IDI_ASTERISK MAKEINTRESOURCE(32516)</term>
            <term>Asterisk icon. Same as IDI_INFORMATION.</term>
            </item>
            <item>
            <term>IDI_ERROR MAKEINTRESOURCE(32513)</term>
            <term>Hand-shaped icon.</term>
            </item>
            <item>
            <term>IDI_EXCLAMATION MAKEINTRESOURCE(32515)</term>
            <term>Exclamation point icon. Same as IDI_WARNING.</term>
            </item>
            <item>
            <term>IDI_HAND MAKEINTRESOURCE(32513)</term>
            <term>Hand-shaped icon. Same as IDI_ERROR.</term>
            </item>
            <item>
            <term>IDI_INFORMATION MAKEINTRESOURCE(32516)</term>
            <term>Asterisk icon.</term>
            </item>
            <item>
            <term>IDI_QUESTION MAKEINTRESOURCE(32514)</term>
            <term>Question mark icon.</term>
            </item>
            <item>
            <term>IDI_SHIELD MAKEINTRESOURCE(32518)</term>
            <term>Security Shield icon.</term>
            </item>
            <item>
            <term>IDI_WARNING MAKEINTRESOURCE(32515)</term>
            <term>Exclamation point icon.</term>
            </item>
            <item>
            <term>IDI_WINLOGO MAKEINTRESOURCE(32517)</term>
            <term>Default application icon. Windows 2000: Windows logo icon.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>HICON</c></para>
            <para>If the function succeeds, the return value is a handle to the newly loaded icon.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            <c>LoadIcon</c> loads the icon resource only if it has not been loaded; otherwise, it retrieves a handle to the existing
            resource. The function searches the icon resource for the icon most appropriate for the current display. The icon resource can be
            a color or monochrome bitmap.
            </para>
            <para>
            <c>LoadIcon</c> can only load an icon whose size conforms to the <c>SM_CXICON</c> and <c>SM_CYICON</c> system metric values. Use
            the LoadImage function to load icons of other sizes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadIcon(Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.ResourceId)">
            <summary>
            <para>Loads the specified icon resource from the executable (.exe) file associated with an application instance.</para>
            <para><c>Note</c> This function has been superseded by the LoadImage function.</para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>
            A handle to an instance of the module whose executable file contains the icon to be loaded. This parameter must be <c>NULL</c>
            when a standard icon is being loaded.
            </para>
            </param>
            <param name="lpIconName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The name of the icon resource to be loaded. Alternatively, this parameter can contain the resource identifier in the low-order
            word and zero in the high-order word. Use the MAKEINTRESOURCE macro to create this value.
            </para>
            <para>
            To use one of the predefined icons, set the hInstance parameter to <c>NULL</c> and the lpIconName parameter to one of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IDI_APPLICATION MAKEINTRESOURCE(32512)</term>
            <term>Default application icon.</term>
            </item>
            <item>
            <term>IDI_ASTERISK MAKEINTRESOURCE(32516)</term>
            <term>Asterisk icon. Same as IDI_INFORMATION.</term>
            </item>
            <item>
            <term>IDI_ERROR MAKEINTRESOURCE(32513)</term>
            <term>Hand-shaped icon.</term>
            </item>
            <item>
            <term>IDI_EXCLAMATION MAKEINTRESOURCE(32515)</term>
            <term>Exclamation point icon. Same as IDI_WARNING.</term>
            </item>
            <item>
            <term>IDI_HAND MAKEINTRESOURCE(32513)</term>
            <term>Hand-shaped icon. Same as IDI_ERROR.</term>
            </item>
            <item>
            <term>IDI_INFORMATION MAKEINTRESOURCE(32516)</term>
            <term>Asterisk icon.</term>
            </item>
            <item>
            <term>IDI_QUESTION MAKEINTRESOURCE(32514)</term>
            <term>Question mark icon.</term>
            </item>
            <item>
            <term>IDI_SHIELD MAKEINTRESOURCE(32518)</term>
            <term>Security Shield icon.</term>
            </item>
            <item>
            <term>IDI_WARNING MAKEINTRESOURCE(32515)</term>
            <term>Exclamation point icon.</term>
            </item>
            <item>
            <term>IDI_WINLOGO MAKEINTRESOURCE(32517)</term>
            <term>Default application icon. Windows 2000: Windows logo icon.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>HICON</c></para>
            <para>If the function succeeds, the return value is a handle to the newly loaded icon.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            <c>LoadIcon</c> loads the icon resource only if it has not been loaded; otherwise, it retrieves a handle to the existing
            resource. The function searches the icon resource for the icon most appropriate for the current display. The icon resource can be
            a color or monochrome bitmap.
            </para>
            <para>
            <c>LoadIcon</c> can only load an icon whose size conforms to the <c>SM_CXICON</c> and <c>SM_CYICON</c> system metric values. Use
            the LoadImage function to load icons of other sizes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.LookupIconIdFromDirectory(System.Byte[],System.Boolean)">
            <summary>
            <para>Searches through icon or cursor data for the icon or cursor that best fits the current display device.</para>
            <para>To specify a desired height or width, use the LookupIconIdFromDirectoryEx function.</para>
            </summary>
            <param name="presbits">
            <para>Type: <c>PBYTE</c></para>
            <para>
            The icon or cursor directory data. Because this function does not validate the resource data, it causes a general protection (GP)
            fault or returns an undefined value if presbits is not pointing to valid resource data.
            </para>
            </param>
            <param name="fIcon">
            <para>Type: <c>BOOL</c></para>
            <para>
            Indicates whether an icon or a cursor is sought. If this parameter is <c>TRUE</c>, the function is searching for an icon; if the
            parameter is <c>FALSE</c>, the function is searching for a cursor.
            </para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            If the function succeeds, the return value is an integer resource identifier for the icon or cursor that best fits the current
            display device.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            A resource file of type <c>RT_GROUP_ICON</c> ( <c>RT_GROUP_CURSOR</c> indicates cursors) contains icon (or cursor) data in
            several device-dependent and device-independent formats. <c>LookupIconIdFromDirectory</c> searches the resource file for the icon
            (or cursor) that best fits the current display device and returns its integer identifier. The FindResource and FindResourceEx
            functions use the MAKEINTRESOURCE macro with this identifier to locate the resource in the module.
            </para>
            <para>
            The icon directory is loaded from a resource file with resource type <c>RT_GROUP_ICON</c> (or <c>RT_GROUP_CURSOR</c> for
            cursors), and an integer resource name for the specific icon to be loaded. <c>LookupIconIdFromDirectory</c> returns an integer
            identifier that is the resource name of the icon that best fits the current display device.
            </para>
            <para>
            The LoadIcon, LoadCursor, and LoadImage functions use this function to search the specified resource data for the icon or cursor
            that best fits the current display device.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.LookupIconIdFromDirectoryEx(System.Byte[],System.Boolean,System.Int32,System.Int32,Vanara.PInvoke.User32.LoadImageOptions)">
            <summary>
            <para>Searches through icon or cursor data for the icon or cursor that best fits the current display device.</para>
            </summary>
            <param name="presbits">
            <para>Type: <c>PBYTE</c></para>
            <para>
            The icon or cursor directory data. Because this function does not validate the resource data, it causes a general protection (GP)
            fault or returns an undefined value if presbits is not pointing to valid resource data.
            </para>
            </param>
            <param name="fIcon">
            <para>Type: <c>BOOL</c></para>
            <para>
            Indicates whether an icon or a cursor is sought. If this parameter is <c>TRUE</c>, the function is searching for an icon; if the
            parameter is <c>FALSE</c>, the function is searching for a cursor.
            </para>
            </param>
            <param name="cxDesired">
            <para>Type: <c>int</c></para>
            <para>
            The desired width, in pixels, of the icon. If this parameter is zero, the function uses the <c>SM_CXICON</c> or
            <c>SM_CXCURSOR</c> system metric value.
            </para>
            </param>
            <param name="cyDesired">
            <para>Type: <c>int</c></para>
            <para>
            The desired height, in pixels, of the icon. If this parameter is zero, the function uses the <c>SM_CYICON</c> or
            <c>SM_CYCURSOR</c> system metric value.
            </para>
            </param>
            <param name="Flags">
            <para>Type: <c>UINT</c></para>
            <para>A combination of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>LR_DEFAULTCOLOR 0x00000000</term>
            <term>Uses the default color format.</term>
            </item>
            <item>
            <term>LR_MONOCHROME 0x00000001</term>
            <term>Creates a monochrome icon or cursor.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            If the function succeeds, the return value is an integer resource identifier for the icon or cursor that best fits the current
            display device.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            A resource file of type <c>RT_GROUP_ICON</c> ( <c>RT_GROUP_CURSOR</c> indicates cursors) contains icon (or cursor) data in
            several device-dependent and device-independent formats. <c>LookupIconIdFromDirectoryEx</c> searches the resource file for the
            icon (or cursor) that best fits the current display device and returns its integer identifier. The FindResource and
            FindResourceEx functions use the MAKEINTRESOURCE macro with this identifier to locate the resource in the module.
            </para>
            <para>
            The icon directory is loaded from a resource file with resource type <c>RT_GROUP_ICON</c> (or <c>RT_GROUP_CURSOR</c> for
            cursors), and an integer resource name for the specific icon to be loaded. <c>LookupIconIdFromDirectoryEx</c> returns an integer
            identifier that is the resource name of the icon that best fits the current display device.
            </para>
            <para>
            The LoadIcon, LoadImage, and LoadCursor functions use this function to search the specified resource data for the icon or cursor
            that best fits the current display device.
            </para>
            <para>Examples</para>
            <para>For an example, see Sharing Icon Resources.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.PrivateExtractIcons(System.String,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.User32.SafeHICON[],System.UInt32@,System.UInt32,Vanara.PInvoke.User32.LoadImageOptions)">
            <summary>
            <para>[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]</para>
            <para>Creates an array of handles to icons that are extracted from a specified file.</para>
            </summary>
            <param name="szFileName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The path and name of the file from which the icon(s) are to be extracted.</para>
            </param>
            <param name="nIconIndex">
            <para>Type: <c>int</c></para>
            <para>
            The zero-based index of the first icon to extract. For example, if this value is zero, the function extracts the first icon in
            the specified file.
            </para>
            </param>
            <param name="cxIcon">
            <para>Type: <c>int</c></para>
            <para>The horizontal icon size wanted. See Remarks.</para>
            </param>
            <param name="cyIcon">
            <para>Type: <c>int</c></para>
            <para>The vertical icon size wanted. See Remarks.</para>
            </param>
            <param name="phicon">
            <para>Type: <c>HICON*</c></para>
            <para>A pointer to the returned array of icon handles.</para>
            </param>
            <param name="piconid">
            <para>Type: <c>UINT*</c></para>
            <para>
            A pointer to a returned resource identifier for the icon that best fits the current display device. The returned identifier is
            0xFFFFFFFF if the identifier is not available for this format. The returned identifier is 0 if the identifier cannot otherwise be obtained.
            </para>
            </param>
            <param name="nIcons">
            <para>Type: <c>UINT</c></para>
            <para>The number of icons to extract from the file. This parameter is only valid when extracting from .exe and .dll files.</para>
            </param>
            <param name="flags">
            <para>Type: <c>UINT</c></para>
            <para>Specifies flags that control this function. These flags are the LR_* flags used by the LoadImage function.</para>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>
            If the phiconparameter is <c>NULL</c> and this function succeeds, then the return value is the number of icons in the file. If
            the function fails then the return value is 0.
            </para>
            <para>
            If the phicon parameter is not <c>NULL</c> and the function succeeds, then the return value is the number of icons extracted.
            Otherwise, the return value is 0xFFFFFFFF if the file is not found.
            </para>
            </returns>
            <remarks>
            <para>
            This function extracts from executable (.exe), DLL (.dll), icon (.ico), cursor (.cur), animated cursor (.ani), and bitmap (.bmp)
            files. Extractions from Windows 3.x 16-bit executables (.exe or .dll) are also supported.
            </para>
            <para>
            The cxIcon and cyIcon parameters specify the size of the icons to extract. Two sizes can be extracted by putting the first size
            in the LOWORD of the parameter and the second size in the HIWORD. For example, for both the cxIcon and cyIcon parameters would
            extract both 24 and 48 size icons.
            </para>
            <para>You must destroy all icons extracted by <c>PrivateExtractIcons</c> by calling the DestroyIcon function.</para>
            <para>
            This function was not included in the SDK headers and libraries until Windows XP Service Pack 1 (SP1) and Windows Server 2003. If
            you do not have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ToHBITMAP(Vanara.PInvoke.HICON)">
            <summary>Creates a <see cref="T:Vanara.PInvoke.Gdi32.SafeHBITMAP"/> from this HICON instance.</summary>
            <returns>A bitmap handle.</returns>
        </member>
        <member name="T:Vanara.PInvoke.User32.ICONINFOEX">
            <summary>
            <para>Contains information about an icon or a cursor. Extends ICONINFO. Used by GetIconInfoEx.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONINFOEX.cbSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The size, in bytes, of this structure.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONINFOEX.fIcon">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONINFOEX.xHotspot">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            The x-coordinate of a cursor's hot spot. If this structure defines an icon, the hot spot is always in the center of the icon,
            and this member is ignored.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONINFOEX.yHotspot">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            The y-coordinate of the cursor's hot spot. If this structure defines an icon, the hot spot is always in the center of the
            icon, and this member is ignored.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONINFOEX.hbmMask">
            <summary>
            <para>Type: <c>HBITMAP</c></para>
            <para>
            The icon bitmask bitmap. If this structure defines a black and white icon, this bitmask is formatted so that the upper half
            is the icon AND bitmask and the lower half is the icon XOR bitmask. Under this condition, the height should be an even
            multiple of two. If this structure defines a color icon, this mask only defines the AND bitmask of the icon.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONINFOEX.hbmColor">
            <summary>
            <para>Type: <c>HBITMAP</c></para>
            <para>
            A handle to the icon color bitmap. This member can be optional if this structure defines a black and white icon. The AND
            bitmask of <c>hbmMask</c> is applied with the <c>SRCAND</c> flag to the destination; subsequently, the color bitmap is
            applied (using XOR) to the destination by using the <c>SRCINVERT</c> flag.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONINFOEX.wResID">
            <summary>
            <para>Type: <c>WORD</c></para>
            <para>
            The icon or cursor resource bits. These bits are typically loaded by calls to the LookupIconIdFromDirectoryEx and
            LoadResource functions.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONINFOEX.szModName">
            <summary>
            <para>Type: <c>TCHAR[MAX_PATH]</c></para>
            <para>The fully qualified path of the module.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONINFOEX.szResName">
            <summary>
            <para>Type: <c>TCHAR[MAX_PATH]</c></para>
            <para>The fully qualified path of the resource.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SafeHICON">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> to a Windows that disposes a created HICON instance at disposal using DestroyIcon.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHICON.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHICON"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="P:Vanara.PInvoke.User32.SafeHICON.Size">
            <summary>Gets the size of this icon in pixels.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHICON.op_Implicit(Vanara.PInvoke.User32.SafeHICON)~Vanara.PInvoke.HICON">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.User32.SafeHICON"/> to <see cref="T:Vanara.PInvoke.HICON"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHICON.ToHBITMAP">
            <summary>Creates a <see cref="T:Vanara.PInvoke.Gdi32.SafeHBITMAP"/> from this HICON instance.</summary>
            <returns>A bitmap handle.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHICON.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.INPUT_MESSAGE_DEVICE_TYPE">
            <summary>
            <para>The type of device that sent the input message.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_MESSAGE_DEVICE_TYPE.IMDT_UNAVAILABLE">
            <summary>The device type isn't identified.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_MESSAGE_DEVICE_TYPE.IMDT_KEYBOARD">
            <summary>Keyboard input.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_MESSAGE_DEVICE_TYPE.IMDT_MOUSE">
            <summary>Mouse input.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_MESSAGE_DEVICE_TYPE.IMDT_TOUCH">
            <summary>Touch input.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_MESSAGE_DEVICE_TYPE.IMDT_PEN">
            <summary>Pen or stylus input.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_MESSAGE_DEVICE_TYPE.IMDT_TOUCHPAD">
            <summary>Touchpad input (Windows 8.1 and later).</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.INPUT_MESSAGE_ORIGIN_ID">
            <summary>The ID of the input message source.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_MESSAGE_ORIGIN_ID.IMO_UNAVAILABLE">
            <summary>The source isn't identified.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_MESSAGE_ORIGIN_ID.IMO_HARDWARE">
            <summary>
            The input message is from a hardware device or has been injected into the message queue by an application that has the
            UIAccess attribute set to TRUE in its manifest file. For more information about the UIAccess attribute and application
            manifests, see UAC References.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_MESSAGE_ORIGIN_ID.IMO_INJECTED">
            <summary>
            The input message has been injected (through the SendInput function) by an application that doesn't have the UIAccess
            attribute set to TRUE in its manifest file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_MESSAGE_ORIGIN_ID.IMO_SYSTEM">
            <summary>The system has injected the input message.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.INPUTTYPE">
            <summary>Type for <see cref="T:Vanara.PInvoke.User32.INPUT"/> structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUTTYPE.INPUT_MOUSE">
            <summary>The event is a mouse event. Use the mi structure of the union.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUTTYPE.INPUT_KEYBOARD">
            <summary>The event is a keyboard event. Use the ki structure of the union.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUTTYPE.INPUT_HARDWARE">
            <summary>The event is a hardware event. Use the hi structure of the union.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MouseState">
            <summary>The mouse state flags.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MouseState.MOUSE_ATTRIBUTES_CHANGED">
            <summary>Mouse attributes changed; application needs to query the mouse attributes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MouseState.MOUSE_MOVE_RELATIVE">
            <summary>Mouse movement data is relative to the last mouse position.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MouseState.MOUSE_MOVE_ABSOLUTE">
            <summary>Mouse movement data is based on absolute position.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MouseState.MOUSE_VIRTUAL_DESKTOP">
            <summary>Mouse coordinates are mapped to the virtual desktop (for a multiple monitor system).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MouseState.MOUSE_MOVE_NOCOALESCE">
            <summary>Do not coalesce mouse moves.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RI_KEY">
            <summary>Flags for scan code information.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_KEY.RI_KEY_MAKE">
            <summary>The key is down.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_KEY.RI_KEY_BREAK">
            <summary>The key is up.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_KEY.RI_KEY_E0">
            <summary>The scan code has the E0 prefix.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_KEY.RI_KEY_E1">
            <summary>The scan code has the E1 prefix.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_KEY.RI_KEY_TERMSRV_SET_LED">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_KEY.RI_KEY_TERMSRV_SHADOW">
            <summary>Undocumented</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RI_MOUSE">
            <summary>Mouse button transition state indicators.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_LEFT_BUTTON_DOWN">
            <summary>Left button changed to down.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_LEFT_BUTTON_UP">
            <summary>Left button changed to up.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_RIGHT_BUTTON_DOWN">
            <summary>Right button changed to down.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_RIGHT_BUTTON_UP">
            <summary>Right button changed to up.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_MIDDLE_BUTTON_DOWN">
            <summary>Middle button changed to down.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_MIDDLE_BUTTON_UP">
            <summary>Middle button changed to up.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_BUTTON_1_DOWN">
            <summary>RI_MOUSE_LEFT_BUTTON_DOWN</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_BUTTON_1_UP">
            <summary>RI_MOUSE_LEFT_BUTTON_UP</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_BUTTON_2_DOWN">
            <summary>RI_MOUSE_RIGHT_BUTTON_DOWN</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_BUTTON_2_UP">
            <summary>RI_MOUSE_RIGHT_BUTTON_UP</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_BUTTON_3_DOWN">
            <summary>RI_MOUSE_MIDDLE_BUTTON_DOWN</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_BUTTON_3_UP">
            <summary>RI_MOUSE_MIDDLE_BUTTON_UP</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_BUTTON_4_DOWN">
            <summary>XBUTTON1 changed to down.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_BUTTON_4_UP">
            <summary>XBUTTON1 changed to up.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_BUTTON_5_DOWN">
            <summary>XBUTTON2 changed to down.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_BUTTON_5_UP">
            <summary>XBUTTON2 changed to up.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_WHEEL">
            <summary>Raw input comes from a mouse wheel. The wheel delta is stored in usButtonData.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RI_MOUSE.RI_MOUSE_HWHEEL">
            <summary>Raw input comes from a mouse horizontal wheel. The wheel delta is stored in usButtonData.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RID">
            <summary>The command flag for <see cref="M:Vanara.PInvoke.User32.GetRawInputData(Vanara.PInvoke.User32.HRAWINPUT,Vanara.PInvoke.User32.RID,System.IntPtr,System.UInt32@,System.UInt32)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID.RID_INPUT">
            <summary>Get the raw data from the RAWINPUT structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID.RID_HEADER">
            <summary>Get the header information from the RAWINPUT structure.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RIDEV">
            <summary>Mode flag that specifies how to interpret the information provided by usUsagePage and usUsage in <see cref="T:Vanara.PInvoke.User32.RAWINPUTDEVICE"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RIDEV.RIDEV_APPKEYS">
            <summary>
            If set, the application command keys are handled. RIDEV_APPKEYS can be specified only if RIDEV_NOLEGACY is specified for a
            keyboard device.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RIDEV.RIDEV_CAPTUREMOUSE">
            <summary>If set, the mouse button click does not activate the other window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RIDEV.RIDEV_DEVNOTIFY">
            <summary>
            If set, this enables the caller to receive WM_INPUT_DEVICE_CHANGE notifications for device arrival and device removal.
            <page>Windows XP: This flag is not supported until Windows Vista</page>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RIDEV.RIDEV_EXCLUDE">
            <summary>
            If set, this specifies the top level collections to exclude when reading a complete usage page. This flag only affects a TLC
            whose usage page is already specified with RIDEV_PAGEONLY.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RIDEV.RIDEV_EXINPUTSINK">
            <summary>
            If set, this enables the caller to receive input in the background only if the foreground application does not process it.
            In other words, if the foreground application is not registered for raw input, then the background application that is
            registered will receive the input. <page>Windows XP: This flag is not supported until Windows Vista</page>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RIDEV.RIDEV_INPUTSINK">
            <summary>
            If set, this enables the caller to receive the input even when the caller is not in the foreground. Note that hwndTarget
            must be specified.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RIDEV.RIDEV_NOHOTKEYS">
            <summary>
            If set, the application-defined keyboard device hotkeys are not handled. However, the system hotkeys; for example, ALT+TAB
            and CTRL+ALT+DEL, are still handled. By default, all keyboard hotkeys are handled. RIDEV_NOHOTKEYS can be specified even if
            RIDEV_NOLEGACY is not specified and hwndTarget is NULL.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RIDEV.RIDEV_NOLEGACY">
            <summary>
            If set, this prevents any devices specified by usUsagePage or usUsage from generating legacy messages. This is only for the
            mouse and keyboard. See Remarks.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RIDEV.RIDEV_PAGEONLY">
            <summary>
            If set, this specifies all devices whose top level collection is from the specified usUsagePage. Note that usUsage must be
            zero. To exclude a particular top level collection, use RIDEV_EXCLUDE.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RIDEV.RIDEV_REMOVE">
            <summary>
            If set, this removes the top level collection from the inclusion list. This tells the operating system to stop reading from
            a device which matches the top level collection.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RIM_TYPE">
            <summary>The type of raw input.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RIM_TYPE.RIM_TYPEHID">
            <summary>Raw input comes from some device that is not a keyboard or a mouse.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RIM_TYPE.RIM_TYPEKEYBOARD">
            <summary>Raw input comes from the keyboard.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RIM_TYPE.RIM_TYPEMOUSE">
            <summary>Raw input comes from the mouse.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.DefRawInputProc(Vanara.PInvoke.User32.RAWINPUT[],System.Int32,System.UInt32)">
            <summary>
            Calls the default raw input procedure to provide default processing for any raw input messages that an application does not
            process. This function ensures that every message is processed. <c>DefRawInputProc</c> is called with the same parameters
            received by the window procedure.
            </summary>
            <param name="paRawInput">
            <para>Type: <c>PRAWINPUT*</c></para>
            <para>An array of RAWINPUT structures.</para>
            </param>
            <param name="nInput">
            <para>Type: <c>INT</c></para>
            <para>The number of RAWINPUT structures pointed to by paRawInput.</para>
            </param>
            <param name="cbSizeHeader">
            <para>Type: <c>UINT</c></para>
            <para>The size, in bytes, of the RAWINPUTHEADER structure.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>If successful, the function returns <c>S_OK</c>. Otherwise it returns an error value.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetCurrentInputMessageSource(Vanara.PInvoke.User32.INPUT_MESSAGE_SOURCE@)">
            <summary>Retrieves the source of the input message.</summary>
            <param name="inputMessageSource">
            <para>The INPUT_MESSAGE_SOURCE structure that holds the device type and the ID of the input message source.</para>
            <para>
            <c>Note</c><c>deviceType</c> in INPUT_MESSAGE_SOURCE is set to IMDT_UNAVAILABLE when SendMessage is used to inject input (system
            generated or through messages such as WM_PAINT). This remains true until <c>SendMessage</c> returns.
            </para>
            </param>
            <returns>
            If this function succeeds, it returns TRUE. Otherwise, it returns FALSE. To retrieve extended error information, call the
            GetLastError function.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetLastInputInfo(Vanara.PInvoke.User32.LASTINPUTINFO@)">
            <summary>Retrieves the time of the last input event.</summary>
            <param name="plii">
            <para>Type: <c>PLASTINPUTINFO</c></para>
            <para>A pointer to a LASTINPUTINFO structure that receives the time of the last input event.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            This function is useful for input idle detection. However, <c>GetLastInputInfo</c> does not provide system-wide user input
            information across all running sessions. Rather, <c>GetLastInputInfo</c> provides session-specific user input information for
            only the session that invoked the function.
            </para>
            <para>
            The tick count when the last input event was received (see LASTINPUTINFO) is not guaranteed to be incremental. In some cases,
            the value might be less than the tick count of a prior event. For example, this can be caused by a timing gap between the raw
            input thread and the desktop thread or an event raised by SendInput, which supplies its own tick count.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetRawInputBuffer(System.IntPtr,System.UInt32@,System.UInt32)">
            <summary>Performs a buffered read of the raw input data.</summary>
            <param name="pData">
            <para>Type: <c>PRAWINPUT</c></para>
            <para>
            A pointer to a buffer of RAWINPUT structures that contain the raw input data. If <c>NULL</c>, the minimum required buffer, in
            bytes, is returned in *pcbSize.
            </para>
            </param>
            <param name="pcbSize">
            <para>Type: <c>PUINT</c></para>
            <para>The size, in bytes, of a RAWINPUT structure.</para>
            </param>
            <param name="cbSizeHeader">
            <para>Type: <c>UINT</c></para>
            <para>The size, in bytes, of the RAWINPUTHEADER structure.</para>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>
            If pData is NULL and the function is successful, the return value is zero. If pData is not NULL and the function is successful,
            the return value is the number of RAWINPUT structures written to pData.
            </para>
            <para>If an error occurs, the return value is ( <c>UINT</c>)-1. Call GetLastError for the error code.</para>
            </returns>
            <remarks>
            <para>
            Using <c>GetRawInputBuffer</c>, the raw input data is buffered in the array of RAWINPUT structures. For an unbuffered read, use
            the GetMessage function to read in the raw input data.
            </para>
            <para>The NEXTRAWINPUTBLOCK macro allows an application to traverse an array of RAWINPUT structures.</para>
            <para>
            <c>Note</c> To get the correct size of the raw input buffer, do not use *pcbSize, use *pcbSize * 8 instead. To ensure
            <c>GetRawInputBuffer</c> behaves properly on WOW64, you must align the RAWINPUT structure by 8 bytes. The following code shows
            how to align <c>RAWINPUT</c> for WOW64.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetRawInputData(Vanara.PInvoke.User32.HRAWINPUT,Vanara.PInvoke.User32.RID,System.IntPtr,System.UInt32@,System.UInt32)">
            <summary>Retrieves the raw input from the specified device.</summary>
            <param name="hRawInput">
            <para>Type: <c>HRAWINPUT</c></para>
            <para>A handle to the RAWINPUT structure. This comes from the lParam in WM_INPUT.</para>
            </param>
            <param name="uiCommand">
            <para>Type: <c>UINT</c></para>
            <para>The command flag. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>RID_HEADER 0x10000005</term>
            <term>Get the header information from the RAWINPUT structure.</term>
            </item>
            <item>
            <term>RID_INPUT 0x10000003</term>
            <term>Get the raw data from the RAWINPUT structure.</term>
            </item>
            </list>
            </param>
            <param name="pData">
            <para>Type: <c>LPVOID</c></para>
            <para>
            A pointer to the data that comes from the RAWINPUT structure. This depends on the value of uiCommand. If pData is <c>NULL</c>,
            the required size of the buffer is returned in *pcbSize.
            </para>
            </param>
            <param name="pcbSize">
            <para>Type: <c>PUINT</c></para>
            <para>The size, in bytes, of the data in pData.</para>
            </param>
            <param name="cbSizeHeader">
            <para>Type: <c>UINT</c></para>
            <para>The size, in bytes, of the RAWINPUTHEADER structure.</para>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>
            If pData is <c>NULL</c> and the function is successful, the return value is 0. If pData is not <c>NULL</c> and the function is
            successful, the return value is the number of bytes copied into pData.
            </para>
            <para>If there is an error, the return value is ( <c>UINT</c>)-1.</para>
            </returns>
            <remarks>
            <c>GetRawInputData</c> gets the raw input one RAWINPUT structure at a time. In contrast, GetRawInputBuffer gets an array of
            <c>RAWINPUT</c> structures.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetRawInputDeviceInfo(Vanara.PInvoke.HANDLE,System.UInt32,System.IntPtr,System.UInt32@)">
            <summary>Retrieves information about the raw input device.</summary>
            <param name="hDevice">
            <para>Type: <c>HANDLE</c></para>
            <para>A handle to the raw input device. This comes from the <c>hDevice</c> member of RAWINPUTHEADER or from GetRawInputDeviceList.</para>
            </param>
            <param name="uiCommand">
            <para>Type: <c>UINT</c></para>
            <para>Specifies what data will be returned in pData. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>RIDI_DEVICENAME 0x20000007</term>
            <term>
            pData points to a string that contains the device name. For this uiCommand only, the value in pcbSize is the character count
            (not the byte count).
            </term>
            </item>
            <item>
            <term>RIDI_DEVICEINFO 0x2000000b</term>
            <term>pData points to an RID_DEVICE_INFO structure.</term>
            </item>
            <item>
            <term>RIDI_PREPARSEDDATA 0x20000005</term>
            <term>pData points to the previously parsed data.</term>
            </item>
            </list>
            </param>
            <param name="pData">
            <para>Type: <c>LPVOID</c></para>
            <para>
            A pointer to a buffer that contains the information specified by uiCommand. If uiCommand is <c>RIDI_DEVICEINFO</c>, set the
            <c>cbSize</c> member of RID_DEVICE_INFO to before calling <c>GetRawInputDeviceInfo</c>.
            </para>
            </param>
            <param name="pcbSize">
            <para>Type: <c>PUINT</c></para>
            <para>The size, in bytes, of the data in pData.</para>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>If successful, this function returns a non-negative number indicating the number of bytes copied to pData.</para>
            <para>
            If pData is not large enough for the data, the function returns -1. If pData is <c>NULL</c>, the function returns a value of
            zero. In both of these cases, pcbSize is set to the minimum size required for the pData buffer.
            </para>
            <para>Call GetLastError to identify any other errors.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetRawInputDeviceList(Vanara.PInvoke.User32.RAWINPUTDEVICELIST[],System.UInt32@,System.UInt32)">
            <summary>Enumerates the raw input devices attached to the system.</summary>
            <param name="pRawInputDeviceList">
            <para>Type: <c>PRAWINPUTDEVICELIST</c></para>
            <para>
            An array of RAWINPUTDEVICELIST structures for the devices attached to the system. If <c>NULL</c>, the number of devices are
            returned in *puiNumDevices.
            </para>
            </param>
            <param name="puiNumDevices">
            <para>Type: <c>PUINT</c></para>
            <para>
            If pRawInputDeviceList is <c>NULL</c>, the function populates this variable with the number of devices attached to the system;
            otherwise, this variable specifies the number of RAWINPUTDEVICELIST structures that can be contained in the buffer to which
            pRawInputDeviceList points. If this value is less than the number of devices attached to the system, the function returns the
            actual number of devices in this variable and fails with <c>ERROR_INSUFFICIENT_BUFFER</c>.
            </para>
            </param>
            <param name="cbSize">
            <para>Type: <c>UINT</c></para>
            <para>The size of a RAWINPUTDEVICELIST structure, in bytes.</para>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>If the function is successful, the return value is the number of devices stored in the buffer pointed to by pRawInputDeviceList.</para>
            <para>On any other error, the function returns ( <c>UINT</c>) -1 and GetLastError returns the error indication.</para>
            </returns>
            <remarks>
            <para>The devices returned from this function are the mouse, the keyboard, and other Human Interface Device (HID) devices.</para>
            <para>To get more detailed information about the attached devices, call GetRawInputDeviceInfo using the hDevice from RAWINPUTDEVICELIST.</para>
            <para>Examples</para>
            <para>The following sample code shows a typical call to <c>GetRawInputDeviceList</c>:</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetRegisteredRawInputDevices(Vanara.PInvoke.User32.RAWINPUTDEVICE[],System.UInt32@,System.UInt32)">
            <summary>Retrieves the information about the raw input devices for the current application.</summary>
            <param name="pRawInputDevices">
            <para>Type: <c>PRAWINPUTDEVICE</c></para>
            <para>An array of RAWINPUTDEVICE structures for the application.</para>
            </param>
            <param name="puiNumDevices">
            <para>Type: <c>PUINT</c></para>
            <para>The number of RAWINPUTDEVICE structures in *pRawInputDevices.</para>
            </param>
            <param name="cbSize">
            <para>Type: <c>UINT</c></para>
            <para>The size, in bytes, of a RAWINPUTDEVICE structure.</para>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>
            If successful, the function returns a non-negative number that is the number of RAWINPUTDEVICE structures written to the buffer.
            </para>
            <para>
            If the pRawInputDevices buffer is too small or <c>NULL</c>, the function sets the last error as
            <c>ERROR_INSUFFICIENT_BUFFER</c>, returns -1, and sets puiNumDevices to the required number of devices. If the function fails
            for any other reason, it returns -1. For more details, call GetLastError.
            </para>
            </returns>
            <remarks>To receive raw input from a device, an application must register it by using RegisterRawInputDevices.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterRawInputDevices(Vanara.PInvoke.User32.RAWINPUTDEVICE[],System.UInt32,System.UInt32)">
            <summary>Registers the devices that supply the raw input data.</summary>
            <param name="pRawInputDevices">
            <para>Type: <c>PCRAWINPUTDEVICE</c></para>
            <para>An array of RAWINPUTDEVICE structures that represent the devices that supply the raw input.</para>
            </param>
            <param name="uiNumDevices">
            <para>Type: <c>UINT</c></para>
            <para>The number of RAWINPUTDEVICE structures pointed to by pRawInputDevices.</para>
            </param>
            <param name="cbSize">
            <para>Type: <c>UINT</c></para>
            <para>The size, in bytes, of a RAWINPUTDEVICE structure.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para><c>TRUE</c> if the function succeeds; otherwise, <c>FALSE</c>. If the function fails, call GetLastError for more information.</para>
            </returns>
            <remarks>
            <para>
            To receive WM_INPUT messages, an application must first register the raw input devices using <c>RegisterRawInputDevices</c>. By
            default, an application does not receive raw input.
            </para>
            <para>
            To receive WM_INPUT_DEVICE_CHANGE messages, an application must specify the RIDEV_DEVNOTIFY flag for each device class that is
            specified by the usUsagePage and usUsage fields of the RAWINPUTDEVICE structure . By default, an application does not receive
            <c>WM_INPUT_DEVICE_CHANGE</c> notifications for raw input device arrival and removal.
            </para>
            <para>
            If a RAWINPUTDEVICE structure has the RIDEV_REMOVE flag set and the hwndTarget parameter is not set to NULL, then parameter
            validation will fail.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendInput(System.UInt32,Vanara.PInvoke.User32.INPUT[],System.Int32)">
            <summary>Synthesizes keystrokes, mouse motions, and button clicks.</summary>
            <param name="cInputs">
            <para>Type: <c>UINT</c></para>
            <para>The number of structures in the pInputs array.</para>
            </param>
            <param name="pInputs">
            <para>Type: <c>LPINPUT</c></para>
            <para>An array of INPUT structures. Each structure represents an event to be inserted into the keyboard or mouse input stream.</para>
            </param>
            <param name="cbSize">
            <para>Type: <c>int</c></para>
            <para>The size, in bytes, of an INPUT structure. If cbSize is not the size of an <c>INPUT</c> structure, the function fails.</para>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>
            The function returns the number of events that it successfully inserted into the keyboard or mouse input stream. If the function
            returns zero, the input was already blocked by another thread. To get extended error information, call GetLastError.
            </para>
            <para>
            This function fails when it is blocked by UIPI. Note that neither GetLastError nor the return value will indicate the failure
            was caused by UIPI blocking.
            </para>
            </returns>
            <remarks>
            <para>
            This function is subject to UIPI. Applications are permitted to inject input only into applications that are at an equal or
            lesser integrity level.
            </para>
            <para>
            The <c>SendInput</c> function inserts the events in the INPUT structures serially into the keyboard or mouse input stream. These
            events are not interspersed with other keyboard or mouse input events inserted either by the user (with the keyboard or mouse)
            or by calls to keybd_event, mouse_event, or other calls to <c>SendInput</c>.
            </para>
            <para>
            This function does not reset the keyboard's current state. Any keys that are already pressed when the function is called might
            interfere with the events that this function generates. To avoid this problem, check the keyboard's state with the
            GetAsyncKeyState function and correct as necessary.
            </para>
            <para>
            Because the touch keyboard uses the surrogate macros defined in winnls.h to send input to the system, a listener on the keyboard
            event hook must decode input originating from the touch keyboard. For more information, see Surrogates and Supplementary Characters.
            </para>
            <para>
            An accessibility application can use <c>SendInput</c> to inject keystrokes corresponding to application launch shortcut keys
            that are handled by the shell. This functionality is not guaranteed to work for other types of applications.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.HARDWAREINPUT">
            <summary>Contains information about a simulated message generated by an input device other than a keyboard or mouse.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HARDWAREINPUT.uMsg">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The message generated by the input hardware.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HARDWAREINPUT.wParamL">
            <summary>
            <para>Type: <c>WORD</c></para>
            <para>The low-order word of the lParam parameter for <c>uMsg</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HARDWAREINPUT.wParamH">
            <summary>
            <para>Type: <c>WORD</c></para>
            <para>The high-order word of the lParam parameter for <c>uMsg</c>.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.HRAWINPUT">
            <summary>Provides a handle to a RAWINPUT structure.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.HRAWINPUT.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.HRAWINPUT"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.User32.HRAWINPUT.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.User32.HRAWINPUT"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.HRAWINPUT.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.HRAWINPUT.op_Explicit(Vanara.PInvoke.User32.HRAWINPUT)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.User32.HRAWINPUT"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HRAWINPUT.op_Implicit(System.IntPtr)~Vanara.PInvoke.User32.HRAWINPUT">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.User32.HRAWINPUT"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HRAWINPUT.op_Inequality(Vanara.PInvoke.User32.HRAWINPUT,Vanara.PInvoke.User32.HRAWINPUT)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HRAWINPUT.op_Equality(Vanara.PInvoke.User32.HRAWINPUT,Vanara.PInvoke.User32.HRAWINPUT)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HRAWINPUT.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.HRAWINPUT.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.HRAWINPUT.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.INPUT">
            <summary>
            Used by SendInput to store information for synthesizing input events such as keystrokes, mouse movement, and mouse clicks.
            </summary>
            <remarks>
            <c>INPUT_KEYBOARD</c> supports nonkeyboard input methods, such as handwriting recognition or voice recognition, as if it were
            text input by using the <c>KEYEVENTF_UNICODE</c> flag. For more information, see the remarks section of KEYBDINPUT.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT.type">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The type of the input event. This member can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>INPUT_MOUSE 0</term>
            <term>The event is a mouse event. Use the mi structure of the union.</term>
            </item>
            <item>
            <term>INPUT_KEYBOARD 1</term>
            <term>The event is a keyboard event. Use the ki structure of the union.</term>
            </item>
            <item>
            <term>INPUT_HARDWARE 2</term>
            <term>The event is a hardware event. Use the hi structure of the union.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.INPUT.mi">
            <summary>
            <para>Type: <c>MOUSEINPUT</c></para>
            <para>The information about a simulated mouse event.</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.INPUT.ki">
            <summary>
            <para>Type: <c>KEYBDINPUT</c></para>
            <para>The information about a simulated keyboard event.</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.INPUT.hi">
            <summary>
            <para>Type: <c>HARDWAREINPUT</c></para>
            <para>The information about a simulated hardware event.</para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.INPUT.#ctor(Vanara.PInvoke.User32.KEYEVENTF,System.UInt16)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.INPUT"/> struct for keyboard input.</summary>
            <param name="keyFlags">Specifies various aspects of a keystroke.</param>
            <param name="vkOrScan">
            If KEYEVENTF_SCANCODE, the value represents a hardware scan code for the key, otherwise, this value represents a virtual key-code.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.User32.INPUT.#ctor(Vanara.PInvoke.User32.MOUSEEVENTF,System.Int32,System.Int32,System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.INPUT"/> struct for mouse input.</summary>
            <param name="keyFlags">A set of bit flags that specify various aspects of mouse motion and button clicks.</param>
            <param name="mouseData">
            <para>
            If <c>dwFlags</c> contains <c>MOUSEEVENTF_WHEEL</c>, then <c>mouseData</c> specifies the amount of wheel movement. A
            positive value indicates that the wheel was rotated forward, away from the user; a negative value indicates that the wheel
            was rotated backward, toward the user. One wheel click is defined as <c>WHEEL_DELTA</c>, which is 120.
            </para>
            <para>
            Windows Vista: If dwFlags contains <c>MOUSEEVENTF_HWHEEL</c>, then dwData specifies the amount of wheel movement. A positive
            value indicates that the wheel was rotated to the right; a negative value indicates that the wheel was rotated to the left.
            One wheel click is defined as <c>WHEEL_DELTA</c>, which is 120.
            </para>
            <para>
            If <c>dwFlags</c> does not contain <c>MOUSEEVENTF_WHEEL</c>, <c>MOUSEEVENTF_XDOWN</c>, or <c>MOUSEEVENTF_XUP</c>, then
            <c>mouseData</c> should be zero.
            </para>
            <para>
            If <c>dwFlags</c> contains <c>MOUSEEVENTF_XDOWN</c> or <c>MOUSEEVENTF_XUP</c>, then <c>mouseData</c> specifies which X
            buttons were pressed or released. This value may be any combination of the following flags.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>XBUTTON1 0x0001</term>
            <term>Set if the first X button is pressed or released.</term>
            </item>
            <item>
            <term>XBUTTON2 0x0002</term>
            <term>Set if the second X button is pressed or released.</term>
            </item>
            </list>
            </param>
            <param name="dx">
            The absolute position of the mouse, or the amount of motion since the last mouse event was generated, depending on the value
            of the <c>dwFlags</c> member. Absolute data is specified as the x coordinate of the mouse; relative data is specified as the
            number of pixels moved.
            </param>
            <param name="dy">
            The absolute position of the mouse, or the amount of motion since the last mouse event was generated, depending on the value
            of the <c>dwFlags</c> member. Absolute data is specified as the y coordinate of the mouse; relative data is specified as the
            number of pixels moved.
            </param>
        </member>
        <member name="T:Vanara.PInvoke.User32.INPUT_MESSAGE_SOURCE">
            <summary>Contains information about the source of the input message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_MESSAGE_SOURCE.deviceType">
            <summary>The device type (INPUT_MESSAGE_DEVICE_TYPE) of the source of the input message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_MESSAGE_SOURCE.originId">
            <summary>The ID (INPUT_MESSAGE_ORIGIN_ID) of the source of the input message.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.LASTINPUTINFO">
            <summary>Contains the time of the last input.</summary>
            <remarks>This function is useful for input idle detection. For more information on tick counts, see GetTickCount.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.LASTINPUTINFO.cbSize">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The size of the structure, in bytes. This member must be set to sizeof(LASTINPUTINFO).</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LASTINPUTINFO.dwTime">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The tick count when the last input event was received.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LASTINPUTINFO.Default">
            <summary>Gets a default instance with the size field set appropriately.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MOUSEINPUT">
            <summary>Contains information about a simulated mouse event.</summary>
            <remarks>
            <para>
            If the mouse has moved, indicated by <c>MOUSEEVENTF_MOVE</c>, <c>dx</c> and <c>dy</c> specify information about that movement.
            The information is specified as absolute or relative integer values.
            </para>
            <para>
            If <c>MOUSEEVENTF_ABSOLUTE</c> value is specified, <c>dx</c> and <c>dy</c> contain normalized absolute coordinates between 0 and
            65,535. The event procedure maps these coordinates onto the display surface. Coordinate (0,0) maps onto the upper-left corner of
            the display surface; coordinate (65535,65535) maps onto the lower-right corner. In a multimonitor system, the coordinates map to
            the primary monitor.
            </para>
            <para>If <c>MOUSEEVENTF_VIRTUALDESK</c> is specified, the coordinates map to the entire virtual desktop.</para>
            <para>
            If the <c>MOUSEEVENTF_ABSOLUTE</c> value is not specified, <c>dx</c> and <c>dy</c> specify movement relative to the previous
            mouse event (the last reported position). Positive values mean the mouse moved right (or down); negative values mean the mouse
            moved left (or up).
            </para>
            <para>
            Relative mouse motion is subject to the effects of the mouse speed and the two-mouse threshold values. A user sets these three
            values with the <c>Pointer Speed</c> slider of the Control Panel's <c>Mouse Properties</c> sheet. You can obtain and set these
            values using the SystemParametersInfo function.
            </para>
            <para>
            The system applies two tests to the specified relative mouse movement. If the specified distance along either the x or y axis is
            greater than the first mouse threshold value, and the mouse speed is not zero, the system doubles the distance. If the specified
            distance along either the x or y axis is greater than the second mouse threshold value, and the mouse speed is equal to two, the
            system doubles the distance that resulted from applying the first threshold test. It is thus possible for the system to multiply
            specified relative mouse movement along the x or y axis by up to four times.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEINPUT.dx">
            <summary>
            <para>Type: <c>LONG</c></para>
            <para>
            The absolute position of the mouse, or the amount of motion since the last mouse event was generated, depending on the value
            of the <c>dwFlags</c> member. Absolute data is specified as the x coordinate of the mouse; relative data is specified as the
            number of pixels moved.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEINPUT.dy">
            <summary>
            <para>Type: <c>LONG</c></para>
            <para>
            The absolute position of the mouse, or the amount of motion since the last mouse event was generated, depending on the value
            of the <c>dwFlags</c> member. Absolute data is specified as the y coordinate of the mouse; relative data is specified as the
            number of pixels moved.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEINPUT.mouseData">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            If <c>dwFlags</c> contains <c>MOUSEEVENTF_WHEEL</c>, then <c>mouseData</c> specifies the amount of wheel movement. A
            positive value indicates that the wheel was rotated forward, away from the user; a negative value indicates that the wheel
            was rotated backward, toward the user. One wheel click is defined as <c>WHEEL_DELTA</c>, which is 120.
            </para>
            <para>
            Windows Vista: If dwFlags contains <c>MOUSEEVENTF_HWHEEL</c>, then dwData specifies the amount of wheel movement. A positive
            value indicates that the wheel was rotated to the right; a negative value indicates that the wheel was rotated to the left.
            One wheel click is defined as <c>WHEEL_DELTA</c>, which is 120.
            </para>
            <para>
            If <c>dwFlags</c> does not contain <c>MOUSEEVENTF_WHEEL</c>, <c>MOUSEEVENTF_XDOWN</c>, or <c>MOUSEEVENTF_XUP</c>, then
            <c>mouseData</c> should be zero.
            </para>
            <para>
            If <c>dwFlags</c> contains <c>MOUSEEVENTF_XDOWN</c> or <c>MOUSEEVENTF_XUP</c>, then <c>mouseData</c> specifies which X
            buttons were pressed or released. This value may be any combination of the following flags.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>XBUTTON1 0x0001</term>
            <term>Set if the first X button is pressed or released.</term>
            </item>
            <item>
            <term>XBUTTON2 0x0002</term>
            <term>Set if the second X button is pressed or released.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEINPUT.dwFlags">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            A set of bit flags that specify various aspects of mouse motion and button clicks. The bits in this member can be any
            reasonable combination of the following values.
            </para>
            <para>
            The bit flags that specify mouse button status are set to indicate changes in status, not ongoing conditions. For example,
            if the left mouse button is pressed and held down, <c>MOUSEEVENTF_LEFTDOWN</c> is set when the left button is first pressed,
            but not for subsequent motions. Similarly, <c>MOUSEEVENTF_LEFTUP</c> is set only when the button is first released.
            </para>
            <para>
            You cannot specify both the <c>MOUSEEVENTF_WHEEL</c> flag and either <c>MOUSEEVENTF_XDOWN</c> or <c>MOUSEEVENTF_XUP</c>
            flags simultaneously in the <c>dwFlags</c> parameter, because they both require use of the <c>mouseData</c> field.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MOUSEEVENTF_ABSOLUTE 0x8000</term>
            <term>
            The dx and dy members contain normalized absolute coordinates. If the flag is not set, dxand dy contain relative data (the
            change in position since the last reported position). This flag can be set, or not set, regardless of what kind of mouse or
            other pointing device, if any, is connected to the system. For further information about relative mouse motion, see the
            following Remarks section.
            </term>
            </item>
            <item>
            <term>MOUSEEVENTF_HWHEEL 0x01000</term>
            <term>
            The wheel was moved horizontally, if the mouse has a wheel. The amount of movement is specified in mouseData. Windows
            XP/2000: This value is not supported.
            </term>
            </item>
            <item>
            <term>MOUSEEVENTF_MOVE 0x0001</term>
            <term>Movement occurred.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_MOVE_NOCOALESCE 0x2000</term>
            <term>
            The WM_MOUSEMOVE messages will not be coalesced. The default behavior is to coalesce WM_MOUSEMOVE messages. Windows XP/2000:
            This value is not supported.
            </term>
            </item>
            <item>
            <term>MOUSEEVENTF_LEFTDOWN 0x0002</term>
            <term>The left button was pressed.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_LEFTUP 0x0004</term>
            <term>The left button was released.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_RIGHTDOWN 0x0008</term>
            <term>The right button was pressed.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_RIGHTUP 0x0010</term>
            <term>The right button was released.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_MIDDLEDOWN 0x0020</term>
            <term>The middle button was pressed.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_MIDDLEUP 0x0040</term>
            <term>The middle button was released.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_VIRTUALDESK 0x4000</term>
            <term>Maps coordinates to the entire desktop. Must be used with MOUSEEVENTF_ABSOLUTE.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_WHEEL 0x0800</term>
            <term>The wheel was moved, if the mouse has a wheel. The amount of movement is specified in mouseData.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_XDOWN 0x0080</term>
            <term>An X button was pressed.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_XUP 0x0100</term>
            <term>An X button was released.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEINPUT.time">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The time stamp for the event, in milliseconds. If this parameter is 0, the system will provide its own time stamp.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEINPUT.dwExtraInfo">
            <summary>
            <para>Type: <c>ULONG_PTR</c></para>
            <para>
            An additional value associated with the mouse event. An application calls GetMessageExtraInfo to obtain this extra information.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RAWHID">
            <summary>Describes the format of the raw input from a Human Interface Device (HID).</summary>
            <remarks>
            Each WM_INPUT can indicate several inputs, but all of the inputs come from the same HID. The size of the <c>bRawData</c> array
            is <c>dwSizeHid</c> * <c>dwCount</c>.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWHID.dwSizeHid">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The size, in bytes, of each HID input in <c>bRawData</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWHID.dwCount">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The number of HID inputs in <c>bRawData</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWHID.bRawData">
            <summary>
            <para>Type: <c>BYTE[1]</c></para>
            <para>The raw input data, as an array of bytes.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RAWINPUT">
            <summary>Contains the raw input from a device.</summary>
            <remarks>
            <para>The handle to this structure is passed in the lParam parameter of WM_INPUT.</para>
            <para>To get detailed information -- such as the header and the content of the raw input -- call GetRawInputData.</para>
            <para>To read the <c>RAWINPUT</c> in the message loop as a buffered read, call GetRawInputBuffer.</para>
            <para>To get device specific information, call GetRawInputDeviceInfo with the hDevice from RAWINPUTHEADER.</para>
            <para>Raw input is available only when the application calls RegisterRawInputDevices with valid device specifications.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWINPUT.header">
            <summary>
            <para>Type: <c>RAWINPUTHEADER</c></para>
            <para>The raw input data.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWINPUT.data">
            <summary>The data</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RAWINPUT.DATA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWINPUT.DATA.mouse">
            <summary><c>Type: <c>RAWMOUSE</c></c> If the data comes from a mouse, this is the raw input data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWINPUT.DATA.keyboard">
            <summary><c>Type: <c>RAWKEYBOARD</c></c> If the data comes from a keyboard, this is the raw input data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWINPUT.DATA.hid">
            <summary><c>Type: <c>RAWHID</c></c> If the data comes from an HID, this is the raw input data.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RAWINPUTDEVICE">
            <summary>Defines information for the raw input devices.</summary>
            <remarks>
            <para>
            If <c>RIDEV_NOLEGACY</c> is set for a mouse or a keyboard, the system does not generate any legacy message for that device for
            the application. For example, if the mouse TLC is set with <c>RIDEV_NOLEGACY</c>, WM_LBUTTONDOWN and related legacy mouse
            messages are not generated. Likewise, if the keyboard TLC is set with <c>RIDEV_NOLEGACY</c>, WM_KEYDOWN and related legacy
            keyboard messages are not generated.
            </para>
            <para>
            If <c>RIDEV_REMOVE</c> is set and the <c>hwndTarget</c> member is not set to <c>NULL</c>, then parameter validation will fail.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWINPUTDEVICE.usUsagePage">
            <summary>
            <para>Type: <c>USHORT</c></para>
            <para>Top level collection Usage page for the raw input device.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWINPUTDEVICE.usUsage">
            <summary>
            <para>Type: <c>USHORT</c></para>
            <para>Top level collection Usage for the raw input device.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWINPUTDEVICE.dwFlags">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            Mode flag that specifies how to interpret the information provided by <c>usUsagePage</c> and <c>usUsage</c>. It can be zero
            (the default) or one of the following values. By default, the operating system sends raw input from devices with the
            specified top level collection (TLC) to the registered application as long as it has the window focus.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>RIDEV_APPKEYS 0x00000400</term>
            <term>
            If set, the application command keys are handled. RIDEV_APPKEYS can be specified only if RIDEV_NOLEGACY is specified for a
            keyboard device.
            </term>
            </item>
            <item>
            <term>RIDEV_CAPTUREMOUSE 0x00000200</term>
            <term>If set, the mouse button click does not activate the other window.</term>
            </item>
            <item>
            <term>RIDEV_DEVNOTIFY 0x00002000</term>
            <term>
            If set, this enables the caller to receive WM_INPUT_DEVICE_CHANGE notifications for device arrival and device removal.
            Windows XP: This flag is not supported until Windows Vista
            </term>
            </item>
            <item>
            <term>RIDEV_EXCLUDE 0x00000010</term>
            <term>
            If set, this specifies the top level collections to exclude when reading a complete usage page. This flag only affects a TLC
            whose usage page is already specified with RIDEV_PAGEONLY.
            </term>
            </item>
            <item>
            <term>RIDEV_EXINPUTSINK 0x00001000</term>
            <term>
            If set, this enables the caller to receive input in the background only if the foreground application does not process it.
            In other words, if the foreground application is not registered for raw input, then the background application that is
            registered will receive the input. Windows XP: This flag is not supported until Windows Vista
            </term>
            </item>
            <item>
            <term>RIDEV_INPUTSINK 0x00000100</term>
            <term>
            If set, this enables the caller to receive the input even when the caller is not in the foreground. Note that hwndTarget
            must be specified.
            </term>
            </item>
            <item>
            <term>RIDEV_NOHOTKEYS 0x00000200</term>
            <term>
            If set, the application-defined keyboard device hotkeys are not handled. However, the system hotkeys; for example, ALT+TAB
            and CTRL+ALT+DEL, are still handled. By default, all keyboard hotkeys are handled. RIDEV_NOHOTKEYS can be specified even if
            RIDEV_NOLEGACY is not specified and hwndTarget is NULL.
            </term>
            </item>
            <item>
            <term>RIDEV_NOLEGACY 0x00000030</term>
            <term>
            If set, this prevents any devices specified by usUsagePage or usUsage from generating legacy messages. This is only for the
            mouse and keyboard. See Remarks.
            </term>
            </item>
            <item>
            <term>RIDEV_PAGEONLY 0x00000020</term>
            <term>
            If set, this specifies all devices whose top level collection is from the specified usUsagePage. Note that usUsage must be
            zero. To exclude a particular top level collection, use RIDEV_EXCLUDE.
            </term>
            </item>
            <item>
            <term>RIDEV_REMOVE 0x00000001</term>
            <term>
            If set, this removes the top level collection from the inclusion list. This tells the operating system to stop reading from
            a device which matches the top level collection.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWINPUTDEVICE.hwndTarget">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the target window. If <c>NULL</c> it follows the keyboard focus.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RAWINPUTDEVICELIST">
            <summary>Contains information about a raw input device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWINPUTDEVICELIST.hDevice">
            <summary>
            <para>Type: <c>HANDLE</c></para>
            <para>A handle to the raw input device.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWINPUTDEVICELIST.dwType">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The type of device. This can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>RIM_TYPEHID 2</term>
            <term>The device is an HID that is not a keyboard and not a mouse.</term>
            </item>
            <item>
            <term>RIM_TYPEKEYBOARD 1</term>
            <term>The device is a keyboard.</term>
            </item>
            <item>
            <term>RIM_TYPEMOUSE 0</term>
            <term>The device is a mouse.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RAWINPUTHEADER">
            <summary>
            <para>Contains the header information that is part of the raw input data.</para>
            </summary>
            <remarks>
            <para>To get more information on the device, use <c>hDevice</c> in a call to GetRawInputDeviceInfo.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWINPUTHEADER.dwType">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The type of raw input. It can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>RIM_TYPEHID 2</term>
            <term>Raw input comes from some device that is not a keyboard or a mouse.</term>
            </item>
            <item>
            <term>RIM_TYPEKEYBOARD 1</term>
            <term>Raw input comes from the keyboard.</term>
            </item>
            <item>
            <term>RIM_TYPEMOUSE 0</term>
            <term>Raw input comes from the mouse.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWINPUTHEADER.dwSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            The size, in bytes, of the entire input packet of data. This includes RAWINPUT plus possible extra input reports in the
            RAWHID variable length array.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWINPUTHEADER.hDevice">
            <summary>
            <para>Type: <c>HANDLE</c></para>
            <para>A handle to the device generating the raw input data.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWINPUTHEADER.wParam">
            <summary>
            <para>Type: <c>WPARAM</c></para>
            <para>The value passed in the wParam parameter of the WM_INPUT message.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RAWKEYBOARD">
            <summary>Contains information about the state of the keyboard.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWKEYBOARD.MakeCode">
            <summary>
            <para>Type: <c>USHORT</c></para>
            <para>The scan code from the key depression. The scan code for keyboard overrun is <c>KEYBOARD_OVERRUN_MAKE_CODE</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWKEYBOARD.Flags">
            <summary>
            <para>Type: <c>USHORT</c></para>
            <para>Flags for scan code information. It can be one or more of the following.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>RI_KEY_BREAK 1</term>
            <term>The key is up.</term>
            </item>
            <item>
            <term>RI_KEY_E0 2</term>
            <term>The scan code has the E0 prefix.</term>
            </item>
            <item>
            <term>RI_KEY_E1 4</term>
            <term>The scan code has the E1 prefix.</term>
            </item>
            <item>
            <term>RI_KEY_MAKE 0</term>
            <term>The key is down.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWKEYBOARD.Reserved">
            <summary>
            <para>Type: <c>USHORT</c></para>
            <para>Reserved; must be zero.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWKEYBOARD.VKey">
            <summary>
            <para>Type: <c>USHORT</c></para>
            <para>Windows message compatible virtual-key code. For more information, see Virtual Key Codes.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWKEYBOARD.Message">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The corresponding window message, for example WM_KEYDOWN, WM_SYSKEYDOWN, and so forth.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWKEYBOARD.ExtraInformation">
            <summary>
            <para>Type: <c>ULONG</c></para>
            <para>The device-specific additional information for the event.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RAWMOUSE">
            <summary>Contains information about the state of the mouse.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWMOUSE.usFlags">
            <summary>
            <para>Type: <c>USHORT</c></para>
            <para>The mouse state. This member can be any reasonable combination of the following.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MOUSE_ATTRIBUTES_CHANGED 0x04</term>
            <term>Mouse attributes changed; application needs to query the mouse attributes.</term>
            </item>
            <item>
            <term>MOUSE_MOVE_RELATIVE 0</term>
            <term>Mouse movement data is relative to the last mouse position.</term>
            </item>
            <item>
            <term>MOUSE_MOVE_ABSOLUTE 1</term>
            <term>Mouse movement data is based on absolute position.</term>
            </item>
            <item>
            <term>MOUSE_VIRTUAL_DESKTOP 0x02</term>
            <term>Mouse coordinates are mapped to the virtual desktop (for a multiple monitor system).</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWMOUSE.ulButtons">
            <summary>
            <para>Type: <c>ULONG</c></para>
            <para>Reserved.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWMOUSE.usButtonFlags">
            <summary>
            <para>Type: <c>USHORT</c></para>
            <para>The transition state of the mouse buttons. This member can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>RI_MOUSE_LEFT_BUTTON_DOWN 0x0001</term>
            <term>Left button changed to down.</term>
            </item>
            <item>
            <term>RI_MOUSE_LEFT_BUTTON_UP 0x0002</term>
            <term>Left button changed to up.</term>
            </item>
            <item>
            <term>RI_MOUSE_MIDDLE_BUTTON_DOWN 0x0010</term>
            <term>Middle button changed to down.</term>
            </item>
            <item>
            <term>RI_MOUSE_MIDDLE_BUTTON_UP 0x0020</term>
            <term>Middle button changed to up.</term>
            </item>
            <item>
            <term>RI_MOUSE_RIGHT_BUTTON_DOWN 0x0004</term>
            <term>Right button changed to down.</term>
            </item>
            <item>
            <term>RI_MOUSE_RIGHT_BUTTON_UP 0x0008</term>
            <term>Right button changed to up.</term>
            </item>
            <item>
            <term>RI_MOUSE_BUTTON_1_DOWN 0x0001</term>
            <term>RI_MOUSE_LEFT_BUTTON_DOWN</term>
            </item>
            <item>
            <term>RI_MOUSE_BUTTON_1_UP 0x0002</term>
            <term>RI_MOUSE_LEFT_BUTTON_UP</term>
            </item>
            <item>
            <term>RI_MOUSE_BUTTON_2_DOWN 0x0004</term>
            <term>RI_MOUSE_RIGHT_BUTTON_DOWN</term>
            </item>
            <item>
            <term>RI_MOUSE_BUTTON_2_UP 0x0008</term>
            <term>RI_MOUSE_RIGHT_BUTTON_UP</term>
            </item>
            <item>
            <term>RI_MOUSE_BUTTON_3_DOWN 0x0010</term>
            <term>RI_MOUSE_MIDDLE_BUTTON_DOWN</term>
            </item>
            <item>
            <term>RI_MOUSE_BUTTON_3_UP 0x0020</term>
            <term>RI_MOUSE_MIDDLE_BUTTON_UP</term>
            </item>
            <item>
            <term>RI_MOUSE_BUTTON_4_DOWN 0x0040</term>
            <term>XBUTTON1 changed to down.</term>
            </item>
            <item>
            <term>RI_MOUSE_BUTTON_4_UP 0x0080</term>
            <term>XBUTTON1 changed to up.</term>
            </item>
            <item>
            <term>RI_MOUSE_BUTTON_5_DOWN 0x100</term>
            <term>XBUTTON2 changed to down.</term>
            </item>
            <item>
            <term>RI_MOUSE_BUTTON_5_UP 0x0200</term>
            <term>XBUTTON2 changed to up.</term>
            </item>
            <item>
            <term>RI_MOUSE_WHEEL 0x0400</term>
            <term>Raw input comes from a mouse wheel. The wheel delta is stored in usButtonData.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWMOUSE.usButtonData">
            <summary>
            <para>Type: <c>USHORT</c></para>
            <para>If <c>usButtonFlags</c> is <c>RI_MOUSE_WHEEL</c>, this member is a signed value that specifies the wheel delta.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWMOUSE.ulRawButtons">
            <summary>
            <para>Type: <c>ULONG</c></para>
            <para>The raw state of the mouse buttons.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWMOUSE.lLastX">
            <summary>
            <para>Type: <c>LONG</c></para>
            <para>The motion in the X direction. This is signed relative motion or absolute motion, depending on the value of <c>usFlags</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWMOUSE.lLastY">
            <summary>
            <para>Type: <c>LONG</c></para>
            <para>The motion in the Y direction. This is signed relative motion or absolute motion, depending on the value of <c>usFlags</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RAWMOUSE.ulExtraInformation">
            <summary>
            <para>Type: <c>ULONG</c></para>
            <para>The device-specific additional information for the event.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RID_DEVICE_INFO">
            <summary>Defines the raw input data coming from any device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO.cbSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The size, in bytes, of the <c>RID_DEVICE_INFO</c> structure.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO.dwType">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The type of raw input data. This member can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>RIM_TYPEHID 2</term>
            <term>Data comes from an HID that is not a keyboard or a mouse.</term>
            </item>
            <item>
            <term>RIM_TYPEKEYBOARD 1</term>
            <term>Data comes from a keyboard.</term>
            </item>
            <item>
            <term>RIM_TYPEMOUSE 0</term>
            <term>Data comes from a mouse.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO.mouse">
            <summary>
            <para>Type: <c>RID_DEVICE_INFO_MOUSE</c></para>
            <para>If <c>dwType</c> is <c>RIM_TYPEMOUSE</c>, this is the RID_DEVICE_INFO_MOUSE structure that defines the mouse.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO.keyboard">
            <summary>
            <para>Type: <c>RID_DEVICE_INFO_KEYBOARD</c></para>
            <para>If <c>dwType</c> is <c>RIM_TYPEKEYBOARD</c>, this is the RID_DEVICE_INFO_KEYBOARD structure that defines the keyboard.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO.hid">
            <summary>
            <para>Type: <c>RID_DEVICE_INFO_HID</c></para>
            <para>If <c>dwType</c> is <c>RIM_TYPEHID</c>, this is the RID_DEVICE_INFO_HID structure that defines the HID device.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RID_DEVICE_INFO_HID">
            <summary>Defines the raw input data coming from the specified Human Interface Device (HID).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO_HID.dwVendorId">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The vendor identifier for the HID.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO_HID.dwProductId">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The product identifier for the HID.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO_HID.dwVersionNumber">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The version number for the HID.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO_HID.usUsagePage">
            <summary>
            <para>Type: <c>USHORT</c></para>
            <para>The top-level collection Usage Page for the device.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO_HID.usUsage">
            <summary>
            <para>Type: <c>USHORT</c></para>
            <para>The top-level collection Usage for the device.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RID_DEVICE_INFO_KEYBOARD">
            <summary>Defines the raw input data coming from the specified keyboard.</summary>
            <remarks>For the keyboard, the Usage Page is 1 and the Usage is 6.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO_KEYBOARD.dwType">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The type of the keyboard.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO_KEYBOARD.dwSubType">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The subtype of the keyboard.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO_KEYBOARD.dwKeyboardMode">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The scan code mode.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO_KEYBOARD.dwNumberOfFunctionKeys">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The number of function keys on the keyboard.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO_KEYBOARD.dwNumberOfIndicators">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The number of LED indicators on the keyboard.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO_KEYBOARD.dwNumberOfKeysTotal">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The total number of keys on the keyboard.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RID_DEVICE_INFO_MOUSE">
            <summary>Defines the raw input data coming from the specified mouse.</summary>
            <remarks>For the mouse, the Usage Page is 1 and the Usage is 2.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO_MOUSE.dwId">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The identifier of the mouse device.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO_MOUSE.dwNumberOfButtons">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The number of buttons for the mouse.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO_MOUSE.dwSampleRate">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The number of data points per second. This information may not be applicable for every mouse device.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RID_DEVICE_INFO_MOUSE.fHasHorizontalWheel">
            <summary>
            <para>Type: <c>BOOL</c></para>
            <para><c>TRUE</c> if the mouse has a wheel for horizontal scrolling; otherwise, <c>FALSE</c>.</para>
            <para><c>Windows XP:</c> This member is only supported starting with Windows Vista.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.HOTKEYF">
            <summary>Flags used by WM_GETHOTKEY and WM_SETHOTKEY</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HOTKEYF.HOTKEYF_SHIFT">
            <summary>SHIFT key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HOTKEYF.HOTKEYF_CONTROL">
            <summary>CTRL key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HOTKEYF.HOTKEYF_ALT">
            <summary>ALT key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HOTKEYF.HOTKEYF_EXT">
            <summary>Extended key</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.HotKeyModifiers">
            <summary>Modifiers for key press.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HotKeyModifiers.MOD_NONE">
            <summary>Nothing held down.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HotKeyModifiers.MOD_ALT">
            <summary>Either ALT key must be held down.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HotKeyModifiers.MOD_CONTROL">
            <summary>Either CTRL key must be held down.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HotKeyModifiers.MOD_SHIFT">
            <summary>Either SHIFT key must be held down.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HotKeyModifiers.MOD_WIN">
            <summary>
            Either WINDOWS key was held down. These keys are labeled with the Windows logo. Keyboard shortcuts that involve the WINDOWS
            key are reserved for use by the operating system.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HotKeyModifiers.MOD_NOREPEAT">
            <summary>
            Changes the hotkey behavior so that the keyboard auto-repeat does not yield multiple hotkey notifications.
            <para>Windows Vista: This flag is not supported.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.KEYEVENTF">
            <summary>Controls various aspects of function operation of <see cref="M:Vanara.PInvoke.User32.keybd_event(System.Byte,System.Byte,Vanara.PInvoke.User32.KEYEVENTF,System.IntPtr)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KEYEVENTF.KEYEVENTF_EXTENDEDKEY">
            <summary>If specified, the scan code was preceded by a prefix byte having the value 0xE0 (224).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KEYEVENTF.KEYEVENTF_KEYUP">
            <summary>If specified, the key is being released. If not specified, the key is being depressed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KEYEVENTF.KEYEVENTF_UNICODE">
            <summary>
            If specified, the system synthesizes a VK_PACKET keystroke. The wVk parameter must be zero. This flag can only be combined
            with the KEYEVENTF_KEYUP flag. For more information, see the Remarks section.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KEYEVENTF.KEYEVENTF_SCANCODE">
            <summary>If specified, wScan identifies the key and wVk is ignored.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.KLF">
            <summary>Flags used by keyboard layout functions.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KLF.KLF_ACTIVATE">
            <summary>
            Prior to Windows 8: If the specified input locale identifier is not already loaded, the function loads and activates the
            input locale identifier for the current thread.
            <para>
            Beginning in Windows 8: If the specified input locale identifier is not already loaded, the function loads and activates the
            input locale identifier for the system.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KLF.KLF_NOTELLSHELL">
            <summary>
            Prior to Windows 8: Prevents a ShellProchook procedure from receiving an HSHELL_LANGUAGE hook code when the new input locale
            identifier is loaded. This value is typically used when an application loads multiple input locale identifiers one after
            another. Applying this value to all but the last input locale identifier delays the shell's processing until all input
            locale identifiers have been added.
            <para>Beginning in Windows 8: In this scenario, the last input locale identifier is set for the entire system.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KLF.KLF_REORDER">
            <summary>
            Prior to Windows 8: Moves the specified input locale identifier to the head of the input locale identifier list, making that
            locale identifier the active locale identifier for the current thread. This value reorders the input locale identifier list
            even if KLF_ACTIVATE is not provided.
            <para>
            Beginning in Windows 8: Moves the specified input locale identifier to the head of the input locale identifier list, making
            that locale identifier the active locale identifier for the system. This value reorders the input locale identifier list
            even if KLF_ACTIVATE is not provided.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KLF.KLF_REPLACELANG">
            <summary>
            If the new input locale identifier has the same language identifier as a current input locale identifier, the new input
            locale identifier replaces the current one as the input locale identifier for that language. If this value is not provided
            and the input locale identifiers have the same language identifiers, the current input locale identifier is not replaced and
            the function returns NULL.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KLF.KLF_SUBSTITUTE_OK">
            <summary>
            Substitutes the specified input locale identifier with another locale preferred by the user. The system starts with this
            flag set, and it is recommended that your application always use this flag. The substitution occurs only if the registry key
            HKEY_CURRENT_USER\Keyboard\Layout\Substitutes explicitly defines a substitution locale. For example, if the key includes the
            value name "00000409" with value "00010409", loading the U.S. English layout ("00000409") causes the Dvorak U.S. English
            layout ("00010409") to be loaded instead. The system uses KLF_SUBSTITUTE_OK when booting, and it is recommended that all
            applications use this value when loading input locale identifiers to ensure that the user's preference is selected.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KLF.KLF_SETFORPROCESS">
            <summary>
            Prior to Windows 8: This flag is valid only with KLF_ACTIVATE. Activates the specified input locale identifier for the
            entire process and sends the WM_INPUTLANGCHANGE message to the current thread's Focus or Active window. Typically,
            LoadKeyboardLayout activates an input locale identifier only for the current thread.
            <para>
            Beginning in Windows 8: This flag is not used. LoadKeyboardLayout always activates an input locale identifier for the entire
            system if the current process owns the window with keyboard focus.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KLF.KLF_SHIFTLOCK">
            <summary>This is used with KLF_RESET. See KLF_RESET for an explanation.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KLF.KLF_RESET">
            <summary>
            If set but KLF_SHIFTLOCK is not set, the Caps Lock state is turned off by pressing the Caps Lock key again. If set and
            KLF_SHIFTLOCK is also set, the Caps Lock state is turned off by pressing either SHIFT key.
            <para>These two methods are mutually exclusive, and the setting persists as part of the User's profile in the registry.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MAPVK">
            <summary>The translation to be performed in <see cref="M:Vanara.PInvoke.User32.MapVirtualKey(System.UInt32,Vanara.PInvoke.User32.MAPVK)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MAPVK.MAPVK_VK_TO_VSC">
            <summary>
            uCode is a virtual-key code and is translated into a scan code. If it is a virtual-key code that does not distinguish
            between left- and right-hand keys, the left-hand scan code is returned. If there is no translation, the function returns 0.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MAPVK.MAPVK_VSC_TO_VK">
            <summary>
            uCode is a scan code and is translated into a virtual-key code that does not distinguish between left- and right-hand keys.
            If there is no translation, the function returns 0.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MAPVK.MAPVK_VK_TO_CHAR">
            <summary>
            uCode is a virtual-key code and is translated into an unshifted character value in the low-order word of the return value.
            Dead keys (diacritics) are indicated by setting the top bit of the return value. If there is no translation, the function
            returns 0.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MAPVK.MAPVK_VSC_TO_VK_EX">
            <summary>
            uCode is a scan code and is translated into a virtual-key code that distinguishes between left- and right-hand keys. If
            there is no translation, the function returns 0.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MAPVK.MAPVK_VK_TO_VSC_EX">
            <summary>
            The uCode parameter is a virtual-key code and is translated into a scan code. If it is a virtual-key code that does not
            distinguish between left- and right-hand keys, the left-hand scan code is returned. If the scan code is an extended scan
            code, the high byte of the uCode value can contain either 0xe0 or 0xe1 to specify the extended scan code. If there is no
            translation, the function returns 0.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.VK">
            <summary>
            The following table shows the symbolic constant names, hexadecimal values, and mouse or keyboard equivalents for the virtual-key
            codes used by the system. The codes are listed in numeric order.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_LBUTTON">
            <summary>Left mouse button</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_RBUTTON">
            <summary>Right mouse button</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_CANCEL">
            <summary>Control-break processing</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_MBUTTON">
            <summary>Middle mouse button (three-button mouse)</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_XBUTTON1">
            <summary>X1 mouse button</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_XBUTTON2">
            <summary>X2 mouse button</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_BACK">
            <summary>BACKSPACE key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_TAB">
            <summary>TAB key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_CLEAR">
            <summary>CLEAR key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_RETURN">
            <summary>ENTER key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_SHIFT">
            <summary>SHIFT key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_CONTROL">
            <summary>CTRL key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_MENU">
            <summary>ALT key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_PAUSE">
            <summary>PAUSE key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_CAPITAL">
            <summary>CAPS LOCK key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_KANA">
            <summary>IME Kana mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_HANGUEL">
            <summary>IME Hanguel mode (maintained for compatibility; use VK_HANGUL)</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_HANGUL">
            <summary>IME Hangul mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_IME_ON">
            <summary>IME On</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_JUNJA">
            <summary>IME Junja mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_FINAL">
            <summary>IME final mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_HANJA">
            <summary>IME Hanja mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_KANJI">
            <summary>IME Kanji mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_IME_OFF">
            <summary>IME Off</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_ESCAPE">
            <summary>ESC key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_CONVERT">
            <summary>IME convert</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_NONCONVERT">
            <summary>IME nonconvert</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_ACCEPT">
            <summary>IME accept</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_MODECHANGE">
            <summary>IME mode change request</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_SPACE">
            <summary>SPACEBAR</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_PRIOR">
            <summary>PAGE UP key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_NEXT">
            <summary>PAGE DOWN key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_END">
            <summary>END key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_HOME">
            <summary>HOME key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_LEFT">
            <summary>LEFT ARROW key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_UP">
            <summary>UP ARROW key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_RIGHT">
            <summary>RIGHT ARROW key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_DOWN">
            <summary>DOWN ARROW key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_SELECT">
            <summary>SELECT key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_PRINT">
            <summary>PRINT key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_EXECUTE">
            <summary>EXECUTE key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_SNAPSHOT">
            <summary>PRINT SCREEN key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_INSERT">
            <summary>INS key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_DELETE">
            <summary>DEL key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_HELP">
            <summary>HELP key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_0">
            <summary>0 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_1">
            <summary>1 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_2">
            <summary>2 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_3">
            <summary>3 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_4">
            <summary>4 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_5">
            <summary>5 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_6">
            <summary>6 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_7">
            <summary>7 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_8">
            <summary>8 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_9">
            <summary>9 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_A">
            <summary>A key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_B">
            <summary>B key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_C">
            <summary>C key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_D">
            <summary>D key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_E">
            <summary>E key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F">
            <summary>F key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_G">
            <summary>G key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_H">
            <summary>H key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_I">
            <summary>I key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_J">
            <summary>J key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_K">
            <summary>K key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_L">
            <summary>L key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_M">
            <summary>M key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_N">
            <summary>N key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_O">
            <summary>O key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_P">
            <summary>P key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_Q">
            <summary>Q key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_R">
            <summary>R key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_S">
            <summary>S key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_T">
            <summary>T key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_U">
            <summary>U key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_V">
            <summary>V key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_W">
            <summary>W key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_X">
            <summary>X key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_Y">
            <summary>Y key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_Z">
            <summary>Z key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_LWIN">
            <summary>Left Windows key (Natural keyboard)</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_RWIN">
            <summary>Right Windows key (Natural keyboard)</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_APPS">
            <summary>Applications key (Natural keyboard)</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_SLEEP">
            <summary>Computer Sleep key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_NUMPAD0">
            <summary>Numeric keypad 0 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_NUMPAD1">
            <summary>Numeric keypad 1 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_NUMPAD2">
            <summary>Numeric keypad 2 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_NUMPAD3">
            <summary>Numeric keypad 3 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_NUMPAD4">
            <summary>Numeric keypad 4 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_NUMPAD5">
            <summary>Numeric keypad 5 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_NUMPAD6">
            <summary>Numeric keypad 6 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_NUMPAD7">
            <summary>Numeric keypad 7 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_NUMPAD8">
            <summary>Numeric keypad 8 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_NUMPAD9">
            <summary>Numeric keypad 9 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_MULTIPLY">
            <summary>Multiply key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_ADD">
            <summary>Add key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_SEPARATOR">
            <summary>Separator key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_SUBTRACT">
            <summary>Subtract key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_DECIMAL">
            <summary>Decimal key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_DIVIDE">
            <summary>Divide key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F1">
            <summary>F1 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F2">
            <summary>F2 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F3">
            <summary>F3 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F4">
            <summary>F4 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F5">
            <summary>F5 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F6">
            <summary>F6 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F7">
            <summary>F7 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F8">
            <summary>F8 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F9">
            <summary>F9 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F10">
            <summary>F10 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F11">
            <summary>F11 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F12">
            <summary>F12 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F13">
            <summary>F13 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F14">
            <summary>F14 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F15">
            <summary>F15 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F16">
            <summary>F16 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F17">
            <summary>F17 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F18">
            <summary>F18 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F19">
            <summary>F19 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F20">
            <summary>F20 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F21">
            <summary>F21 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F22">
            <summary>F22 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F23">
            <summary>F23 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_F24">
            <summary>F24 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_NUMLOCK">
            <summary>NUM LOCK key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_SCROLL">
            <summary>SCROLL LOCK key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_NEC_EQUAL">
            <summary>NEC '=' key on numpad</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_FJ_JISHO">
            <summary>Fujitsu 'Dictionary' key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_FJ_MASSHOU">
            <summary>Fujitsu 'Unregister word' key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_FJ_TOUROKU">
            <summary>Fujitsu 'Register word' key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_FJ_LOYA">
            <summary>Fujitsu 'Left OYAYUBI' key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_FJ_ROYA">
            <summary>Fujitsu 'Right OYAYUBI' key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_LSHIFT">
            <summary>Left SHIFT key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_RSHIFT">
            <summary>Right SHIFT key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_LCONTROL">
            <summary>Left CONTROL key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_RCONTROL">
            <summary>Right CONTROL key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_LMENU">
            <summary>Left MENU key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_RMENU">
            <summary>Right MENU key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_BROWSER_BACK">
            <summary>Browser Back key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_BROWSER_FORWARD">
            <summary>Browser Forward key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_BROWSER_REFRESH">
            <summary>Browser Refresh key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_BROWSER_STOP">
            <summary>Browser Stop key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_BROWSER_SEARCH">
            <summary>Browser Search key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_BROWSER_FAVORITES">
            <summary>Browser Favorites key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_BROWSER_HOME">
            <summary>Browser Start and Home key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_VOLUME_MUTE">
            <summary>Volume Mute key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_VOLUME_DOWN">
            <summary>Volume Down key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_VOLUME_UP">
            <summary>Volume Up key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_MEDIA_NEXT_TRACK">
            <summary>Next Track key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_MEDIA_PREV_TRACK">
            <summary>Previous Track key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_MEDIA_STOP">
            <summary>Stop Media key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_MEDIA_PLAY_PAUSE">
            <summary>Play/Pause Media key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_LAUNCH_MAIL">
            <summary>Start Mail key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_LAUNCH_MEDIA_SELECT">
            <summary>Select Media key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_LAUNCH_APP1">
            <summary>Start Application 1 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_LAUNCH_APP2">
            <summary>Start Application 2 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_1">
            <summary>
            Used for miscellaneous characters; it can vary by keyboard.
            <para>For the US standard keyboard, the ';:' key///<summary>For any country/region, the '+' key</summary></para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_PLUS">
            <summary>For any country/region, the '+' key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_COMMA">
            <summary>For any country/region, the ',' key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_MINUS">
            <summary>For any country/region, the '-' key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_PERIOD">
            <summary>For any country/region, the '.' key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_2">
            <summary>
            Used for miscellaneous characters; it can vary by keyboard.
            <para>For the US standard keyboard, the '/?' key</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_3">
            <summary>
            Used for miscellaneous characters; it can vary by keyboard.
            <para>For the US standard keyboard, the '`~' key</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_A">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_B">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_X">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_Y">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_RIGHT_SHOULDER">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_LEFT_SHOULDER">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_LEFT_TRIGGER">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_RIGHT_TRIGGER">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_DPAD_UP">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_DPAD_DOWN">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_DPAD_LEFT">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_DPAD_RIGHT">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_MENU">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_VIEW">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_RIGHT_THUMBSTICK_BUTTON">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_LEFT_THUMBSTICK_UP">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_LEFT_THUMBSTICK_DOWN">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_LEFT_THUMBSTICK_LEFT">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_RIGHT_THUMBSTICK_UP">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_4">
            <summary>
            Used for miscellaneous characters; it can vary by keyboard.
            <para>For the US standard keyboard, the '[{' key</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_5">
            <summary>
            Used for miscellaneous characters; it can vary by keyboard.
            <para>For the US standard keyboard, the '\|' key</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_6">
            <summary>
            Used for miscellaneous characters; it can vary by keyboard.
            <para>For the US standard keyboard, the ']}' key</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_7">
            <summary>
            Used for miscellaneous characters; it can vary by keyboard.
            <para>For the US standard keyboard, the 'single-quote/double-quote' key</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_8">
            <summary>Used for miscellaneous characters; it can vary by keyboard.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_AX">
            <summary>'AX' key on Japanese AX kbd</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_102">
            <summary>Either the angle bracket key or the backslash key on the RT 102-key keyboard</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_PROCESSKEY">
            <summary>IME PROCESS key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_ICO_CLEAR">
            <summary>OEM specific</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_PACKET">
            <summary>
            Used to pass Unicode characters as if they were keystrokes. The VK_PACKET key is the low word of a 32-bit Virtual Key value
            used for non-keyboard input methods. For more information, see Remark in KEYBDINPUT, SendInput, WM_KEYDOWN, and WM_KEYUP
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_RESET">
            <summary>Nokia/Ericsson definition</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_JUMP">
            <summary>Nokia/Ericsson definition</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_PA1">
            <summary>Nokia/Ericsson definition</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_PA2">
            <summary>Nokia/Ericsson definition</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_PA3">
            <summary>Nokia/Ericsson definition</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_WSCTRL">
            <summary>Nokia/Ericsson definition</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_CUSEL">
            <summary>Nokia/Ericsson definition</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_ATTN">
            <summary>Nokia/Ericsson definition</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_FINISH">
            <summary>Nokia/Ericsson definition</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_COPY">
            <summary>Nokia/Ericsson definition</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_AUTO">
            <summary>Nokia/Ericsson definition</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_ENLW">
            <summary>Nokia/Ericsson definition</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_BACKTAB">
            <summary>Nokia/Ericsson definition</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_ATTN">
            <summary>Attn key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_CRSEL">
            <summary>CrSel key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_EXSEL">
            <summary>ExSel key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_EREOF">
            <summary>Erase EOF key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_PLAY">
            <summary>Play key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_ZOOM">
            <summary>Zoom key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_NONAME">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_PA1">
            <summary>PA1 key</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.VK.VK_OEM_CLEAR">
            <summary>Clear key</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.ActivateKeyboardLayout(Vanara.PInvoke.User32.HKL,Vanara.PInvoke.User32.KLF)">
            <summary>
            Sets the input locale identifier (formerly called the keyboard layout handle) for the calling thread or the current process. The
            input locale identifier specifies a locale as well as the physical layout of the keyboard.
            </summary>
            <param name="hkl">
            <para>Type: <c>HKL</c></para>
            <para>Input locale identifier to be activated.</para>
            <para>
            The input locale identifier must have been loaded by a previous call to the LoadKeyboardLayout function. This parameter must be
            either the handle to a keyboard layout or one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>HKL_NEXT 1</term>
            <term>Selects the next locale identifier in the circular list of loaded locale identifiers maintained by the system.</term>
            </item>
            <item>
            <term>HKL_PREV 0</term>
            <term>Selects the previous locale identifier in the circular list of loaded locale identifiers maintained by the system.</term>
            </item>
            </list>
            </param>
            <param name="Flags">
            <para>Type: <c>UINT</c></para>
            <para>Specifies how the input locale identifier is to be activated. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>KLF_REORDER 0x00000008</term>
            <term>
            If this bit is set, the system's circular list of loaded locale identifiers is reordered by moving the locale identifier to the
            head of the list. If this bit is not set, the list is rotated without a change of order. For example, if a user had an English
            locale identifier active, as well as having French, German, and Spanish locale identifiers loaded (in that order), then
            activating the German locale identifier with the KLF_REORDER bit set would produce the following order: German, English, French,
            Spanish. Activating the German locale identifier without the KLF_REORDER bit set would produce the following order: German,
            Spanish, English, French. If less than three locale identifiers are loaded, the value of this flag is irrelevant.
            </term>
            </item>
            <item>
            <term>KLF_RESET 0x40000000</term>
            <term>
            If set but KLF_SHIFTLOCK is not set, the Caps Lock state is turned off by pressing the Caps Lock key again. If set and
            KLF_SHIFTLOCK is also set, the Caps Lock state is turned off by pressing either SHIFT key. These two methods are mutually
            exclusive, and the setting persists as part of the User's profile in the registry.
            </term>
            </item>
            <item>
            <term>KLF_SETFORPROCESS 0x00000100</term>
            <term>
            Activates the specified locale identifier for the entire process and sends the WM_INPUTLANGCHANGE message to the current
            thread's focus or active window.
            </term>
            </item>
            <item>
            <term>KLF_SHIFTLOCK 0x00010000</term>
            <term>This is used with KLF_RESET. See KLF_RESET for an explanation.</term>
            </item>
            <item>
            <term>KLF_UNLOADPREVIOUS</term>
            <term>This flag is unsupported. Use the UnloadKeyboardLayout function instead.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>HKL</c></para>
            <para>
            The return value is of type <c>HKL</c>. If the function succeeds, the return value is the previous input locale identifier.
            Otherwise, it is zero.
            </para>
            <para>To get extended error information, use the GetLastError function.</para>
            </returns>
            <remarks>
            <para>This function only affects the layout for the current process or thread.</para>
            <para>
            This function is not restricted to keyboard layouts. The hkl parameter is actually an input locale identifier. This is a broader
            concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any
            other form of input. Several input locale identifiers can be loaded at any one time, but only one is active at a time. Loading
            multiple input locale identifiers makes it possible to rapidly switch between them.
            </para>
            <para>
            When multiple IMEs are allowed for each locale, passing an input locale identifier in which the high word (the device handle) is
            zero activates the first IME in the list belonging to the locale.
            </para>
            <para>
            The <c>KLF_RESET</c> and <c>KLF_SHIFTLOCK</c> flags alter the method by which the Caps Lock state is turned off. By default, the
            Caps Lock state is turned off by hitting the Caps Lock key again. If only <c>KLF_RESET</c> is set, the default state is
            reestablished. If <c>KLF_RESET</c> and <c>KLF_SHIFTLOCK</c> are set, the Caps Lock state is turned off by pressing either Caps
            Lock key. This feature is used to conform to local keyboard behavior standards as well as for personal preferences.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.BlockInput(System.Boolean)">
            <summary>Blocks keyboard and mouse input events from reaching applications.</summary>
            <param name="fBlockIt">
            <para>Type: <c>BOOL</c></para>
            <para>
            The function's purpose. If this parameter is <c>TRUE</c>, keyboard and mouse input events are blocked. If this parameter is
            <c>FALSE</c>, keyboard and mouse events are unblocked. Note that only the thread that blocked input can successfully unblock input.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If input is already blocked, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            When input is blocked, real physical input from the mouse or keyboard will not affect the input queue's synchronous key state
            (reported by GetKeyState and GetKeyboardState), nor will it affect the asynchronous key state (reported by GetAsyncKeyState).
            However, the thread that is blocking input can affect both of these key states by calling SendInput. No other thread can do this.
            </para>
            <para>The system will unblock input in the following cases:</para>
            <list type="bullet">
            <item>
            <term>
            The thread that blocked input unexpectedly exits without calling <c>BlockInput</c> with fBlock set to <c>FALSE</c>. In this
            case, the system cleans up properly and re-enables input.
            </term>
            </item>
            <item>
            <term>
            The user presses CTRL+ALT+DEL or the system invokes the <c>Hard System Error</c> modal message box (for example, when a program
            faults or a device fails).
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetAsyncKeyState(System.Int32)">
            <summary>
            Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call
            to <c>GetAsyncKeyState</c>.
            </summary>
            <param name="vKey">
            <para>Type: <c>int</c></para>
            <para>The virtual-key code. For more information, see Virtual Key Codes.</para>
            <para>You can use left- and right-distinguishing constants to specify certain keys. See the Remarks section for further information.</para>
            </param>
            <returns>
            <para>Type: <c>SHORT</c></para>
            <para>
            If the function succeeds, the return value specifies whether the key was pressed since the last call to <c>GetAsyncKeyState</c>,
            and whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant
            bit is set, the key was pressed after the previous call to <c>GetAsyncKeyState</c>. However, you should not rely on this last
            behavior; for more information, see the Remarks.
            </para>
            <para>The return value is zero for the following cases:</para>
            <list type="bullet">
            <item>
            <term>The current desktop is not the active desktop</term>
            </item>
            <item>
            <term>The foreground thread belongs to another process and the desktop does not allow the hook or the journal record.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>GetAsyncKeyState</c> function works with mouse buttons. However, it checks on the state of the physical mouse buttons,
            not on the logical mouse buttons that the physical buttons are mapped to. For example, the call
            <c>GetAsyncKeyState</c>(VK_LBUTTON) always returns the state of the left physical mouse button, regardless of whether it is
            mapped to the left or right logical mouse button. You can determine the system's current mapping of physical mouse buttons to
            logical mouse buttons by calling .
            </para>
            <para>which returns TRUE if the mouse buttons have been swapped.</para>
            <para>
            Although the least significant bit of the return value indicates whether the key has been pressed since the last query, due to
            the pre-emptive multitasking nature of Windows, another application can call <c>GetAsyncKeyState</c> and receive the "recently
            pressed" bit instead of your application. The behavior of the least significant bit of the return value is retained strictly for
            compatibility with 16-bit Windows applications (which are non-preemptive) and should not be relied upon.
            </para>
            <para>
            You can use the virtual-key code constants <c>VK_SHIFT</c>, <c>VK_CONTROL</c>, and <c>VK_MENU</c> as values for the vKey
            parameter. This gives the state of the SHIFT, CTRL, or ALT keys without distinguishing between left and right.
            </para>
            <para>
            You can use the following virtual-key code constants as values for vKey to distinguish between the left and right instances of
            those keys.
            </para>
            <list type="table">
            <listheader>
            <term>Code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>VK_LSHIFT</term>
            <term>Left-shift key.</term>
            </item>
            <item>
            <term>VK_RSHIFT</term>
            <term>Right-shift key.</term>
            </item>
            <item>
            <term>VK_LCONTROL</term>
            <term>Left-control key.</term>
            </item>
            <item>
            <term>VK_RCONTROL</term>
            <term>Right-control key.</term>
            </item>
            <item>
            <term>VK_LMENU</term>
            <term>Left-menu key.</term>
            </item>
            <item>
            <term>VK_RMENU</term>
            <term>Right-menu key.</term>
            </item>
            </list>
            <para>
            These left- and right-distinguishing constants are only available when you call the GetKeyboardState, SetKeyboardState,
            <c>GetAsyncKeyState</c>, GetKeyState, and MapVirtualKey functions.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetKBCodePage">
            <summary>
            <para>Retrieves the current code page.</para>
            <para>
            <c>Note</c> This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the
            GetOEMCP function to retrieve the OEM code-page identifier for the system.
            </para>
            </summary>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>
            The return value is an OEM code-page identifier, or it is the default identifier if the registry value is not readable. For a
            list of OEM code-page identifiers, see Code Page Identifiers.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetKeyboardLayout(System.UInt32)">
            <summary>Retrieves the active input locale identifier (formerly called the keyboard layout).</summary>
            <param name="idThread">
            <para>Type: <c>DWORD</c></para>
            <para>The identifier of the thread to query, or 0 for the current thread.</para>
            </param>
            <returns>
            <para>Type: <c>HKL</c></para>
            <para>
            The return value is the input locale identifier for the thread. The low word contains a Language Identifier for the input
            language and the high word contains a device handle to the physical layout of the keyboard.
            </para>
            </returns>
            <remarks>
            <para>
            The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter,
            an Input Method Editor (IME), or any other form of input.
            </para>
            <para>
            Since the keyboard layout can be dynamically changed, applications that cache information about the current keyboard layout
            should process the WM_INPUTLANGCHANGE message to be informed of changes in the input language.
            </para>
            <para>To get the KLID (keyboard layout ID) of the currently active HKL, call the GetKeyboardLayoutName.</para>
            <para>
            <c>Beginning in Windows 8:</c> The preferred method to retrieve the language associated with the current keyboard layout or
            input method is a call to Windows.Globalization.Language.CurrentInputMethodLanguageTag. If your app passes language tags from
            <c>CurrentInputMethodLanguageTag</c> to any National Language Support functions, it must first convert the tags by calling ResolveLocaleName.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetKeyboardLayoutList(System.Int32,Vanara.PInvoke.User32.HKL[])">
            <summary>
            Retrieves the input locale identifiers (formerly called keyboard layout handles) corresponding to the current set of input
            locales in the system. The function copies the identifiers to the specified buffer.
            </summary>
            <param name="nBuff">
            <para>Type: <c>int</c></para>
            <para>The maximum number of handles that the buffer can hold.</para>
            </param>
            <param name="lpList">
            <para>Type: <c>HKL*</c></para>
            <para>A pointer to the buffer that receives the array of input locale identifiers.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            If the function succeeds, the return value is the number of input locale identifiers copied to the buffer or, if nBuff is zero,
            the return value is the size, in array elements, of the buffer needed to receive all current input locale identifiers.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter,
            an Input Method Editor (IME), or any other form of input.
            </para>
            <para>
            <c>Beginning in Windows 8:</c> The preferred method to retrieve the language associated with the current keyboard layout or
            input method is a call to Windows.Globalization.Language.CurrentInputMethodLanguageTag. If your app passes language tags from
            <c>CurrentInputMethodLanguageTag</c> to any National Language Support functions, it must first convert the tags by calling ResolveLocaleName.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetKeyboardLayoutName(System.Text.StringBuilder)">
            <summary>Retrieves the name of the active input locale identifier (formerly called the keyboard layout) for the system.</summary>
            <param name="pwszKLID">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            The buffer (of at least <c>KL_NAMELENGTH</c> characters in length) that receives the name of the input locale identifier,
            including the terminating null character. This will be a copy of the string provided to the LoadKeyboardLayout function, unless
            layout substitution took place.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter,
            an Input Method Editor (IME), or any other form of input.
            </para>
            <para>
            <c>Beginning in Windows 8:</c> The preferred method to retrieve the language associated with the current keyboard layout or
            input method is a call to Windows.Globalization.Language.CurrentInputMethodLanguageTag. If your app passes language tags from
            <c>CurrentInputMethodLanguageTag</c> to any National Language Support functions, it must first convert the tags by calling ResolveLocaleName.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetKeyboardState(System.Byte[])">
            <summary>Copies the status of the 256 virtual keys to the specified buffer.</summary>
            <param name="lpKeyState">
            <para>Type: <c>PBYTE</c></para>
            <para>The 256-byte array that receives the status data for each virtual key.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            An application can call this function to retrieve the current status of all the virtual keys. The status changes as a thread
            removes keyboard messages from its message queue. The status does not change as keyboard messages are posted to the thread's
            message queue, nor does it change as keyboard messages are posted to or retrieved from message queues of other threads.
            (Exception: Threads that are connected through AttachThreadInput share the same keyboard state.)
            </para>
            <para>
            When the function returns, each member of the array pointed to by the lpKeyState parameter contains status data for a virtual
            key. If the high-order bit is 1, the key is down; otherwise, it is up. If the key is a toggle key, for example CAPS LOCK, then
            the low-order bit is 1 when the key is toggled and is 0 if the key is untoggled. The low-order bit is meaningless for non-toggle
            keys. A toggle key is said to be toggled when it is turned on. A toggle key's indicator light (if any) on the keyboard will be
            on when the key is toggled, and off when the key is untoggled.
            </para>
            <para>
            To retrieve status information for an individual key, use the GetKeyState function. To retrieve the current state for an
            individual key regardless of whether the corresponding keyboard message has been retrieved from the message queue, use the
            GetAsyncKeyState function.
            </para>
            <para>
            An application can use the virtual-key code constants <c>VK_SHIFT</c>, <c>VK_CONTROL</c> and <c>VK_MENU</c> as indices into the
            array pointed to by lpKeyState. This gives the status of the SHIFT, CTRL, or ALT keys without distinguishing between left and
            right. An application can also use the following virtual-key code constants as indices to distinguish between the left and right
            instances of those keys:
            </para>
            <list type="table">
            <listheader>
            <term>VK_LSHIFT</term>
            </listheader>
            <item>
            <term>VK_RSHIFT</term>
            </item>
            <item>
            <term>VK_LCONTROL</term>
            </item>
            <item>
            <term>VK_RCONTROL</term>
            </item>
            <item>
            <term>VK_LMENU</term>
            </item>
            <item>
            <term>VK_RMENU</term>
            </item>
            </list>
            <para>
            These left- and right-distinguishing constants are available to an application only through the <c>GetKeyboardState</c>,
            SetKeyboardState, GetAsyncKeyState, GetKeyState, and MapVirtualKey functions.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetKeyboardType(System.Int32)">
            <summary>Retrieves information about the current keyboard.</summary>
            <param name="nTypeFlag">
            <para>Type: <c>int</c></para>
            <para>The type of keyboard information to be retrieved. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>Keyboard type</term>
            </item>
            <item>
            <term>1</term>
            <term>Keyboard subtype</term>
            </item>
            <item>
            <term>2</term>
            <term>The number of function keys on the keyboard</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>If the function succeeds, the return value specifies the requested information.</para>
            <para>
            If the function fails and nTypeFlag is not one, the return value is zero; zero is a valid return value when nTypeFlag is one
            (keyboard subtype). To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>The type may be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>1</term>
            <term>IBM PC/XT or compatible (83-key) keyboard</term>
            </item>
            <item>
            <term>2</term>
            <term>Olivetti "ICO" (102-key) keyboard</term>
            </item>
            <item>
            <term>3</term>
            <term>IBM PC/AT (84-key) or similar keyboard</term>
            </item>
            <item>
            <term>4</term>
            <term>IBM enhanced (101- or 102-key) keyboard</term>
            </item>
            <item>
            <term>5</term>
            <term>Nokia 1050 and similar keyboards</term>
            </item>
            <item>
            <term>6</term>
            <term>Nokia 9140 and similar keyboards</term>
            </item>
            <item>
            <term>7</term>
            <term>Japanese keyboard</term>
            </item>
            </list>
            <para>The subtype is an original equipment manufacturer (OEM)-dependent value.</para>
            <para>
            The application can also determine the number of function keys on a keyboard from the keyboard type. Following are the number of
            function keys for each keyboard type.
            </para>
            <list type="table">
            <listheader>
            <term>Type</term>
            <term>Number of function keys</term>
            </listheader>
            <item>
            <term>1</term>
            <term>10</term>
            </item>
            <item>
            <term>2</term>
            <term>12 (sometimes 18)</term>
            </item>
            <item>
            <term>3</term>
            <term>10</term>
            </item>
            <item>
            <term>4</term>
            <term>12</term>
            </item>
            <item>
            <term>5</term>
            <term>10</term>
            </item>
            <item>
            <term>6</term>
            <term>24</term>
            </item>
            <item>
            <term>7</term>
            <term>Hardware dependent and specified by the OEM</term>
            </item>
            </list>
            <para>When a single USB keyboard is connected to the computer, this function returns the code 81.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetKeyNameText(System.Int32,System.Text.StringBuilder,System.Int32)">
            <summary>Retrieves a string that represents the name of a key.</summary>
            <param name="lParam">
            <para>Type: <c>LONG</c></para>
            <para>
            The second parameter of the keyboard message (such as WM_KEYDOWN) to be processed. The function interprets the following bit
            positions in the lParam.
            </para>
            <list type="table">
            <listheader>
            <term>Bits</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>16-23</term>
            <term>Scan code.</term>
            </item>
            <item>
            <term>24</term>
            <term>Extended-key flag. Distinguishes some keys on an enhanced keyboard.</term>
            </item>
            <item>
            <term>25</term>
            <term>
            "Do not care" bit. The application calling this function sets this bit to indicate that the function should not distinguish
            between left and right CTRL and SHIFT keys, for example.
            </term>
            </item>
            </list>
            </param>
            <param name="lpString">
            <para>Type: <c>LPTSTR</c></para>
            <para>The buffer that will receive the key name.</para>
            </param>
            <param name="cchSize">
            <para>Type: <c>int</c></para>
            <para>
            The maximum length, in characters, of the key name, including the terminating null character. (This parameter should be equal to
            the size of the buffer pointed to by the lpString parameter.)
            </para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            If the function succeeds, a null-terminated string is copied into the specified buffer, and the return value is the length of
            the string, in characters, not counting the terminating null character.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            The format of the key-name string depends on the current keyboard layout. The keyboard driver maintains a list of names in the
            form of character strings for keys with names longer than a single character. The key name is translated according to the layout
            of the currently installed keyboard, thus the function may give different results for different input locales. The name of a
            character key is the character itself. The names of dead keys are spelled out in full.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetKeyState(System.Int32)">
            <summary>
            Retrieves the status of the specified virtual key. The status specifies whether the key is up, down, or toggled (on,
            off—alternating each time the key is pressed).
            </summary>
            <param name="nVirtKey">
            <para>Type: <c>int</c></para>
            <para>
            A virtual key. If the desired virtual key is a letter or digit (A through Z, a through z, or 0 through 9), nVirtKey must be set
            to the ASCII value of that character. For other keys, it must be a virtual-key code.
            </para>
            <para>
            If a non-English keyboard layout is used, virtual keys with values in the range ASCII A through Z and 0 through 9 are used to
            specify most of the character keys. For example, for the German keyboard layout, the virtual key of value ASCII O (0x4F) refers
            to the "o" key, whereas VK_OEM_1 refers to the "o with umlaut" key.
            </para>
            </param>
            <returns>
            <para>Type: <c>SHORT</c></para>
            <para>The return value specifies the status of the specified virtual key, as follows:</para>
            <list type="bullet">
            <item>
            <term>If the high-order bit is 1, the key is down; otherwise, it is up.</term>
            </item>
            <item>
            <term>
            If the low-order bit is 1, the key is toggled. A key, such as the CAPS LOCK key, is toggled if it is turned on. The key is off
            and untoggled if the low-order bit is 0. A toggle key's indicator light (if any) on the keyboard will be on when the key is
            toggled, and off when the key is untoggled.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The key status returned from this function changes as a thread reads key messages from its message queue. The status does not
            reflect the interrupt-level state associated with the hardware. Use the GetAsyncKeyState function to retrieve that information.
            </para>
            <para>
            An application calls <c>GetKeyState</c> in response to a keyboard-input message. This function retrieves the state of the key
            when the input message was generated.
            </para>
            <para>To retrieve state information for all the virtual keys, use the GetKeyboardState function.</para>
            <para>
            An application can use the virtual key code constants <c>VK_SHIFT</c>, <c>VK_CONTROL</c>, and <c>VK_MENU</c> as values for the
            nVirtKey parameter. This gives the status of the SHIFT, CTRL, or ALT keys without distinguishing between left and right. An
            application can also use the following virtual-key code constants as values for nVirtKey to distinguish between the left and
            right instances of those keys:
            </para>
            <para>
            <c>VK_LSHIFT</c><c>VK_RSHIFT</c><c>VK_LCONTROL</c><c>VK_RCONTROL</c><c>VK_LMENU</c><c>VK_RMENU</c> These left- and
            right-distinguishing constants are available to an application only through the GetKeyboardState, SetKeyboardState,
            GetAsyncKeyState, <c>GetKeyState</c>, and MapVirtualKey functions.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying Keyboard Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.keybd_event(System.Byte,System.Byte,Vanara.PInvoke.User32.KEYEVENTF,System.IntPtr)">
            <summary>
            <para>
            Synthesizes a keystroke. The system can use such a synthesized keystroke to generate a WM_KEYUP or WM_KEYDOWN message. The
            keyboard driver's interrupt handler calls the <c>keybd_event</c> function.
            </para>
            <para><c>Note</c> This function has been superseded. Use SendInput instead.</para>
            </summary>
            <param name="bVk">
            <para>Type: <c>BYTE</c></para>
            <para>A virtual-key code. The code must be a value in the range 1 to 254. For a complete list, see Virtual Key Codes.</para>
            </param>
            <param name="bScan">
            <para>Type: <c>BYTE</c></para>
            <para>A hardware scan code for the key.</para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>Controls various aspects of function operation. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>KEYEVENTF_EXTENDEDKEY 0x0001</term>
            <term>If specified, the scan code was preceded by a prefix byte having the value 0xE0 (224).</term>
            </item>
            <item>
            <term>KEYEVENTF_KEYUP 0x0002</term>
            <term>If specified, the key is being released. If not specified, the key is being depressed.</term>
            </item>
            </list>
            </param>
            <param name="dwExtraInfo">
            <para>Type: <c>ULONG_PTR</c></para>
            <para>An additional value associated with the key stroke.</para>
            </param>
            <remarks>
            <para>
            An application can simulate a press of the PRINTSCRN key in order to obtain a screen snapshot and save it to the clipboard. To
            do this, call <c>keybd_event</c> with the bVk parameter set to <c>VK_SNAPSHOT</c>.
            </para>
            <para>Examples</para>
            <para>
            The following sample program toggles the NUM LOCK light by using <c>keybd_event</c> with a virtual key of <c>VK_NUMLOCK</c>. It
            takes a Boolean value that indicates whether the light should be turned off ( <c>FALSE</c>) or on ( <c>TRUE</c>). The same
            technique can be used for the CAPS LOCK key ( <c>VK_CAPITAL</c>) and the SCROLL LOCK key ( <c>VK_SCROLL</c>).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadKeyboardLayout(System.String,Vanara.PInvoke.User32.KLF)">
            <summary>
            <para>Loads a new input locale identifier (formerly called the keyboard layout) into the system.</para>
            <para>
            <c>Prior to Windows 8:</c> Several input locale identifiers can be loaded at a time, but only one per process is active at a
            time. Loading multiple input locale identifiers makes it possible to rapidly switch between them.
            </para>
            <para>
            <c>Beginning in Windows 8:</c> The input locale identifier is loaded for the entire system. This function has no effect if the
            current process does not own the window with keyboard focus.
            </para>
            </summary>
            <param name="pwszKLID">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The name of the input locale identifier to load. This name is a string composed of the hexadecimal value of the Language
            Identifier (low word) and a device identifier (high word). For example, U.S. English has a language identifier of 0x0409, so the
            primary U.S. English layout is named "00000409". Variants of U.S. English layout (such as the Dvorak layout) are named
            "00010409", "00020409", and so on.
            </para>
            </param>
            <param name="Flags">
            <para>Type: <c>UINT</c></para>
            <para>Specifies how the input locale identifier is to be loaded. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>KLF_ACTIVATE 0x00000001</term>
            <term>
            Prior to Windows 8: If the specified input locale identifier is not already loaded, the function loads and activates the input
            locale identifier for the current thread. Beginning in Windows 8: If the specified input locale identifier is not already
            loaded, the function loads and activates the input locale identifier for the system.
            </term>
            </item>
            <item>
            <term>KLF_NOTELLSHELL 0x00000080</term>
            <term>
            Prior to Windows 8: Prevents a ShellProchook procedure from receiving an HSHELL_LANGUAGE hook code when the new input locale
            identifier is loaded. This value is typically used when an application loads multiple input locale identifiers one after
            another. Applying this value to all but the last input locale identifier delays the shell's processing until all input locale
            identifiers have been added. Beginning in Windows 8: In this scenario, the last input locale identifier is set for the entire system.
            </term>
            </item>
            <item>
            <term>KLF_REORDER 0x00000008</term>
            <term>
            Prior to Windows 8: Moves the specified input locale identifier to the head of the input locale identifier list, making that
            locale identifier the active locale identifier for the current thread. This value reorders the input locale identifier list even
            if KLF_ACTIVATE is not provided. Beginning in Windows 8: Moves the specified input locale identifier to the head of the input
            locale identifier list, making that locale identifier the active locale identifier for the system. This value reorders the input
            locale identifier list even if KLF_ACTIVATE is not provided.
            </term>
            </item>
            <item>
            <term>KLF_REPLACELANG 0x00000010</term>
            <term>
            If the new input locale identifier has the same language identifier as a current input locale identifier, the new input locale
            identifier replaces the current one as the input locale identifier for that language. If this value is not provided and the
            input locale identifiers have the same language identifiers, the current input locale identifier is not replaced and the
            function returns NULL.
            </term>
            </item>
            <item>
            <term>KLF_SUBSTITUTE_OK 0x00000002</term>
            <term>
            Substitutes the specified input locale identifier with another locale preferred by the user. The system starts with this flag
            set, and it is recommended that your application always use this flag. The substitution occurs only if the registry key
            HKEY_CURRENT_USER\Keyboard\Layout\Substitutes explicitly defines a substitution locale. For example, if the key includes the
            value name "00000409" with value "00010409", loading the U.S. English layout ("00000409") causes the Dvorak U.S. English layout
            ("00010409") to be loaded instead. The system uses KLF_SUBSTITUTE_OK when booting, and it is recommended that all applications
            use this value when loading input locale identifiers to ensure that the user's preference is selected.
            </term>
            </item>
            <item>
            <term>KLF_SETFORPROCESS 0x00000100</term>
            <term>
            Prior to Windows 8: This flag is valid only with KLF_ACTIVATE. Activates the specified input locale identifier for the entire
            process and sends the WM_INPUTLANGCHANGE message to the current thread's Focus or Active window. Typically, LoadKeyboardLayout
            activates an input locale identifier only for the current thread. Beginning in Windows 8: This flag is not used.
            LoadKeyboardLayout always activates an input locale identifier for the entire system if the current process owns the window with
            keyboard focus.
            </term>
            </item>
            <item>
            <term>KLF_UNLOADPREVIOUS</term>
            <term>This flag is unsupported. Use the UnloadKeyboardLayout function instead.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>HKL</c></para>
            <para>
            If the function succeeds, the return value is the input locale identifier corresponding to the name specified in pwszKLID. If no
            matching locale is available, the return value is the default language of the system. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter,
            an Input Method Editor (IME), or any other form of input.
            </para>
            <para>
            An application can and will typically load the default input locale identifier or IME for a language and can do so by specifying
            only a string version of the language identifier. If an application wants to load a specific locale or IME, it should read the
            registry to determine the specific input locale identifier to pass to <c>LoadKeyboardLayout</c>. In this case, a request to
            activate the default input locale identifier for a locale will activate the first matching one. A specific IME should be
            activated using an explicit input locale identifier returned from GetKeyboardLayout or <c>LoadKeyboardLayout</c>.
            </para>
            <para><c>Prior to Windows 8:</c> This function only affects the layout for the current process or thread.</para>
            <para><c>Beginning in Windows 8:</c> This function affects the layout for the entire system.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.MapVirtualKey(System.UInt32,Vanara.PInvoke.User32.MAPVK)">
            <summary>
            <para>
            Translates (maps) a virtual-key code into a scan code or character value, or translates a scan code into a virtual-key code.
            </para>
            <para>To specify a handle to the keyboard layout to use for translating the specified code, use the MapVirtualKeyEx function.</para>
            </summary>
            <param name="uCode">
            <para>Type: <c>UINT</c></para>
            <para>The virtual key code or scan code for a key. How this value is interpreted depends on the value of the uMapType parameter.</para>
            </param>
            <param name="uMapType">
            <para>Type: <c>UINT</c></para>
            <para>The translation to be performed. The value of this parameter depends on the value of the uCode parameter.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MAPVK_VK_TO_CHAR 2</term>
            <term>
            uCode is a virtual-key code and is translated into an unshifted character value in the low-order word of the return value. Dead
            keys (diacritics) are indicated by setting the top bit of the return value. If there is no translation, the function returns 0.
            </term>
            </item>
            <item>
            <term>MAPVK_VK_TO_VSC 0</term>
            <term>
            uCode is a virtual-key code and is translated into a scan code. If it is a virtual-key code that does not distinguish between
            left- and right-hand keys, the left-hand scan code is returned. If there is no translation, the function returns 0.
            </term>
            </item>
            <item>
            <term>MAPVK_VSC_TO_VK 1</term>
            <term>
            uCode is a scan code and is translated into a virtual-key code that does not distinguish between left- and right-hand keys. If
            there is no translation, the function returns 0.
            </term>
            </item>
            <item>
            <term>MAPVK_VSC_TO_VK_EX 3</term>
            <term>
            uCode is a scan code and is translated into a virtual-key code that distinguishes between left- and right-hand keys. If there is
            no translation, the function returns 0.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>
            The return value is either a scan code, a virtual-key code, or a character value, depending on the value of uCode and uMapType.
            If there is no translation, the return value is zero.
            </para>
            </returns>
            <remarks>
            <para>
            An application can use <c>MapVirtualKey</c> to translate scan codes to the virtual-key code constants <c>VK_SHIFT</c>,
            <c>VK_CONTROL</c>, and <c>VK_MENU</c>, and vice versa. These translations do not distinguish between the left and right
            instances of the SHIFT, CTRL, or ALT keys.
            </para>
            <para>
            An application can get the scan code corresponding to the left or right instance of one of these keys by calling
            <c>MapVirtualKey</c> with uCode set to one of the following virtual-key code constants.
            </para>
            <list type="bullet">
            <item>
            <term><c>VK_LSHIFT</c></term>
            </item>
            <item>
            <term><c>VK_RSHIFT</c></term>
            </item>
            <item>
            <term><c>VK_LCONTROL</c></term>
            </item>
            <item>
            <term><c>VK_RCONTROL</c></term>
            </item>
            <item>
            <term><c>VK_LMENU</c></term>
            </item>
            <item>
            <term><c>VK_RMENU</c></term>
            </item>
            </list>
            <para>
            These left- and right-distinguishing constants are available to an application only through the GetKeyboardState,
            SetKeyboardState, GetAsyncKeyState, GetKeyState, and <c>MapVirtualKey</c> functions.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.MapVirtualKeyEx(System.UInt32,Vanara.PInvoke.User32.MAPVK,Vanara.PInvoke.User32.HKL)">
            <summary>
            Translates (maps) a virtual-key code into a scan code or character value, or translates a scan code into a virtual-key code. The
            function translates the codes using the input language and an input locale identifier.
            </summary>
            <param name="uCode">
            <para>Type: <c>UINT</c></para>
            <para>The virtual-key code or scan code for a key. How this value is interpreted depends on the value of the uMapType parameter.</para>
            <para>
            Starting with Windows Vista, the high byte of the uCode value can contain either 0xe0 or 0xe1 to specify the extended scan code.
            </para>
            </param>
            <param name="uMapType">
            <para>Type: <c>UINT</c></para>
            <para>The translation to perform. The value of this parameter depends on the value of the uCode parameter.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MAPVK_VK_TO_CHAR 2</term>
            <term>
            The uCode parameter is a virtual-key code and is translated into an unshifted character value in the low order word of the
            return value. Dead keys (diacritics) are indicated by setting the top bit of the return value. If there is no translation, the
            function returns 0.
            </term>
            </item>
            <item>
            <term>MAPVK_VK_TO_VSC 0</term>
            <term>
            The uCode parameter is a virtual-key code and is translated into a scan code. If it is a virtual-key code that does not
            distinguish between left- and right-hand keys, the left-hand scan code is returned. If there is no translation, the function
            returns 0.
            </term>
            </item>
            <item>
            <term>MAPVK_VK_TO_VSC_EX 4</term>
            <term>
            The uCode parameter is a virtual-key code and is translated into a scan code. If it is a virtual-key code that does not
            distinguish between left- and right-hand keys, the left-hand scan code is returned. If the scan code is an extended scan code,
            the high byte of the uCode value can contain either 0xe0 or 0xe1 to specify the extended scan code. If there is no translation,
            the function returns 0.
            </term>
            </item>
            <item>
            <term>MAPVK_VSC_TO_VK 1</term>
            <term>
            The uCode parameter is a scan code and is translated into a virtual-key code that does not distinguish between left- and
            right-hand keys. If there is no translation, the function returns 0.
            </term>
            </item>
            <item>
            <term>MAPVK_VSC_TO_VK_EX 3</term>
            <term>
            The uCode parameter is a scan code and is translated into a virtual-key code that distinguishes between left- and right-hand
            keys. If there is no translation, the function returns 0.
            </term>
            </item>
            </list>
            </param>
            <param name="dwhkl">
            <para>Type: <c>HKL</c></para>
            <para>
            Input locale identifier to use for translating the specified code. This parameter can be any input locale identifier previously
            returned by the LoadKeyboardLayout function.
            </para>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>
            The return value is either a scan code, a virtual-key code, or a character value, depending on the value of uCode and uMapType.
            If there is no translation, the return value is zero.
            </para>
            </returns>
            <remarks>
            <para>
            The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter,
            an Input Method Editor (IME), or any other form of input.
            </para>
            <para>
            An application can use <c>MapVirtualKeyEx</c> to translate scan codes to the virtual-key code constants <c>VK_SHIFT</c>,
            <c>VK_CONTROL</c>, and <c>VK_MENU</c>, and vice versa. These translations do not distinguish between the left and right
            instances of the SHIFT, CTRL, or ALT keys.
            </para>
            <para>
            An application can get the scan code corresponding to the left or right instance of one of these keys by calling
            <c>MapVirtualKeyEx</c> with uCode set to one of the following virtual-key code constants.
            </para>
            <list type="bullet">
            <item>
            <term><c>VK_LSHIFT</c></term>
            </item>
            <item>
            <term><c>VK_RSHIFT</c></term>
            </item>
            <item>
            <term><c>VK_LCONTROL</c></term>
            </item>
            <item>
            <term><c>VK_RCONTROL</c></term>
            </item>
            <item>
            <term><c>VK_LMENU</c></term>
            </item>
            <item>
            <term><c>VK_RMENU</c></term>
            </item>
            </list>
            <para>
            These left- and right-distinguishing constants are available to an application only through the GetKeyboardState,
            SetKeyboardState, GetAsyncKeyState, GetKeyState, MapVirtualKey, and <c>MapVirtualKeyEx</c> functions. For list complete table of
            virtual key codes, see Virtual Key Codes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.OemKeyScan(System.UInt16)">
            <summary>
            Maps OEMASCII codes 0 through 0x0FF into the OEM scan codes and shift states. The function provides information that allows a
            program to send OEM text to another program by simulating keyboard input.
            </summary>
            <param name="wOemChar">
            <para>Type: <c>WORD</c></para>
            <para>The ASCII value of the OEM character.</para>
            </param>
            <returns>
            <para>Type: <c>DWORD</c></para>
            <para>
            The low-order word of the return value contains the scan code of the OEM character, and the high-order word contains the shift
            state, which can be a combination of the following bits.
            </para>
            <list type="table">
            <listheader>
            <term>Bit</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>1</term>
            <term>Either SHIFT key is pressed.</term>
            </item>
            <item>
            <term>2</term>
            <term>Either CTRL key is pressed.</term>
            </item>
            <item>
            <term>4</term>
            <term>Either ALT key is pressed.</term>
            </item>
            <item>
            <term>8</term>
            <term>The Hankaku key is pressed.</term>
            </item>
            <item>
            <term>16</term>
            <term>Reserved (defined by the keyboard layout driver).</term>
            </item>
            <item>
            <term>32</term>
            <term>Reserved (defined by the keyboard layout driver).</term>
            </item>
            </list>
            <para>If the character cannot be produced by a single keystroke using the current keyboard layout, the return value is –1.</para>
            </returns>
            <remarks>
            <para>
            This function does not provide translations for characters that require CTRL+ALT or dead keys. Characters not translated by this
            function must be copied by simulating input using the ALT+ keypad mechanism. The NUMLOCK key must be off.
            </para>
            <para>
            This function does not provide translations for characters that cannot be typed with one keystroke using the current keyboard
            layout, such as characters with diacritics requiring dead keys. Characters not translated by this function may be simulated
            using the ALT+ keypad mechanism. The NUMLOCK key must be on.
            </para>
            <para>This function is implemented using the VkKeyScan function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterHotKey(Vanara.PInvoke.HWND,System.Int32,Vanara.PInvoke.User32.HotKeyModifiers,System.UInt32)">
            <summary>
            <para>Defines a system-wide hot key.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window that will receive WM_HOTKEY messages generated by the hot key. If this parameter is <c>NULL</c>,
            <c>WM_HOTKEY</c> messages are posted to the message queue of the calling thread and must be processed in the message loop.
            </para>
            </param>
            <param name="id">
            <para>Type: <c>int</c></para>
            <para>
            The identifier of the hot key. If the hWnd parameter is NULL, then the hot key is associated with the current thread rather than
            with a particular window. If a hot key already exists with the same hWnd and id parameters, see Remarks for the action taken.
            </para>
            </param>
            <param name="fsModifiers">
            <para>Type: <c>UINT</c></para>
            <para>
            The keys that must be pressed in combination with the key specified by the uVirtKey parameter in order to generate the WM_HOTKEY
            message. The fsModifiers parameter can be a combination of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MOD_ALT 0x0001</term>
            <term>Either ALT key must be held down.</term>
            </item>
            <item>
            <term>MOD_CONTROL 0x0002</term>
            <term>Either CTRL key must be held down.</term>
            </item>
            <item>
            <term>MOD_NOREPEAT 0x4000</term>
            <term>
            Changes the hotkey behavior so that the keyboard auto-repeat does not yield multiple hotkey notifications. Windows Vista: This
            flag is not supported.
            </term>
            </item>
            <item>
            <term>MOD_SHIFT 0x0004</term>
            <term>Either SHIFT key must be held down.</term>
            </item>
            <item>
            <term>MOD_WIN 0x0008</term>
            <term>
            Either WINDOWS key was held down. These keys are labeled with the Windows logo. Keyboard shortcuts that involve the WINDOWS key
            are reserved for use by the operating system.
            </term>
            </item>
            </list>
            </param>
            <param name="vk">
            <para>Type: <c>UINT</c></para>
            <para>The virtual-key code of the hot key. See Virtual Key Codes.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            When a key is pressed, the system looks for a match against all hot keys. Upon finding a match, the system posts the WM_HOTKEY
            message to the message queue of the window with which the hot key is associated. If the hot key is not associated with a window,
            then the <c>WM_HOTKEY</c> message is posted to the thread associated with the hot key.
            </para>
            <para>This function cannot associate a hot key with a window created by another thread.</para>
            <para><c>RegisterHotKey</c> fails if the keystrokes specified for the hot key have already been registered by another hot key.</para>
            <para>
            If a hot key already exists with the same hWnd and id parameters, it is maintained along with the new hot key. The application
            must explicitly call UnregisterHotKey to unregister the old hot key.
            </para>
            <para>
            <c>Windows Server 2003:</c> If a hot key already exists with the same hWnd and id parameters, it is replaced by the new hot key.
            </para>
            <para>
            The F12 key is reserved for use by the debugger at all times, so it should not be registered as a hot key. Even when you are not
            debugging an application, F12 is reserved in case a kernel-mode debugger or a just-in-time debugger is resident.
            </para>
            <para>
            An application must specify an id value in the range 0x0000 through 0xBFFF. A shared DLL must specify a value in the range
            0xC000 through 0xFFFF (the range returned by the GlobalAddAtom function). To avoid conflicts with hot-key identifiers defined by
            other shared DLLs, a DLL should use the <c>GlobalAddAtom</c> function to obtain the hot-key identifier.
            </para>
            <para>Examples</para>
            <para>
            The following example shows how to use the <c>RegisterHotKey</c> function with the <c>MOD_NOREPEAT</c> flag. In this example,
            the hotkey 'ALT+b' is registered for the main thread. When the hotkey is pressed, the thread will receive a WM_HOTKEY message,
            which will get picked up in the GetMessage call. Because this example uses <c>MOD_ALT</c> with the <c>MOD_NOREPEAT</c> value for
            fsModifiers, the thread will only receive another <c>WM_HOTKEY</c> message when the 'b' key is released and then pressed again
            while the 'ALT' key is being pressed down.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetKeyboardState(System.Byte[])">
            <summary>
            <para>
            Copies an array of keyboard key states into the calling thread's keyboard input-state table. This is the same table accessed by
            the GetKeyboardState and GetKeyState functions. Changes made to this table do not affect keyboard input to any other thread.
            </para>
            </summary>
            <param name="lpKeyState">
            <para>Type: <c>LPBYTE</c></para>
            <para>A pointer to a 256-byte array that contains keyboard key states.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Because the <c>SetKeyboardState</c> function alters the input state of the calling thread and not the global input state of the
            system, an application cannot use <c>SetKeyboardState</c> to set the NUM LOCK, CAPS LOCK, or SCROLL LOCK (or the Japanese KANA)
            indicator lights on the keyboard. These can be set or cleared using SendInput to simulate keystrokes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ToAscii(System.UInt32,System.UInt32,System.Byte[],System.UInt16@,System.UInt32)">
            <summary>
            <para>
            Translates the specified virtual-key code and keyboard state to the corresponding character or characters. The function
            translates the code using the input language and physical keyboard layout identified by the keyboard layout handle.
            </para>
            <para>To specify a handle to the keyboard layout to use to translate the specified code, use the ToAsciiEx function.</para>
            </summary>
            <param name="uVirtKey">
            <para>Type: <c>UINT</c></para>
            <para>The virtual-key code to be translated. See Virtual-Key Codes.</para>
            </param>
            <param name="uScanCode">
            <para>Type: <c>UINT</c></para>
            <para>The hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up (not pressed).</para>
            </param>
            <param name="lpKeyState">
            <para>Type: <c>const BYTE*</c></para>
            <para>
            A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of
            one key. If the high-order bit of a byte is set, the key is down (pressed).
            </para>
            <para>
            The low bit, if set, indicates that the key is toggled on. In this function, only the toggle bit of the CAPS LOCK key is
            relevant. The toggle state of the NUM LOCK and SCROLL LOCK keys is ignored.
            </para>
            </param>
            <param name="lpChar">
            <para>Type: <c>LPWORD</c></para>
            <para>The buffer that receives the translated character or characters.</para>
            </param>
            <param name="uFlags">
            <para>Type: <c>UINT</c></para>
            <para>This parameter must be 1 if a menu is active, or 0 otherwise.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>If the specified key is a dead key, the return value is negative. Otherwise, it is one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The specified virtual key has no translation for the current state of the keyboard.</term>
            </item>
            <item>
            <term>1</term>
            <term>One character was copied to the buffer.</term>
            </item>
            <item>
            <term>2</term>
            <term>
            Two characters were copied to the buffer. This usually happens when a dead-key character (accent or diacritic) stored in the
            keyboard layout cannot be composed with the specified virtual key to form a single character.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The parameters supplied to the <c>ToAscii</c> function might not be sufficient to translate the virtual-key code, because a
            previous dead key is stored in the keyboard layout.
            </para>
            <para>
            Typically, <c>ToAscii</c> performs the translation based on the virtual-key code. In some cases, however, bit 15 of the
            uScanCode parameter may be used to distinguish between a key press and a key release. The scan code is used for translating ALT+
            number key combinations.
            </para>
            <para>
            Although NUM LOCK is a toggle key that affects keyboard behavior, <c>ToAscii</c> ignores the toggle setting (the low bit) of
            lpKeyState ( <c>VK_NUMLOCK</c>) because the uVirtKey parameter alone is sufficient to distinguish the cursor movement keys (
            <c>VK_HOME</c>, <c>VK_INSERT</c>, and so on) from the numeric keys ( <c>VK_DECIMAL</c>, <c>VK_NUMPAD0</c> - <c>VK_NUMPAD9</c>).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ToAsciiEx(System.UInt32,System.UInt32,System.Byte[],System.UInt16@,System.UInt32,Vanara.PInvoke.User32.HKL)">
            <summary>
            Translates the specified virtual-key code and keyboard state to the corresponding character or characters. The function
            translates the code using the input language and physical keyboard layout identified by the input locale identifier.
            </summary>
            <param name="uVirtKey">
            <para>Type: <c>UINT</c></para>
            <para>The virtual-key code to be translated. See Virtual-Key Codes.</para>
            </param>
            <param name="uScanCode">
            <para>Type: <c>UINT</c></para>
            <para>The hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up (not pressed).</para>
            </param>
            <param name="lpKeyState">
            <para>Type: <c>const BYTE*</c></para>
            <para>
            A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of
            one key. If the high-order bit of a byte is set, the key is down (pressed).
            </para>
            <para>
            The low bit, if set, indicates that the key is toggled on. In this function, only the toggle bit of the CAPS LOCK key is
            relevant. The toggle state of the NUM LOCK and SCOLL LOCK keys is ignored.
            </para>
            </param>
            <param name="lpChar">
            <para>Type: <c>LPWORD</c></para>
            <para>A pointer to the buffer that receives the translated character or characters.</para>
            </param>
            <param name="uFlags">
            <para>Type: <c>UINT</c></para>
            <para>This parameter must be 1 if a menu is active, zero otherwise.</para>
            </param>
            <param name="dwhkl">
            <para>Type: <c>HKL</c></para>
            <para>
            Input locale identifier to use to translate the code. This parameter can be any input locale identifier previously returned by
            the LoadKeyboardLayout function.
            </para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>If the specified key is a dead key, the return value is negative. Otherwise, it is one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The specified virtual key has no translation for the current state of the keyboard.</term>
            </item>
            <item>
            <term>1</term>
            <term>One character was copied to the buffer.</term>
            </item>
            <item>
            <term>2</term>
            <term>
            Two characters were copied to the buffer. This usually happens when a dead-key character (accent or diacritic) stored in the
            keyboard layout cannot be composed with the specified virtual key to form a single character.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter,
            an Input Method Editor (IME), or any other form of input.
            </para>
            <para>
            The parameters supplied to the <c>ToAsciiEx</c> function might not be sufficient to translate the virtual-key code, because a
            previous dead key is stored in the keyboard layout.
            </para>
            <para>
            Typically, <c>ToAsciiEx</c> performs the translation based on the virtual-key code. In some cases, however, bit 15 of the
            uScanCode parameter may be used to distinguish between a key press and a key release. The scan code is used for translating
            ALT+number key combinations.
            </para>
            <para>
            Although NUM LOCK is a toggle key that affects keyboard behavior, <c>ToAsciiEx</c> ignores the toggle setting (the low bit) of
            lpKeyState ( <c>VK_NUMLOCK</c>) because the uVirtKey parameter alone is sufficient to distinguish the cursor movement keys (
            <c>VK_HOME</c>, <c>VK_INSERT</c>, and so on) from the numeric keys ( <c>VK_DECIMAL</c>, <c>VK_NUMPAD0</c> - <c>VK_NUMPAD9</c>).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ToUnicode(System.UInt32,System.UInt32,System.Byte[],System.Text.StringBuilder,System.Int32,System.UInt32)">
            <summary>
            <para>Translates the specified virtual-key code and keyboard state to the corresponding Unicode character or characters.</para>
            <para>To specify a handle to the keyboard layout to use to translate the specified code, use the ToUnicodeEx function.</para>
            </summary>
            <param name="wVirtKey">
            <para>Type: <c>UINT</c></para>
            <para>The virtual-key code to be translated. See Virtual-Key Codes.</para>
            </param>
            <param name="wScanCode">
            <para>Type: <c>UINT</c></para>
            <para>The hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up.</para>
            </param>
            <param name="lpKeyState">
            <para>Type: <c>const BYTE*</c></para>
            <para>
            A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of
            one key. If the high-order bit of a byte is set, the key is down.
            </para>
            </param>
            <param name="pwszBuff">
            <para>Type: <c>LPWSTR</c></para>
            <para>
            The buffer that receives the translated Unicode character or characters. However, this buffer may be returned without being
            null-terminated even though the variable name suggests that it is null-terminated.
            </para>
            </param>
            <param name="cchBuff">
            <para>Type: <c>int</c></para>
            <para>The size, in characters, of the buffer pointed to by the pwszBuff parameter.</para>
            </param>
            <param name="wFlags">
            <para>Type: <c>UINT</c></para>
            <para>The behavior of the function.</para>
            <para>If bit 0 is set, a menu is active.</para>
            <para>If bit 2 is set, keyboard state is not changed (Windows 10, version 1607 and newer)</para>
            <para>All other bits (through 31) are reserved.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>The function returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>-1</term>
            <term>
            The specified virtual key is a dead-key character (accent or diacritic). This value is returned regardless of the keyboard
            layout, even if several characters have been typed and are stored in the keyboard state. If possible, even with Unicode keyboard
            layouts, the function has written a spacing version of the dead-key character to the buffer specified by pwszBuff. For example,
            the function writes the character SPACING ACUTE (0x00B4), rather than the character NON_SPACING ACUTE (0x0301).
            </term>
            </item>
            <item>
            <term>0</term>
            <term>
            The specified virtual key has no translation for the current state of the keyboard. Nothing was written to the buffer specified
            by pwszBuff.
            </term>
            </item>
            <item>
            <term>1</term>
            <term>One character was written to the buffer specified by pwszBuff.</term>
            </item>
            <item>
            <term>2 ≤ value</term>
            <term>
            Two or more characters were written to the buffer specified by pwszBuff. The most common cause for this is that a dead-key
            character (accent or diacritic) stored in the keyboard layout could not be combined with the specified virtual key to form a
            single character. However, the buffer may contain more characters than the return value specifies. When this happens, any extra
            characters are invalid and should be ignored.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The parameters supplied to the <c>ToUnicode</c> function might not be sufficient to translate the virtual-key code because a
            previous dead key is stored in the keyboard layout.
            </para>
            <para>
            Typically, <c>ToUnicode</c> performs the translation based on the virtual-key code. In some cases, however, bit 15 of the
            wScanCode parameter can be used to distinguish between a key press and a key release.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ToUnicodeEx(System.UInt32,System.UInt32,System.Byte[],System.Text.StringBuilder,System.Int32,System.UInt32,Vanara.PInvoke.User32.HKL)">
            <summary>Translates the specified virtual-key code and keyboard state to the corresponding Unicode character or characters.</summary>
            <param name="wVirtKey">
            <para>Type: <c>UINT</c></para>
            <para>The virtual-key code to be translated. See Virtual-Key Codes.</para>
            </param>
            <param name="wScanCode">
            <para>Type: <c>UINT</c></para>
            <para>The hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up.</para>
            </param>
            <param name="lpKeyState">
            <para>Type: <c>const BYTE*</c></para>
            <para>
            A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of
            one key. If the high-order bit of a byte is set, the key is down.
            </para>
            </param>
            <param name="pwszBuff">
            <para>Type: <c>LPWSTR</c></para>
            <para>
            The buffer that receives the translated Unicode character or characters. However, this buffer may be returned without being
            null-terminated even though the variable name suggests that it is null-terminated.
            </para>
            </param>
            <param name="cchBuff">
            <para>Type: <c>int</c></para>
            <para>The size, in characters, of the buffer pointed to by the pwszBuff parameter.</para>
            </param>
            <param name="wFlags">
            <para>Type: <c>UINT</c></para>
            <para>The behavior of the function.</para>
            <para>If bit 0 is set, a menu is active.</para>
            <para>If bit 2 is set, keyboard state is not changed (Windows 10, version 1607 and newer)</para>
            <para>All other bits (through 31) are reserved.</para>
            </param>
            <param name="dwhkl">
            <para>Type: <c>HKL</c></para>
            <para>
            The input locale identifier used to translate the specified code. This parameter can be any input locale identifier previously
            returned by the LoadKeyboardLayout function.
            </para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>The function returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>-1</term>
            <term>
            The specified virtual key is a dead-key character (accent or diacritic). This value is returned regardless of the keyboard
            layout, even if several characters have been typed and are stored in the keyboard state. If possible, even with Unicode keyboard
            layouts, the function has written a spacing version of the dead-key character to the buffer specified by pwszBuff. For example,
            the function writes the character SPACING ACUTE (0x00B4), rather than the character NON_SPACING ACUTE (0x0301).
            </term>
            </item>
            <item>
            <term>0</term>
            <term>
            The specified virtual key has no translation for the current state of the keyboard. Nothing was written to the buffer specified
            by pwszBuff.
            </term>
            </item>
            <item>
            <term>1</term>
            <term>One character was written to the buffer specified by pwszBuff.</term>
            </item>
            <item>
            <term>2 ≤ value</term>
            <term>
            Two or more characters were written to the buffer specified by pwszBuff. The most common cause for this is that a dead-key
            character (accent or diacritic) stored in the keyboard layout could not be combined with the specified virtual key to form a
            single character. However, the buffer may contain more characters than the return value specifies. When this happens, any extra
            characters are invalid and should be ignored.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter,
            an Input Method Editor (IME), or any other form of input.
            </para>
            <para>
            The parameters supplied to the <c>ToUnicodeEx</c> function might not be sufficient to translate the virtual-key code because a
            previous dead key is stored in the keyboard layout.
            </para>
            <para>
            Typically, <c>ToUnicodeEx</c> performs the translation based on the virtual-key code. In some cases, however, bit 15 of the
            wScanCode parameter can be used to distinguish between a key press and a key release.
            </para>
            <para>
            As <c>ToUnicodeEx</c> translates the virtual-key code, it also changes the state of the kernel-mode keyboard buffer. This
            state-change affects dead keys, ligatures, alt+numpad key entry, and so on. It might also cause undesired side-effects if used
            in conjunction with TranslateMessage (which also changes the state of the kernel-mode keyboard buffer).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.UnloadKeyboardLayout(Vanara.PInvoke.User32.HKL)">
            <summary>Unloads an input locale identifier (formerly called a keyboard layout).</summary>
            <param name="hkl">
            <para>Type: <c>HKL</c></para>
            <para>The input locale identifier to be unloaded.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. The function can fail for the following reasons:</para>
            <list type="bullet">
            <item>
            <term>An invalid input locale identifier was passed.</term>
            </item>
            <item>
            <term>The input locale identifier was preloaded.</term>
            </item>
            <item>
            <term>The input locale identifier is in use.</term>
            </item>
            </list>
            <para>To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter,
            an Input Method Editor (IME), or any other form of input.
            </para>
            <para>
            <c>UnloadKeyboardLayout</c> cannot unload the system default input locale identifier if it is the only keyboard layout loaded.
            You must first load another input locale identifier before unloading the default input locale identifier.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.UnregisterHotKey(Vanara.PInvoke.HWND,System.Int32)">
            <summary>
            <para>Frees a hot key previously registered by the calling thread.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window associated with the hot key to be freed. This parameter should be <c>NULL</c> if the hot key is not
            associated with a window.
            </para>
            </param>
            <param name="id">
            <para>Type: <c>int</c></para>
            <para>The identifier of the hot key to be freed.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.VkKeyScanA(System.Byte)">
            <summary>
            <para>
            [This function has been superseded by the VkKeyScanEx function. You can still use <c>VkKeyScan</c>, however, if you do not need
            to specify a keyboard layout.]
            </para>
            <para>Translates a character to the corresponding virtual-key code and shift state for the current keyboard.</para>
            </summary>
            <param name="ch">
            <para>Type: <c>TCHAR</c></para>
            <para>The character to be translated into a virtual-key code.</para>
            </param>
            <returns>
            <para>Type: <c>SHORT</c></para>
            <para>
            If the function succeeds, the low-order byte of the return value contains the virtual-key code and the high-order byte contains
            the shift state, which can be a combination of the following flag bits.
            </para>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>1</term>
            <term>Either SHIFT key is pressed.</term>
            </item>
            <item>
            <term>2</term>
            <term>Either CTRL key is pressed.</term>
            </item>
            <item>
            <term>4</term>
            <term>Either ALT key is pressed.</term>
            </item>
            <item>
            <term>8</term>
            <term>The Hankaku key is pressed</term>
            </item>
            <item>
            <term>16</term>
            <term>Reserved (defined by the keyboard layout driver).</term>
            </item>
            <item>
            <term>32</term>
            <term>Reserved (defined by the keyboard layout driver).</term>
            </item>
            </list>
            <para>
            If the function finds no key that translates to the passed character code, both the low-order and high-order bytes contain –1.
            </para>
            </returns>
            <remarks>
            <para>
            For keyboard layouts that use the right-hand ALT key as a shift key (for example, the French keyboard layout), the shift state
            is represented by the value 6, because the right-hand ALT key is converted internally into CTRL+ALT.
            </para>
            <para>
            Translations for the numeric keypad ( <c>VK_NUMPAD0</c> through <c>VK_DIVIDE</c>) are ignored. This function is intended to
            translate characters into keystrokes from the main keyboard section only. For example, the character "7" is translated into
            VK_7, not VK_NUMPAD7.
            </para>
            <para><c>VkKeyScan</c> is used by applications that send characters by using the WM_KEYUP and WM_KEYDOWN messages.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.VkKeyScanExA(System.Byte,Vanara.PInvoke.User32.HKL)">
            <summary>
            Translates a character to the corresponding virtual-key code and shift state. The function translates the character using the
            input language and physical keyboard layout identified by the input locale identifier.
            </summary>
            <param name="ch">
            <para>Type: <c>TCHAR</c></para>
            <para>The character to be translated into a virtual-key code.</para>
            </param>
            <param name="dwhkl">
            <para>Type: <c>HKL</c></para>
            <para>
            Input locale identifier used to translate the character. This parameter can be any input locale identifier previously returned
            by the LoadKeyboardLayout function.
            </para>
            </param>
            <returns>
            <para>Type: <c>SHORT</c></para>
            <para>
            If the function succeeds, the low-order byte of the return value contains the virtual-key code and the high-order byte contains
            the shift state, which can be a combination of the following flag bits.
            </para>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>1</term>
            <term>Either SHIFT key is pressed.</term>
            </item>
            <item>
            <term>2</term>
            <term>Either CTRL key is pressed.</term>
            </item>
            <item>
            <term>4</term>
            <term>Either ALT key is pressed.</term>
            </item>
            <item>
            <term>8</term>
            <term>The Hankaku key is pressed</term>
            </item>
            <item>
            <term>16</term>
            <term>Reserved (defined by the keyboard layout driver).</term>
            </item>
            <item>
            <term>32</term>
            <term>Reserved (defined by the keyboard layout driver).</term>
            </item>
            </list>
            <para>
            If the function finds no key that translates to the passed character code, both the low-order and high-order bytes contain –1.
            </para>
            </returns>
            <remarks>
            <para>
            The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter,
            an Input Method Editor (IME), or any other form of input.
            </para>
            <para>
            For keyboard layouts that use the right-hand ALT key as a shift key (for example, the French keyboard layout), the shift state
            is represented by the value 6, because the right-hand ALT key is converted internally into CTRL+ALT.
            </para>
            <para>
            Translations for the numeric keypad (VK_NUMPAD0 through VK_DIVIDE) are ignored. This function is intended to translate
            characters into keystrokes from the main keyboard section only. For example, the character "7" is translated into VK_7, not VK_NUMPAD7.
            </para>
            <para><c>VkKeyScanEx</c> is used by applications that send characters by using the WM_KEYUP and WM_KEYDOWN messages.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.VkKeyScanExW(System.Char,Vanara.PInvoke.User32.HKL)">
            <summary>
            Translates a character to the corresponding virtual-key code and shift state. The function translates the character using the
            input language and physical keyboard layout identified by the input locale identifier.
            </summary>
            <param name="ch">
            <para>Type: <c>TCHAR</c></para>
            <para>The character to be translated into a virtual-key code.</para>
            </param>
            <param name="dwhkl">
            <para>Type: <c>HKL</c></para>
            <para>
            Input locale identifier used to translate the character. This parameter can be any input locale identifier previously returned
            by the LoadKeyboardLayout function.
            </para>
            </param>
            <returns>
            <para>Type: <c>SHORT</c></para>
            <para>
            If the function succeeds, the low-order byte of the return value contains the virtual-key code and the high-order byte contains
            the shift state, which can be a combination of the following flag bits.
            </para>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>1</term>
            <term>Either SHIFT key is pressed.</term>
            </item>
            <item>
            <term>2</term>
            <term>Either CTRL key is pressed.</term>
            </item>
            <item>
            <term>4</term>
            <term>Either ALT key is pressed.</term>
            </item>
            <item>
            <term>8</term>
            <term>The Hankaku key is pressed</term>
            </item>
            <item>
            <term>16</term>
            <term>Reserved (defined by the keyboard layout driver).</term>
            </item>
            <item>
            <term>32</term>
            <term>Reserved (defined by the keyboard layout driver).</term>
            </item>
            </list>
            <para>
            If the function finds no key that translates to the passed character code, both the low-order and high-order bytes contain –1.
            </para>
            </returns>
            <remarks>
            <para>
            The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter,
            an Input Method Editor (IME), or any other form of input.
            </para>
            <para>
            For keyboard layouts that use the right-hand ALT key as a shift key (for example, the French keyboard layout), the shift state
            is represented by the value 6, because the right-hand ALT key is converted internally into CTRL+ALT.
            </para>
            <para>
            Translations for the numeric keypad (VK_NUMPAD0 through VK_DIVIDE) are ignored. This function is intended to translate
            characters into keystrokes from the main keyboard section only. For example, the character "7" is translated into VK_7, not VK_NUMPAD7.
            </para>
            <para><c>VkKeyScanEx</c> is used by applications that send characters by using the WM_KEYUP and WM_KEYDOWN messages.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.VkKeyScanW(System.Char)">
            <summary>
            <para>
            [This function has been superseded by the VkKeyScanEx function. You can still use <c>VkKeyScan</c>, however, if you do not need
            to specify a keyboard layout.]
            </para>
            <para>Translates a character to the corresponding virtual-key code and shift state for the current keyboard.</para>
            </summary>
            <param name="ch">
            <para>Type: <c>TCHAR</c></para>
            <para>The character to be translated into a virtual-key code.</para>
            </param>
            <returns>
            <para>Type: <c>SHORT</c></para>
            <para>
            If the function succeeds, the low-order byte of the return value contains the virtual-key code and the high-order byte contains
            the shift state, which can be a combination of the following flag bits.
            </para>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>1</term>
            <term>Either SHIFT key is pressed.</term>
            </item>
            <item>
            <term>2</term>
            <term>Either CTRL key is pressed.</term>
            </item>
            <item>
            <term>4</term>
            <term>Either ALT key is pressed.</term>
            </item>
            <item>
            <term>8</term>
            <term>The Hankaku key is pressed</term>
            </item>
            <item>
            <term>16</term>
            <term>Reserved (defined by the keyboard layout driver).</term>
            </item>
            <item>
            <term>32</term>
            <term>Reserved (defined by the keyboard layout driver).</term>
            </item>
            </list>
            <para>
            If the function finds no key that translates to the passed character code, both the low-order and high-order bytes contain –1.
            </para>
            </returns>
            <remarks>
            <para>
            For keyboard layouts that use the right-hand ALT key as a shift key (for example, the French keyboard layout), the shift state
            is represented by the value 6, because the right-hand ALT key is converted internally into CTRL+ALT.
            </para>
            <para>
            Translations for the numeric keypad ( <c>VK_NUMPAD0</c> through <c>VK_DIVIDE</c>) are ignored. This function is intended to
            translate characters into keystrokes from the main keyboard section only. For example, the character "7" is translated into
            VK_7, not VK_NUMPAD7.
            </para>
            <para><c>VkKeyScan</c> is used by applications that send characters by using the WM_KEYUP and WM_KEYDOWN messages.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.HKL">
            <summary>Provides a handle to a .</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.HKL.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.HKL"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.User32.HKL.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.User32.HKL"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.HKL.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.HKL.op_Explicit(Vanara.PInvoke.User32.HKL)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.User32.HKL"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HKL.op_Implicit(System.IntPtr)~Vanara.PInvoke.User32.HKL">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.User32.HKL"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HKL.op_Inequality(Vanara.PInvoke.User32.HKL,Vanara.PInvoke.User32.HKL)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HKL.op_Equality(Vanara.PInvoke.User32.HKL,Vanara.PInvoke.User32.HKL)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HKL.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.HKL.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.HKL.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.KEYBDINPUT">
            <summary>Contains information about a simulated keyboard event.</summary>
            <remarks>
            <para>
            <c>INPUT_KEYBOARD</c> supports nonkeyboard-input methods—such as handwriting recognition or voice recognition—as if it were text
            input by using the <c>KEYEVENTF_UNICODE</c> flag. If <c>KEYEVENTF_UNICODE</c> is specified, SendInput sends a WM_KEYDOWN or
            WM_KEYUP message to the foreground thread's message queue with wParam equal to <c>VK_PACKET</c>. Once GetMessage or PeekMessage
            obtains this message, passing the message to TranslateMessage posts a WM_CHAR message with the Unicode character originally
            specified by <c>wScan</c>. This Unicode character will automatically be converted to the appropriate ANSI value if it is posted
            to an ANSI window.
            </para>
            <para>
            Set the <c>KEYEVENTF_SCANCODE</c> flag to define keyboard input in terms of the scan code. This is useful to simulate a physical
            keystroke regardless of which keyboard is currently being used. The virtual key value of a key may alter depending on the
            current keyboard layout or what other keys were pressed, but the scan code will always be the same.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.KEYBDINPUT.wVk">
            <summary>
            <para>Type: <c>WORD</c></para>
            <para>
            A virtual-key code. The code must be a value in the range 1 to 254. If the <c>dwFlags</c> member specifies
            <c>KEYEVENTF_UNICODE</c>, <c>wVk</c> must be 0.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KEYBDINPUT.wScan">
            <summary>
            <para>Type: <c>WORD</c></para>
            <para>
            A hardware scan code for the key. If <c>dwFlags</c> specifies <c>KEYEVENTF_UNICODE</c>, <c>wScan</c> specifies a Unicode
            character which is to be sent to the foreground application.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KEYBDINPUT.dwFlags">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>Specifies various aspects of a keystroke. This member can be certain combinations of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>KEYEVENTF_EXTENDEDKEY 0x0001</term>
            <term>If specified, the scan code was preceded by a prefix byte that has the value 0xE0 (224).</term>
            </item>
            <item>
            <term>KEYEVENTF_KEYUP 0x0002</term>
            <term>If specified, the key is being released. If not specified, the key is being pressed.</term>
            </item>
            <item>
            <term>KEYEVENTF_SCANCODE 0x0008</term>
            <term>If specified, wScan identifies the key and wVk is ignored.</term>
            </item>
            <item>
            <term>KEYEVENTF_UNICODE 0x0004</term>
            <term>
            If specified, the system synthesizes a VK_PACKET keystroke. The wVk parameter must be zero. This flag can only be combined
            with the KEYEVENTF_KEYUP flag. For more information, see the Remarks section.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KEYBDINPUT.time">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The time stamp for the event, in milliseconds. If this parameter is zero, the system will provide its own time stamp.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.KEYBDINPUT.dwExtraInfo">
            <summary>
            <para>Type: <c>ULONG_PTR</c></para>
            <para>An additional value associated with the keystroke. Use the GetMessageExtraInfo function to obtain this information.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SafeHKL">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <see cref="T:Vanara.PInvoke.User32.HKL"/> that is disposed using <see cref="M:Vanara.PInvoke.User32.UnloadKeyboardLayout(Vanara.PInvoke.User32.HKL)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHKL.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHKL"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHKL.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHKL"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHKL.op_Implicit(Vanara.PInvoke.User32.SafeHKL)~Vanara.PInvoke.User32.HKL">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.User32.SafeHKL"/> to <see cref="T:Vanara.PInvoke.User32.HKL"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHKL.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.GetMenuDefaultItemFlags">
            <summary>Indicates how the GetMenuDefaultItem function should search for menu items.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetMenuDefaultItemFlags.GMDI_USEDISABLED">
            <summary>
            The function is to return a default item, even if it is disabled. By default, the function skips disabled or grayed items.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetMenuDefaultItemFlags.GMDI_GOINTOPOPUPS">
            <summary>
            If the default item is one that opens a submenu, the function is to search recursively in the corresponding submenu. If the
            submenu has no default item, the return value identifies the item that opens the submenu. By default, the function returns
            the first default item on the specified menu, regardless of whether it is an item that opens a submenu.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MenuFlags">
            <summary>Flags used by various menu functions.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_BYCOMMAND">
            <summary>
            Indicates that the uPosition parameter gives the identifier of the menu item. The MF_BYCOMMAND flag is the default if neither
            the MF_BYCOMMAND nor MF_BYPOSITION flag is specified.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_BYPOSITION">
            <summary>
            Indicates that the uPosition parameter gives the zero-based relative position of the new menu item. If uPosition is -1, the
            new menu item is appended to the end of the menu.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_SEPARATOR">
            <summary>
            Draws a horizontal dividing line. This flag is used only in a drop-down menu, submenu, or shortcut menu. The line cannot be
            grayed, disabled, or highlighted. The lpNewItem and uIDNewItem parameters are ignored.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_ENABLED">
            <summary>Enables the menu item so that it can be selected, and restores it from its grayed state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_GRAYED">
            <summary>Disables the menu item and grays it so that it cannot be selected.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_DISABLED">
            <summary>Disables the menu item so that it cannot be selected, but the flag does not gray it.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_UNCHECKED">
            <summary>
            Does not place a check mark next to the item (default). If the application supplies check-mark bitmaps (see
            SetMenuItemBitmaps), this flag displays the clear bitmap next to the menu item.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_CHECKED">
            <summary>
            Places a check mark next to the menu item. If the application provides check-mark bitmaps (see SetMenuItemBitmaps, this flag
            displays the check-mark bitmap next to the menu item.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_USECHECKBITMAPS">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_STRING">
            <summary>Specifies that the menu item is a text string; the lpNewItem parameter is a pointer to the string.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_BITMAP">
            <summary>Uses a bitmap as the menu item. The lpNewItem parameter contains a handle to the bitmap.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_OWNERDRAW">
            <summary>
            Specifies that the item is an owner-drawn item. Before the menu is displayed for the first time, the window that owns the
            menu receives a WM_MEASUREITEM message to retrieve the width and height of the menu item. The WM_DRAWITEM message is then
            sent to the window procedure of the owner window whenever the appearance of the menu item must be updated.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_POPUP">
            <summary>
            Specifies that the menu item opens a drop-down menu or submenu. The uIDNewItem parameter specifies a handle to the drop-down
            menu or submenu. This flag is used to add a menu name to a menu bar, or a menu item that opens a submenu to a drop-down menu,
            submenu, or shortcut menu.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_MENUBARBREAK">
            <summary>
            Functions the same as the MF_MENUBREAK flag for a menu bar. For a drop-down menu, submenu, or shortcut menu, the new column
            is separated from the old column by a vertical line.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_MENUBREAK">
            <summary>
            Places the item on a new line (for a menu bar) or in a new column (for a drop-down menu, submenu, or shortcut menu) without
            separating columns.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_UNHILITE">
            <summary>Removes highlighting from the menu item.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_HILITE">
            <summary>Highlights the menu item. If this flag is not specified, the highlighting is removed from the item.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_DEFAULT">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_SYSMENU">
            <summary>
            Item is contained in the window menu. The lParam parameter contains a handle to the menu associated with the message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_HELP">
            <summary>Indicates that the menu item has a vertical separator to its left.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_RIGHTJUSTIFY">
            <summary>Indicates that the menu item has a vertical separator to its left.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_MOUSESELECT">
            <summary>Item is selected with the mouse.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuFlags.MF_END">
            <summary>Undocumented.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MenuInfoMember">
            <summary>Indicates the members to be retrieved or set (except for MIM_APPLYTOSUBMENUS) in <see cref="F:Vanara.PInvoke.User32.MENUINFO.fMask"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuInfoMember.MIM_APPLYTOSUBMENUS">
            <summary>
            Settings apply to the menu and all of its submenus. SetMenuInfo uses this flag and GetMenuInfo ignores this flag
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuInfoMember.MIM_BACKGROUND">
            <summary>Retrieves or sets the hbrBack member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuInfoMember.MIM_HELPID">
            <summary>Retrieves or sets the dwContextHelpID member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuInfoMember.MIM_MAXHEIGHT">
            <summary>Retrieves or sets the cyMax member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuInfoMember.MIM_MENUDATA">
            <summary>Retrieves or sets the dwMenuData member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuInfoMember.MIM_STYLE">
            <summary>Retrieves or sets the dwStyle member.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MenuInfoStyle">
            <summary>The menu style use by <see cref="F:Vanara.PInvoke.User32.MENUINFO.dwStyle"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuInfoStyle.MNS_AUTODISMISS">
            <summary>Menu automatically ends when mouse is outside the menu for approximately 10 seconds.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuInfoStyle.MNS_CHECKORBMP">
            <summary>
            The same space is reserved for the check mark and the bitmap. If the check mark is drawn, the bitmap is not. All checkmarks
            and bitmaps are aligned. Used for menus where some items use checkmarks and some use bitmaps.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuInfoStyle.MNS_DRAGDROP">
            <summary>Menu items are OLE drop targets or drag sources. Menu owner receives WM_MENUDRAG and WM_MENUGETOBJECT messages.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuInfoStyle.MNS_MODELESS">
            <summary>Menu is modeless; that is, there is no menu modal message loop while the menu is active.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuInfoStyle.MNS_NOCHECK">
            <summary>
            No space is reserved to the left of an item for a check mark. The item can still be selected, but the check mark will not
            appear next to the item.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuInfoStyle.MNS_NOTIFYBYPOS">
            <summary>
            Menu owner receives a WM_MENUCOMMAND message instead of a WM_COMMAND message when the user makes a selection. MNS_NOTIFYBYPOS
            is a menu header style and has no effect when applied to individual sub menus.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MenuItemInfoMask">
            <summary>Indicates the members to be retrieved or set in <see cref="T:Vanara.PInvoke.User32.MENUITEMINFO"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemInfoMask.MIIM_STATE">
            <summary>Retrieves or sets the fState member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemInfoMask.MIIM_ID">
            <summary>Retrieves or sets the wID member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemInfoMask.MIIM_SUBMENU">
            <summary>Retrieves or sets the hSubMenu member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemInfoMask.MIIM_CHECKMARKS">
            <summary>Retrieves or sets the hbmpChecked and hbmpUnchecked members.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemInfoMask.MIIM_TYPE">
            <summary>
            Retrieves or sets the fType and dwTypeData members.
            <para>MIIM_TYPE is replaced by MIIM_BITMAP, MIIM_FTYPE, and MIIM_STRING.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemInfoMask.MIIM_DATA">
            <summary>Retrieves or sets the dwItemData member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemInfoMask.MIIM_STRING">
            <summary>Retrieves or sets the dwTypeData member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemInfoMask.MIIM_BITMAP">
            <summary>Retrieves or sets the hbmpItem member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemInfoMask.MIIM_FTYPE">
            <summary>Retrieves or sets the fType member.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MenuItemState">
            <summary>The menu item state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemState.MFS_GRAYED">
            <summary>Disables the menu item and grays it so that it cannot be selected. This is equivalent to MFS_DISABLED.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemState.MFS_DISABLED">
            <summary>Disables the menu item and grays it so that it cannot be selected. This is equivalent to MFS_GRAYED.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemState.MFS_CHECKED">
            <summary>Checks the menu item. For more information about selected menu items, see the hbmpChecked member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemState.MFS_HILITE">
            <summary>Highlights the menu item.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemState.MFS_ENABLED">
            <summary>Enables the menu item so that it can be selected. This is the default state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemState.MFS_UNCHECKED">
            <summary>Unchecks the menu item. For more information about clear menu items, see the hbmpChecked member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemState.MFS_UNHILITE">
            <summary>Removes the highlight from the menu item. This is the default state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemState.MFS_DEFAULT">
            <summary>
            Specifies that the menu item is the default. A menu can contain only one default menu item, which is displayed in bold.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MenuItemType">
            <summary>The menu item type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemType.MFT_STRING">
            <summary>
            Displays the menu item using a text string. The dwTypeData member is the pointer to a null-terminated string, and the cch
            member is the length of the string.
            <para>MFT_STRING is replaced by MIIM_STRING.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemType.MFT_BITMAP">
            <summary>
            Displays the menu item using a bitmap. The low-order word of the dwTypeData member is the bitmap handle, and the cch member
            is ignored.
            <para>MFT_BITMAP is replaced by MIIM_BITMAP and hbmpItem.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemType.MFT_MENUBARBREAK">
            <summary>
            Places the menu item on a new line (for a menu bar) or in a new column (for a drop-down menu, submenu, or shortcut menu). For
            a drop-down menu, submenu, or shortcut menu, a vertical line separates the new column from the old.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemType.MFT_MENUBREAK">
            <summary>
            Places the menu item on a new line (for a menu bar) or in a new column (for a drop-down menu, submenu, or shortcut menu). For
            a drop-down menu, submenu, or shortcut menu, the columns are not separated by a vertical line.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemType.MFT_OWNERDRAW">
            <summary>
            Assigns responsibility for drawing the menu item to the window that owns the menu. The window receives a WM_MEASUREITEM
            message before the menu is displayed for the first time, and a WM_DRAWITEM message whenever the appearance of the menu item
            must be updated. If this value is specified, the dwTypeData member contains an application-defined value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemType.MFT_RADIOCHECK">
            <summary>
            Displays selected menu items using a radio-button mark instead of a check mark if the hbmpChecked member is NULL.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemType.MFT_SEPARATOR">
            <summary>
            Specifies that the menu item is a separator. A menu item separator appears as a horizontal dividing line. The dwTypeData and
            cch members are ignored. This value is valid only in a drop-down menu, submenu, or shortcut menu.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemType.MFT_RIGHTORDER">
            <summary>
            Specifies that menus cascade right-to-left (the default is left-to-right). This is used to support right-to-left languages,
            such as Arabic and Hebrew.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MenuItemType.MFT_RIGHTJUSTIFY">
            <summary>
            Right-justifies the menu item and any subsequent items. This value is valid only if the menu item is in a menu bar.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MNGOF">
            <summary>The position of the mouse cursor with respect to the item indicated by MENUGETOBJECTINFO.uPos.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MNGOF.MNGOF_BOTTOMGAP">
            <summary>The mouse is on the bottom of the item indicated by uPos.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MNGOF.MNGOF_TOPGAP">
            <summary>The mouse is on the top of the item indicated by uPos.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.AppendMenu(Vanara.PInvoke.HMENU,Vanara.PInvoke.User32.MenuFlags,System.IntPtr,System.String)">
            <summary>
            <para>
            Appends a new item to the end of the specified menu bar, drop-down menu, submenu, or shortcut menu. You can use this function to
            specify the content, appearance, and behavior of the menu item.
            </para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu bar, drop-down menu, submenu, or shortcut menu to be changed.</para>
            </param>
            <param name="uFlags">
            <para>Type: <c>UINT</c></para>
            <para>Controls the appearance and behavior of the new menu item. This parameter can be a combination of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BITMAP 0x00000004L</term>
            <term>Uses a bitmap as the menu item. The lpNewItem parameter contains a handle to the bitmap.</term>
            </item>
            <item>
            <term>MF_CHECKED 0x00000008L</term>
            <term>
            Places a check mark next to the menu item. If the application provides check-mark bitmaps (see SetMenuItemBitmaps, this flag
            displays the check-mark bitmap next to the menu item.
            </term>
            </item>
            <item>
            <term>MF_DISABLED 0x00000002L</term>
            <term>Disables the menu item so that it cannot be selected, but the flag does not gray it.</term>
            </item>
            <item>
            <term>MF_ENABLED 0x00000000L</term>
            <term>Enables the menu item so that it can be selected, and restores it from its grayed state.</term>
            </item>
            <item>
            <term>MF_GRAYED 0x00000001L</term>
            <term>Disables the menu item and grays it so that it cannot be selected.</term>
            </item>
            <item>
            <term>MF_MENUBARBREAK 0x00000020L</term>
            <term>
            Functions the same as the MF_MENUBREAK flag for a menu bar. For a drop-down menu, submenu, or shortcut menu, the new column is
            separated from the old column by a vertical line.
            </term>
            </item>
            <item>
            <term>MF_MENUBREAK 0x00000040L</term>
            <term>
            Places the item on a new line (for a menu bar) or in a new column (for a drop-down menu, submenu, or shortcut menu) without
            separating columns.
            </term>
            </item>
            <item>
            <term>MF_OWNERDRAW 0x00000100L</term>
            <term>
            Specifies that the item is an owner-drawn item. Before the menu is displayed for the first time, the window that owns the menu
            receives a WM_MEASUREITEM message to retrieve the width and height of the menu item. The WM_DRAWITEM message is then sent to the
            window procedure of the owner window whenever the appearance of the menu item must be updated.
            </term>
            </item>
            <item>
            <term>MF_POPUP 0x00000010L</term>
            <term>
            Specifies that the menu item opens a drop-down menu or submenu. The uIDNewItem parameter specifies a handle to the drop-down menu
            or submenu. This flag is used to add a menu name to a menu bar, or a menu item that opens a submenu to a drop-down menu, submenu,
            or shortcut menu.
            </term>
            </item>
            <item>
            <term>MF_SEPARATOR 0x00000800L</term>
            <term>
            Draws a horizontal dividing line. This flag is used only in a drop-down menu, submenu, or shortcut menu. The line cannot be
            grayed, disabled, or highlighted. The lpNewItem and uIDNewItem parameters are ignored.
            </term>
            </item>
            <item>
            <term>MF_STRING 0x00000000L</term>
            <term>Specifies that the menu item is a text string; the lpNewItem parameter is a pointer to the string.</term>
            </item>
            <item>
            <term>MF_UNCHECKED 0x00000000L</term>
            <term>
            Does not place a check mark next to the item (default). If the application supplies check-mark bitmaps (see SetMenuItemBitmaps),
            this flag displays the clear bitmap next to the menu item.
            </term>
            </item>
            </list>
            </param>
            <param name="uIDNewItem">
            <para>Type: <c>UINT_PTR</c></para>
            <para>
            The identifier of the new menu item or, if the uFlags parameter is set to <c>MF_POPUP</c>, a handle to the drop-down menu or submenu.
            </para>
            </param>
            <param name="lpNewItem">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The content of the new menu item. The interpretation of lpNewItem depends on whether the uFlags parameter includes the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BITMAP 0x00000004L</term>
            <term>Contains a bitmap handle.</term>
            </item>
            <item>
            <term>MF_OWNERDRAW 0x00000100L</term>
            <term>
            Contains an application-supplied value that can be used to maintain additional data related to the menu item. The value is in the
            itemData member of the structure pointed to by the lParam parameter of the WM_MEASUREITEM or WM_DRAWITEM message sent when the
            menu is created or its appearance is updated.
            </term>
            </item>
            <item>
            <term>MF_STRING 0x00000000L</term>
            <term>Contains a pointer to a null-terminated string.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error
            information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>The application must call the DrawMenuBar function whenever a menu changes, whether the menu is in a displayed window.</para>
            <para>
            To get keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the WM_MENUCHAR
            message. For more information, see Owner-Drawn Menus and the WM_MENUCHAR Message.
            </para>
            <para>The following groups of flags cannot be used together:</para>
            <list type="bullet">
            <item>
            <term><c>MF_BITMAP</c>, <c>MF_STRING</c>, and <c>MF_OWNERDRAW</c></term>
            </item>
            <item>
            <term><c>MF_CHECKED</c> and <c>MF_UNCHECKED</c></term>
            </item>
            <item>
            <term><c>MF_DISABLED</c>, <c>MF_ENABLED</c>, and <c>MF_GRAYED</c></term>
            </item>
            <item>
            <term><c>MF_MENUBARBREAK</c> and <c>MF_MENUBREAK</c></term>
            </item>
            </list>
            <para>Examples</para>
            <para>For an example, see Adding Lines and Graphs to a Menu.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.AppendMenu(Vanara.PInvoke.HMENU,Vanara.PInvoke.User32.MenuFlags,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            Appends a new item to the end of the specified menu bar, drop-down menu, submenu, or shortcut menu. You can use this function to
            specify the content, appearance, and behavior of the menu item.
            </para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu bar, drop-down menu, submenu, or shortcut menu to be changed.</para>
            </param>
            <param name="uFlags">
            <para>Type: <c>UINT</c></para>
            <para>Controls the appearance and behavior of the new menu item. This parameter can be a combination of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BITMAP 0x00000004L</term>
            <term>Uses a bitmap as the menu item. The lpNewItem parameter contains a handle to the bitmap.</term>
            </item>
            <item>
            <term>MF_CHECKED 0x00000008L</term>
            <term>
            Places a check mark next to the menu item. If the application provides check-mark bitmaps (see SetMenuItemBitmaps, this flag
            displays the check-mark bitmap next to the menu item.
            </term>
            </item>
            <item>
            <term>MF_DISABLED 0x00000002L</term>
            <term>Disables the menu item so that it cannot be selected, but the flag does not gray it.</term>
            </item>
            <item>
            <term>MF_ENABLED 0x00000000L</term>
            <term>Enables the menu item so that it can be selected, and restores it from its grayed state.</term>
            </item>
            <item>
            <term>MF_GRAYED 0x00000001L</term>
            <term>Disables the menu item and grays it so that it cannot be selected.</term>
            </item>
            <item>
            <term>MF_MENUBARBREAK 0x00000020L</term>
            <term>
            Functions the same as the MF_MENUBREAK flag for a menu bar. For a drop-down menu, submenu, or shortcut menu, the new column is
            separated from the old column by a vertical line.
            </term>
            </item>
            <item>
            <term>MF_MENUBREAK 0x00000040L</term>
            <term>
            Places the item on a new line (for a menu bar) or in a new column (for a drop-down menu, submenu, or shortcut menu) without
            separating columns.
            </term>
            </item>
            <item>
            <term>MF_OWNERDRAW 0x00000100L</term>
            <term>
            Specifies that the item is an owner-drawn item. Before the menu is displayed for the first time, the window that owns the menu
            receives a WM_MEASUREITEM message to retrieve the width and height of the menu item. The WM_DRAWITEM message is then sent to the
            window procedure of the owner window whenever the appearance of the menu item must be updated.
            </term>
            </item>
            <item>
            <term>MF_POPUP 0x00000010L</term>
            <term>
            Specifies that the menu item opens a drop-down menu or submenu. The uIDNewItem parameter specifies a handle to the drop-down menu
            or submenu. This flag is used to add a menu name to a menu bar, or a menu item that opens a submenu to a drop-down menu, submenu,
            or shortcut menu.
            </term>
            </item>
            <item>
            <term>MF_SEPARATOR 0x00000800L</term>
            <term>
            Draws a horizontal dividing line. This flag is used only in a drop-down menu, submenu, or shortcut menu. The line cannot be
            grayed, disabled, or highlighted. The lpNewItem and uIDNewItem parameters are ignored.
            </term>
            </item>
            <item>
            <term>MF_STRING 0x00000000L</term>
            <term>Specifies that the menu item is a text string; the lpNewItem parameter is a pointer to the string.</term>
            </item>
            <item>
            <term>MF_UNCHECKED 0x00000000L</term>
            <term>
            Does not place a check mark next to the item (default). If the application supplies check-mark bitmaps (see SetMenuItemBitmaps),
            this flag displays the clear bitmap next to the menu item.
            </term>
            </item>
            </list>
            </param>
            <param name="uIDNewItem">
            <para>Type: <c>UINT_PTR</c></para>
            <para>
            The identifier of the new menu item or, if the uFlags parameter is set to <c>MF_POPUP</c>, a handle to the drop-down menu or submenu.
            </para>
            </param>
            <param name="lpNewItem">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The content of the new menu item. The interpretation of lpNewItem depends on whether the uFlags parameter includes the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BITMAP 0x00000004L</term>
            <term>Contains a bitmap handle.</term>
            </item>
            <item>
            <term>MF_OWNERDRAW 0x00000100L</term>
            <term>
            Contains an application-supplied value that can be used to maintain additional data related to the menu item. The value is in the
            itemData member of the structure pointed to by the lParam parameter of the WM_MEASUREITEM or WM_DRAWITEM message sent when the
            menu is created or its appearance is updated.
            </term>
            </item>
            <item>
            <term>MF_STRING 0x00000000L</term>
            <term>Contains a pointer to a null-terminated string.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error
            information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>The application must call the DrawMenuBar function whenever a menu changes, whether the menu is in a displayed window.</para>
            <para>
            To get keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the WM_MENUCHAR
            message. For more information, see Owner-Drawn Menus and the WM_MENUCHAR Message.
            </para>
            <para>The following groups of flags cannot be used together:</para>
            <list type="bullet">
            <item>
            <term><c>MF_BITMAP</c>, <c>MF_STRING</c>, and <c>MF_OWNERDRAW</c></term>
            </item>
            <item>
            <term><c>MF_CHECKED</c> and <c>MF_UNCHECKED</c></term>
            </item>
            <item>
            <term><c>MF_DISABLED</c>, <c>MF_ENABLED</c>, and <c>MF_GRAYED</c></term>
            </item>
            <item>
            <term><c>MF_MENUBARBREAK</c> and <c>MF_MENUBREAK</c></term>
            </item>
            </list>
            <para>Examples</para>
            <para>For an example, see Adding Lines and Graphs to a Menu.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CheckMenuItem(Vanara.PInvoke.HMENU,System.UInt32,Vanara.PInvoke.User32.MenuFlags)">
            <summary>
            <para>
            [ <c>CheckMenuItem</c> is available for use in the operating systems specified in the Requirements section. It may be altered or
            unavailable in subsequent versions. Instead, use SetMenuItemInfo. ]
            </para>
            <para>Sets the state of the specified menu item's check-mark attribute to either selected or clear.</para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu of interest.</para>
            </param>
            <param name="uIDCheckItem">
            <para>Type: <c>UINT</c></para>
            <para>The menu item whose check-mark attribute is to be set, as determined by the uCheck parameter.</para>
            </param>
            <param name="uCheck">
            <para>Type: <c>UINT</c></para>
            <para>
            The flags that control the interpretation of the uIDCheckItem parameter and the state of the menu item's check-mark attribute.
            This parameter can be a combination of either <c>MF_BYCOMMAND</c>, or <c>MF_BYPOSITION</c> and <c>MF_CHECKED</c> or <c>MF_UNCHECKED</c>.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BYCOMMAND 0x00000000L</term>
            <term>
            Indicates that the uIDCheckItem parameter gives the identifier of the menu item. The MF_BYCOMMAND flag is the default, if neither
            the MF_BYCOMMAND nor MF_BYPOSITION flag is specified.
            </term>
            </item>
            <item>
            <term>MF_BYPOSITION 0x00000400L</term>
            <term>Indicates that the uIDCheckItem parameter gives the zero-based relative position of the menu item.</term>
            </item>
            <item>
            <term>MF_CHECKED 0x00000008L</term>
            <term>Sets the check-mark attribute to the selected state.</term>
            </item>
            <item>
            <term>MF_UNCHECKED 0x00000000L</term>
            <term>Sets the check-mark attribute to the clear state.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>DWORD</c></para>
            <para>
            The return value specifies the previous state of the menu item (either <c>MF_CHECKED</c> or <c>MF_UNCHECKED</c>). If the menu
            item does not exist, the return value is –1.
            </para>
            </returns>
            <remarks>
            <para>An item in a menu bar cannot have a check mark.</para>
            <para>
            The uIDCheckItem parameter identifies a item that opens a submenu or a command item. For a item that opens a submenu, the
            uIDCheckItem parameter must specify the position of the item. For a command item, the uIDCheckItem parameter can specify either
            the item's position or its identifier.
            </para>
            <para>Examples</para>
            <para>For an example, see Simulating Check Boxes in a Menu.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CheckMenuRadioItem(Vanara.PInvoke.HMENU,System.UInt32,System.UInt32,System.UInt32,Vanara.PInvoke.User32.MenuFlags)">
            <summary>
            <para>
            Checks a specified menu item and makes it a radio item. At the same time, the function clears all other menu items in the
            associated group and clears the radio-item type flag for those items.
            </para>
            </summary>
            <param name="hmenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu that contains the group of menu items.</para>
            </param>
            <param name="first">
            <para>Type: <c>UINT</c></para>
            <para>The identifier or position of the first menu item in the group.</para>
            </param>
            <param name="last">
            <para>Type: <c>UINT</c></para>
            <para>The identifier or position of the last menu item in the group.</para>
            </param>
            <param name="check">
            <para>Type: <c>UINT</c></para>
            <para>The identifier or position of the menu item to check.</para>
            </param>
            <param name="flags">
            <para>Type: <c>UINT</c></para>
            <para>
            Indicates the meaning of idFirst, idLast, and idCheck. If this parameter is <c>MF_BYCOMMAND</c>, the other parameters specify
            menu item identifiers. If it is <c>MF_BYPOSITION</c>, the other parameters specify the menu item positions.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
            </returns>
            <remarks>
            <para>
            The <c>CheckMenuRadioItem</c> function sets the <c>MFT_RADIOCHECK</c> type flag and the <c>MFS_CHECKED</c> state for the item
            specified by idCheck and, at the same time, clears both flags for all other items in the group. The selected item is displayed
            using a bullet bitmap instead of a check-mark bitmap.
            </para>
            <para>For more information about menu item type and state flags, see the MENUITEMINFO structure.</para>
            <para>Examples</para>
            <para>For an example, see Example of Example of Using Custom Checkmark Bitmaps.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateMenu">
            <summary>
            <para>
            Creates a menu. The menu is initially empty, but it can be filled with menu items by using the InsertMenuItem, AppendMenu, and
            InsertMenu functions.
            </para>
            </summary>
            <returns>
            <para>Type: <c>HMENU</c></para>
            <para>If the function succeeds, the return value is a handle to the newly created menu.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Resources associated with a menu that is assigned to a window are freed automatically. If the menu is not assigned to a window,
            an application must free system resources associated with the menu before closing. An application frees menu resources by calling
            the DestroyMenu function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreatePopupMenu">
            <summary>
            <para>
            Creates a drop-down menu, submenu, or shortcut menu. The menu is initially empty. You can insert or append menu items by using
            the InsertMenuItem function. You can also use the InsertMenu function to insert menu items and the AppendMenu function to append
            menu items.
            </para>
            </summary>
            <returns>
            <para>Type: <c>HMENU</c></para>
            <para>If the function succeeds, the return value is a handle to the newly created menu.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The application can add the new menu to an existing menu, or it can display a shortcut menu by calling the TrackPopupMenuEx or
            TrackPopupMenu functions.
            </para>
            <para>
            Resources associated with a menu that is assigned to a window are freed automatically. If the menu is not assigned to a window,
            an application must free system resources associated with the menu before closing. An application frees menu resources by calling
            the DestroyMenu function.
            </para>
            <para>Examples</para>
            <para>For an example, see Adding Lines and Graphs to a Menu.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DeleteMenu(Vanara.PInvoke.HMENU,System.UInt32,Vanara.PInvoke.User32.MenuFlags)">
            <summary>
            <para>
            Deletes an item from the specified menu. If the menu item opens a menu or submenu, this function destroys the handle to the menu
            or submenu and frees the memory used by the menu or submenu.
            </para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu to be changed.</para>
            </param>
            <param name="uPosition">
            <para>Type: <c>UINT</c></para>
            <para>The menu item to be deleted, as determined by the uFlags parameter.</para>
            </param>
            <param name="uFlags">
            <para>Type: <c>UINT</c></para>
            <para>Indicates how the uPosition parameter is interpreted. This parameter must be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BYCOMMAND 0x00000000L</term>
            <term>
            Indicates that uPosition gives the identifier of the menu item. The MF_BYCOMMAND flag is the default flag if neither the
            MF_BYCOMMAND nor MF_BYPOSITION flag is specified.
            </term>
            </item>
            <item>
            <term>MF_BYPOSITION 0x00000400L</term>
            <term>Indicates that uPosition gives the zero-based relative position of the menu item.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>The application must call the DrawMenuBar function whenever a menu changes, whether the menu is in a displayed window.</para>
            <para>Examples</para>
            <para>For an example, see Example of a Clipboard Viewer.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DestroyMenu(Vanara.PInvoke.HMENU)">
            <summary>
            <para>Destroys the specified menu and frees any memory that the menu occupies.</para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu to be destroyed.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Before closing, an application must use the <c>DestroyMenu</c> function to destroy a menu not assigned to a window. A menu that
            is assigned to a window is automatically destroyed when the application closes.
            </para>
            <para><c>DestroyMenu</c> is recursive, that is, it will destroy the menu and all its submenus.</para>
            <para>Examples</para>
            <para>For an example, see Displaying a Shortcut Menu.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DrawMenuBar(Vanara.PInvoke.HWND)">
            <summary>
            <para>
            Redraws the menu bar of the specified window. If the menu bar changes after the system has created the window, this function must
            be called to draw the changed menu bar.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose menu bar is to be redrawn.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnableMenuItem(Vanara.PInvoke.HMENU,System.UInt32,Vanara.PInvoke.User32.MenuFlags)">
            <summary>
            <para>Enables, disables, or grays the specified menu item.</para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu.</para>
            </param>
            <param name="uIDEnableItem">
            <para>Type: <c>UINT</c></para>
            <para>
            The menu item to be enabled, disabled, or grayed, as determined by the uEnable parameter. This parameter specifies an item in a
            menu bar, menu, or submenu.
            </para>
            </param>
            <param name="uEnable">
            <para>Type: <c>UINT</c></para>
            <para>
            Controls the interpretation of the uIDEnableItem parameter and indicate whether the menu item is enabled, disabled, or grayed.
            This parameter must be a combination of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BYCOMMAND 0x00000000L</term>
            <term>
            Indicates that uIDEnableItem gives the identifier of the menu item. If neither the MF_BYCOMMAND nor MF_BYPOSITION flag is
            specified, the MF_BYCOMMAND flag is the default flag.
            </term>
            </item>
            <item>
            <term>MF_BYPOSITION 0x00000400L</term>
            <term>Indicates that uIDEnableItem gives the zero-based relative position of the menu item.</term>
            </item>
            <item>
            <term>MF_DISABLED 0x00000002L</term>
            <term>Indicates that the menu item is disabled, but not grayed, so it cannot be selected.</term>
            </item>
            <item>
            <term>MF_ENABLED 0x00000000L</term>
            <term>Indicates that the menu item is enabled and restored from a grayed state so that it can be selected.</term>
            </item>
            <item>
            <term>MF_GRAYED 0x00000001L</term>
            <term>Indicates that the menu item is disabled and grayed so that it cannot be selected.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            The return value specifies the previous state of the menu item (it is either <c>MF_DISABLED</c>, <c>MF_ENABLED</c>, or
            <c>MF_GRAYED</c>). If the menu item does not exist, the return value is -1.
            </para>
            </returns>
            <remarks>
            <para>
            An application must use the <c>MF_BYPOSITION</c> flag to specify the correct menu handle. If the menu handle to the menu bar is
            specified, the top-level menu item (an item in the menu bar) is affected. To set the state of an item in a drop-down menu or
            submenu by position, an application must specify a handle to the drop-down menu or submenu.
            </para>
            <para>
            When an application specifies the <c>MF_BYCOMMAND</c> flag, the system checks all items that open submenus in the menu identified
            by the specified menu handle. Therefore, unless duplicate menu items are present, specifying the menu handle to the menu bar is sufficient.
            </para>
            <para>
            The InsertMenu, InsertMenuItem, LoadMenuIndirect, ModifyMenu, and SetMenuItemInfo functions can also set the state (enabled,
            disabled, or grayed) of a menu item.
            </para>
            <para>When you change a window menu, the menu bar is not immediately updated. To force the update, call DrawMenuBar.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EndMenu">
            <summary>
            <para>Ends the calling thread's active menu.</para>
            </summary>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>If a platform does not support <c>EndMenu</c>, send the owner of the active menu a WM_CANCELMODE message.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMenu(Vanara.PInvoke.HWND)">
            <summary>
            <para>Retrieves a handle to the menu assigned to the specified window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose menu handle is to be retrieved.</para>
            </param>
            <returns>
            <para>Type: <c>HMENU</c></para>
            <para>
            The return value is a handle to the menu. If the specified window has no menu, the return value is <c>NULL</c>. If the window is
            a child window, the return value is undefined.
            </para>
            </returns>
            <remarks>
            <para>
            <c>GetMenu</c> does not work on floating menu bars. Floating menu bars are custom controls that mimic standard menus; they are
            not menus. To get the handle on a floating menu bar, use the Active Accessibility APIs.
            </para>
            <para>Examples</para>
            <para>For an example, see Adding Lines and Graphs to a Menu.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMenuBarInfo(Vanara.PInvoke.HWND,System.Int32,System.Int32,Vanara.PInvoke.User32.MENUBARINFO@)">
            <summary>
            <para>Retrieves information about the specified menu bar.</para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window (menu bar) whose information is to be retrieved.</para>
            </param>
            <param name="idObject">
            <para>Type: <c>LONG</c></para>
            <para>The menu object. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>OBJID_CLIENT ((LONG)0xFFFFFFFC)</term>
            <term>The popup menu associated with the window.</term>
            </item>
            <item>
            <term>OBJID_MENU ((LONG)0xFFFFFFFD)</term>
            <term>The menu bar associated with the window (see the GetMenu function).</term>
            </item>
            <item>
            <term>OBJID_SYSMENU ((LONG)0xFFFFFFFF)</term>
            <term>The system menu associated with the window (see the GetSystemMenu function).</term>
            </item>
            </list>
            </param>
            <param name="idItem">
            <para>Type: <c>LONG</c></para>
            <para>
            The item for which to retrieve information. If this parameter is zero, the function retrieves information about the menu itself.
            If this parameter is 1, the function retrieves information about the first item on the menu, and so on.
            </para>
            </param>
            <param name="pmbi">
            <para>Type: <c>PMENUBARINFO</c></para>
            <para>
            A pointer to a MENUBARINFO structure that receives the information. Note that you must set the <c>cbSize</c> member to before
            calling this function.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMenuCheckMarkDimensions">
            <summary>
            <para>
            Retrieves the dimensions of the default check-mark bitmap. The system displays this bitmap next to selected menu items. Before
            calling the SetMenuItemBitmaps function to replace the default check-mark bitmap for a menu item, an application must determine
            the correct bitmap size by calling <c>GetMenuCheckMarkDimensions</c>.
            </para>
            <para>
            <c>Note</c> The <c>GetMenuCheckMarkDimensions</c> function is included only for compatibility with 16-bit versions of Windows.
            Applications should use the GetSystemMetrics function with the <c>CXMENUCHECK</c> and <c>CYMENUCHECK</c> values to retrieve the
            bitmap dimensions.
            </para>
            </summary>
            <returns>
            <para>Type: <c>LONG</c></para>
            <para>
            The return value specifies the height and width, in pixels, of the default check-mark bitmap. The high-order word contains the
            height; the low-order word contains the width.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMenuContextHelpId(Vanara.PInvoke.HMENU)">
            <summary>Retrieves the Help context identifier associated with the specified menu.</summary>
            <param name="Arg1">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu for which the Help context identifier is to be retrieved.</para>
            </param>
            <returns>
            <para>Type: <c>DWORD</c></para>
            <para>Returns the Help context identifier if the menu has one, or zero otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMenuDefaultItem(Vanara.PInvoke.HMENU,System.Boolean,Vanara.PInvoke.User32.GetMenuDefaultItemFlags)">
            <summary>
            <para>Determines the default menu item on the specified menu.</para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu for which to retrieve the default menu item.</para>
            </param>
            <param name="fByPos">
            <para>Type: <c>UINT</c></para>
            <para>
            Indicates whether to retrieve the menu item's identifier or its position. If this parameter is <c>FALSE</c>, the identifier is
            returned. Otherwise, the position is returned.
            </para>
            </param>
            <param name="gmdiFlags">
            <para>Type: <c>UINT</c></para>
            <para>Indicates how the function should search for menu items. This parameter can be zero or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>GMDI_GOINTOPOPUPS 0x0002L</term>
            <term>
            If the default item is one that opens a submenu, the function is to search recursively in the corresponding submenu. If the
            submenu has no default item, the return value identifies the item that opens the submenu. By default, the function returns the
            first default item on the specified menu, regardless of whether it is an item that opens a submenu.
            </term>
            </item>
            <item>
            <term>GMDI_USEDISABLED 0x0001L</term>
            <term>The function is to return a default item, even if it is disabled. By default, the function skips disabled or grayed items.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>If the function succeeds, the return value is the identifier or position of the menu item.</para>
            <para>If the function fails, the return value is -1. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMenuInfo(Vanara.PInvoke.HMENU,Vanara.PInvoke.User32.MENUINFO@)">
            <summary>
            <para>Retrieves information about a specified menu.</para>
            </summary>
            <param name="hmenu">A handle on a menu.</param>
            <param name="lpcmi">
            A pointer to a MENUINFO structure containing information for the menu. Note that you must set the cbSize member to
            sizeof(MENUINFO) before calling this function.
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMenuItemCount(Vanara.PInvoke.HMENU)">
            <summary>
            <para>Determines the number of items in the specified menu.</para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu to be examined.</para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>If the function succeeds, the return value specifies the number of items in the menu.</para>
            <para>If the function fails, the return value is -1. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMenuItemID(Vanara.PInvoke.HMENU,System.Int32)">
            <summary>
            <para>Retrieves the menu item identifier of a menu item located at the specified position in a menu.</para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu that contains the item whose identifier is to be retrieved.</para>
            </param>
            <param name="nPos">
            <para>Type: <c>int</c></para>
            <para>The zero-based relative position of the menu item whose identifier is to be retrieved.</para>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>
            The return value is the identifier of the specified menu item. If the menu item identifier is <c>NULL</c> or if the specified
            item opens a submenu, the return value is -1.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMenuItemInfo(Vanara.PInvoke.HMENU,System.UInt32,System.Boolean,Vanara.PInvoke.User32.MENUITEMINFO@)">
            <summary>
            <para>Retrieves information about a menu item.</para>
            </summary>
            <param name="hmenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu that contains the menu item.</para>
            </param>
            <param name="item">
            <para>Type: <c>UINT</c></para>
            <para>
            The identifier or position of the menu item to get information about. The meaning of this parameter depends on the value of fByPosition.
            </para>
            </param>
            <param name="fByPosition">
            <para>Type: <c>BOOL</c></para>
            <para>
            The meaning of uItem. If this parameter is <c>FALSE</c>, uItem is a menu item identifier. Otherwise, it is a menu item position.
            See Accessing Menu Items Programmatically for more information.
            </para>
            </param>
            <param name="lpmii">
            <para>Type: <c>LPMENUITEMINFO</c></para>
            <para>
            A pointer to a MENUITEMINFO structure that specifies the information to retrieve and receives information about the menu item.
            Note that you must set the <c>cbSize</c> member to before calling this function.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
            </returns>
            <remarks>
            <para>
            To retrieve a menu item of type <c>MFT_STRING</c>, first find the size of the string by setting the <c>dwTypeData</c> member of
            MENUITEMINFO to <c>NULL</c> and then calling <c>GetMenuItemInfo</c>. The value of <c>cch</c>+1 is the size needed. Then allocate
            a buffer of this size, place the pointer to the buffer in <c>dwTypeData</c>, increment <c>cch</c> by one, and then call
            <c>GetMenuItemInfo</c> once again to fill the buffer with the string.
            </para>
            <para>
            If the retrieved menu item is of some other type, then <c>GetMenuItemInfo</c> sets the <c>dwTypeData</c> member to a value whose
            type is specified by the <c>fType</c><c>fType</c> member and sets <c>cch</c> to 0.
            </para>
            <para>Examples</para>
            <para>For an example, see Example of Owner-Drawn Menu Items.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMenuItemRect(Vanara.PInvoke.HWND,Vanara.PInvoke.HMENU,System.UInt32,Vanara.PInvoke.RECT@)">
            <summary>
            <para>Retrieves the bounding rectangle for the specified menu item.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window containing the menu.</para>
            <para>If this value is <c>NULL</c> and the hMenu parameter represents a popup menu, the function will find the menu window.</para>
            </param>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to a menu.</para>
            </param>
            <param name="uItem">
            <para>Type: <c>UINT</c></para>
            <para>The zero-based position of the menu item.</para>
            </param>
            <param name="lprcItem">
            <para>Type: <c>LPRECT</c></para>
            <para>A pointer to a RECT structure that receives the bounding rectangle of the specified menu item expressed in screen coordinates.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
            </returns>
            <remarks>
            <para>
            In order for the returned rectangle to be meaningful, the menu must be popped up if a popup menu or attached to a window if a
            menu bar. Menu item positions are not determined until the menu is displayed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMenuState(Vanara.PInvoke.HMENU,System.UInt32,Vanara.PInvoke.User32.MenuFlags)">
            <summary>
            <para>
            Retrieves the menu flags associated with the specified menu item. If the menu item opens a submenu, this function also returns
            the number of items in the submenu.
            </para>
            <para>
            <c>Note</c> The <c>GetMenuState</c> function has been superseded by the GetMenuItemInfo. You can still use <c>GetMenuState</c>,
            however, if you do not need any of the extended features of <c>GetMenuItemInfo</c>.
            </para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu that contains the menu item whose flags are to be retrieved.</para>
            </param>
            <param name="uId">
            <para>Type: <c>UINT</c></para>
            <para>The menu item for which the menu flags are to be retrieved, as determined by the uFlags parameter.</para>
            </param>
            <param name="uFlags">
            <para>Type: <c>UINT</c></para>
            <para>Indicates how the uId parameter is interpreted. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BYCOMMAND 0x00000000L</term>
            <term>
            Indicates that the uId parameter gives the identifier of the menu item. The MF_BYCOMMAND flag is the default if neither the
            MF_BYCOMMAND nor MF_BYPOSITION flag is specified.
            </term>
            </item>
            <item>
            <term>MF_BYPOSITION 0x00000400L</term>
            <term>Indicates that the uId parameter gives the zero-based relative position of the menu item.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>If the specified item does not exist, the return value is -1.</para>
            <para>
            If the menu item opens a submenu, the low-order byte of the return value contains the menu flags associated with the item, and
            the high-order byte contains the number of items in the submenu opened by the item.
            </para>
            <para>
            Otherwise, the return value is a mask (Bitwise OR) of the menu flags. Following are the menu flags associated with the menu item.
            </para>
            <list type="table">
            <listheader>
            <term>Return code/value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MF_CHECKED 0x00000008L</term>
            <term>A check mark is placed next to the item (for drop-down menus, submenus, and shortcut menus only).</term>
            </item>
            <item>
            <term>MF_DISABLED 0x00000002L</term>
            <term>The item is disabled.</term>
            </item>
            <item>
            <term>MF_GRAYED 0x00000001L</term>
            <term>The item is disabled and grayed.</term>
            </item>
            <item>
            <term>MF_HILITE 0x00000080L</term>
            <term>The item is highlighted.</term>
            </item>
            <item>
            <term>MF_MENUBARBREAK 0x00000020L</term>
            <term>
            This is the same as the MF_MENUBREAK flag, except for drop-down menus, submenus, and shortcut menus, where the new column is
            separated from the old column by a vertical line.
            </term>
            </item>
            <item>
            <term>MF_MENUBREAK 0x00000040L</term>
            <term>
            The item is placed on a new line (for menu bars) or in a new column (for drop-down menus, submenus, and shortcut menus) without
            separating columns.
            </term>
            </item>
            <item>
            <term>MF_OWNERDRAW 0x00000100L</term>
            <term>The item is owner-drawn.</term>
            </item>
            <item>
            <term>MF_POPUP 0x00000010L</term>
            <term>Menu item is a submenu.</term>
            </item>
            <item>
            <term>MF_SEPARATOR 0x00000800L</term>
            <term>There is a horizontal dividing line (for drop-down menus, submenus, and shortcut menus only).</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            It is possible to test an item for a flag value of <c>MF_ENABLED</c>, <c>MF_STRING</c>, <c>MF_UNCHECKED</c>, or
            <c>MF_UNHILITE</c>. However, since these values equate to zero you must use an expression to test for them.
            </para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Expression to test for the flag</term>
            </listheader>
            <item>
            <term>MF_ENABLED</term>
            <term/>
            </item>
            <item>
            <term>MF_STRING</term>
            <term/>
            </item>
            <item>
            <term>MF_UNCHECKED</term>
            <term/>
            </item>
            <item>
            <term>MF_UNHILITE</term>
            <term/>
            </item>
            </list>
            <para>Examples</para>
            <para>For an example, see Simulating Check Boxes in a Menu.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMenuString(Vanara.PInvoke.HMENU,System.UInt32,System.Text.StringBuilder,System.Int32,Vanara.PInvoke.User32.MenuFlags)">
            <summary>
            <para>Copies the text string of the specified menu item into the specified buffer.</para>
            <para>
            <c>Note</c> The <c>GetMenuString</c> function has been superseded. Use the GetMenuItemInfo function to retrieve the menu item text.
            </para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu.</para>
            </param>
            <param name="uIDItem">
            <para>Type: <c>UINT</c></para>
            <para>The menu item to be changed, as determined by the uFlag parameter.</para>
            </param>
            <param name="lpString">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            The buffer that receives the null-terminated string. If the string is as long or longer than lpString, the string is truncated
            and the terminating null character is added. If lpString is <c>NULL</c>, the function returns the length of the menu string.
            </para>
            </param>
            <param name="cchMax">
            <para>Type: <c>int</c></para>
            <para>
            The maximum length, in characters, of the string to be copied. If the string is longer than the maximum specified in the
            nMaxCount parameter, the extra characters are truncated. If nMaxCount is 0, the function returns the length of the menu string.
            </para>
            </param>
            <param name="flags">
            <para>Type: <c>UINT</c></para>
            <para>Indicates how the uIDItem parameter is interpreted. This parameter must be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BYCOMMAND 0x00000000L</term>
            <term>
            Indicates that uIDItem gives the identifier of the menu item. If neither the MF_BYCOMMAND nor MF_BYPOSITION flag is specified,
            the MF_BYCOMMAND flag is the default flag.
            </term>
            </item>
            <item>
            <term>MF_BYPOSITION 0x00000400L</term>
            <term>Indicates that uIDItem gives the zero-based relative position of the menu item.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            If the function succeeds, the return value specifies the number of characters copied to the buffer, not including the terminating
            null character.
            </para>
            <para>If the function fails, the return value is zero.</para>
            <para>If the specified item is not of type <c>MIIM_STRING</c> or <c>MFT_STRING</c>, then the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            The nMaxCount parameter must be one larger than the number of characters in the text string to accommodate the terminating null character.
            </para>
            <para>If nMaxCount is 0, the function returns the length of the menu string.</para>
            <para>Security Warning</para>
            <para>
            The lpString parameter is a <c>TCHAR</c> buffer, and nMaxCount is the length of the menu string in characters. Sizing these
            parameters incorrectly can cause truncation of the string, leading to possible loss of data.
            </para>
            <para>Examples</para>
            <para>For an example, see Creating User Editable Accelerators.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetSubMenu(Vanara.PInvoke.HMENU,System.Int32)">
            <summary>
            <para>Retrieves a handle to the drop-down menu or submenu activated by the specified menu item.</para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu.</para>
            </param>
            <param name="nPos">
            <para>Type: <c>int</c></para>
            <para>The zero-based relative position in the specified menu of an item that activates a drop-down menu or submenu.</para>
            </param>
            <returns>
            <para>Type: <c>HMENU</c></para>
            <para>
            If the function succeeds, the return value is a handle to the drop-down menu or submenu activated by the menu item. If the menu
            item does not activate a drop-down menu or submenu, the return value is <c>NULL</c>.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetSystemMenu(Vanara.PInvoke.HWND,System.Boolean)">
            <summary>
            <para>
            Enables the application to access the window menu (also known as the system menu or the control menu) for copying and modifying.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that will own a copy of the window menu.</para>
            </param>
            <param name="bRevert">
            <para>Type: <c>BOOL</c></para>
            <para>
            The action to be taken. If this parameter is <c>FALSE</c>, <c>GetSystemMenu</c> returns a handle to the copy of the window menu
            currently in use. The copy is initially identical to the window menu, but it can be modified. If this parameter is <c>TRUE</c>,
            <c>GetSystemMenu</c> resets the window menu back to the default state. The previous window menu, if any, is destroyed.
            </para>
            </param>
            <returns>
            <para>Type: <c>HMENU</c></para>
            <para>
            If the bRevert parameter is <c>FALSE</c>, the return value is a handle to a copy of the window menu. If the bRevert parameter is
            <c>TRUE</c>, the return value is <c>NULL</c>.
            </para>
            </returns>
            <remarks>
            <para>
            Any window that does not use the <c>GetSystemMenu</c> function to make its own copy of the window menu receives the standard
            window menu.
            </para>
            <para>
            The window menu initially contains items with various identifier values, such as <c>SC_CLOSE</c>, <c>SC_MOVE</c>, and <c>SC_SIZE</c>.
            </para>
            <para>Menu items on the window menu send WM_SYSCOMMAND messages.</para>
            <para>
            All predefined window menu items have identifier numbers greater than 0xF000. If an application adds commands to the window menu,
            it should use identifier numbers less than 0xF000.
            </para>
            <para>
            The system automatically grays items on the standard window menu, depending on the situation. The application can perform its own
            checking or graying by responding to the WM_INITMENU message that is sent before any menu is displayed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.HiliteMenuItem(Vanara.PInvoke.HWND,Vanara.PInvoke.HMENU,System.UInt32,Vanara.PInvoke.User32.MenuFlags)">
            <summary>
            <para>Adds or removes highlighting from an item in a menu bar.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that contains the menu.</para>
            </param>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu bar that contains the item.</para>
            </param>
            <param name="uIDHiliteItem">
            <para>Type: <c>UINT</c></para>
            <para>
            The menu item. This parameter is either the identifier of the menu item or the offset of the menu item in the menu bar, depending
            on the value of the uHilite parameter.
            </para>
            </param>
            <param name="uHilite">
            <para>Type: <c>UINT</c></para>
            <para>
            Controls the interpretation of the uItemHilite parameter and indicates whether the menu item is highlighted. This parameter must
            be a combination of either <c>MF_BYCOMMAND</c> or <c>MF_BYPOSITION</c> and <c>MF_HILITE</c> or <c>MF_UNHILITE</c>.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BYCOMMAND 0x00000000L</term>
            <term>Indicates that uItemHilite gives the identifier of the menu item.</term>
            </item>
            <item>
            <term>MF_BYPOSITION 0x00000400L</term>
            <term>Indicates that uItemHilite gives the zero-based relative position of the menu item.</term>
            </item>
            <item>
            <term>MF_HILITE 0x00000080L</term>
            <term>Highlights the menu item. If this flag is not specified, the highlighting is removed from the item.</term>
            </item>
            <item>
            <term>MF_UNHILITE 0x00000000L</term>
            <term>Removes highlighting from the menu item.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the menu item is set to the specified highlight state, the return value is nonzero.</para>
            <para>If the menu item is not set to the specified highlight state, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            The <c>MF_HILITE</c> and <c>MF_UNHILITE</c> flags can be used only with the <c>HiliteMenuItem</c> function; they cannot be used
            with the ModifyMenu function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.InsertMenu(Vanara.PInvoke.HMENU,System.UInt32,Vanara.PInvoke.User32.MenuFlags,System.IntPtr,System.IntPtr)">
            <summary>
            <para>Inserts a new menu item into a menu, moving other items down the menu.</para>
            <para>
            <c>Note</c> The <c>InsertMenu</c> function has been superseded by the InsertMenuItem function. You can still use
            <c>InsertMenu</c>, however, if you do not need any of the extended features of <c>InsertMenuItem</c>.
            </para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu to be changed.</para>
            </param>
            <param name="uPosition">
            <para>Type: <c>UINT</c></para>
            <para>The menu item before which the new menu item is to be inserted, as determined by the uFlags parameter.</para>
            </param>
            <param name="uFlags">
            <para>Type: <c>UINT</c></para>
            <para>
            Controls the interpretation of the uPosition parameter and the content, appearance, and behavior of the new menu item. This
            parameter must include one of the following required values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BYCOMMAND 0x00000000L</term>
            <term>
            Indicates that the uPosition parameter gives the identifier of the menu item. The MF_BYCOMMAND flag is the default if neither the
            MF_BYCOMMAND nor MF_BYPOSITION flag is specified.
            </term>
            </item>
            <item>
            <term>MF_BYPOSITION 0x00000400L</term>
            <term>
            Indicates that the uPosition parameter gives the zero-based relative position of the new menu item. If uPosition is -1, the new
            menu item is appended to the end of the menu.
            </term>
            </item>
            </list>
            <para>The parameter must also include at least one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BITMAP 0x00000004L</term>
            <term>Uses a bitmap as the menu item. The lpNewItem parameter contains a handle to the bitmap.</term>
            </item>
            <item>
            <term>MF_CHECKED 0x00000008L</term>
            <term>
            Places a check mark next to the menu item. If the application provides check-mark bitmaps (see SetMenuItemBitmaps), this flag
            displays the check-mark bitmap next to the menu item.
            </term>
            </item>
            <item>
            <term>MF_DISABLED 0x00000002L</term>
            <term>Disables the menu item so that it cannot be selected, but does not gray it.</term>
            </item>
            <item>
            <term>MF_ENABLED 0x00000000L</term>
            <term>Enables the menu item so that it can be selected and restores it from its grayed state.</term>
            </item>
            <item>
            <term>MF_GRAYED 0x00000001L</term>
            <term>Disables the menu item and grays it so it cannot be selected.</term>
            </item>
            <item>
            <term>MF_MENUBARBREAK 0x00000020L</term>
            <term>
            Functions the same as the MF_MENUBREAK flag for a menu bar. For a drop-down menu, submenu, or shortcut menu, the new column is
            separated from the old column by a vertical line.
            </term>
            </item>
            <item>
            <term>MF_MENUBREAK 0x00000040L</term>
            <term>
            Places the item on a new line (for menu bars) or in a new column (for a drop-down menu, submenu, or shortcut menu) without
            separating columns.
            </term>
            </item>
            <item>
            <term>MF_OWNERDRAW 0x00000100L</term>
            <term>
            Specifies that the item is an owner-drawn item. Before the menu is displayed for the first time, the window that owns the menu
            receives a WM_MEASUREITEM message to retrieve the width and height of the menu item. The WM_DRAWITEM message is then sent to the
            window procedure of the owner window whenever the appearance of the menu item must be updated.
            </term>
            </item>
            <item>
            <term>MF_POPUP 0x00000010L</term>
            <term>
            Specifies that the menu item opens a drop-down menu or submenu. The uIDNewItem parameter specifies a handle to the drop-down menu
            or submenu. This flag is used to add a menu name to a menu bar or a menu item that opens a submenu to a drop-down menu, submenu,
            or shortcut menu.
            </term>
            </item>
            <item>
            <term>MF_SEPARATOR 0x00000800L</term>
            <term>
            Draws a horizontal dividing line. This flag is used only in a drop-down menu, submenu, or shortcut menu. The line cannot be
            grayed, disabled, or highlighted. The lpNewItem and uIDNewItem parameters are ignored.
            </term>
            </item>
            <item>
            <term>MF_STRING 0x00000000L</term>
            <term>Specifies that the menu item is a text string; the lpNewItem parameter is a pointer to the string.</term>
            </item>
            <item>
            <term>MF_UNCHECKED 0x00000000L</term>
            <term>
            Does not place a check mark next to the menu item (default). If the application supplies check-mark bitmaps (see the
            SetMenuItemBitmaps function), this flag displays the clear bitmap next to the menu item.
            </term>
            </item>
            </list>
            </param>
            <param name="uIDNewItem">
            <para>Type: <c>UINT_PTR</c></para>
            <para>
            The identifier of the new menu item or, if the uFlags parameter has the <c>MF_POPUP</c> flag set, a handle to the drop-down menu
            or submenu.
            </para>
            </param>
            <param name="lpNewItem">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The content of the new menu item. The interpretation of lpNewItem depends on whether the uFlags parameter includes the
            <c>MF_BITMAP</c>, <c>MF_OWNERDRAW</c>, or <c>MF_STRING</c> flag, as follows.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BITMAP 0x00000004L</term>
            <term>Contains a bitmap handle.</term>
            </item>
            <item>
            <term>MF_OWNERDRAW 0x00000100L</term>
            <term>
            Contains an application-supplied value that can be used to maintain additional data related to the menu item. The value is in the
            itemData member of the structure pointed to by the lParam parameter of the WM_MEASUREITEM or WM_DRAWITEM message sent when the
            menu item is created or its appearance is updated.
            </term>
            </item>
            <item>
            <term>MF_STRING 0x00000000L</term>
            <term>Contains a pointer to a null-terminated string (the default).</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>The application must call the DrawMenuBar function whenever a menu changes, whether the menu is in a displayed window.</para>
            <para>The following groups of flags cannot be used together:</para>
            <list type="bullet">
            <item>
            <term><c>MF_BYCOMMAND</c> and <c>MF_BYPOSITION</c></term>
            </item>
            <item>
            <term><c>MF_DISABLED</c>, <c>MF_ENABLED</c>, and <c>MF_GRAYED</c></term>
            </item>
            <item>
            <term><c>MF_BITMAP</c>, <c>MF_STRING</c>, <c>MF_OWNERDRAW</c>, and <c>MF_SEPARATOR</c></term>
            </item>
            <item>
            <term><c>MF_MENUBARBREAK</c> and <c>MF_MENUBREAK</c></term>
            </item>
            <item>
            <term><c>MF_CHECKED</c> and <c>MF_UNCHECKED</c></term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.InsertMenu(Vanara.PInvoke.HMENU,System.UInt32,Vanara.PInvoke.User32.MenuFlags,System.IntPtr,System.String)">
            <summary>
            <para>Inserts a new menu item into a menu, moving other items down the menu.</para>
            <para>
            <c>Note</c> The <c>InsertMenu</c> function has been superseded by the InsertMenuItem function. You can still use
            <c>InsertMenu</c>, however, if you do not need any of the extended features of <c>InsertMenuItem</c>.
            </para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu to be changed.</para>
            </param>
            <param name="uPosition">
            <para>Type: <c>UINT</c></para>
            <para>The menu item before which the new menu item is to be inserted, as determined by the uFlags parameter.</para>
            </param>
            <param name="uFlags">
            <para>Type: <c>UINT</c></para>
            <para>
            Controls the interpretation of the uPosition parameter and the content, appearance, and behavior of the new menu item. This
            parameter must include one of the following required values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BYCOMMAND 0x00000000L</term>
            <term>
            Indicates that the uPosition parameter gives the identifier of the menu item. The MF_BYCOMMAND flag is the default if neither the
            MF_BYCOMMAND nor MF_BYPOSITION flag is specified.
            </term>
            </item>
            <item>
            <term>MF_BYPOSITION 0x00000400L</term>
            <term>
            Indicates that the uPosition parameter gives the zero-based relative position of the new menu item. If uPosition is -1, the new
            menu item is appended to the end of the menu.
            </term>
            </item>
            </list>
            <para>The parameter must also include at least one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BITMAP 0x00000004L</term>
            <term>Uses a bitmap as the menu item. The lpNewItem parameter contains a handle to the bitmap.</term>
            </item>
            <item>
            <term>MF_CHECKED 0x00000008L</term>
            <term>
            Places a check mark next to the menu item. If the application provides check-mark bitmaps (see SetMenuItemBitmaps), this flag
            displays the check-mark bitmap next to the menu item.
            </term>
            </item>
            <item>
            <term>MF_DISABLED 0x00000002L</term>
            <term>Disables the menu item so that it cannot be selected, but does not gray it.</term>
            </item>
            <item>
            <term>MF_ENABLED 0x00000000L</term>
            <term>Enables the menu item so that it can be selected and restores it from its grayed state.</term>
            </item>
            <item>
            <term>MF_GRAYED 0x00000001L</term>
            <term>Disables the menu item and grays it so it cannot be selected.</term>
            </item>
            <item>
            <term>MF_MENUBARBREAK 0x00000020L</term>
            <term>
            Functions the same as the MF_MENUBREAK flag for a menu bar. For a drop-down menu, submenu, or shortcut menu, the new column is
            separated from the old column by a vertical line.
            </term>
            </item>
            <item>
            <term>MF_MENUBREAK 0x00000040L</term>
            <term>
            Places the item on a new line (for menu bars) or in a new column (for a drop-down menu, submenu, or shortcut menu) without
            separating columns.
            </term>
            </item>
            <item>
            <term>MF_OWNERDRAW 0x00000100L</term>
            <term>
            Specifies that the item is an owner-drawn item. Before the menu is displayed for the first time, the window that owns the menu
            receives a WM_MEASUREITEM message to retrieve the width and height of the menu item. The WM_DRAWITEM message is then sent to the
            window procedure of the owner window whenever the appearance of the menu item must be updated.
            </term>
            </item>
            <item>
            <term>MF_POPUP 0x00000010L</term>
            <term>
            Specifies that the menu item opens a drop-down menu or submenu. The uIDNewItem parameter specifies a handle to the drop-down menu
            or submenu. This flag is used to add a menu name to a menu bar or a menu item that opens a submenu to a drop-down menu, submenu,
            or shortcut menu.
            </term>
            </item>
            <item>
            <term>MF_SEPARATOR 0x00000800L</term>
            <term>
            Draws a horizontal dividing line. This flag is used only in a drop-down menu, submenu, or shortcut menu. The line cannot be
            grayed, disabled, or highlighted. The lpNewItem and uIDNewItem parameters are ignored.
            </term>
            </item>
            <item>
            <term>MF_STRING 0x00000000L</term>
            <term>Specifies that the menu item is a text string; the lpNewItem parameter is a pointer to the string.</term>
            </item>
            <item>
            <term>MF_UNCHECKED 0x00000000L</term>
            <term>
            Does not place a check mark next to the menu item (default). If the application supplies check-mark bitmaps (see the
            SetMenuItemBitmaps function), this flag displays the clear bitmap next to the menu item.
            </term>
            </item>
            </list>
            </param>
            <param name="uIDNewItem">
            <para>Type: <c>UINT_PTR</c></para>
            <para>
            The identifier of the new menu item or, if the uFlags parameter has the <c>MF_POPUP</c> flag set, a handle to the drop-down menu
            or submenu.
            </para>
            </param>
            <param name="lpNewItem">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The content of the new menu item. The interpretation of lpNewItem depends on whether the uFlags parameter includes the
            <c>MF_BITMAP</c>, <c>MF_OWNERDRAW</c>, or <c>MF_STRING</c> flag, as follows.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BITMAP 0x00000004L</term>
            <term>Contains a bitmap handle.</term>
            </item>
            <item>
            <term>MF_OWNERDRAW 0x00000100L</term>
            <term>
            Contains an application-supplied value that can be used to maintain additional data related to the menu item. The value is in the
            itemData member of the structure pointed to by the lParam parameter of the WM_MEASUREITEM or WM_DRAWITEM message sent when the
            menu item is created or its appearance is updated.
            </term>
            </item>
            <item>
            <term>MF_STRING 0x00000000L</term>
            <term>Contains a pointer to a null-terminated string (the default).</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>The application must call the DrawMenuBar function whenever a menu changes, whether the menu is in a displayed window.</para>
            <para>The following groups of flags cannot be used together:</para>
            <list type="bullet">
            <item>
            <term><c>MF_BYCOMMAND</c> and <c>MF_BYPOSITION</c></term>
            </item>
            <item>
            <term><c>MF_DISABLED</c>, <c>MF_ENABLED</c>, and <c>MF_GRAYED</c></term>
            </item>
            <item>
            <term><c>MF_BITMAP</c>, <c>MF_STRING</c>, <c>MF_OWNERDRAW</c>, and <c>MF_SEPARATOR</c></term>
            </item>
            <item>
            <term><c>MF_MENUBARBREAK</c> and <c>MF_MENUBREAK</c></term>
            </item>
            <item>
            <term><c>MF_CHECKED</c> and <c>MF_UNCHECKED</c></term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.InsertMenuItem(Vanara.PInvoke.HMENU,System.UInt32,System.Boolean,Vanara.PInvoke.User32.MENUITEMINFO@)">
            <summary>
            <para>Inserts a new menu item at the specified position in a menu.</para>
            </summary>
            <param name="hmenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu in which the new menu item is inserted.</para>
            </param>
            <param name="item">
            <para>Type: <c>UINT</c></para>
            <para>
            The identifier or position of the menu item before which to insert the new item. The meaning of this parameter depends on the
            value of fByPosition.
            </para>
            </param>
            <param name="fByPosition">
            <para>Type: <c>BOOL</c></para>
            <para>
            Controls the meaning of uItem. If this parameter is <c>FALSE</c>, uItem is a menu item identifier. Otherwise, it is a menu item
            position. See Accessing Menu Items Programmatically for more information.
            </para>
            </param>
            <param name="lpmi">
            <para>Type: <c>LPCMENUITEMINFO</c></para>
            <para>A pointer to a MENUITEMINFO structure that contains information about the new menu item.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
            </returns>
            <remarks>
            <para>The application must call the DrawMenuBar function whenever a menu changes, whether the menu is in a displayed window.</para>
            <para>
            In order for keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the
            WM_MENUCHAR message. See Owner-Drawn Menus and the WM_MENUCHAR Message for more information.
            </para>
            <para>Examples</para>
            <para>For an example, see Example of Menu-Item Bitmaps.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsMenu(Vanara.PInvoke.HMENU)">
            <summary>
            <para>Determines whether a handle is a menu handle.</para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to be tested.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the handle is a menu handle, the return value is nonzero.</para>
            <para>If the handle is not a menu handle, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadMenu(Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.SafeResourceId)">
            <summary>
            <para>Loads the specified menu resource from the executable (.exe) file associated with an application instance.</para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to the module containing the menu resource to be loaded.</para>
            </param>
            <param name="lpMenuName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The name of the menu resource. Alternatively, this parameter can consist of the resource identifier in the low-order word and
            zero in the high-order word. To create this value, use the MAKEINTRESOURCE macro.
            </para>
            </param>
            <returns>
            <para>Type: <c>HMENU</c></para>
            <para>If the function succeeds, the return value is a handle to the menu resource.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The DestroyMenu function is used, before an application closes, to destroy the menu and free memory that the loaded menu occupied.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying a Shortcut Menu</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadMenuIndirect(System.IntPtr)">
            <summary>
            <para>Loads the specified menu template in memory.</para>
            </summary>
            <param name="lpMenuTemplate">
            <para>Type: <c>const MENUTEMPLATE*</c></para>
            <para>
            A pointer to a menu template or an extended menu template. A menu template consists of a MENUITEMTEMPLATEHEADER structure
            followed by one or more contiguous MENUITEMTEMPLATE structures. An extended menu template consists of a MENUEX_TEMPLATE_HEADER
            structure followed by one or more contiguous MENUEX_TEMPLATE_ITEM structures.
            </para>
            </param>
            <returns>
            <para>Type: <c>HMENU</c></para>
            <para>If the function succeeds, the return value is a handle to the menu.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            For both the ANSI and the Unicode version of this function, the strings in the MENUITEMTEMPLATE structure must be Unicode strings.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.MenuItemFromPoint(Vanara.PInvoke.HWND,Vanara.PInvoke.HMENU,Vanara.PInvoke.POINT)">
            <summary>
            <para>Determines which menu item, if any, is at the specified location.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window containing the menu. If this value is <c>NULL</c> and the hMenu parameter represents a popup menu, the
            function will find the menu window.
            </para>
            </param>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu containing the menu items to hit test.</para>
            </param>
            <param name="ptScreen">
            <para>Type: <c>POINT</c></para>
            <para>
            A structure that specifies the location to test. If hMenu specifies a menu bar, this parameter is in window coordinates.
            Otherwise, it is in client coordinates.
            </para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>Returns the zero-based position of the menu item at the specified location or -1 if no menu item is at the specified location.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.ModifyMenu(Vanara.PInvoke.HMENU,System.UInt32,Vanara.PInvoke.User32.MenuFlags,System.IntPtr,System.IntPtr)">
            <summary>
            <para>Changes an existing menu item. This function is used to specify the content, appearance, and behavior of the menu item.</para>
            <para>
            <c>Note</c> The <c>ModifyMenu</c> function has been superseded by the SetMenuItemInfo function. You can still use
            <c>ModifyMenu</c>, however, if you do not need any of the extended features of <c>SetMenuItemInfo</c>.
            </para>
            </summary>
            <param name="hMnu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu to be changed.</para>
            </param>
            <param name="uPosition">
            <para>Type: <c>UINT</c></para>
            <para>The menu item to be changed, as determined by the uFlags parameter.</para>
            </param>
            <param name="uFlags">
            <para>Type: <c>UINT</c></para>
            <para>
            Controls the interpretation of the uPosition parameter and the content, appearance, and behavior of the menu item. This parameter
            must include one of the following required values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BYCOMMAND 0x00000000L</term>
            <term>
            Indicates that the uPosition parameter gives the identifier of the menu item. The MF_BYCOMMAND flag is the default if neither the
            MF_BYCOMMAND nor MF_BYPOSITION flag is specified.
            </term>
            </item>
            <item>
            <term>MF_BYPOSITION 0x00000400L</term>
            <term>Indicates that the uPosition parameter gives the zero-based relative position of the menu item.</term>
            </item>
            </list>
            <para>The parameter must also include at least one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BITMAP 0x00000004L</term>
            <term>Uses a bitmap as the menu item. The lpNewItem parameter contains a handle to the bitmap.</term>
            </item>
            <item>
            <term>MF_CHECKED 0x00000008L</term>
            <term>
            Places a check mark next to the item. If your application provides check-mark bitmaps (see the SetMenuItemBitmaps function), this
            flag displays a selected bitmap next to the menu item.
            </term>
            </item>
            <item>
            <term>MF_DISABLED 0x00000002L</term>
            <term>Disables the menu item so that it cannot be selected, but this flag does not gray it.</term>
            </item>
            <item>
            <term>MF_ENABLED 0x00000000L</term>
            <term>Enables the menu item so that it can be selected and restores it from its grayed state.</term>
            </item>
            <item>
            <term>MF_GRAYED 0x00000001L</term>
            <term>Disables the menu item and grays it so that it cannot be selected.</term>
            </item>
            <item>
            <term>MF_MENUBARBREAK 0x00000020L</term>
            <term>
            Functions the same as the MF_MENUBREAK flag for a menu bar. For a drop-down menu, submenu, or shortcut menu, the new column is
            separated from the old column by a vertical line.
            </term>
            </item>
            <item>
            <term>MF_MENUBREAK 0x00000040L</term>
            <term>
            Places the item on a new line (for menu bars) or in a new column (for a drop-down menu, submenu, or shortcut menu) without
            separating columns.
            </term>
            </item>
            <item>
            <term>MF_OWNERDRAW 0x00000100L</term>
            <term>
            Specifies that the item is an owner-drawn item. Before the menu is displayed for the first time, the window that owns the menu
            receives a WM_MEASUREITEM message to retrieve the width and height of the menu item. The WM_DRAWITEM message is then sent to the
            window procedure of the owner window whenever the appearance of the menu item must be updated.
            </term>
            </item>
            <item>
            <term>MF_POPUP 0x00000010L</term>
            <term>
            Specifies that the menu item opens a drop-down menu or submenu. The uIDNewItem parameter specifies a handle to the drop-down menu
            or submenu. This flag is used to add a menu name to a menu bar or a menu item that opens a submenu to a drop-down menu, submenu,
            or shortcut menu.
            </term>
            </item>
            <item>
            <term>MF_SEPARATOR 0x00000800L</term>
            <term>
            Draws a horizontal dividing line. This flag is used only in a drop-down menu, submenu, or shortcut menu. The line cannot be
            grayed, disabled, or highlighted. The lpNewItem and uIDNewItem parameters are ignored.
            </term>
            </item>
            <item>
            <term>MF_STRING 0x00000000L</term>
            <term>Specifies that the menu item is a text string; the lpNewItem parameter is a pointer to the string.</term>
            </item>
            <item>
            <term>MF_UNCHECKED 0x00000000L</term>
            <term>
            Does not place a check mark next to the item (the default). If your application supplies check-mark bitmaps (see the
            SetMenuItemBitmaps function), this flag displays a clear bitmap next to the menu item.
            </term>
            </item>
            </list>
            </param>
            <param name="uIDNewItem">
            <para>Type: <c>UINT_PTR</c></para>
            <para>
            The identifier of the modified menu item or, if the uFlags parameter has the <c>MF_POPUP</c> flag set, a handle to the drop-down
            menu or submenu.
            </para>
            </param>
            <param name="lpNewItem">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The contents of the changed menu item. The interpretation of this parameter depends on whether the uFlags parameter includes the
            <c>MF_BITMAP</c>, <c>MF_OWNERDRAW</c>, or <c>MF_STRING</c> flag.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BITMAP 0x00000004L</term>
            <term>A bitmap handle.</term>
            </item>
            <item>
            <term>MF_OWNERDRAW 0x00000100L</term>
            <term>
            A value supplied by an application that is used to maintain additional data related to the menu item. The value is in the
            itemData member of the structure pointed to by the lParam parameter of the WM_MEASUREITEM or WM_DRAWITEM messages sent when the
            menu item is created or its appearance is updated.
            </term>
            </item>
            <item>
            <term>MF_STRING 0x00000000L</term>
            <term>A pointer to a null-terminated string (the default).</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If <c>ModifyMenu</c> replaces a menu item that opens a drop-down menu or submenu, the function destroys the old drop-down menu or
            submenu and frees the memory used by it.
            </para>
            <para>
            In order for keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the
            WM_MENUCHAR message. See Owner-Drawn Menus and the WM_MENUCHAR Message for more information.
            </para>
            <para>
            The application must call the DrawMenuBar function whenever a menu changes, whether the menu is in a displayed window. To change
            the attributes of existing menu items, it is much faster to use the CheckMenuItem and EnableMenuItem functions.
            </para>
            <para>The following groups of flags cannot be used together:</para>
            <list type="bullet">
            <item>
            <term><c>MF_BYCOMMAND</c> and <c>MF_BYPOSITION</c></term>
            </item>
            <item>
            <term><c>MF_DISABLED</c>, <c>MF_ENABLED</c>, and <c>MF_GRAYED</c></term>
            </item>
            <item>
            <term><c>MF_BITMAP</c>, <c>MF_STRING</c>, <c>MF_OWNERDRAW</c>, and <c>MF_SEPARATOR</c></term>
            </item>
            <item>
            <term><c>MF_MENUBARBREAK</c> and <c>MF_MENUBREAK</c></term>
            </item>
            <item>
            <term><c>MF_CHECKED</c> and <c>MF_UNCHECKED</c></term>
            </item>
            </list>
            <para>Examples</para>
            <para>For an example, see Setting Fonts for Menu-Item Text Strings.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ModifyMenu(Vanara.PInvoke.HMENU,System.UInt32,Vanara.PInvoke.User32.MenuFlags,System.IntPtr,System.String)">
            <summary>
            <para>Changes an existing menu item. This function is used to specify the content, appearance, and behavior of the menu item.</para>
            <para>
            <c>Note</c> The <c>ModifyMenu</c> function has been superseded by the SetMenuItemInfo function. You can still use
            <c>ModifyMenu</c>, however, if you do not need any of the extended features of <c>SetMenuItemInfo</c>.
            </para>
            </summary>
            <param name="hMnu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu to be changed.</para>
            </param>
            <param name="uPosition">
            <para>Type: <c>UINT</c></para>
            <para>The menu item to be changed, as determined by the uFlags parameter.</para>
            </param>
            <param name="uFlags">
            <para>Type: <c>UINT</c></para>
            <para>
            Controls the interpretation of the uPosition parameter and the content, appearance, and behavior of the menu item. This parameter
            must include one of the following required values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BYCOMMAND 0x00000000L</term>
            <term>
            Indicates that the uPosition parameter gives the identifier of the menu item. The MF_BYCOMMAND flag is the default if neither the
            MF_BYCOMMAND nor MF_BYPOSITION flag is specified.
            </term>
            </item>
            <item>
            <term>MF_BYPOSITION 0x00000400L</term>
            <term>Indicates that the uPosition parameter gives the zero-based relative position of the menu item.</term>
            </item>
            </list>
            <para>The parameter must also include at least one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BITMAP 0x00000004L</term>
            <term>Uses a bitmap as the menu item. The lpNewItem parameter contains a handle to the bitmap.</term>
            </item>
            <item>
            <term>MF_CHECKED 0x00000008L</term>
            <term>
            Places a check mark next to the item. If your application provides check-mark bitmaps (see the SetMenuItemBitmaps function), this
            flag displays a selected bitmap next to the menu item.
            </term>
            </item>
            <item>
            <term>MF_DISABLED 0x00000002L</term>
            <term>Disables the menu item so that it cannot be selected, but this flag does not gray it.</term>
            </item>
            <item>
            <term>MF_ENABLED 0x00000000L</term>
            <term>Enables the menu item so that it can be selected and restores it from its grayed state.</term>
            </item>
            <item>
            <term>MF_GRAYED 0x00000001L</term>
            <term>Disables the menu item and grays it so that it cannot be selected.</term>
            </item>
            <item>
            <term>MF_MENUBARBREAK 0x00000020L</term>
            <term>
            Functions the same as the MF_MENUBREAK flag for a menu bar. For a drop-down menu, submenu, or shortcut menu, the new column is
            separated from the old column by a vertical line.
            </term>
            </item>
            <item>
            <term>MF_MENUBREAK 0x00000040L</term>
            <term>
            Places the item on a new line (for menu bars) or in a new column (for a drop-down menu, submenu, or shortcut menu) without
            separating columns.
            </term>
            </item>
            <item>
            <term>MF_OWNERDRAW 0x00000100L</term>
            <term>
            Specifies that the item is an owner-drawn item. Before the menu is displayed for the first time, the window that owns the menu
            receives a WM_MEASUREITEM message to retrieve the width and height of the menu item. The WM_DRAWITEM message is then sent to the
            window procedure of the owner window whenever the appearance of the menu item must be updated.
            </term>
            </item>
            <item>
            <term>MF_POPUP 0x00000010L</term>
            <term>
            Specifies that the menu item opens a drop-down menu or submenu. The uIDNewItem parameter specifies a handle to the drop-down menu
            or submenu. This flag is used to add a menu name to a menu bar or a menu item that opens a submenu to a drop-down menu, submenu,
            or shortcut menu.
            </term>
            </item>
            <item>
            <term>MF_SEPARATOR 0x00000800L</term>
            <term>
            Draws a horizontal dividing line. This flag is used only in a drop-down menu, submenu, or shortcut menu. The line cannot be
            grayed, disabled, or highlighted. The lpNewItem and uIDNewItem parameters are ignored.
            </term>
            </item>
            <item>
            <term>MF_STRING 0x00000000L</term>
            <term>Specifies that the menu item is a text string; the lpNewItem parameter is a pointer to the string.</term>
            </item>
            <item>
            <term>MF_UNCHECKED 0x00000000L</term>
            <term>
            Does not place a check mark next to the item (the default). If your application supplies check-mark bitmaps (see the
            SetMenuItemBitmaps function), this flag displays a clear bitmap next to the menu item.
            </term>
            </item>
            </list>
            </param>
            <param name="uIDNewItem">
            <para>Type: <c>UINT_PTR</c></para>
            <para>
            The identifier of the modified menu item or, if the uFlags parameter has the <c>MF_POPUP</c> flag set, a handle to the drop-down
            menu or submenu.
            </para>
            </param>
            <param name="lpNewItem">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The contents of the changed menu item. The interpretation of this parameter depends on whether the uFlags parameter includes the
            <c>MF_BITMAP</c>, <c>MF_OWNERDRAW</c>, or <c>MF_STRING</c> flag.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BITMAP 0x00000004L</term>
            <term>A bitmap handle.</term>
            </item>
            <item>
            <term>MF_OWNERDRAW 0x00000100L</term>
            <term>
            A value supplied by an application that is used to maintain additional data related to the menu item. The value is in the
            itemData member of the structure pointed to by the lParam parameter of the WM_MEASUREITEM or WM_DRAWITEM messages sent when the
            menu item is created or its appearance is updated.
            </term>
            </item>
            <item>
            <term>MF_STRING 0x00000000L</term>
            <term>A pointer to a null-terminated string (the default).</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If <c>ModifyMenu</c> replaces a menu item that opens a drop-down menu or submenu, the function destroys the old drop-down menu or
            submenu and frees the memory used by it.
            </para>
            <para>
            In order for keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the
            WM_MENUCHAR message. See Owner-Drawn Menus and the WM_MENUCHAR Message for more information.
            </para>
            <para>
            The application must call the DrawMenuBar function whenever a menu changes, whether the menu is in a displayed window. To change
            the attributes of existing menu items, it is much faster to use the CheckMenuItem and EnableMenuItem functions.
            </para>
            <para>The following groups of flags cannot be used together:</para>
            <list type="bullet">
            <item>
            <term><c>MF_BYCOMMAND</c> and <c>MF_BYPOSITION</c></term>
            </item>
            <item>
            <term><c>MF_DISABLED</c>, <c>MF_ENABLED</c>, and <c>MF_GRAYED</c></term>
            </item>
            <item>
            <term><c>MF_BITMAP</c>, <c>MF_STRING</c>, <c>MF_OWNERDRAW</c>, and <c>MF_SEPARATOR</c></term>
            </item>
            <item>
            <term><c>MF_MENUBARBREAK</c> and <c>MF_MENUBREAK</c></term>
            </item>
            <item>
            <term><c>MF_CHECKED</c> and <c>MF_UNCHECKED</c></term>
            </item>
            </list>
            <para>Examples</para>
            <para>For an example, see Setting Fonts for Menu-Item Text Strings.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.RemoveMenu(Vanara.PInvoke.HMENU,System.UInt32,Vanara.PInvoke.User32.MenuFlags)">
            <summary>
            <para>
            Deletes a menu item or detaches a submenu from the specified menu. If the menu item opens a drop-down menu or submenu,
            <c>RemoveMenu</c> does not destroy the menu or its handle, allowing the menu to be reused. Before this function is called, the
            GetSubMenu function should retrieve a handle to the drop-down menu or submenu.
            </para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu to be changed.</para>
            </param>
            <param name="uPosition">
            <para>Type: <c>UINT</c></para>
            <para>The menu item to be deleted, as determined by the uFlags parameter.</para>
            </param>
            <param name="uFlags">
            <para>Type: <c>UINT</c></para>
            <para>Indicates how the uPosition parameter is interpreted. This parameter must be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BYCOMMAND 0x00000000L</term>
            <term>
            Indicates that uPosition gives the identifier of the menu item. If neither the MF_BYCOMMAND nor MF_BYPOSITION flag is specified,
            the MF_BYCOMMAND flag is the default flag.
            </term>
            </item>
            <item>
            <term>MF_BYPOSITION 0x00000400L</term>
            <term>Indicates that uPosition gives the zero-based relative position of the menu item.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>The application must call the DrawMenuBar function whenever a menu changes, whether the menu is in a displayed window.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetMenu(Vanara.PInvoke.HWND,Vanara.PInvoke.HMENU)">
            <summary>
            <para>Assigns a new menu to the specified window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to which the menu is to be assigned.</para>
            </param>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the new menu. If this parameter is <c>NULL</c>, the window's current menu is removed.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>The window is redrawn to reflect the menu change. A menu can be assigned to any window that is not a child window.</para>
            <para>
            The <c>SetMenu</c> function replaces the previous menu, if any, but it does not destroy it. An application should call the
            DestroyMenu function to accomplish this task.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetMenuContextHelpId(Vanara.PInvoke.HMENU,System.UInt32)">
            <summary>Associates a Help context identifier with a menu.</summary>
            <param name="arg1">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu with which to associate the Help context identifier.</para>
            </param>
            <param name="arg2">
            <para>Type: <c>DWORD</c></para>
            <para>The help context identifier.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns nonzero if successful, or zero otherwise.</para>
            <para>To retrieve extended error information, call GetLastError.</para>
            </returns>
            <remarks>All items in the menu share this identifier. Help context identifiers can't be attached to individual menu items.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetMenuDefaultItem(Vanara.PInvoke.HMENU,System.UInt32,System.Boolean)">
            <summary>
            <para>Sets the default menu item for the specified menu.</para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu to set the default item for.</para>
            </param>
            <param name="uItem">
            <para>Type: <c>UINT</c></para>
            <para>
            The identifier or position of the new default menu item or -1 for no default item. The meaning of this parameter depends on the
            value of fByPos.
            </para>
            </param>
            <param name="fByPos">
            <para>Type: <c>UINT</c></para>
            <para>
            The meaning of uItem. If this parameter is <c>FALSE</c>, uItem is a menu item identifier. Otherwise, it is a menu item position.
            See About Menus for more information.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetMenuInfo(Vanara.PInvoke.HMENU,Vanara.PInvoke.User32.MENUINFO@)">
            <summary>
            <para>Sets information for a specified menu.</para>
            </summary>
            <param name="hMenu">A handle to a menu.</param>
            <param name="lpcmi">A pointer to a MENUINFO structure for the menu.</param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetMenuItemBitmaps(Vanara.PInvoke.HMENU,System.UInt32,Vanara.PInvoke.User32.MenuFlags,Vanara.PInvoke.HBITMAP,Vanara.PInvoke.HBITMAP)">
            <summary>
            <para>
            Associates the specified bitmap with a menu item. Whether the menu item is selected or clear, the system displays the appropriate
            bitmap next to the menu item.
            </para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu containing the item to receive new check-mark bitmaps.</para>
            </param>
            <param name="uPosition">
            <para>Type: <c>UINT</c></para>
            <para>The menu item to be changed, as determined by the uFlags parameter.</para>
            </param>
            <param name="uFlags">
            <para>Type: <c>UINT</c></para>
            <para>Specifies how the uPosition parameter is to be interpreted. The uFlags parameter must be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_BYCOMMAND 0x00000000L</term>
            <term>
            Indicates that uPosition gives the identifier of the menu item. If neither MF_BYCOMMAND nor MF_BYPOSITION is specified,
            MF_BYCOMMAND is the default flag.
            </term>
            </item>
            <item>
            <term>MF_BYPOSITION 0x00000400L</term>
            <term>Indicates that uPosition gives the zero-based relative position of the menu item.</term>
            </item>
            </list>
            </param>
            <param name="hBitmapUnchecked">
            <para>Type: <c>HBITMAP</c></para>
            <para>A handle to the bitmap displayed when the menu item is not selected.</para>
            </param>
            <param name="hBitmapChecked">
            <para>Type: <c>HBITMAP</c></para>
            <para>A handle to the bitmap displayed when the menu item is selected.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If either the hBitmapUnchecked or hBitmapChecked parameter is <c>NULL</c>, the system displays nothing next to the menu item for
            the corresponding check state. If both parameters are <c>NULL</c>, the system displays the default check-mark bitmap when the
            item is selected, and removes the bitmap when the item is not selected.
            </para>
            <para>When the menu is destroyed, these bitmaps are not destroyed; it is up to the application to destroy them.</para>
            <para>
            The selected and clear bitmaps should be monochrome. The system uses the Boolean AND operator to combine bitmaps with the menu so
            that the white part becomes transparent and the black part becomes the menu-item color. If you use color bitmaps, the results may
            be undesirable.
            </para>
            <para>Use the GetSystemMetrics function with the <c>CXMENUCHECK</c> and <c>CYMENUCHECK</c> values to retrieve the bitmap dimensions.</para>
            <para>Examples</para>
            <para>For an example, see Simulating Check Boxes in a Menu.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetMenuItemInfo(Vanara.PInvoke.HMENU,System.UInt32,System.Boolean,Vanara.PInvoke.User32.MENUITEMINFO@)">
            <summary>
            <para>Changes information about a menu item.</para>
            </summary>
            <param name="hmenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu that contains the menu item.</para>
            </param>
            <param name="item">
            <para>Type: <c>UINT</c></para>
            <para>The identifier or position of the menu item to change. The meaning of this parameter depends on the value of fByPosition.</para>
            </param>
            <param name="fByPositon">
            <para>Type: <c>BOOL</c></para>
            <para>
            The meaning of uItem. If this parameter is <c>FALSE</c>, uItem is a menu item identifier. Otherwise, it is a menu item position.
            See About Menus for more information.
            </para>
            </param>
            <param name="lpmii">
            <para>Type: <c>LPMENUITEMINFO</c></para>
            <para>
            A pointer to a MENUITEMINFO structure that contains information about the menu item and specifies which menu item attributes to change.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
            </returns>
            <remarks>
            <para>The application must call the DrawMenuBar function whenever a menu changes, whether the menu is in a displayed window.</para>
            <para>
            In order for keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the
            WM_MENUCHAR message. See Owner-Drawn Menus and the WM_MENUCHAR Message for more information.
            </para>
            <para>Examples</para>
            <para>For an example, see Example of Owner-Drawn Menu Items.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.TrackPopupMenu(Vanara.PInvoke.HMENU,Vanara.PInvoke.User32.TrackPopupMenuFlags,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.HWND,Vanara.PInvoke.PRECT)">
            <summary>
            <para>
            Displays a shortcut menu at the specified location and tracks the selection of items on the menu. The shortcut menu can appear
            anywhere on the screen.
            </para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>
            A handle to the shortcut menu to be displayed. The handle can be obtained by calling CreatePopupMenu to create a new shortcut
            menu, or by calling GetSubMenu to retrieve a handle to a submenu associated with an existing menu item.
            </para>
            </param>
            <param name="uFlags">
            <para>Type: <c>UINT</c></para>
            <para>Use zero of more of these flags to specify function options.</para>
            <para>Use one of the following flags to specify how the function positions the shortcut menu horizontally.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TPM_CENTERALIGN 0x0004L</term>
            <term>Centers the shortcut menu horizontally relative to the coordinate specified by the x parameter.</term>
            </item>
            <item>
            <term>TPM_LEFTALIGN 0x0000L</term>
            <term>Positions the shortcut menu so that its left side is aligned with the coordinate specified by the x parameter.</term>
            </item>
            <item>
            <term>TPM_RIGHTALIGN 0x0008L</term>
            <term>Positions the shortcut menu so that its right side is aligned with the coordinate specified by the x parameter.</term>
            </item>
            </list>
            <para>Use one of the following flags to specify how the function positions the shortcut menu vertically.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TPM_BOTTOMALIGN 0x0020L</term>
            <term>Positions the shortcut menu so that its bottom side is aligned with the coordinate specified by the y parameter.</term>
            </item>
            <item>
            <term>TPM_TOPALIGN 0x0000L</term>
            <term>Positions the shortcut menu so that its top side is aligned with the coordinate specified by the y parameter.</term>
            </item>
            <item>
            <term>TPM_VCENTERALIGN 0x0010L</term>
            <term>Centers the shortcut menu vertically relative to the coordinate specified by the y parameter.</term>
            </item>
            </list>
            <para>Use the following flags to control discovery of the user selection without having to set up a parent window for the menu.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TPM_NONOTIFY 0x0080L</term>
            <term>The function does not send notification messages when the user clicks a menu item.</term>
            </item>
            <item>
            <term>TPM_RETURNCMD 0x0100L</term>
            <term>The function returns the menu item identifier of the user's selection in the return value.</term>
            </item>
            </list>
            <para>Use one of the following flags to specify which mouse button the shortcut menu tracks.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TPM_LEFTBUTTON 0x0000L</term>
            <term>The user can select menu items with only the left mouse button.</term>
            </item>
            <item>
            <term>TPM_RIGHTBUTTON 0x0002L</term>
            <term>The user can select menu items with both the left and right mouse buttons.</term>
            </item>
            </list>
            <para>
            Use any reasonable combination of the following flags to modify the animation of a menu. For example, by selecting a horizontal
            and a vertical flag, you can achieve diagonal animation.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TPM_HORNEGANIMATION 0x0800L</term>
            <term>Animates the menu from right to left.</term>
            </item>
            <item>
            <term>TPM_HORPOSANIMATION 0x0400L</term>
            <term>Animates the menu from left to right.</term>
            </item>
            <item>
            <term>TPM_NOANIMATION 0x4000L</term>
            <term>Displays menu without animation.</term>
            </item>
            <item>
            <term>TPM_VERNEGANIMATION 0x2000L</term>
            <term>Animates the menu from bottom to top.</term>
            </item>
            <item>
            <term>TPM_VERPOSANIMATION 0x1000L</term>
            <term>Animates the menu from top to bottom.</term>
            </item>
            </list>
            <para>
            For any animation to occur, the SystemParametersInfo function must set <c>SPI_SETMENUANIMATION</c>. Also, all the TPM_*ANIMATION
            flags, except <c>TPM_NOANIMATION</c>, are ignored if menu fade animation is on. For more information, see the
            <c>SPI_GETMENUFADE</c> flag in <c>SystemParametersInfo</c>.
            </para>
            <para>
            Use the <c>TPM_RECURSE</c> flag to display a menu when another menu is already displayed. This is intended to support context
            menus within a menu.
            </para>
            <para>For right-to-left text layout, use <c>TPM_LAYOUTRTL</c>. By default, the text layout is left-to-right.</para>
            </param>
            <param name="x">
            <para>Type: <c>int</c></para>
            <para>The horizontal location of the shortcut menu, in screen coordinates.</para>
            </param>
            <param name="y">
            <para>Type: <c>int</c></para>
            <para>The vertical location of the shortcut menu, in screen coordinates.</para>
            </param>
            <param name="nReserved">
            <para>Type: <c>int</c></para>
            <para>Reserved; must be zero.</para>
            </param>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window that owns the shortcut menu. This window receives all messages from the menu. The window does not receive
            a WM_COMMAND message from the menu until the function returns. If you specify TPM_NONOTIFY in the uFlags parameter, the function
            does not send messages to the window identified by hWnd. However, you must still pass a window handle in hWnd. It can be any
            window handle from your application.
            </para>
            </param>
            <param name="prcRect">
            <para>Type: <c>const RECT*</c></para>
            <para>Ignored.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            If you specify <c>TPM_RETURNCMD</c> in the uFlags parameter, the return value is the menu-item identifier of the item that the
            user selected. If the user cancels the menu without making a selection, or if an error occurs, the return value is zero.
            </para>
            <para>
            If you do not specify <c>TPM_RETURNCMD</c> in the uFlags parameter, the return value is nonzero if the function succeeds and zero
            if it fails. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            Call GetSystemMetrics with <c>SM_MENUDROPALIGNMENT</c> to determine the correct horizontal alignment flag ( <c>TPM_LEFTALIGN</c>
            or <c>TPM_RIGHTALIGN</c>) and/or horizontal animation direction flag ( <c>TPM_HORPOSANIMATION</c> or <c>TPM_HORNEGANIMATION</c>)
            to pass to <c>TrackPopupMenu</c> or TrackPopupMenuEx. This is essential for creating an optimal user experience, especially when
            developing Microsoft Tablet PC applications.
            </para>
            <para>To specify an area of the screen that the menu should not overlap, use the TrackPopupMenuEx function</para>
            <para>
            To display a context menu for a notification icon, the current window must be the foreground window before the application calls
            <c>TrackPopupMenu</c> or TrackPopupMenuEx. Otherwise, the menu will not disappear when the user clicks outside of the menu or the
            window that created the menu (if it is visible). If the current window is a child window, you must set the (top-level) parent
            window as the foreground window.
            </para>
            <para>
            However, when the current window is the foreground window, the second time this menu is displayed, it appears and then
            immediately disappears. To correct this, you must force a task switch to the application that called <c>TrackPopupMenu</c>. This
            is done by posting a benign message to the window or thread, as shown in the following code sample:
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying a Shortcut Menu.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.TrackPopupMenuEx(Vanara.PInvoke.HMENU,Vanara.PInvoke.User32.TrackPopupMenuFlags,System.Int32,System.Int32,Vanara.PInvoke.HWND,Vanara.PInvoke.User32.TPMPARAMS)">
            <summary>
            <para>
            Displays a shortcut menu at the specified location and tracks the selection of items on the shortcut menu. The shortcut menu can
            appear anywhere on the screen.
            </para>
            </summary>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>
            A handle to the shortcut menu to be displayed. This handle can be obtained by calling the CreatePopupMenu function to create a
            new shortcut menu or by calling the GetSubMenu function to retrieve a handle to a submenu associated with an existing menu item.
            </para>
            </param>
            <param name="uFlags">
            <para>Type: <c>UINT</c></para>
            <para>Specifies function options.</para>
            <para>Use one of the following flags to specify how the function positions the shortcut menu horizontally.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TPM_CENTERALIGN 0x0004L</term>
            <term>Centers the shortcut menu horizontally relative to the coordinate specified by the x parameter.</term>
            </item>
            <item>
            <term>TPM_LEFTALIGN 0x0000L</term>
            <term>Positions the shortcut menu so that its left side is aligned with the coordinate specified by the x parameter.</term>
            </item>
            <item>
            <term>TPM_RIGHTALIGN 0x0008L</term>
            <term>Positions the shortcut menu so that its right side is aligned with the coordinate specified by the x parameter.</term>
            </item>
            </list>
            <para>Use one of the following flags to specify how the function positions the shortcut menu vertically.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TPM_BOTTOMALIGN 0x0020L</term>
            <term>Positions the shortcut menu so that its bottom side is aligned with the coordinate specified by the y parameter.</term>
            </item>
            <item>
            <term>TPM_TOPALIGN 0x0000L</term>
            <term>Positions the shortcut menu so that its top side is aligned with the coordinate specified by the y parameter.</term>
            </item>
            <item>
            <term>TPM_VCENTERALIGN 0x0010L</term>
            <term>Centers the shortcut menu vertically relative to the coordinate specified by the y parameter.</term>
            </item>
            </list>
            <para>Use the following flags to control discovery of the user selection without having to set up a parent window for the menu.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TPM_NONOTIFY 0x0080L</term>
            <term>The function does not send notification messages when the user clicks a menu item.</term>
            </item>
            <item>
            <term>TPM_RETURNCMD 0x0100L</term>
            <term>The function returns the menu item identifier of the user's selection in the return value.</term>
            </item>
            </list>
            <para>Use one of the following flags to specify which mouse button the shortcut menu tracks.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TPM_LEFTBUTTON 0x0000L</term>
            <term>The user can select menu items with only the left mouse button.</term>
            </item>
            <item>
            <term>TPM_RIGHTBUTTON 0x0002L</term>
            <term>The user can select menu items with both the left and right mouse buttons.</term>
            </item>
            </list>
            <para>
            Use any reasonable combination of the following flags to modify the animation of a menu. For example, by selecting a horizontal
            and a vertical flag, you can achieve diagonal animation.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TPM_HORNEGANIMATION 0x0800L</term>
            <term>Animates the menu from right to left.</term>
            </item>
            <item>
            <term>TPM_HORPOSANIMATION 0x0400L</term>
            <term>Animates the menu from left to right.</term>
            </item>
            <item>
            <term>TPM_NOANIMATION 0x4000L</term>
            <term>Displays menu without animation.</term>
            </item>
            <item>
            <term>TPM_VERNEGANIMATION 0x2000L</term>
            <term>Animates the menu from bottom to top.</term>
            </item>
            <item>
            <term>TPM_VERPOSANIMATION 0x1000L</term>
            <term>Animates the menu from top to bottom.</term>
            </item>
            </list>
            <para>
            For any animation to occur, the SystemParametersInfo function must set <c>SPI_SETMENUANIMATION</c>. Also, all the
            <c>TPM_*ANIMATION</c> flags, except <c>TPM_NOANIMATION</c>, are ignored if menu fade animation is on. For more information, see
            the <c>SPI_GETMENUFADE</c> flag in <c>SystemParametersInfo</c>.
            </para>
            <para>
            Use the <c>TPM_RECURSE</c> flag to display a menu when another menu is already displayed. This is intended to support context
            menus within a menu.
            </para>
            <para>Use one of the following flags to specify whether to accommodate horizontal or vertical alignment.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TPM_HORIZONTAL 0x0000L</term>
            <term>
            If the menu cannot be shown at the specified location without overlapping the excluded rectangle, the system tries to accommodate
            the requested horizontal alignment before the requested vertical alignment.
            </term>
            </item>
            <item>
            <term>TPM_VERTICAL 0x0040L</term>
            <term>
            If the menu cannot be shown at the specified location without overlapping the excluded rectangle, the system tries to accommodate
            the requested vertical alignment before the requested horizontal alignment.
            </term>
            </item>
            </list>
            <para>The excluded rectangle is a portion of the screen that the menu should not overlap; it is specified by the lptpm parameter.</para>
            <para>For right-to-left text layout, use <c>TPM_LAYOUTRTL</c>. By default, the text layout is left-to-right.</para>
            </param>
            <param name="x">
            <para>Type: <c>int</c></para>
            <para>The horizontal location of the shortcut menu, in screen coordinates.</para>
            </param>
            <param name="y">
            <para>Type: <c>int</c></para>
            <para>The vertical location of the shortcut menu, in screen coordinates.</para>
            </param>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window that owns the shortcut menu. This window receives all messages from the menu. The window does not receive
            a WM_COMMAND message from the menu until the function returns. If you specify TPM_NONOTIFY in the fuFlags parameter, the function
            does not send messages to the window identified by hwnd. However, you must still pass a window handle in hwnd. It can be any
            window handle from your application.
            </para>
            </param>
            <param name="lptpm">
            <para>Type: <c>LPTPMPARAMS</c></para>
            <para>
            A pointer to a TPMPARAMS structure that specifies an area of the screen the menu should not overlap. This parameter can be <c>NULL</c>.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>
            If you specify <c>TPM_RETURNCMD</c> in the fuFlags parameter, the return value is the menu-item identifier of the item that the
            user selected. If the user cancels the menu without making a selection, or if an error occurs, the return value is zero.
            </para>
            <para>
            If you do not specify <c>TPM_RETURNCMD</c> in the fuFlags parameter, the return value is nonzero if the function succeeds and
            zero if it fails. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            Call GetSystemMetrics with <c>SM_MENUDROPALIGNMENT</c> to determine the correct horizontal alignment flag ( <c>TPM_LEFTALIGN</c>
            or <c>TPM_RIGHTALIGN</c>) and/or horizontal animation direction flag ( <c>TPM_HORPOSANIMATION</c> or <c>TPM_HORNEGANIMATION</c>)
            to pass to TrackPopupMenu or <c>TrackPopupMenuEx</c>. This is essential for creating an optimal user experience, especially when
            developing Microsoft Tablet PC applications.
            </para>
            <para>
            To display a context menu for a notification icon, the current window must be the foreground window before the application calls
            TrackPopupMenu or <c>TrackPopupMenuEx</c>. Otherwise, the menu will not disappear when the user clicks outside of the menu or the
            window that created the menu (if it is visible). If the current window is a child window, you must set the (top-level) parent
            window as the foreground window.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.MDINEXTMENU">
            <summary>
            <para>Contains information about the menu to be activated.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MDINEXTMENU.hmenuIn">
            <summary>
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the current menu.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MDINEXTMENU.hmenuNext">
            <summary>
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu to be activated.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MDINEXTMENU.hwndNext">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to receive the menu notification messages.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MENUBARINFO">
            <summary>
            <para>Contains menu bar information.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUBARINFO.cbSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The size of the structure, in bytes. The caller must set this to .</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUBARINFO.rcBar">
            <summary>
            <para>Type: <c>RECT</c></para>
            <para>The coordinates of the menu bar, popup menu, or menu item.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUBARINFO.hMenu">
            <summary>
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu bar or popup menu.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUBARINFO.hwndMenu">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the submenu.</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.MENUBARINFO.fBarFocused">
            <summary>
            <para>Type: <c>BOOL</c></para>
            <para>If the menu bar or popup menu has the focus, this member is <c>TRUE</c>. Otherwise, the member is <c>FALSE</c>.</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.MENUBARINFO.fFocused">
            <summary>
            <para>Type: <c>BOOL</c></para>
            <para>If the menu item has the focus, this member is <c>TRUE</c>. Otherwise, the member is <c>FALSE</c>.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MENUEX_TEMPLATE_HEADER">
            <summary>
            <para>
            Defines the header for an extended menu template. This structure definition is for explanation only; it is not present in any
            standard header file.
            </para>
            </summary>
            <remarks>
            <para>
            An extended menu template consists of a <c>MENUEX_TEMPLATE_HEADER</c> structure followed by one or more contiguous
            <c>MENUEX_TEMPLATE_ITEM</c> structures. The <c>MENUEX_TEMPLATE_ITEM</c> structures, which are variable in length, are aligned on
            <c>DWORD</c> boundaries. To create a menu from an extended menu template in memory, use the <c>LoadMenuIndirect</c> function.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUEX_TEMPLATE_HEADER.wVersion">
            <summary>The template version number. This member must be 1 for extended menu templates.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUEX_TEMPLATE_HEADER.wOffset">
            <summary>
            The offset to the first MENUEX_TEMPLATE_ITEM structure, relative to the end of this structure member. If the first item
            definition immediately follows the dwHelpId member, this member should be 4.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUEX_TEMPLATE_HEADER.dwHelpId">
            <summary>The help identifier of menu bar.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MENUEX_TEMPLATE_ITEM">
            <summary>
            <para>
            Defines a menu item in an extended menu template. This structure definition is for explanation only; it is not present in any
            standard header file.
            </para>
            </summary>
            <remarks>
            <para>
            An extended menu template consists of a <c>MENUEX_TEMPLATE_HEADER</c> structure followed by one or more contiguous
            <c>MENUEX_TEMPLATE_ITEM</c> structures. The <c>MENUEX_TEMPLATE_ITEM</c> structures, which are variable in length, are aligned on
            <c>DWORD</c> boundaries. To create a menu from an extended menu template in memory, use the <c>LoadMenuIndirect</c> function.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUEX_TEMPLATE_ITEM.dwType">
            <summary>
            The menu item type. This member can be a combination of the type (beginning with MFT) values listed with the MENUITEMINFO structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUEX_TEMPLATE_ITEM.dwState">
            <summary>
            The menu item state. This member can be a combination of the state (beginning with MFS) values listed with the MENUITEMINFO structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUEX_TEMPLATE_ITEM.menuId">
            <summary>
            The menu item identifier. This is an application-defined value that identifies the menu item. In an extended menu resource,
            items that open drop-down menus or submenus as well as command items can have identifiers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUEX_TEMPLATE_ITEM.bResInfo">
            <summary>
            Specifies whether the menu item is the last item in the menu bar, drop-down menu, submenu, or shortcut menu and whether it is
            an item that opens a drop-down menu or submenu. This member can be zero or more of these values. For 32-bit applications,
            this member is a word; for 16-bit applications, it is a byte.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUEX_TEMPLATE_ITEM.szText">
            <summary>
            The menu item text. This member is a null-terminated Unicode string, aligned on a word boundary. The size of the menu item
            definition varies depending on the length of this string.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUEX_TEMPLATE_ITEM.dwHelpId">
            <summary>
            The help identifier for a drop-down menu or submenu. This member, which is included only for items that open drop-down menus
            or submenus, is located at the first DWORD boundary following the variable-length szText member.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MENUGETOBJECTINFO">
            <summary>
            <para>Contains information about the menu that the mouse cursor is on.</para>
            </summary>
            <remarks>
            <para>
            The <c>MENUGETOBJECTINFO</c> structure is used only in drag-and-drop menus. When the WM_MENUGETOBJECT message is sent, lParam is
            a pointer to this structure.
            </para>
            <para>To create a drag-and-drop menu, call SetMenuInfo with <c>MNS_DRAGDROP</c> set.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUGETOBJECTINFO.dwFlags">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            The position of the mouse cursor with respect to the item indicated by <c>uPos</c>. It is a bitmask of the following values:
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MNGOF_BOTTOMGAP 0x00000002</term>
            <term>The mouse is on the bottom of the item indicated by uPos.</term>
            </item>
            <item>
            <term>MNGOF_TOPGAP 0x00000001</term>
            <term>The mouse is on the top of the item indicated by uPos.</term>
            </item>
            </list>
            <para>If neither MNGOF_BOTTOMGAP nor MNGOF_TOPGAP is set, then the mouse is directly on the item indicated by <c>uPos</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUGETOBJECTINFO.uPos">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The position of the item the mouse cursor is on.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUGETOBJECTINFO.hmenu">
            <summary>
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu the mouse cursor is on.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUGETOBJECTINFO.riid">
            <summary>
            <para>Type: <c>PVOID</c></para>
            <para>The identifier of the requested interface. Currently it can only be IDropTarget.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUGETOBJECTINFO.pvObj">
            <summary>
            <para>Type: <c>PVOID</c></para>
            <para>
            A pointer to the interface corresponding to the <c>riid</c> member. This pointer is to be returned by the application when
            processing the message.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MENUINFO">
            <summary>
            <para>Contains information about a menu.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUINFO.cbSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The size of the structure, in bytes. The caller must set this member to .</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUINFO.fMask">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            Indicates the members to be retrieved or set (except for <c>MIM_APPLYTOSUBMENUS</c>). This member can be one or more of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MIM_APPLYTOSUBMENUS 0x80000000</term>
            <term>Settings apply to the menu and all of its submenus. SetMenuInfo uses this flag and GetMenuInfo ignores this flag</term>
            </item>
            <item>
            <term>MIM_BACKGROUND 0x00000002</term>
            <term>Retrieves or sets the hbrBack member.</term>
            </item>
            <item>
            <term>MIM_HELPID 0x00000004</term>
            <term>Retrieves or sets the dwContextHelpID member.</term>
            </item>
            <item>
            <term>MIM_MAXHEIGHT 0x00000001</term>
            <term>Retrieves or sets the cyMax member.</term>
            </item>
            <item>
            <term>MIM_MENUDATA 0x00000008</term>
            <term>Retrieves or sets the dwMenuData member.</term>
            </item>
            <item>
            <term>MIM_STYLE 0x00000010</term>
            <term>Retrieves or sets the dwStyle member.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUINFO.dwStyle">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The menu style. This member can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MNS_AUTODISMISS 0x10000000</term>
            <term>Menu automatically ends when mouse is outside the menu for approximately 10 seconds.</term>
            </item>
            <item>
            <term>MNS_CHECKORBMP 0x04000000</term>
            <term>
            The same space is reserved for the check mark and the bitmap. If the check mark is drawn, the bitmap is not. All checkmarks
            and bitmaps are aligned. Used for menus where some items use checkmarks and some use bitmaps.
            </term>
            </item>
            <item>
            <term>MNS_DRAGDROP 0x20000000</term>
            <term>Menu items are OLE drop targets or drag sources. Menu owner receives WM_MENUDRAG and WM_MENUGETOBJECT messages.</term>
            </item>
            <item>
            <term>MNS_MODELESS 0x40000000</term>
            <term>Menu is modeless; that is, there is no menu modal message loop while the menu is active.</term>
            </item>
            <item>
            <term>MNS_NOCHECK 0x80000000</term>
            <term>
            No space is reserved to the left of an item for a check mark. The item can still be selected, but the check mark will not
            appear next to the item.
            </term>
            </item>
            <item>
            <term>MNS_NOTIFYBYPOS 0x08000000</term>
            <term>
            Menu owner receives a WM_MENUCOMMAND message instead of a WM_COMMAND message when the user makes a selection. MNS_NOTIFYBYPOS
            is a menu header style and has no effect when applied to individual sub menus.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUINFO.cyMax">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>
            The maximum height of the menu in pixels. When the menu items exceed the space available, scroll bars are automatically used.
            The default (0) is the screen height.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUINFO.hbrBack">
            <summary>
            <para>Type: <c>HBRUSH</c></para>
            <para>A handle to the brush to be used for the menu's background.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUINFO.dwContextHelpID">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The context help identifier. This is the same value used in the GetMenuContextHelpId and SetMenuContextHelpId functions.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUINFO.dwMenuData">
            <summary>
            <para>Type: <c>ULONG_PTR</c></para>
            <para>An application-defined value.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MENUITEMINFO">
            <summary>
            <para>Contains information about a menu item.</para>
            </summary>
            <remarks>
            <para>The <c>MENUITEMINFO</c> structure is used with the GetMenuItemInfo, InsertMenuItem, and SetMenuItemInfo functions.</para>
            <para>The menu can display items using text, bitmaps, or both.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMINFO.cbSize">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The size of the structure, in bytes. The caller must set this member to .</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMINFO.fMask">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>Indicates the members to be retrieved or set. This member can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MIIM_BITMAP 0x00000080</term>
            <term>Retrieves or sets the hbmpItem member.</term>
            </item>
            <item>
            <term>MIIM_CHECKMARKS 0x00000008</term>
            <term>Retrieves or sets the hbmpChecked and hbmpUnchecked members.</term>
            </item>
            <item>
            <term>MIIM_DATA 0x00000020</term>
            <term>Retrieves or sets the dwItemData member.</term>
            </item>
            <item>
            <term>MIIM_FTYPE 0x00000100</term>
            <term>Retrieves or sets the fType member.</term>
            </item>
            <item>
            <term>MIIM_ID 0x00000002</term>
            <term>Retrieves or sets the wID member.</term>
            </item>
            <item>
            <term>MIIM_STATE 0x00000001</term>
            <term>Retrieves or sets the fState member.</term>
            </item>
            <item>
            <term>MIIM_STRING 0x00000040</term>
            <term>Retrieves or sets the dwTypeData member.</term>
            </item>
            <item>
            <term>MIIM_SUBMENU 0x00000004</term>
            <term>Retrieves or sets the hSubMenu member.</term>
            </item>
            <item>
            <term>MIIM_TYPE 0x00000010</term>
            <term>Retrieves or sets the fType and dwTypeData members. MIIM_TYPE is replaced by MIIM_BITMAP, MIIM_FTYPE, and MIIM_STRING.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMINFO.fType">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The menu item type. This member can be one or more of the following values.</para>
            <para>
            The <c>MFT_BITMAP</c>, <c>MFT_SEPARATOR</c>, and <c>MFT_STRING</c> values cannot be combined with one another. Set
            <c>fMask</c> to <c>MIIM_TYPE</c> to use <c>fType</c>.
            </para>
            <para><c>fType</c> is used only if <c>fMask</c> has a value of <c>MIIM_FTYPE</c>.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MFT_BITMAP 0x00000004L</term>
            <term>
            Displays the menu item using a bitmap. The low-order word of the dwTypeData member is the bitmap handle, and the cch member
            is ignored. MFT_BITMAP is replaced by MIIM_BITMAP and hbmpItem.
            </term>
            </item>
            <item>
            <term>MFT_MENUBARBREAK 0x00000020L</term>
            <term>
            Places the menu item on a new line (for a menu bar) or in a new column (for a drop-down menu, submenu, or shortcut menu). For
            a drop-down menu, submenu, or shortcut menu, a vertical line separates the new column from the old.
            </term>
            </item>
            <item>
            <term>MFT_MENUBREAK 0x00000040L</term>
            <term>
            Places the menu item on a new line (for a menu bar) or in a new column (for a drop-down menu, submenu, or shortcut menu). For
            a drop-down menu, submenu, or shortcut menu, the columns are not separated by a vertical line.
            </term>
            </item>
            <item>
            <term>MFT_OWNERDRAW 0x00000100L</term>
            <term>
            Assigns responsibility for drawing the menu item to the window that owns the menu. The window receives a WM_MEASUREITEM
            message before the menu is displayed for the first time, and a WM_DRAWITEM message whenever the appearance of the menu item
            must be updated. If this value is specified, the dwTypeData member contains an application-defined value.
            </term>
            </item>
            <item>
            <term>MFT_RADIOCHECK 0x00000200L</term>
            <term>Displays selected menu items using a radio-button mark instead of a check mark if the hbmpChecked member is NULL.</term>
            </item>
            <item>
            <term>MFT_RIGHTJUSTIFY 0x00004000L</term>
            <term>Right-justifies the menu item and any subsequent items. This value is valid only if the menu item is in a menu bar.</term>
            </item>
            <item>
            <term>MFT_RIGHTORDER 0x00002000L</term>
            <term>
            Specifies that menus cascade right-to-left (the default is left-to-right). This is used to support right-to-left languages,
            such as Arabic and Hebrew.
            </term>
            </item>
            <item>
            <term>MFT_SEPARATOR 0x00000800L</term>
            <term>
            Specifies that the menu item is a separator. A menu item separator appears as a horizontal dividing line. The dwTypeData and
            cch members are ignored. This value is valid only in a drop-down menu, submenu, or shortcut menu.
            </term>
            </item>
            <item>
            <term>MFT_STRING 0x00000000L</term>
            <term>
            Displays the menu item using a text string. The dwTypeData member is the pointer to a null-terminated string, and the cch
            member is the length of the string. MFT_STRING is replaced by MIIM_STRING.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMINFO.fState">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>
            The menu item state. This member can be one or more of these values. Set <c>fMask</c> to <c>MIIM_STATE</c> to use <c>fState</c>.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MFS_CHECKED 0x00000008L</term>
            <term>Checks the menu item. For more information about selected menu items, see the hbmpChecked member.</term>
            </item>
            <item>
            <term>MFS_DEFAULT 0x00001000L</term>
            <term>
            Specifies that the menu item is the default. A menu can contain only one default menu item, which is displayed in bold.
            </term>
            </item>
            <item>
            <term>MFS_DISABLED 0x00000003L</term>
            <term>Disables the menu item and grays it so that it cannot be selected. This is equivalent to MFS_GRAYED.</term>
            </item>
            <item>
            <term>MFS_ENABLED 0x00000000L</term>
            <term>Enables the menu item so that it can be selected. This is the default state.</term>
            </item>
            <item>
            <term>MFS_GRAYED 0x00000003L</term>
            <term>Disables the menu item and grays it so that it cannot be selected. This is equivalent to MFS_DISABLED.</term>
            </item>
            <item>
            <term>MFS_HILITE 0x00000080L</term>
            <term>Highlights the menu item.</term>
            </item>
            <item>
            <term>MFS_UNCHECKED 0x00000000L</term>
            <term>Unchecks the menu item. For more information about clear menu items, see the hbmpChecked member.</term>
            </item>
            <item>
            <term>MFS_UNHILITE 0x00000000L</term>
            <term>Removes the highlight from the menu item. This is the default state.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMINFO.wID">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>An application-defined value that identifies the menu item. Set <c>fMask</c> to <c>MIIM_ID</c> to use <c>wID</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMINFO.hSubMenu">
            <summary>
            <para>Type: <c>HMENU</c></para>
            <para>
            A handle to the drop-down menu or submenu associated with the menu item. If the menu item is not an item that opens a
            drop-down menu or submenu, this member is <c>NULL</c>. Set <c>fMask</c> to <c>MIIM_SUBMENU</c> to use <c>hSubMenu</c>.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMINFO.hbmpChecked">
            <summary>
            <para>Type: <c>HBITMAP</c></para>
            <para>
            A handle to the bitmap to display next to the item if it is selected. If this member is <c>NULL</c>, a default bitmap is
            used. If the <c>MFT_RADIOCHECK</c> type value is specified, the default bitmap is a bullet. Otherwise, it is a check mark.
            Set <c>fMask</c> to <c>MIIM_CHECKMARKS</c> to use <c>hbmpChecked</c>.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMINFO.hbmpUnchecked">
            <summary>
            <para>Type: <c>HBITMAP</c></para>
            <para>
            A handle to the bitmap to display next to the item if it is not selected. If this member is <c>NULL</c>, no bitmap is used.
            Set <c>fMask</c> to <c>MIIM_CHECKMARKS</c> to use <c>hbmpUnchecked</c>.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMINFO.dwItemData">
            <summary>
            <para>Type: <c>ULONG_PTR</c></para>
            <para>An application-defined value associated with the menu item. Set <c>fMask</c> to <c>MIIM_DATA</c> to use <c>dwItemData</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMINFO.dwTypeData">
            <summary>
            <para>Type: <c>LPTSTR</c></para>
            <para>
            The contents of the menu item. The meaning of this member depends on the value of <c>fType</c> and is used only if the
            <c>MIIM_TYPE</c> flag is set in the <c>fMask</c> member.
            </para>
            <para>
            To retrieve a menu item of type <c>MFT_STRING</c>, first find the size of the string by setting the <c>dwTypeData</c> member
            of <c>MENUITEMINFO</c> to <c>NULL</c> and then calling GetMenuItemInfo. The value of <c>cch</c>+1 is the size needed. Then
            allocate a buffer of this size, place the pointer to the buffer in <c>dwTypeData</c>, increment <c>cch</c>, and call
            <c>GetMenuItemInfo</c> once again to fill the buffer with the string. If the retrieved menu item is of some other type, then
            <c>GetMenuItemInfo</c> sets the <c>dwTypeData</c> member to a value whose type is specified by the <c>fType</c> member.
            </para>
            <para>
            When using with the SetMenuItemInfo function, this member should contain a value whose type is specified by the <c>fType</c> member.
            </para>
            <para><c>dwTypeData</c> is used only if the <c>MIIM_STRING</c> flag is set in the <c>fMask</c> member</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMINFO.cch">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>
            The length of the menu item text, in characters, when information is received about a menu item of the <c>MFT_STRING</c>
            type. However, <c>cch</c> is used only if the <c>MIIM_TYPE</c> flag is set in the <c>fMask</c> member and is zero otherwise.
            Also, <c>cch</c> is ignored when the content of a menu item is set by calling SetMenuItemInfo.
            </para>
            <para>
            Note that, before calling GetMenuItemInfo, the application must set <c>cch</c> to the length of the buffer pointed to by the
            <c>dwTypeData</c> member. If the retrieved menu item is of type <c>MFT_STRING</c> (as indicated by the <c>fType</c> member),
            then <c>GetMenuItemInfo</c> changes <c>cch</c> to the length of the menu item text. If the retrieved menu item is of some
            other type, <c>GetMenuItemInfo</c> sets the <c>cch</c> field to zero.
            </para>
            <para>The <c>cch</c> member is used when the <c>MIIM_STRING</c> flag is set in the <c>fMask</c> member.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMINFO.hbmpItem">
            <summary>
            <para>Type: <c>HBITMAP</c></para>
            <para>
            A handle to the bitmap to be displayed, or it can be one of the values in the following table. It is used when the
            <c>MIIM_BITMAP</c> flag is set in the <c>fMask</c> member.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>HBMMENU_CALLBACK ((HBITMAP) -1)</term>
            <term>
            A bitmap that is drawn by the window that owns the menu. The application must process the WM_MEASUREITEM and WM_DRAWITEM messages.
            </term>
            </item>
            <item>
            <term>HBMMENU_MBAR_CLOSE ((HBITMAP) 5)</term>
            <term>Close button for the menu bar.</term>
            </item>
            <item>
            <term>HBMMENU_MBAR_CLOSE_D ((HBITMAP) 6)</term>
            <term>Disabled close button for the menu bar.</term>
            </item>
            <item>
            <term>HBMMENU_MBAR_MINIMIZE ((HBITMAP) 3)</term>
            <term>Minimize button for the menu bar.</term>
            </item>
            <item>
            <term>HBMMENU_MBAR_MINIMIZE_D ((HBITMAP) 7)</term>
            <term>Disabled minimize button for the menu bar.</term>
            </item>
            <item>
            <term>HBMMENU_MBAR_RESTORE ((HBITMAP) 2)</term>
            <term>Restore button for the menu bar.</term>
            </item>
            <item>
            <term>HBMMENU_POPUP_CLOSE ((HBITMAP) 8)</term>
            <term>Close button for the submenu.</term>
            </item>
            <item>
            <term>HBMMENU_POPUP_MAXIMIZE ((HBITMAP) 10)</term>
            <term>Maximize button for the submenu.</term>
            </item>
            <item>
            <term>HBMMENU_POPUP_MINIMIZE ((HBITMAP) 11)</term>
            <term>Minimize button for the submenu.</term>
            </item>
            <item>
            <term>HBMMENU_POPUP_RESTORE ((HBITMAP) 9)</term>
            <term>Restore button for the submenu.</term>
            </item>
            <item>
            <term>HBMMENU_SYSTEM ((HBITMAP) 1)</term>
            <term>Windows icon or the icon of the window specified in dwItemData.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.MENUITEMINFO.#ctor(System.UInt32,Vanara.PInvoke.User32.MenuItemType,Vanara.PInvoke.User32.MenuItemState,Vanara.PInvoke.HMENU)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.MENUITEMINFO"/> struct.</summary>
            <param name="id">An application-defined value that identifies the menu item.</param>
            <param name="type">The menu type.</param>
            <param name="state">The menu state.</param>
            <param name="subMenu">
            A handle to the drop-down menu or submenu associated with the menu item. If the menu item is not an item that opens a
            drop-down menu or submenu, this member is <see cref="P:Vanara.PInvoke.HMENU.NULL"/>.
            </param>
        </member>
        <member name="T:Vanara.PInvoke.User32.MENUITEMTEMPLATE">
            <summary>
            <para>Defines a menu item in a menu template.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMTEMPLATE.mtOption">
            <summary>
            <para>Type: <c>WORD</c></para>
            <para>
            One or more of the following predefined menu options that control the appearance of the menu item as shown in the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MF_CHECKED 0x00000008L</term>
            <term>Indicates that the menu item has a check mark next to it.</term>
            </item>
            <item>
            <term>MF_GRAYED 0x00000001L</term>
            <term>Indicates that the menu item is initially inactive and drawn with a gray effect.</term>
            </item>
            <item>
            <term>MF_HELP 0x00004000L</term>
            <term>Indicates that the menu item has a vertical separator to its left.</term>
            </item>
            <item>
            <term>MF_MENUBARBREAK 0x00000020L</term>
            <term>Indicates that the menu item is placed in a new column. The old and new columns are separated by a bar.</term>
            </item>
            <item>
            <term>MF_MENUBREAK 0x00000040L</term>
            <term>Indicates that the menu item is placed in a new column.</term>
            </item>
            <item>
            <term>MF_OWNERDRAW 0x00000100L</term>
            <term>
            Indicates that the owner window of the menu is responsible for drawing all visual aspects of the menu item, including
            highlighted, selected, and inactive states. This option is not valid for an item in a menu bar.
            </term>
            </item>
            <item>
            <term>MF_POPUP 0x00000010L</term>
            <term>Indicates that the item is one that opens a drop-down menu or submenu.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMTEMPLATE.mtID">
            <summary>
            <para>Type: <c>WORD</c></para>
            <para>
            The menu item identifier of a command item; a command item sends a command message to its owner window. The
            <c>MENUITEMTEMPLATE</c> structure for an item that opens a drop-down menu or submenu does not contain the <c>mtID</c> member.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMTEMPLATE.mtString">
            <summary>
            <para>Type: <c>WCHAR[1]</c></para>
            <para>The menu item.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MENUITEMTEMPLATEHEADER">
            <summary>
            <para>Defines the header for a menu template. A complete menu template consists of a header and one or more menu item lists.</para>
            </summary>
            <remarks>
            <para>One or more MENUITEMTEMPLATE structures are combined to form the menu item list.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMTEMPLATEHEADER.versionNumber">
            <summary>
            <para>Type: <c>WORD</c></para>
            <para>The version number. This member must be zero.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MENUITEMTEMPLATEHEADER.offset">
            <summary>
            <para>Type: <c>WORD</c></para>
            <para>
            The offset, in bytes, from the end of the header. The menu item list begins at this offset. Usually, this member is zero, and
            the menu item list follows immediately after the header.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SafeHMENU">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <see cref="T:Vanara.PInvoke.HMENU"/> that is disposed using <see cref="M:Vanara.PInvoke.User32.DestroyMenu(Vanara.PInvoke.HMENU)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHMENU.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHMENU"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHMENU.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHMENU"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHMENU.op_Implicit(Vanara.PInvoke.User32.SafeHMENU)~Vanara.PInvoke.HMENU">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.User32.SafeHMENU"/> to <see cref="T:Vanara.PInvoke.HMENU"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHMENU.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.TPMPARAMS">
            <summary>
            <para>Contains extended parameters for the TrackPopupMenuEx function.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TPMPARAMS.cbSize">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The size of structure, in bytes.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TPMPARAMS.rcExclude">
            <summary>
            <para>Type: <c>RECT</c></para>
            <para>The rectangle to be excluded when positioning the window, in screen coordinates.</para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.TPMPARAMS.#ctor(Vanara.PInvoke.RECT)">
            <summary>
            Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.TPMPARAMS"/> class.
            </summary>
            <param name="rExclude">The rectangle to exclude.</param>
        </member>
        <member name="F:Vanara.PInvoke.User32.BROADCAST_QUERY_DENY">
            <summary>Return this value when processing a broadcast message to deny a query.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.OCM__BASE">
            <summary>
            Used to define private messages for use by private window classes, usually of the form OCM__BASE+x, where x is an integer value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WM_APP">
            <summary>Used to define private messages, usually of the form WM_APP+x, where x is an integer value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WM_USER">
            <summary>
            Used to define private messages for use by private window classes, usually of the form WM_USER+x, where x is an integer value.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.Sendasyncproc">
            <summary>
            An application-defined callback function used with the SendMessageCallback function. The system passes the message to the
            callback function after passing the message to the destination window procedure. The <c>SENDASYNCPROC</c> type defines a pointer
            to this callback function. SendAsyncProc is a placeholder for the application-defined function name.
            </summary>
            <param name="hwnd">
            A handle to the window whose window procedure received the message.
            <para>
            If the SendMessageCallback function was called with its hwnd parameter set to HWND_BROADCAST, the system calls the SendAsyncProc
            function once for each top-level window.
            </para>
            </param>
            <param name="uMsg">The message.</param>
            <param name="dwData">An application-defined value sent from the SendMessageCallback function.</param>
            <param name="lResult">The result of the message processing.This value depends on the message.</param>
            <remarks>
            <para>
            You install a SendAsyncProc application-defined callback function by passing a <c>SENDASYNCPROC</c> pointer to the
            SendMessageCallback function.
            </para>
            <para>
            The callback function is only called when the thread that called SendMessageCallback calls GetMessage, PeekMessage, or WaitMessage.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.BSF">
            <summary>Flags used by BroadcastSystemMessage and BroadcastSystemMessageEx.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSF.BSF_ALLOWSFW">
            <summary>Enables the recipient to set the foreground window while processing the message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSF.BSF_FLUSHDISK">
            <summary>Flushes the disk after each recipient processes the message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSF.BSF_FORCEIFHUNG">
            <summary>Continues to broadcast the message, even if the time-out period elapses or one of the recipients is not responding.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSF.BSF_IGNORECURRENTTASK">
            <summary>
            Does not send the message to windows that belong to the current task. This prevents an application from receiving its own message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSF.BSF_NOHANG">
            <summary>
            Forces a non-responsive application to time out. If one of the recipients times out, do not continue broadcasting the message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSF.BSF_NOTIMEOUTIFNOTHUNG">
            <summary>Waits for a response to the message, as long as the recipient is not being unresponsive. Does not time out.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSF.BSF_POSTMESSAGE">
            <summary>Posts the message. Do not use in combination with BSF_QUERY.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSF.BSF_QUERY">
            <summary>
            Sends the message to one recipient at a time, sending to a subsequent recipient only if the current recipient returns TRUE.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSF.BSF_SENDNOTIFYMESSAGE">
            <summary>Sends the message using SendNotifyMessage function. Do not use in combination with BSF_QUERY.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSF.BSF_RETURNHDESK">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSF.BSF_LUID">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.User32.BSM">
            <summary>System message info flags used by BroadcastSystemMessage and BroadcastSystemMessageEx.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSM.BSM_ALLCOMPONENTS">
            <summary>Broadcast to all system components.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSM.BSM_ALLDESKTOPS">
            <summary>Broadcast to all desktops. Requires the SE_TCB_NAME privilege.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSM.BSM_APPLICATIONS">
            <summary>Broadcast to applications.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSM.BSM_VXDS">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSM.BSM_NETDRIVER">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSM.BSM_INSTALLABLEDRIVERS">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.User32.ISMEX">
            <summary>Return values from InSendMessageEx</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ISMEX.ISMEX_NOSEND">
            <summary>The message was not sent.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ISMEX.ISMEX_CALLBACK">
            <summary>The message was sent using the SendMessageCallback function. The thread that sent the message is not blocked.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ISMEX.ISMEX_NOTIFY">
            <summary>The message was sent using the SendNotifyMessage function. The thread that sent the message is not blocked.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ISMEX.ISMEX_REPLIED">
            <summary>The window procedure has processed the message. The thread that sent the message is no longer blocked.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ISMEX.ISMEX_SEND">
            <summary>
            The message was sent using the SendMessage or SendMessageTimeout function. If ISMEX_REPLIED is not set, the thread that sent
            the message is blocked.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MWMO">
            <summary>Flags for <see cref="M:Vanara.PInvoke.User32.MsgWaitForMultipleObjectsEx(System.UInt32,Vanara.PInvoke.HANDLE[],System.UInt32,Vanara.PInvoke.User32.QS,Vanara.PInvoke.User32.MWMO)"/></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MWMO.MWMO_ANY">
            <summary>
            The function returns when any one of the objects is signaled. The return value indicates the object whose state caused the
            function to return.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MWMO.MWMO_ALERTABLE">
            <summary>
            The function also returns if an APC has been queued to the thread with QueueUserAPC while the thread is in the waiting state.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MWMO.MWMO_INPUTAVAILABLE">
            <summary>
            The function returns if input exists for the queue, even if the input has been seen (but not removed) using a call to another
            function, such as PeekMessage.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MWMO.MWMO_WAITALL">
            <summary>
            The function returns when all objects in the pHandles array are signaled and an input event has been received, all at the
            same time.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.PM">
            <summary>Flags used by PeekMessage.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PM.M_NOREMOVE">
            <summary>Messages are not removed from the queue after processing by PeekMessage.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PM.PM_REMOVE">
            <summary>Messages are removed from the queue after processing by PeekMessage.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PM.PM_NOYIELD">
            <summary>
            Prevents the system from releasing any thread that is waiting for the caller to go idle (see WaitForInputIdle).
            <para>Combine this value with either PM_NOREMOVE or PM_REMOVE.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PM.PM_QS_INPUT">
            <summary>Process mouse and keyboard messages.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PM.PM_QS_POSTMESSAGE">
            <summary>Process all posted messages, including timers and hotkeys.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PM.PM_QS_PAINT">
            <summary>Process paint messages.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PM.PM_QS_SENDMESSAGE">
            <summary>Process all sent messages.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.QS">
            <summary>Flags used GetQueueStatus.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QS.QS_ALLEVENTS">
            <summary>An input, WM_TIMER, WM_PAINT, WM_HOTKEY, or posted message is in the queue.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QS.QS_ALLINPUT">
            <summary>Any message is in the queue.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QS.QS_ALLPOSTMESSAGE">
            <summary>A posted message (other than those listed here) is in the queue.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QS.QS_HOTKEY">
            <summary>A WM_HOTKEY message is in the queue.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QS.QS_INPUT">
            <summary>An input message is in the queue.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QS.QS_KEY">
            <summary>A WM_KEYUP, WM_KEYDOWN, WM_SYSKEYUP, or WM_SYSKEYDOWN message is in the queue.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QS.QS_MOUSE">
            <summary>A WM_MOUSEMOVE message or mouse-button message (WM_LBUTTONUP, WM_RBUTTONDOWN, and so on).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QS.QS_MOUSEBUTTON">
            <summary>A mouse-button message (WM_LBUTTONUP, WM_RBUTTONDOWN, and so on).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QS.QS_MOUSEMOVE">
            <summary>A WM_MOUSEMOVE message is in the queue.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QS.QS_PAINT">
            <summary>A WM_PAINT message is in the queue.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QS.QS_POSTMESSAGE">
            <summary>A posted message (other than those listed here) is in the queue.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QS.QS_RAWINPUT">
            <summary>
            A raw input message is in the queue. For more information, see Raw Input.
            <para>Windows 2000: This flag is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QS.QS_SENDMESSAGE">
            <summary>A message sent by another thread or application is in the queue.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QS.QS_TIMER">
            <summary>A WM_TIMER message is in the queue.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.QS.QS_TOUCH">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.QS.QS_POINTER">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.User32.SMTO">
            <summary>Flags used by the SendMessageTimeout function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SMTO.SMTO_ABORTIFHUNG">
            <summary>
            The function returns without waiting for the time-out period to elapse if the receiving thread appears to not respond or "hangs."
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SMTO.SMTO_BLOCK">
            <summary>Prevents the calling thread from processing any other requests until the function returns.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SMTO.SMTO_NORMAL">
            <summary>The calling thread is not prevented from processing other requests while waiting for the function to return.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SMTO.SMTO_NOTIMEOUTIFNOTHUNG">
            <summary>The function does not enforce the time-out period as long as the receiving thread is processing messages.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SMTO.SMTO_ERRORONEXIT">
            <summary>
            The function should return 0 if the receiving window is destroyed or its owning thread dies while the message is being processed.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.BroadcastSystemMessage(Vanara.PInvoke.User32.BSF,Vanara.PInvoke.User32.BSM@,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            Sends a message to the specified recipients. The recipients can be applications, installable drivers, network drivers,
            system-level device drivers, or any combination of these system components.
            </para>
            <para>To receive additional information if the request is defined, use the BroadcastSystemMessageEx function.</para>
            </summary>
            <param name="flags">
            <para>Type: <c>DWORD</c></para>
            <para>The broadcast option. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>BSF_ALLOWSFW 0x00000080</term>
            <term>Enables the recipient to set the foreground window while processing the message.</term>
            </item>
            <item>
            <term>BSF_FLUSHDISK 0x00000004</term>
            <term>Flushes the disk after each recipient processes the message.</term>
            </item>
            <item>
            <term>BSF_FORCEIFHUNG 0x00000020</term>
            <term>Continues to broadcast the message, even if the time-out period elapses or one of the recipients is not responding.</term>
            </item>
            <item>
            <term>BSF_IGNORECURRENTTASK 0x00000002</term>
            <term>
            Does not send the message to windows that belong to the current task. This prevents an application from receiving its own message.
            </term>
            </item>
            <item>
            <term>BSF_NOHANG 0x00000008</term>
            <term>
            Forces a non-responsive application to time out. If one of the recipients times out, do not continue broadcasting the message.
            </term>
            </item>
            <item>
            <term>BSF_NOTIMEOUTIFNOTHUNG 0x00000040</term>
            <term>Waits for a response to the message, as long as the recipient is not being unresponsive. Does not time out.</term>
            </item>
            <item>
            <term>BSF_POSTMESSAGE 0x00000010</term>
            <term>Posts the message. Do not use in combination with BSF_QUERY.</term>
            </item>
            <item>
            <term>BSF_QUERY 0x00000001</term>
            <term>
            Sends the message to one recipient at a time, sending to a subsequent recipient only if the current recipient returns TRUE.
            </term>
            </item>
            <item>
            <term>BSF_SENDNOTIFYMESSAGE 0x00000100</term>
            <term>Sends the message using SendNotifyMessage function. Do not use in combination with BSF_QUERY.</term>
            </item>
            </list>
            </param>
            <param name="lpInfo">
            <para>Type: <c>LPDWORD</c></para>
            <para>A pointer to a variable that contains and receives information about the recipients of the message.</para>
            <para>
            When the function returns, this variable receives a combination of these values identifying which recipients actually received
            the message.
            </para>
            <para>If this parameter is <c>NULL</c>, the function broadcasts to all components.</para>
            <para>This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>BSM_ALLCOMPONENTS 0x00000000</term>
            <term>Broadcast to all system components.</term>
            </item>
            <item>
            <term>BSM_ALLDESKTOPS 0x00000010</term>
            <term>Broadcast to all desktops. Requires the SE_TCB_NAME privilege.</term>
            </item>
            <item>
            <term>BSM_APPLICATIONS 0x00000008</term>
            <term>Broadcast to applications.</term>
            </item>
            </list>
            </param>
            <param name="Msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>long</c></c></para>
            <para>If the function succeeds, the return value is a positive value.</para>
            <para>If the function is unable to broadcast the message, the return value is –1.</para>
            <para>
            If the dwFlags parameter is <c>BSF_QUERY</c> and at least one recipient returned <c>BROADCAST_QUERY_DENY</c> to the corresponding
            message, the return value is zero. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            If <c>BSF_QUERY</c> is not specified, the function sends the specified message to all requested recipients, ignoring values
            returned by those recipients.
            </para>
            <para>
            The system only does marshaling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshaling.
            </para>
            <para>Examples</para>
            <para>For an example, see Terminating a Process.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.BroadcastSystemMessageEx(Vanara.PInvoke.User32.BSF,Vanara.PInvoke.User32.BSM@,System.UInt32,System.IntPtr,System.IntPtr,Vanara.PInvoke.User32.BSMINFO@)">
            <summary>
            <para>
            Sends a message to the specified recipients. The recipients can be applications, installable drivers, network drivers,
            system-level device drivers, or any combination of these system components.
            </para>
            <para>This function is similar to BroadcastSystemMessage except that this function can return more information from the recipients.</para>
            </summary>
            <param name="flags">
            <para>Type: <c>DWORD</c></para>
            <para>The broadcast option. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>BSF_ALLOWSFW 0x00000080</term>
            <term>Enables the recipient to set the foreground window while processing the message.</term>
            </item>
            <item>
            <term>BSF_FLUSHDISK 0x00000004</term>
            <term>Flushes the disk after each recipient processes the message.</term>
            </item>
            <item>
            <term>BSF_FORCEIFHUNG 0x00000020</term>
            <term>Continues to broadcast the message, even if the time-out period elapses or one of the recipients is not responding.</term>
            </item>
            <item>
            <term>BSF_IGNORECURRENTTASK 0x00000002</term>
            <term>
            Does not send the message to windows that belong to the current task. This prevents an application from receiving its own message.
            </term>
            </item>
            <item>
            <term>BSF_LUID 0x00000400</term>
            <term>
            If BSF_LUID is set, the message is sent to the window that has the same LUID as specified in the luid member of the BSMINFO
            structure. Windows 2000: This flag is not supported.
            </term>
            </item>
            <item>
            <term>BSF_NOHANG 0x00000008</term>
            <term>
            Forces a non-responsive application to time out. If one of the recipients times out, do not continue broadcasting the message.
            </term>
            </item>
            <item>
            <term>BSF_NOTIMEOUTIFNOTHUNG 0x00000040</term>
            <term>Waits for a response to the message, as long as the recipient is not being unresponsive. Does not time out.</term>
            </item>
            <item>
            <term>BSF_POSTMESSAGE 0x00000010</term>
            <term>Posts the message. Do not use in combination with BSF_QUERY.</term>
            </item>
            <item>
            <term>BSF_RETURNHDESK 0x00000200</term>
            <term>
            If access is denied and both this and BSF_QUERY are set, BSMINFO returns both the desktop handle and the window handle. If access
            is denied and only BSF_QUERY is set, only the window handle is returned by BSMINFO. Windows 2000: This flag is not supported.
            </term>
            </item>
            <item>
            <term>BSF_QUERY 0x00000001</term>
            <term>
            Sends the message to one recipient at a time, sending to a subsequent recipient only if the current recipient returns TRUE.
            </term>
            </item>
            <item>
            <term>BSF_SENDNOTIFYMESSAGE 0x00000100</term>
            <term>Sends the message using SendNotifyMessage function. Do not use in combination with BSF_QUERY.</term>
            </item>
            </list>
            </param>
            <param name="lpInfo">
            <para>Type: <c>LPDWORD</c></para>
            <para>A pointer to a variable that contains and receives information about the recipients of the message.</para>
            <para>
            When the function returns, this variable receives a combination of these values identifying which recipients actually received
            the message.
            </para>
            <para>If this parameter is <c>NULL</c>, the function broadcasts to all components.</para>
            <para>This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>BSM_ALLCOMPONENTS 0x00000000</term>
            <term>Broadcast to all system components.</term>
            </item>
            <item>
            <term>BSM_ALLDESKTOPS 0x00000010</term>
            <term>Broadcast to all desktops. Requires the SE_TCB_NAME privilege.</term>
            </item>
            <item>
            <term>BSM_APPLICATIONS 0x00000008</term>
            <term>Broadcast to applications.</term>
            </item>
            </list>
            </param>
            <param name="Msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="pbsmInfo">
            <para>Type: <c>PBSMINFO</c></para>
            <para>A pointer to a BSMINFO structure that contains additional information if the request is denied and dwFlags is set to <c>BSF_QUERY</c>.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>long</c></c></para>
            <para>If the function succeeds, the return value is a positive value.</para>
            <para>If the function is unable to broadcast the message, the return value is –1.</para>
            <para>
            If the dwFlags parameter is <c>BSF_QUERY</c> and at least one recipient returned <c>BROADCAST_QUERY_DENY</c> to the corresponding
            message, the return value is zero. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            If <c>BSF_QUERY</c> is not specified, the function sends the specified message to all requested recipients, ignoring values
            returned by those recipients.
            </para>
            <para>
            If the caller's thread is on a desktop other than that of the window that denied the request, the caller must call
            SetThreadDesktop <c>(hdesk)</c> to query anything on that window. Also, the caller must call CloseDesktop on the returned
            <c>hdesk</c> handle.
            </para>
            <para>
            The system only does marshaling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshaling.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DispatchMessage(Vanara.PInvoke.MSG@)">
            <summary>
            Dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the GetMessage function.
            </summary>
            <param name="lpMsg">
            <para>Type: <c>const MSG*</c></para>
            <para>A pointer to a structure that contains the message.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>LRESULT</c></c></para>
            <para>
            The return value specifies the value returned by the window procedure. Although its meaning depends on the message being
            dispatched, the return value generally is ignored.
            </para>
            </returns>
            <remarks>
            <para>
            The MSG structure must contain valid message values. If the <paramref name="lpMsg"/> parameter points to a WM_TIMER message and
            the lParam parameter of the <c>WM_TIMER</c> message is not <c>NULL</c>, lParam points to a function that is called instead of the
            window procedure.
            </para>
            <para>
            Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use
            the main message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the
            application must call IsDialogMessage. For more information, see Dialog Box Keyboard Interface.
            </para>
            <para>Examples</para>
            <para>For an example, see Creating a Message Loop.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.FreeDDElParam(System.UInt32,System.IntPtr)">
            <summary>
            Frees the memory specified by the lParam parameter of a posted Dynamic Data Exchange (DDE) message. An application receiving a
            posted DDE message should call this function after it has used the UnpackDDElParam function to unpack the lParam value.
            </summary>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The posted DDE message.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>The lParam parameter of the posted DDE message.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>An application should call this function only for posted DDE messages.</para>
            <para>This function frees the memory specified by the lParam parameter. It does not free the contents of lParam.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetInputState">
            <summary>Determines whether there are mouse-button or keyboard messages in the calling thread's message queue.</summary>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the queue contains one or more new mouse-button or keyboard messages, the return value is nonzero.</para>
            <para>If there are no new mouse-button or keyboard messages in the queue, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMessage(Vanara.PInvoke.MSG@,Vanara.PInvoke.HWND,System.UInt32,System.UInt32)">
            <summary>
            <para>
            Retrieves a message from the calling thread's message queue. The function dispatches incoming sent messages until a posted
            message is available for retrieval.
            </para>
            <para>Unlike <c>GetMessage</c>, the PeekMessage function does not wait for a message to be posted before returning.</para>
            </summary>
            <param name="lpMsg">
            <para>Type: <c>LPMSG</c></para>
            <para>A pointer to an MSG structure that receives message information from the thread's message queue.</para>
            </param>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose messages are to be retrieved. The window must belong to the current thread.</para>
            <para>
            If hWnd is <c>NULL</c>, <c>GetMessage</c> retrieves messages for any window that belongs to the current thread, and any messages
            on the current thread's message queue whose <c>hwnd</c> value is <c>NULL</c> (see the MSG structure). Therefore if hWnd is
            <c>NULL</c>, both window messages and thread messages are processed.
            </para>
            <para>
            If hWnd is -1, <c>GetMessage</c> retrieves only messages on the current thread's message queue whose <c>hwnd</c> value is
            <c>NULL</c>, that is, thread messages as posted by PostMessage (when the hWnd parameter is <c>NULL</c>) or PostThreadMessage.
            </para>
            </param>
            <param name="wMsgFilterMin">
            <para>Type: <c>UINT</c></para>
            <para>
            The integer value of the lowest message value to be retrieved. Use <c>WM_KEYFIRST</c> (0x0100) to specify the first keyboard
            message or <c>WM_MOUSEFIRST</c> (0x0200) to specify the first mouse message.
            </para>
            <para>Use WM_INPUT here and in wMsgFilterMax to specify only the <c>WM_INPUT</c> messages.</para>
            <para>
            If wMsgFilterMin and wMsgFilterMax are both zero, <c>GetMessage</c> returns all available messages (that is, no range filtering
            is performed).
            </para>
            </param>
            <param name="wMsgFilterMax">
            <para>Type: <c>UINT</c></para>
            <para>
            The integer value of the highest message value to be retrieved. Use <c>WM_KEYLAST</c> to specify the last keyboard message or
            <c>WM_MOUSELAST</c> to specify the last mouse message.
            </para>
            <para>Use WM_INPUT here and in wMsgFilterMin to specify only the <c>WM_INPUT</c> messages.</para>
            <para>
            If wMsgFilterMin and wMsgFilterMax are both zero, <c>GetMessage</c> returns all available messages (that is, no range filtering
            is performed).
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function retrieves a message other than WM_QUIT, the return value is nonzero.</para>
            <para>If the function retrieves the WM_QUIT message, the return value is zero.</para>
            <para>
            If there is an error, the return value is -1. For example, the function fails if hWnd is an invalid window handle or lpMsg is an
            invalid pointer. To get extended error information, call GetLastError.
            </para>
            <para>Because the return value can be nonzero, zero, or -1, avoid code like this:</para>
            <para>
            The possibility of a -1 return value in the case that hWnd is an invalid parameter (such as referring to a window that has
            already been destroyed) means that such code can lead to fatal application errors. Instead, use code like this:
            </para>
            </returns>
            <remarks>
            <para>An application typically uses the return value to determine whether to end the main message loop and exit the program.</para>
            <para>
            The <c>GetMessage</c> function retrieves messages associated with the window identified by the hWnd parameter or any of its
            children, as specified by the IsChild function, and within the range of message values given by the wMsgFilterMin and
            wMsgFilterMax parameters. Note that an application can only use the low word in the wMsgFilterMin and wMsgFilterMax parameters;
            the high word is reserved for the system.
            </para>
            <para>
            Note that <c>GetMessage</c> always retrieves WM_QUIT messages, no matter which values you specify for wMsgFilterMin and wMsgFilterMax.
            </para>
            <para>
            During this call, the system delivers pending, non-queued messages, that is, messages sent to windows owned by the calling thread
            using the SendMessage, SendMessageCallback, SendMessageTimeout, or SendNotifyMessage function. Then the first queued message that
            matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are
            processed in the following order:
            </para>
            <list type="bullet">
            <item>
            <term>Sent messages</term>
            </item>
            <item>
            <term>Posted messages</term>
            </item>
            <item>
            <term>Input (hardware) messages and system internal events</term>
            </item>
            <item>
            <term>Sent messages (again)</term>
            </item>
            <item>
            <term>WM_PAINT messages</term>
            </item>
            <item>
            <term>WM_TIMER messages</term>
            </item>
            </list>
            <para>To retrieve input messages before posted messages, use the wMsgFilterMin and wMsgFilterMax parameters.</para>
            <para><c>GetMessage</c> does not remove WM_PAINT messages from the queue. The messages remain in the queue until processed.</para>
            <para>
            If a top-level window stops responding to messages for more than several seconds, the system considers the window to be not
            responding and replaces it with a ghost window that has the same z-order, location, size, and visual attributes. This allows the
            user to move it, resize it, or even close the application. However, these are the only actions available because the application
            is actually not responding. When in the debugger mode, the system does not generate a ghost window.
            </para>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. The output is in the mode of the window that the message is targeting. The
            calling thread is not taken into consideration.
            </para>
            <para>Examples</para>
            <para>For an example, see Creating a Message Loop.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMessageExtraInfo">
            <summary>
            Retrieves the extra message information for the current thread. Extra message information is an application- or driver-defined
            value associated with the current thread's message queue.
            </summary>
            <returns>
            <para>Type: <c>Type: <c>LPARAM</c></c></para>
            <para>The return value specifies the extra information. The meaning of the extra information is device specific.</para>
            </returns>
            <remarks>To set a thread's extra message information, use the SetMessageExtraInfo function.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMessagePos">
            <summary>
            <para>Retrieves the cursor position for the last message retrieved by the GetMessage function.</para>
            <para>To determine the current position of the cursor, use the GetCursorPos function.</para>
            </summary>
            <returns>
            <para>Type: <c>Type: <c>DWORD</c></c></para>
            <para>
            The return value specifies the x- and y-coordinates of the cursor position. The x-coordinate is the low order <c>short</c> and
            the y-coordinate is the high-order <c>short</c>.
            </para>
            </returns>
            <remarks>
            <para>
            As noted above, the x-coordinate is in the low-order <c>short</c> of the return value; the y-coordinate is in the high-order
            <c>short</c> (both represent signed values because they can take negative values on systems with multiple monitors). If the
            return value is assigned to a variable, you can use the MAKEPOINTS macro to obtain a POINTS structure from the return value. You
            can also use the GET_X_LPARAM or GET_Y_LPARAM macro to extract the x- or y-coordinate.
            </para>
            <para>
            <c>Important</c> Do not use the LOWORD or HIWORD macros to extract the x- and y- coordinates of the cursor position because these
            macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x- and y-
            coordinates, and <c>LOWORD</c> and <c>HIWORD</c> treat the coordinates as unsigned quantities.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMessageTime">
            <summary>
            Retrieves the message time for the last message retrieved by the GetMessage function. The time is a long integer that specifies
            the elapsed time, in milliseconds, from the time the system was started to the time the message was created (that is, placed in
            the thread's message queue).
            </summary>
            <returns>
            <para>Type: <c>Type: <c>LONG</c></c></para>
            <para>The return value specifies the message time.</para>
            </returns>
            <remarks>
            <para>
            The return value from the <c>GetMessageTime</c> function does not necessarily increase between subsequent messages, because the
            value wraps to wraps to the minimum value for a long integer if the timer count exceeds the maximum value for a long integer.
            </para>
            <para>
            To calculate time delays between messages, subtract the time of the first message from the time of the second message (ignoring
            overflow) and compare the result of the subtraction against the desired delay amount.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetQueueStatus(Vanara.PInvoke.User32.QS)">
            <summary>Retrieves the type of messages found in the calling thread's message queue.</summary>
            <param name="flags">
            <para>Type: <c>UINT</c></para>
            <para>The types of messages for which to check. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>QS_ALLEVENTS (QS_INPUT | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_HOTKEY)</term>
            <term>An input, WM_TIMER, WM_PAINT, WM_HOTKEY, or posted message is in the queue.</term>
            </item>
            <item>
            <term>QS_ALLINPUT (QS_INPUT | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_HOTKEY | QS_SENDMESSAGE)</term>
            <term>Any message is in the queue.</term>
            </item>
            <item>
            <term>QS_ALLPOSTMESSAGE 0x0100</term>
            <term>A posted message (other than those listed here) is in the queue.</term>
            </item>
            <item>
            <term>QS_HOTKEY 0x0080</term>
            <term>A WM_HOTKEY message is in the queue.</term>
            </item>
            <item>
            <term>QS_INPUT (QS_MOUSE | QS_KEY | QS_RAWINPUT)</term>
            <term>An input message is in the queue.</term>
            </item>
            <item>
            <term>QS_KEY 0x0001</term>
            <term>A WM_KEYUP, WM_KEYDOWN, WM_SYSKEYUP, or WM_SYSKEYDOWN message is in the queue.</term>
            </item>
            <item>
            <term>QS_MOUSE (QS_MOUSEMOVE | QS_MOUSEBUTTON)</term>
            <term>A WM_MOUSEMOVE message or mouse-button message (WM_LBUTTONUP, WM_RBUTTONDOWN, and so on).</term>
            </item>
            <item>
            <term>QS_MOUSEBUTTON 0x0004</term>
            <term>A mouse-button message (WM_LBUTTONUP, WM_RBUTTONDOWN, and so on).</term>
            </item>
            <item>
            <term>QS_MOUSEMOVE 0x0002</term>
            <term>A WM_MOUSEMOVE message is in the queue.</term>
            </item>
            <item>
            <term>QS_PAINT 0x0020</term>
            <term>A WM_PAINT message is in the queue.</term>
            </item>
            <item>
            <term>QS_POSTMESSAGE 0x0008</term>
            <term>A posted message (other than those listed here) is in the queue.</term>
            </item>
            <item>
            <term>QS_RAWINPUT 0x0400</term>
            <term>A raw input message is in the queue. For more information, see Raw Input. Windows 2000: This flag is not supported.</term>
            </item>
            <item>
            <term>QS_SENDMESSAGE 0x0040</term>
            <term>A message sent by another thread or application is in the queue.</term>
            </item>
            <item>
            <term>QS_TIMER 0x0010</term>
            <term>A WM_TIMER message is in the queue.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>DWORD</c></c></para>
            <para>
            The high-order word of the return value indicates the types of messages currently in the queue. The low-order word indicates the
            types of messages that have been added to the queue and that are still in the queue since the last call to the
            <c>GetQueueStatus</c>, GetMessage, or PeekMessage function.
            </para>
            </returns>
            <remarks>
            <para>
            The presence of a QS_ flag in the return value does not guarantee that a subsequent call to the GetMessage or PeekMessage
            function will return a message. <c>GetMessage</c> and <c>PeekMessage</c> perform some internal filtering that may cause the
            message to be processed internally. For this reason, the return value from <c>GetQueueStatus</c> should be considered only a hint
            as to whether <c>GetMessage</c> or <c>PeekMessage</c> should be called.
            </para>
            <para>
            The <c>QS_ALLPOSTMESSAGE</c> and <c>QS_POSTMESSAGE</c> flags differ in when they are cleared. <c>QS_POSTMESSAGE</c> is cleared
            when you call GetMessage or PeekMessage, whether or not you are filtering messages. <c>QS_ALLPOSTMESSAGE</c> is cleared when you
            call <c>GetMessage</c> or <c>PeekMessage</c> without filtering messages (wMsgFilterMin and wMsgFilterMax are 0). This can be
            useful when you call <c>PeekMessage</c> multiple times to get messages in different ranges.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.InSendMessage">
            <summary>
            <para>
            Determines whether the current window procedure is processing a message that was sent from another thread (in the same process or
            a different process) by a call to the SendMessage function.
            </para>
            <para>To obtain additional information about how the message was sent, use the InSendMessageEx function.</para>
            </summary>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>
            If the window procedure is processing a message sent to it from another thread using the SendMessage function, the return value
            is nonzero.
            </para>
            <para>
            If the window procedure is not processing a message sent to it from another thread using the SendMessage function, the return
            value is zero.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.InSendMessageEx(System.IntPtr)">
            <summary>
            Determines whether the current window procedure is processing a message that was sent from another thread (in the same process or
            a different process).
            </summary>
            <param name="lpReserved">
            <para>Type: <c>LPVOID</c></para>
            <para>Reserved; must be <c>NULL</c>.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>DWORD</c></c></para>
            <para>
            If the message was not sent, the return value is <c>ISMEX_NOSEND</c> (0x00000000). Otherwise, the return value is one or more of
            the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code/value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ISMEX_CALLBACK 0x00000004</term>
            <term>The message was sent using the SendMessageCallback function. The thread that sent the message is not blocked.</term>
            </item>
            <item>
            <term>ISMEX_NOTIFY 0x00000002</term>
            <term>The message was sent using the SendNotifyMessage function. The thread that sent the message is not blocked.</term>
            </item>
            <item>
            <term>ISMEX_REPLIED 0x00000008</term>
            <term>The window procedure has processed the message. The thread that sent the message is no longer blocked.</term>
            </item>
            <item>
            <term>ISMEX_SEND 0x00000001</term>
            <term>
            The message was sent using the SendMessage or SendMessageTimeout function. If ISMEX_REPLIED is not set, the thread that sent the
            message is blocked.
            </term>
            </item>
            </list>
            </returns>
            <remarks>To determine if the sender is blocked, use the following test:</remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsWow64Message">
            <summary>Determines whether the last message read from the current thread's queue originated from a WOW64 process.</summary>
            <returns>
            The function returns TRUE if the last message read from the current thread's queue originated from a WOW64 process, and FALSE otherwise.
            </returns>
            <remarks>
            <para>
            This function is useful to helping you develop 64-bit native applications that can receive private messages sent from 32-bit
            client applications, if the messages are associated with data structures that contain pointer-dependent data. In these
            situations, you can call this function in your 64-bit native application to determine if the message originated from a WOW64
            process and then thunk the message appropriately.
            </para>
            <para>Examples</para>
            <para>
            For compatibility with operating systems that do not support this function, call GetProcAddress to detect whether
            <c>IsWow64Message</c> is implemented in User32.dll. If <c>GetProcAddress</c> succeeds, it is safe to call this function.
            Otherwise, WOW64 is not present. Note that this technique is not a reliable way to detect whether the operating system is a
            64-bit version of Windows because the User32.dll in current versions of 32-bit Windows also contains this function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.MsgWaitForMultipleObjects(System.UInt32,Vanara.PInvoke.HANDLE[],System.Boolean,System.UInt32,Vanara.PInvoke.User32.QS)">
            <summary>
            <para>
            Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses. The objects can
            include input event objects, which you specify using the dwWakeMask parameter.
            </para>
            <para>To enter an alertable wait state, use the MsgWaitForMultipleObjectsEx function.</para>
            </summary>
            <param name="nCount">
            The number of object handles in the array pointed to by pHandles. The maximum number of object handles is
            <c>MAXIMUM_WAIT_OBJECTS</c> minus one. If this parameter has the value zero, then the function waits only for an input event.
            </param>
            <param name="pHandles">
            <para>
            An array of object handles. For a list of the object types whose handles can be specified, see the following Remarks section. The
            array can contain handles of objects of different types. It may not contain multiple copies of the same handle.
            </para>
            <para>If one of these handles is closed while the wait is still pending, the function's behavior is undefined.</para>
            <para>The handles must have the <c>SYNCHRONIZE</c> access right. For more information, see Standard Access Rights.</para>
            </param>
            <param name="fWaitAll">
            If this parameter is <c>TRUE</c>, the function returns when the states of all objects in the pHandles array have been set to
            signaled and an input event has been received. If this parameter is <c>FALSE</c>, the function returns when the state of any one
            of the objects is set to signaled or an input event has been received. In this case, the return value indicates the object whose
            state caused the function to return.
            </param>
            <param name="dwMilliseconds">
            The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are
            signaled or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the specified objects
            are not signaled; it always returns immediately. If dwMilliseconds is <c>INFINITE</c>, the function will return only when the
            specified objects are signaled.
            </param>
            <param name="dwWakeMask">
            <para>
            The input types for which an input event object handle will be added to the array of object handles. This parameter can be any
            combination of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>QS_ALLEVENTS 0x04BF</term>
            <term>
            An input, WM_TIMER, WM_PAINT, WM_HOTKEY, or posted message is in the queue. This value is a combination of QS_INPUT,
            QS_POSTMESSAGE, QS_TIMER, QS_PAINT, and QS_HOTKEY.
            </term>
            </item>
            <item>
            <term>QS_ALLINPUT 0x04FF</term>
            <term>
            Any message is in the queue. This value is a combination of QS_INPUT, QS_POSTMESSAGE, QS_TIMER, QS_PAINT, QS_HOTKEY, and QS_SENDMESSAGE.
            </term>
            </item>
            <item>
            <term>QS_ALLPOSTMESSAGE 0x0100</term>
            <term>A posted message is in the queue. This value is cleared when you call GetMessage or PeekMessage without filtering messages.</term>
            </item>
            <item>
            <term>QS_HOTKEY 0x0080</term>
            <term>A WM_HOTKEY message is in the queue.</term>
            </item>
            <item>
            <term>QS_INPUT 0x407</term>
            <term>An input message is in the queue. This value is a combination of QS_MOUSE, QS_KEY, and QS_RAWINPUT.</term>
            </item>
            <item>
            <term>QS_KEY 0x0001</term>
            <term>A WM_KEYUP, WM_KEYDOWN, WM_SYSKEYUP, or WM_SYSKEYDOWN message is in the queue.</term>
            </item>
            <item>
            <term>QS_MOUSE 0x0006</term>
            <term>
            A WM_MOUSEMOVE message or mouse-button message (WM_LBUTTONUP, WM_RBUTTONDOWN, and so on). This value is a combination of
            QS_MOUSEMOVE and QS_MOUSEBUTTON.
            </term>
            </item>
            <item>
            <term>QS_MOUSEBUTTON 0x0004</term>
            <term>A mouse-button message (WM_LBUTTONUP, WM_RBUTTONDOWN, and so on).</term>
            </item>
            <item>
            <term>QS_MOUSEMOVE 0x0002</term>
            <term>A WM_MOUSEMOVE message is in the queue.</term>
            </item>
            <item>
            <term>QS_PAINT 0x0020</term>
            <term>A WM_PAINT message is in the queue.</term>
            </item>
            <item>
            <term>QS_POSTMESSAGE 0x0008</term>
            <term>
            A posted message is in the queue. This value is cleared when you call GetMessage or PeekMessage, whether or not you are filtering messages.
            </term>
            </item>
            <item>
            <term>QS_RAWINPUT 0x0400</term>
            <term>A raw input message is in the queue. For more information, see Raw Input.</term>
            </item>
            <item>
            <term>QS_SENDMESSAGE 0x0040</term>
            <term>A message sent by another thread or application is in the queue.</term>
            </item>
            <item>
            <term>QS_TIMER 0x0010</term>
            <term>A WM_TIMER message is in the queue.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>
            If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following
            values. (Note that <c>WAIT_OBJECT_0</c> is defined as 0 and <c>WAIT_ABANDONED_0</c> is defined as 0x00000080L.)
            </para>
            <list type="table">
            <listheader>
            <term>Return code/value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>WAIT_OBJECT_0 to (WAIT_OBJECT_0 + nCount– 1)</term>
            <term>
            If bWaitAll is TRUE, the return value indicates that the state of all specified objects is signaled. If bWaitAll is FALSE, the
            return value minus WAIT_OBJECT_0 indicates the pHandles array index of the object that satisfied the wait.
            </term>
            </item>
            <item>
            <term>WAIT_OBJECT_0 + nCount</term>
            <term>
            New input of the type specified in the dwWakeMask parameter is available in the thread's input queue. Functions such as
            PeekMessage, GetMessage, and WaitMessage mark messages in the queue as old messages. Therefore, after you call one of these
            functions, a subsequent call to MsgWaitForMultipleObjects will not return until new input of the specified type arrives. This
            value is also returned upon the occurrence of a system event that requires the thread's action, such as foreground activation.
            Therefore, MsgWaitForMultipleObjects can return even though no appropriate input is available and even if dwWakeMask is set to 0.
            If this occurs, call GetMessage or PeekMessage to process the system event before trying the call to MsgWaitForMultipleObjects again.
            </term>
            </item>
            <item>
            <term>WAIT_ABANDONED_0 to (WAIT_ABANDONED_0 + nCount– 1)</term>
            <term>
            If bWaitAll is TRUE, the return value indicates that the state of all specified objects is signaled and at least one of the
            objects is an abandoned mutex object. If bWaitAll is FALSE, the return value minus WAIT_ABANDONED_0 indicates the pHandles array
            index of an abandoned mutex object that satisfied the wait. Ownership of the mutex object is granted to the calling thread, and
            the mutex is set to nonsignaled. If the mutex was protecting persistent state information, you should check it for consistency.
            </term>
            </item>
            <item>
            <term>WAIT_TIMEOUT 258L</term>
            <term>The time-out interval elapsed and the conditions specified by the bWaitAll and dwWakeMask parameters were not satisfied.</term>
            </item>
            <item>
            <term>WAIT_FAILED (DWORD)0xFFFFFFFF</term>
            <term>The function has failed. To get extended error information, call GetLastError.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>MsgWaitForMultipleObjects</c> function determines whether the wait criteria have been met. If the criteria have not been
            met, the calling thread enters the wait state until the conditions of the wait criteria have been met or the time-out interval elapses.
            </para>
            <para>
            When bWaitAll is <c>TRUE</c>, the function does not modify the states of the specified objects until the states of all objects
            have been set to signaled. For example, a mutex can be signaled, but the thread does not get ownership until the states of the
            other objects have also been set to signaled. In the meantime, some other thread may get ownership of the mutex, thereby setting
            its state to nonsignaled.
            </para>
            <para>
            When bWaitAll is <c>TRUE</c>, the function's wait is completed only when the states of all objects have been set to signaled and
            an input event has been received. Therefore, setting bWaitAll to <c>TRUE</c> prevents input from being processed until the state
            of all objects in the pHandles array have been set to signaled. For this reason, if you set bWaitAll to <c>TRUE</c>, you should
            use a short timeout value in dwMilliseconds. If you have a thread that creates windows waiting for all objects in the pHandles
            array, including input events specified by dwWakeMask, with no timeout interval, the system will deadlock. This is because
            threads that create windows must process messages. DDE sends message to all windows in the system. Therefore, if a thread creates
            windows, do not set the bWaitAll parameter to <c>TRUE</c> in calls to <c>MsgWaitForMultipleObjects</c> made from that thread.
            </para>
            <para>
            When bWaitAll is <c>FALSE</c>, this function checks the handles in the array in order starting with index 0, until one of the
            objects is signaled. If multiple objects become signaled, the function returns the index of the first handle in the array whose
            object was signaled.
            </para>
            <para>
            <c>MsgWaitForMultipleObjects</c> does not return if there is unread input of the specified type in the message queue after the
            thread has called a function to check the queue. This is because functions such as PeekMessage, GetMessage, GetQueueStatus, and
            WaitMessage check the queue and then change the state information for the queue so that the input is no longer considered new. A
            subsequent call to <c>MsgWaitForMultipleObjects</c> will not return until new input of the specified type arrives. The existing
            unread input (received prior to the last time the thread checked the queue) is ignored.
            </para>
            <para>
            The function modifies the state of some types of synchronization objects. Modification occurs only for the object or objects
            whose signaled state caused the function to return. For example, the count of a semaphore object is decreased by one. For more
            information, see the documentation for the individual synchronization objects.
            </para>
            <para>
            The <c>MsgWaitForMultipleObjects</c> function can specify handles of any of the following object types in the pHandles array:
            </para>
            <list type="bullet">
            <item>
            <term>Change notification</term>
            </item>
            <item>
            <term>Console input</term>
            </item>
            <item>
            <term>Event</term>
            </item>
            <item>
            <term>Memory resource notification</term>
            </item>
            <item>
            <term>Mutex</term>
            </item>
            <item>
            <term>Process</term>
            </item>
            <item>
            <term>Semaphore</term>
            </item>
            <item>
            <term>Thread</term>
            </item>
            <item>
            <term>Waitable timer</term>
            </item>
            </list>
            <para>
            The <c>QS_ALLPOSTMESSAGE</c> and <c>QS_POSTMESSAGE</c> flags differ in when they are cleared. <c>QS_POSTMESSAGE</c> is cleared
            when you call GetMessage or PeekMessage, whether or not you are filtering messages. <c>QS_ALLPOSTMESSAGE</c> is cleared when you
            call <c>GetMessage</c> or PeekMessage without filtering messages (wMsgFilterMin and wMsgFilterMax are 0). This can be useful when
            you call PeekMessage multiple times to get messages in different ranges.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.MsgWaitForMultipleObjectsEx(System.UInt32,Vanara.PInvoke.HANDLE[],System.UInt32,Vanara.PInvoke.User32.QS,Vanara.PInvoke.User32.MWMO)">
            <summary>
            <para>
            Waits until one or all of the specified objects are in the signaled state, an I/O completion routine or asynchronous procedure
            call (APC) is queued to the thread, or the time-out interval elapses. The array of objects can include input event objects, which
            you specify using the dwWakeMask parameter.
            </para>
            </summary>
            <param name="nCount">
            <para>
            The number of object handles in the array pointed to by pHandles. The maximum number of object handles is
            <c>MAXIMUM_WAIT_OBJECTS</c> minus one. If this parameter has the value zero, then the function waits only for an input event.
            </para>
            </param>
            <param name="pHandles">
            <para>
            An array of object handles. For a list of the object types whose handles you can specify, see the Remarks section later in this
            topic. The array can contain handles to multiple types of objects. It may not contain multiple copies of the same handle.
            </para>
            <para>If one of these handles is closed while the wait is still pending, the function's behavior is undefined.</para>
            <para>The handles must have the <c>SYNCHRONIZE</c> access right. For more information, see Standard Access Rights.</para>
            </param>
            <param name="dwMilliseconds">
            <para>
            The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are
            signaled, an I/O completion routine or APC is queued, or the interval elapses. If dwMilliseconds is zero, the function does not
            enter a wait state if the criteria is not met; it always returns immediately. If dwMilliseconds is <c>INFINITE</c>, the function
            will return only when the specified objects are signaled or an I/O completion routine or APC is queued.
            </para>
            </param>
            <param name="dwWakeMask">
            <para>
            The input types for which an input event object handle will be added to the array of object handles. This parameter can be one or
            more of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>QS_ALLEVENTS 0x04BF</term>
            <term>
            An input, WM_TIMER, WM_PAINT, WM_HOTKEY, or posted message is in the queue. This value is a combination of QS_INPUT,
            QS_POSTMESSAGE, QS_TIMER, QS_PAINT, and QS_HOTKEY.
            </term>
            </item>
            <item>
            <term>QS_ALLINPUT 0x04FF</term>
            <term>
            Any message is in the queue. This value is a combination of QS_INPUT, QS_POSTMESSAGE, QS_TIMER, QS_PAINT, QS_HOTKEY, and QS_SENDMESSAGE.
            </term>
            </item>
            <item>
            <term>QS_ALLPOSTMESSAGE 0x0100</term>
            <term>A posted message is in the queue. This value is cleared when you call GetMessage or PeekMessage without filtering messages.</term>
            </item>
            <item>
            <term>QS_HOTKEY 0x0080</term>
            <term>A WM_HOTKEY message is in the queue.</term>
            </item>
            <item>
            <term>QS_INPUT 0x407</term>
            <term>An input message is in the queue. This value is a combination of QS_MOUSE, QS_KEY, and QS_RAWINPUT.</term>
            </item>
            <item>
            <term>QS_KEY 0x0001</term>
            <term>A WM_KEYUP, WM_KEYDOWN, WM_SYSKEYUP, or WM_SYSKEYDOWN message is in the queue.</term>
            </item>
            <item>
            <term>QS_MOUSE 0x0006</term>
            <term>
            A WM_MOUSEMOVE message or mouse-button message (WM_LBUTTONUP, WM_RBUTTONDOWN, and so on). This value is a combination of
            QS_MOUSEMOVE and QS_MOUSEBUTTON.
            </term>
            </item>
            <item>
            <term>QS_MOUSEBUTTON 0x0004</term>
            <term>A mouse-button message (WM_LBUTTONUP, WM_RBUTTONDOWN, and so on).</term>
            </item>
            <item>
            <term>QS_MOUSEMOVE 0x0002</term>
            <term>A WM_MOUSEMOVE message is in the queue.</term>
            </item>
            <item>
            <term>QS_PAINT 0x0020</term>
            <term>A WM_PAINT message is in the queue.</term>
            </item>
            <item>
            <term>QS_POSTMESSAGE 0x0008</term>
            <term>
            A posted message is in the queue. This value is cleared when you call GetMessage or PeekMessage, whether or not you are filtering messages.
            </term>
            </item>
            <item>
            <term>QS_RAWINPUT 0x0400</term>
            <term>A raw input message is in the queue. For more information, see Raw Input.</term>
            </item>
            <item>
            <term>QS_SENDMESSAGE 0x0040</term>
            <term>A message sent by another thread or application is in the queue.</term>
            </item>
            <item>
            <term>QS_TIMER 0x0010</term>
            <term>A WM_TIMER message is in the queue.</term>
            </item>
            </list>
            </param>
            <param name="dwFlags">
            <para>The wait type. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>
            The function returns when any one of the objects is signaled. The return value indicates the object whose state caused the
            function to return.
            </term>
            </item>
            <item>
            <term>MWMO_ALERTABLE 0x0002</term>
            <term>
            The function also returns if an APC has been queued to the thread with QueueUserAPC while the thread is in the waiting state.
            </term>
            </item>
            <item>
            <term>MWMO_INPUTAVAILABLE 0x0004</term>
            <term>
            The function returns if input exists for the queue, even if the input has been seen (but not removed) using a call to another
            function, such as PeekMessage.
            </term>
            </item>
            <item>
            <term>MWMO_WAITALL 0x0001</term>
            <term>
            The function returns when all objects in the pHandles array are signaled and an input event has been received, all at the same time.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>
            If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following
            values. (Note that <c>WAIT_OBJECT_0</c> is defined as 0 and <c>WAIT_ABANDONED_0</c> is defined as 0x00000080L.)
            </para>
            <list type="table">
            <listheader>
            <term>Return code/value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>WAIT_OBJECT_0 to (WAIT_OBJECT_0 + nCount - 1)</term>
            <term>
            If the MWMO_WAITALL flag is used, the return value indicates that the state of all specified objects is signaled. Otherwise, the
            return value minus WAIT_OBJECT_0 indicates the pHandles array index of the object that caused the function to return.
            </term>
            </item>
            <item>
            <term>WAIT_OBJECT_0 + nCount</term>
            <term>
            New input of the type specified in the dwWakeMask parameter is available in the thread's input queue. Functions such as
            PeekMessage, GetMessage, GetQueueStatus, and WaitMessage mark messages in the queue as old messages. Therefore, after you call
            one of these functions, a subsequent call to MsgWaitForMultipleObjectsEx will not return until new input of the specified type
            arrives. This value is also returned upon the occurrence of a system event that requires the thread's action, such as foreground
            activation. Therefore, MsgWaitForMultipleObjectsEx can return even though no appropriate input is available and even if
            dwWakeMask is set to 0. If this occurs, call GetMessage or PeekMessage to process the system event before trying the call to
            MsgWaitForMultipleObjectsEx again.
            </term>
            </item>
            <item>
            <term>WAIT_ABANDONED_0 to (WAIT_ABANDONED_0 + nCount - 1)</term>
            <term>
            If the MWMO_WAITALL flag is used, the return value indicates that the state of all specified objects is signaled and at least one
            of the objects is an abandoned mutex object. Otherwise, the return value minus WAIT_ABANDONED_0 indicates the pHandles array
            index of an abandoned mutex object that caused the function to return. Ownership of the mutex object is granted to the calling
            thread, and the mutex is set to nonsignaled. If the mutex was protecting persistent state information, you should check it for consistency.
            </term>
            </item>
            <item>
            <term>WAIT_IO_COMPLETION 0x000000C0L</term>
            <term>The wait was ended by one or more user-mode asynchronous procedure calls (APC) queued to the thread.</term>
            </item>
            <item>
            <term>WAIT_TIMEOUT 258L</term>
            <term>The time-out interval elapsed, but the conditions specified by the dwFlags and dwWakeMask parameters were not met.</term>
            </item>
            <item>
            <term>WAIT_FAILED (DWORD)0xFFFFFFFF</term>
            <term>The function has failed. To get extended error information, call GetLastError.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>MsgWaitForMultipleObjectsEx</c> function determines whether the conditions specified by dwWakeMask and dwFlags have been
            met. If the conditions have not been met, the calling thread enters the wait state until the conditions of the wait criteria have
            been met or the time-out interval elapses.
            </para>
            <para>
            When dwFlags is zero, this function checks the handles in the array in order starting with index 0, until one of the objects is
            signaled. If multiple objects become signaled, the function returns the index of the first handle in the array whose object was signaled.
            </para>
            <para>
            <c>MsgWaitForMultipleObjectsEx</c> does not return if there is unread input of the specified type in the message queue after the
            thread has called a function to check the queue, unless you use the <c>MWMO_INPUTAVAILABLE</c> flag. This is because functions
            such as PeekMessage, GetMessage, GetQueueStatus, and WaitMessage check the queue and then change the state information for the
            queue so that the input is no longer considered new. A subsequent call to <c>MsgWaitForMultipleObjectsEx</c> will not return
            until new input of the specified type arrives, unless you use the <c>MWMO_INPUTAVAILABLE</c> flag. If this flag is not used, the
            existing unread input (received prior to the last time the thread checked the queue) is ignored.
            </para>
            <para>
            The function modifies the state of some types of synchronization objects. Modification occurs only for the object or objects
            whose signaled state caused the function to return. For example, the system decreases the count of a semaphore object by one. For
            more information, see the documentation for the individual synchronization objects.
            </para>
            <para>
            The <c>MsgWaitForMultipleObjectsEx</c> function can specify handles of any of the following object types in the pHandles array:
            </para>
            <list type="bullet">
            <item>
            <term>Change notification</term>
            </item>
            <item>
            <term>Console input</term>
            </item>
            <item>
            <term>Event</term>
            </item>
            <item>
            <term>Memory resource notification</term>
            </item>
            <item>
            <term>Mutex</term>
            </item>
            <item>
            <term>Process</term>
            </item>
            <item>
            <term>Semaphore</term>
            </item>
            <item>
            <term>Thread</term>
            </item>
            <item>
            <term>Waitable timer</term>
            </item>
            </list>
            <para>
            The <c>QS_ALLPOSTMESSAGE</c> and <c>QS_POSTMESSAGE</c> flags differ in when they are cleared. <c>QS_POSTMESSAGE</c> is cleared
            when you call GetMessage or PeekMessage, whether or not you are filtering messages. <c>QS_ALLPOSTMESSAGE</c> is cleared when you
            call <c>GetMessage</c> or <c>PeekMessage</c> without filtering messages (wMsgFilterMin and wMsgFilterMax are 0). This can be
            useful when you call <c>PeekMessage</c> multiple times to get messages in different ranges.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.PackDDElParam(System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>Packs a Dynamic Data Exchange (DDE) lParam value into an internal structure used for sharing DDE data between processes.</summary>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The DDE message to be posted.</para>
            </param>
            <param name="uiLo">
            <para>Type: <c>UINT_PTR</c></para>
            <para>A value that corresponds to the 16-bit Windows low-order word of an lParam parameter for the DDE message being posted.</para>
            </param>
            <param name="uiHi">
            <para>Type: <c>UINT_PTR</c></para>
            <para>A value that corresponds to the 16-bit Windows high-order word of an lParam parameter for the DDE message being posted.</para>
            </param>
            <returns>
            <para>Type: <c>LPARAM</c></para>
            <para>The return value is the lParam value.</para>
            </returns>
            <remarks>
            <para>
            The return value must be posted as the lParam parameter of a DDE message; it must not be used for any other purpose. After the
            application posts a return value, it need not perform any action to dispose of the lParam parameter.
            </para>
            <para>An application should call this function only for posted DDE messages.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.PeekMessage(Vanara.PInvoke.MSG@,Vanara.PInvoke.HWND,System.UInt32,System.UInt32,Vanara.PInvoke.User32.PM)">
            <summary>
            Dispatches incoming sent messages, checks the thread message queue for a posted message, and retrieves the message (if any exist).
            </summary>
            <param name="lpMsg">
            <para>Type: <c>LPMSG</c></para>
            <para>A pointer to an MSG structure that receives message information.</para>
            </param>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose messages are to be retrieved. The window must belong to the current thread.</para>
            <para>
            If hWnd is <c>NULL</c>, <c>PeekMessage</c> retrieves messages for any window that belongs to the current thread, and any messages
            on the current thread's message queue whose <c>hwnd</c> value is <c>NULL</c> (see the MSG structure). Therefore if hWnd is
            <c>NULL</c>, both window messages and thread messages are processed.
            </para>
            <para>
            If hWnd is -1, <c>PeekMessage</c> retrieves only messages on the current thread's message queue whose <c>hwnd</c> value is
            <c>NULL</c>, that is, thread messages as posted by PostMessage (when the hWnd parameter is <c>NULL</c>) or PostThreadMessage.
            </para>
            </param>
            <param name="wMsgFilterMin">
            <para>Type: <c>UINT</c></para>
            <para>
            The value of the first message in the range of messages to be examined. Use <c>WM_KEYFIRST</c> (0x0100) to specify the first
            keyboard message or <c>WM_MOUSEFIRST</c> (0x0200) to specify the first mouse message.
            </para>
            <para>
            If wMsgFilterMin and wMsgFilterMax are both zero, <c>PeekMessage</c> returns all available messages (that is, no range filtering
            is performed).
            </para>
            </param>
            <param name="wMsgFilterMax">
            <para>Type: <c>UINT</c></para>
            <para>
            The value of the last message in the range of messages to be examined. Use <c>WM_KEYLAST</c> to specify the last keyboard message
            or <c>WM_MOUSELAST</c> to specify the last mouse message.
            </para>
            <para>
            If wMsgFilterMin and wMsgFilterMax are both zero, <c>PeekMessage</c> returns all available messages (that is, no range filtering
            is performed).
            </para>
            </param>
            <param name="wRemoveMsg">
            <para>Type: <c>UINT</c></para>
            <para>Specifies how messages are to be handled. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>PM_NOREMOVE 0x0000</term>
            <term>Messages are not removed from the queue after processing by PeekMessage.</term>
            </item>
            <item>
            <term>PM_REMOVE 0x0001</term>
            <term>Messages are removed from the queue after processing by PeekMessage.</term>
            </item>
            <item>
            <term>PM_NOYIELD 0x0002</term>
            <term>
            Prevents the system from releasing any thread that is waiting for the caller to go idle (see WaitForInputIdle). Combine this
            value with either PM_NOREMOVE or PM_REMOVE.
            </term>
            </item>
            </list>
            <para>
            By default, all message types are processed. To specify that only certain message should be processed, specify one or more of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>PM_QS_INPUT (QS_INPUT &lt;&lt; 16)</term>
            <term>Process mouse and keyboard messages.</term>
            </item>
            <item>
            <term>PM_QS_PAINT (QS_PAINT &lt;&lt; 16)</term>
            <term>Process paint messages.</term>
            </item>
            <item>
            <term>PM_QS_POSTMESSAGE ((QS_POSTMESSAGE | QS_HOTKEY | QS_TIMER) &lt;&lt; 16)</term>
            <term>Process all posted messages, including timers and hotkeys.</term>
            </item>
            <item>
            <term>PM_QS_SENDMESSAGE (QS_SENDMESSAGE &lt;&lt; 16)</term>
            <term>Process all sent messages.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If a message is available, the return value is nonzero.</para>
            <para>If no messages are available, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            <c>PeekMessage</c> retrieves messages associated with the window identified by the hWnd parameter or any of its children as
            specified by the IsChild function, and within the range of message values given by the wMsgFilterMin and wMsgFilterMax
            parameters. Note that an application can only use the low word in the wMsgFilterMin and wMsgFilterMax parameters; the high word
            is reserved for the system.
            </para>
            <para>
            Note that <c>PeekMessage</c> always retrieves WM_QUIT messages, no matter which values you specify for wMsgFilterMin and wMsgFilterMax.
            </para>
            <para>
            During this call, the system delivers pending, non-queued messages, that is, messages sent to windows owned by the calling thread
            using the SendMessage, SendMessageCallback, SendMessageTimeout, or SendNotifyMessage function. Then the first queued message that
            matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are
            processed in the following order:
            </para>
            <list type="bullet">
            <item>
            <term>Sent messages</term>
            </item>
            <item>
            <term>Posted messages</term>
            </item>
            <item>
            <term>Input (hardware) messages and system internal events</term>
            </item>
            <item>
            <term>Sent messages (again)</term>
            </item>
            <item>
            <term>WM_PAINT messages</term>
            </item>
            <item>
            <term>WM_TIMER messages</term>
            </item>
            </list>
            <para>To retrieve input messages before posted messages, use the wMsgFilterMin and wMsgFilterMax parameters.</para>
            <para>
            The <c>PeekMessage</c> function normally does not remove WM_PAINT messages from the queue. <c>WM_PAINT</c> messages remain in the
            queue until they are processed. However, if a <c>WM_PAINT</c> message has a <c>NULL</c> update region, <c>PeekMessage</c> does
            remove it from the queue.
            </para>
            <para>
            If a top-level window stops responding to messages for more than several seconds, the system considers the window to be not
            responding and replaces it with a ghost window that has the same z-order, location, size, and visual attributes. This allows the
            user to move it, resize it, or even close the application. However, these are the only actions available because the application
            is actually not responding. When an application is being debugged, the system does not generate a ghost window.
            </para>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. The output is in the mode of the window that the message is targeting. The
            calling thread is not taken into consideration.
            </para>
            <para>Examples</para>
            <para>For an example, see Examining a Message Queue.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.PeekMessage``1(Vanara.PInvoke.MSG@,Vanara.PInvoke.HWND,``0,``0,Vanara.PInvoke.User32.PM)">
            <summary>
            Dispatches incoming sent messages, checks the thread message queue for a posted message, and retrieves the message (if any exist).
            </summary>
            <typeparam name="TMsg">The type of <paramref name="wMsgFilterMin"/> and <paramref name="wMsgFilterMax"/>.</typeparam>
            <param name="lpMsg">
            <para>Type: <c>LPMSG</c></para>
            <para>A pointer to an MSG structure that receives message information.</para>
            </param>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose messages are to be retrieved. The window must belong to the current thread.</para>
            <para>
            If hWnd is <c>NULL</c>, <c>PeekMessage</c> retrieves messages for any window that belongs to the current thread, and any messages
            on the current thread's message queue whose <c>hwnd</c> value is <c>NULL</c> (see the MSG structure). Therefore if hWnd is
            <c>NULL</c>, both window messages and thread messages are processed.
            </para>
            <para>
            If hWnd is -1, <c>PeekMessage</c> retrieves only messages on the current thread's message queue whose <c>hwnd</c> value is
            <c>NULL</c>, that is, thread messages as posted by PostMessage (when the hWnd parameter is <c>NULL</c>) or PostThreadMessage.
            </para>
            </param>
            <param name="wMsgFilterMin">
            <para>Type: <c>UINT</c></para>
            <para>
            The value of the first message in the range of messages to be examined. Use <c>WM_KEYFIRST</c> (0x0100) to specify the first
            keyboard message or <c>WM_MOUSEFIRST</c> (0x0200) to specify the first mouse message.
            </para>
            <para>
            If wMsgFilterMin and wMsgFilterMax are both zero, <c>PeekMessage</c> returns all available messages (that is, no range filtering
            is performed).
            </para>
            </param>
            <param name="wMsgFilterMax">
            <para>Type: <c>UINT</c></para>
            <para>
            The value of the last message in the range of messages to be examined. Use <c>WM_KEYLAST</c> to specify the last keyboard message
            or <c>WM_MOUSELAST</c> to specify the last mouse message.
            </para>
            <para>
            If wMsgFilterMin and wMsgFilterMax are both zero, <c>PeekMessage</c> returns all available messages (that is, no range filtering
            is performed).
            </para>
            </param>
            <param name="wRemoveMsg">
            <para>Type: <c>UINT</c></para>
            <para>Specifies how messages are to be handled. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>PM_NOREMOVE 0x0000</term>
            <term>Messages are not removed from the queue after processing by PeekMessage.</term>
            </item>
            <item>
            <term>PM_REMOVE 0x0001</term>
            <term>Messages are removed from the queue after processing by PeekMessage.</term>
            </item>
            <item>
            <term>PM_NOYIELD 0x0002</term>
            <term>
            Prevents the system from releasing any thread that is waiting for the caller to go idle (see WaitForInputIdle). Combine this
            value with either PM_NOREMOVE or PM_REMOVE.
            </term>
            </item>
            </list>
            <para>
            By default, all message types are processed. To specify that only certain message should be processed, specify one or more of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>PM_QS_INPUT (QS_INPUT &lt;&lt; 16)</term>
            <term>Process mouse and keyboard messages.</term>
            </item>
            <item>
            <term>PM_QS_PAINT (QS_PAINT &lt;&lt; 16)</term>
            <term>Process paint messages.</term>
            </item>
            <item>
            <term>PM_QS_POSTMESSAGE ((QS_POSTMESSAGE | QS_HOTKEY | QS_TIMER) &lt;&lt; 16)</term>
            <term>Process all posted messages, including timers and hotkeys.</term>
            </item>
            <item>
            <term>PM_QS_SENDMESSAGE (QS_SENDMESSAGE &lt;&lt; 16)</term>
            <term>Process all sent messages.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If a message is available, the return value is nonzero.</para>
            <para>If no messages are available, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            <c>PeekMessage</c> retrieves messages associated with the window identified by the hWnd parameter or any of its children as
            specified by the IsChild function, and within the range of message values given by the wMsgFilterMin and wMsgFilterMax
            parameters. Note that an application can only use the low word in the wMsgFilterMin and wMsgFilterMax parameters; the high word
            is reserved for the system.
            </para>
            <para>
            Note that <c>PeekMessage</c> always retrieves WM_QUIT messages, no matter which values you specify for wMsgFilterMin and wMsgFilterMax.
            </para>
            <para>
            During this call, the system delivers pending, non-queued messages, that is, messages sent to windows owned by the calling thread
            using the SendMessage, SendMessageCallback, SendMessageTimeout, or SendNotifyMessage function. Then the first queued message that
            matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are
            processed in the following order:
            </para>
            <list type="bullet">
            <item>
            <term>Sent messages</term>
            </item>
            <item>
            <term>Posted messages</term>
            </item>
            <item>
            <term>Input (hardware) messages and system internal events</term>
            </item>
            <item>
            <term>Sent messages (again)</term>
            </item>
            <item>
            <term>WM_PAINT messages</term>
            </item>
            <item>
            <term>WM_TIMER messages</term>
            </item>
            </list>
            <para>To retrieve input messages before posted messages, use the wMsgFilterMin and wMsgFilterMax parameters.</para>
            <para>
            The <c>PeekMessage</c> function normally does not remove WM_PAINT messages from the queue. <c>WM_PAINT</c> messages remain in the
            queue until they are processed. However, if a <c>WM_PAINT</c> message has a <c>NULL</c> update region, <c>PeekMessage</c> does
            remove it from the queue.
            </para>
            <para>
            If a top-level window stops responding to messages for more than several seconds, the system considers the window to be not
            responding and replaces it with a ghost window that has the same z-order, location, size, and visual attributes. This allows the
            user to move it, resize it, or even close the application. However, these are the only actions available because the application
            is actually not responding. When an application is being debugged, the system does not generate a ghost window.
            </para>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. The output is in the mode of the window that the message is targeting. The
            calling thread is not taken into consideration.
            </para>
            <para>Examples</para>
            <para>For an example, see Examining a Message Queue.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.PostMessage(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            Places (posts) a message in the message queue associated with the thread that created the specified window and returns without
            waiting for the thread to process the message.
            </para>
            <para>To post a message in the message queue associated with a thread, use the PostThreadMessage function.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose window procedure is to receive the message. The following values have special meanings.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>HWND_BROADCAST ((HWND)0xffff)</term>
            <term>
            The message is posted to all top-level windows in the system, including disabled or invisible unowned windows, overlapped
            windows, and pop-up windows. The message is not posted to child windows.
            </term>
            </item>
            <item>
            <term>NULL</term>
            <term>
            The function behaves like a call to PostThreadMessage with the dwThreadId parameter set to the identifier of the current thread.
            </term>
            </item>
            </list>
            <para>
            Starting with Windows Vista, message posting is subject to UIPI. The thread of a process can post messages only to message queues
            of threads in processes of lesser or equal integrity level.
            </para>
            </param>
            <param name="Msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be posted.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>
            If the function fails, the return value is zero. To get extended error information, call GetLastError. <c>GetLastError</c>
            returns <c>ERROR_NOT_ENOUGH_QUOTA</c> when the limit is hit.
            </para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>Messages in a message queue are retrieved by calls to the GetMessage or PeekMessage function.</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshaling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshaling.
            </para>
            <para>
            If you send a message in the range below WM_USER to the asynchronous message functions ( <c>PostMessage</c>, SendNotifyMessage,
            and SendMessageCallback), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will
            return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used.
            </para>
            <para>Do not post the WM_QUIT message using <c>PostMessage</c>; use the PostQuitMessage function.</para>
            <para>
            An accessibility application can use <c>PostMessage</c> to post WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>
            There is a limit of 10,000 posted messages per message queue. This limit should be sufficiently large. If your application
            exceeds the limit, it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the
            following registry key.
            </para>
            <para><c>HKEY_LOCAL_MACHINE</c><c>SOFTWARE</c><c>Microsoft</c><c>Windows NT</c><c>CurrentVersion</c><c>Windows</c><c>USERPostMessageLimit</c></para>
            <para>The minimum acceptable value is 4000.</para>
            <para>Examples</para>
            <para>
            The following example shows how to post a private window message using the <c>PostMessage</c> function. Assume you defined a
            private window message called <c>WM_COMPLETE</c>:
            </para>
            <para>You can post a message to the message queue associated with the thread that created the specified window as shown below:</para>
            <para>For more examples, see Initiating a Data Link.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.PostMessage``1(Vanara.PInvoke.HWND,``0,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            Places (posts) a message in the message queue associated with the thread that created the specified window and returns without
            waiting for the thread to process the message.
            </para>
            <para>To post a message in the message queue associated with a thread, use the PostThreadMessage function.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose window procedure is to receive the message. The following values have special meanings.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>HWND_BROADCAST ((HWND)0xffff)</term>
            <term>
            The message is posted to all top-level windows in the system, including disabled or invisible unowned windows, overlapped
            windows, and pop-up windows. The message is not posted to child windows.
            </term>
            </item>
            <item>
            <term>NULL</term>
            <term>
            The function behaves like a call to PostThreadMessage with the dwThreadId parameter set to the identifier of the current thread.
            </term>
            </item>
            </list>
            <para>
            Starting with Windows Vista, message posting is subject to UIPI. The thread of a process can post messages only to message queues
            of threads in processes of lesser or equal integrity level.
            </para>
            </param>
            <param name="Msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be posted.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>
            If the function fails, the return value is zero. To get extended error information, call GetLastError. <c>GetLastError</c>
            returns <c>ERROR_NOT_ENOUGH_QUOTA</c> when the limit is hit.
            </para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>Messages in a message queue are retrieved by calls to the GetMessage or PeekMessage function.</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshaling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshaling.
            </para>
            <para>
            If you send a message in the range below WM_USER to the asynchronous message functions ( <c>PostMessage</c>, SendNotifyMessage,
            and SendMessageCallback), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will
            return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used.
            </para>
            <para>Do not post the WM_QUIT message using <c>PostMessage</c>; use the PostQuitMessage function.</para>
            <para>
            An accessibility application can use <c>PostMessage</c> to post WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>
            There is a limit of 10,000 posted messages per message queue. This limit should be sufficiently large. If your application
            exceeds the limit, it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the
            following registry key.
            </para>
            <para><c>HKEY_LOCAL_MACHINE</c><c>SOFTWARE</c><c>Microsoft</c><c>Windows NT</c><c>CurrentVersion</c><c>Windows</c><c>USERPostMessageLimit</c></para>
            <para>The minimum acceptable value is 4000.</para>
            <para>Examples</para>
            <para>
            The following example shows how to post a private window message using the <c>PostMessage</c> function. Assume you defined a
            private window message called <c>WM_COMPLETE</c>:
            </para>
            <para>You can post a message to the message queue associated with the thread that created the specified window as shown below:</para>
            <para>For more examples, see Initiating a Data Link.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.PostQuitMessage(System.Int32)">
            <summary>
            Indicates to the system that a thread has made a request to terminate (quit). It is typically used in response to a WM_DESTROY message.
            </summary>
            <param name="nExitCode">
            <para>Type: <c>int</c></para>
            <para>The application exit code. This value is used as the wParam parameter of the WM_QUIT message.</para>
            </param>
            <remarks>
            <para>
            The <c>PostQuitMessage</c> function posts a WM_QUIT message to the thread's message queue and returns immediately; the function
            simply indicates to the system that the thread is requesting to quit at some time in the future.
            </para>
            <para>
            When the thread retrieves the WM_QUIT message from its message queue, it should exit its message loop and return control to the
            system. The exit value returned to the system must be the wParam parameter of the <c>WM_QUIT</c> message.
            </para>
            <para>Examples</para>
            <para>For an example, see Posting a Message.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.PostThreadMessage(System.UInt32,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Posts a message to the message queue of the specified thread. It returns without waiting for the thread to process the message.
            </summary>
            <param name="idThread">
            <para>Type: <c>DWORD</c></para>
            <para>The identifier of the thread to which the message is to be posted.</para>
            <para>
            The function fails if the specified thread does not have a message queue. The system creates a thread's message queue when the
            thread makes its first call to one of the User or GDI functions. For more information, see the Remarks section.
            </para>
            <para>
            Message posting is subject to UIPI. The thread of a process can post messages only to posted-message queues of threads in
            processes of lesser or equal integrity level.
            </para>
            <para>
            This thread must have the <c>SE_TCB_NAME</c> privilege to post a message to a thread that belongs to a process with the same
            locally unique identifier (LUID) but is in a different desktop. Otherwise, the function fails and returns <c>ERROR_INVALID_THREAD_ID</c>.
            </para>
            <para>
            This thread must either belong to the same desktop as the calling thread or to a process with the same LUID. Otherwise, the
            function fails and returns <c>ERROR_INVALID_THREAD_ID</c>.
            </para>
            </param>
            <param name="Msg">
            <para>Type: <c>UINT</c></para>
            <para>The type of message to be posted.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>
            If the function fails, the return value is zero. To get extended error information, call GetLastError. <c>GetLastError</c>
            returns <c>ERROR_INVALID_THREAD_ID</c> if idThread is not a valid thread identifier, or if the thread specified by idThread does
            not have a message queue. <c>GetLastError</c> returns <c>ERROR_NOT_ENOUGH_QUOTA</c> when the message limit is hit.
            </para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>
            The thread to which the message is posted must have created a message queue, or else the call to <c>PostThreadMessage</c> fails.
            Use the following method to handle this situation.
            </para>
            <list type="bullet">
            <item>
            <term>Create an event object, then create the thread.</term>
            </item>
            <item>
            <term>Use the WaitForSingleObject function to wait for the event to be set to the signaled state before calling <c>PostThreadMessage</c>.</term>
            </item>
            <item>
            <term>
            In the thread to which the message will be posted, call PeekMessage as shown here to force the system to create the message queue.
            </term>
            </item>
            <item>
            <term>Set the event, to indicate that the thread is ready to receive posted messages.</term>
            </item>
            </list>
            <para>
            The thread to which the message is posted retrieves the message by calling the GetMessage or PeekMessage function. The
            <c>hwnd</c> member of the returned MSG structure is <c>NULL</c>.
            </para>
            <para>
            Messages sent by <c>PostThreadMessage</c> are not associated with a window. As a general rule, messages that are not associated
            with a window cannot be dispatched by the DispatchMessage function. Therefore, if the recipient thread is in a modal loop (as
            used by MessageBox or DialogBox), the messages will be lost. To intercept thread messages while in a modal loop, use a
            thread-specific hook.
            </para>
            <para>
            The system only does marshaling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshaling.
            </para>
            <para>
            There is a limit of 10,000 posted messages per message queue. This limit should be sufficiently large. If your application
            exceeds the limit, it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the
            following registry key.
            </para>
            <para><c>HKEY_LOCAL_MACHINE</c><c>SOFTWARE</c><c>Microsoft</c><c>Windows NT</c><c>CurrentVersion</c><c>Windows</c><c>USERPostMessageLimit</c></para>
            <para>The minimum acceptable value is 4000.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterWindowMessage(System.String)">
            <summary>
            Defines a new window message that is guaranteed to be unique throughout the system. The message value can be used when sending or
            posting messages.
            </summary>
            <param name="lpString">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The message to be registered.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>UINT</c></c></para>
            <para>If the message is successfully registered, the return value is a message identifier in the range 0xC000 through 0xFFFF.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>RegisterWindowMessage</c> function is typically used to register messages for communicating between two cooperating applications.
            </para>
            <para>
            If two different applications register the same message string, the applications return the same message value. The message
            remains registered until the session ends.
            </para>
            <para>
            Only use <c>RegisterWindowMessage</c> when more than one application must process the same message. For sending private messages
            within a window class, an application can use any integer in the range WM_USER through 0x7FFF. (Messages in this range are
            private to a window class, not to an application. For example, predefined control classes such as <c>BUTTON</c>, <c>EDIT</c>,
            <c>LISTBOX</c>, and <c>COMBOBOX</c> may use values in this range.)
            </para>
            <para>Examples</para>
            <para>For an example, see Finding Text.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ReplyMessage(System.IntPtr)">
            <summary>Replies to a message sent from another thread by the SendMessage function.</summary>
            <param name="lResult">
            <para>Type: <c>LRESULT</c></para>
            <para>The result of the message processing. The possible values are based on the message sent.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the calling thread was processing a message sent from another thread or process, the return value is nonzero.</para>
            <para>If the calling thread was not processing a message sent from another thread or process, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            By calling this function, the window procedure that receives the message allows the thread that called SendMessage to continue to
            run as though the thread receiving the message had returned control. The thread that calls the <c>ReplyMessage</c> function also
            continues to run.
            </para>
            <para>
            If the message was not sent through SendMessage or if the message was sent by the same thread, <c>ReplyMessage</c> has no effect.
            </para>
            <para>Examples</para>
            <para>For an example, see Sending a Message.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ReuseDDElParam(System.IntPtr,System.UInt32,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Enables an application to reuse a packed Dynamic Data Exchange (DDE) lParam parameter, rather than allocating a new packed
            lParam. Using this function reduces reallocations for applications that pass packed DDE messages.
            </summary>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>The lParam parameter of the posted DDE message being reused.</para>
            </param>
            <param name="msgIn">
            <para>Type: <c>UINT</c></para>
            <para>The identifier of the received DDE message.</para>
            </param>
            <param name="msgOut">
            <para>Type: <c>UINT</c></para>
            <para>The identifier of the DDE message to be posted. The DDE message will reuse the packed lParam parameter.</para>
            </param>
            <param name="uiLo">
            <para>Type: <c>UINT_PTR</c></para>
            <para>The value to be packed into the low-order word of the reused lParam parameter.</para>
            </param>
            <param name="uiHi">
            <para>Type: <c>UINT_PTR</c></para>
            <para>The value to be packed into the high-order word of the reused lParam parameter.</para>
            </param>
            <returns>
            <para>Type: <c>LPARAM</c></para>
            <para>The return value is the new lParam value.</para>
            </returns>
            <remarks>
            <para>
            The return value must be posted as the lParam parameter of a DDE message; it must not be used for any other purpose. Once the
            return value is posted, the posting application need not perform any action to dispose of the lParam parameter.
            </para>
            <para>
            Use <c>ReuseDDElParam</c> instead of FreeDDElParam if the lParam parameter will be reused in a responding message.
            <c>ReuseDDElParam</c> returns the lParam appropriate for reuse.
            </para>
            <para>
            This function allocates or frees lParam parameters as needed, depending on the packing requirements of the incoming and outgoing
            messages. This reduces reallocations in passing DDE messages.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessage(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            Sends the specified message to a window or windows. The <c>SendMessage</c> function calls the window procedure for the specified
            window and does not return until the window procedure has processed the message.
            </para>
            <para>
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a
            thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            <para>
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of
            lesser or equal integrity level.
            </para>
            </param>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshalling.
            </para>
            <para>
            If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the
            specified window was created by a different thread, the system switches to that thread and calls the appropriate window
            procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The
            sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming
            nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set.
            For more information on nonqueued messages, see Nonqueued Messages.
            </para>
            <para>
            An accessibility application can use <c>SendMessage</c> to send WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying Keyboard Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessage(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.String)">
            <summary>
            <para>
            Sends the specified message to a window or windows. The <c>SendMessage</c> function calls the window procedure for the specified
            window and does not return until the window procedure has processed the message.
            </para>
            <para>
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a
            thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            <para>
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of
            lesser or equal integrity level.
            </para>
            </param>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshalling.
            </para>
            <para>
            If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the
            specified window was created by a different thread, the system switches to that thread and calls the appropriate window
            procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The
            sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming
            nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set.
            For more information on nonqueued messages, see Nonqueued Messages.
            </para>
            <para>
            An accessibility application can use <c>SendMessage</c> to send WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying Keyboard Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessage(Vanara.PInvoke.HWND,System.UInt32,System.Int32@,System.Text.StringBuilder)">
            <summary>
            <para>
            Sends the specified message to a window or windows. The <c>SendMessage</c> function calls the window procedure for the specified
            window and does not return until the window procedure has processed the message.
            </para>
            <para>
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a
            thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            <para>
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of
            lesser or equal integrity level.
            </para>
            </param>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshalling.
            </para>
            <para>
            If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the
            specified window was created by a different thread, the system switches to that thread and calls the appropriate window
            procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The
            sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming
            nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set.
            For more information on nonqueued messages, see Nonqueued Messages.
            </para>
            <para>
            An accessibility application can use <c>SendMessage</c> to send WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying Keyboard Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessage(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.Text.StringBuilder)">
            <summary>
            <para>
            Sends the specified message to a window or windows. The <c>SendMessage</c> function calls the window procedure for the specified
            window and does not return until the window procedure has processed the message.
            </para>
            <para>
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a
            thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            <para>
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of
            lesser or equal integrity level.
            </para>
            </param>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshalling.
            </para>
            <para>
            If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the
            specified window was created by a different thread, the system switches to that thread and calls the appropriate window
            procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The
            sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming
            nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set.
            For more information on nonqueued messages, see Nonqueued Messages.
            </para>
            <para>
            An accessibility application can use <c>SendMessage</c> to send WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying Keyboard Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessage``1(Vanara.PInvoke.HWND,``0,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            Sends the specified message to a window or windows. The <c>SendMessage</c> function calls the window procedure for the specified
            window and does not return until the window procedure has processed the message.
            </para>
            <para>
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a
            thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </para>
            </summary>
            <typeparam name="TMsg">The type of the message. This can be any type that converts to <see cref="T:System.UInt32"/>.</typeparam>
            <param name="hWnd"><para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            <para>
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of
            lesser or equal integrity level.
            </para></param>
            <param name="msg"><para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para></param>
            <param name="wParam"><para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para></param>
            <param name="lParam"><para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para></param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshalling.
            </para>
            <para>
            If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the
            specified window was created by a different thread, the system switches to that thread and calls the appropriate window
            procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The
            sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming
            nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set.
            For more information on nonqueued messages, see Nonqueued Messages.
            </para>
            <para>
            An accessibility application can use <c>SendMessage</c> to send WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying Keyboard Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessage``2(Vanara.PInvoke.HWND,``0,``1,System.IntPtr)">
            <summary>
            <para>
            Sends the specified message to a window or windows. The <c>SendMessage</c> function calls the window procedure for the specified
            window and does not return until the window procedure has processed the message.
            </para>
            <para>
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a
            thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </para>
            </summary>
            <typeparam name="TMsg">The type of the message. This can be any type that converts to <see cref="T:System.UInt32"/>.</typeparam>
            <typeparam name="TWP">The type of the <paramref name="wParam"/> parameter. This can be any type that converts to <see cref="T:System.Int64" />.</typeparam>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            <para>
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of
            lesser or equal integrity level.
            </para>
            </param>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshalling.
            </para>
            <para>
            If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the
            specified window was created by a different thread, the system switches to that thread and calls the appropriate window
            procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The
            sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming
            nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set.
            For more information on nonqueued messages, see Nonqueued Messages.
            </para>
            <para>
            An accessibility application can use <c>SendMessage</c> to send WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying Keyboard Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessage``2(Vanara.PInvoke.HWND,``0,``1@,System.IntPtr)">
            <summary>
            <para>
            Sends the specified message to a window or windows. The <c>SendMessage</c> function calls the window procedure for the specified
            window and does not return until the window procedure has processed the message.
            </para>
            <para>
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a
            thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </para>
            </summary>
            <typeparam name="TMsg">The type of the message. This can be any type that converts to <see cref="T:System.UInt32"/>.</typeparam>
            <typeparam name="TWP">The type of the <paramref name="wParam"/> parameter. This must be a type that can be marshaled to memory.</typeparam>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            <para>
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of
            lesser or equal integrity level.
            </para>
            </param>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshalling.
            </para>
            <para>
            If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the
            specified window was created by a different thread, the system switches to that thread and calls the appropriate window
            procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The
            sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming
            nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set.
            For more information on nonqueued messages, see Nonqueued Messages.
            </para>
            <para>
            An accessibility application can use <c>SendMessage</c> to send WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying Keyboard Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessage``2(Vanara.PInvoke.HWND,``0,``1,System.String)">
            <summary>
            <para>
            Sends the specified message to a window or windows. The <c>SendMessage</c> function calls the window procedure for the specified
            window and does not return until the window procedure has processed the message.
            </para>
            <para>
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a
            thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </para>
            </summary>
            <typeparam name="TMsg">The type of the message. This can be any type that converts to <see cref="T:System.UInt32"/>.</typeparam>
            <typeparam name="TWP">The type of the <paramref name="wParam"/> parameter. This can be any type that converts to <see cref="T:System.Int64" />.</typeparam>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            <para>
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of
            lesser or equal integrity level.
            </para>
            </param>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshalling.
            </para>
            <para>
            If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the
            specified window was created by a different thread, the system switches to that thread and calls the appropriate window
            procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The
            sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming
            nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set.
            For more information on nonqueued messages, see Nonqueued Messages.
            </para>
            <para>
            An accessibility application can use <c>SendMessage</c> to send WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying Keyboard Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessage``1(Vanara.PInvoke.HWND,``0,System.IntPtr,System.String)">
            <summary>
            <para>
            Sends the specified message to a window or windows. The <c>SendMessage</c> function calls the window procedure for the specified
            window and does not return until the window procedure has processed the message.
            </para>
            <para>
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a
            thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </para>
            </summary>
            <typeparam name="TMsg">The type of the message. This can be any type that converts to <see cref="T:System.UInt32"/>.</typeparam>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            <para>
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of
            lesser or equal integrity level.
            </para>
            </param>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshalling.
            </para>
            <para>
            If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the
            specified window was created by a different thread, the system switches to that thread and calls the appropriate window
            procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The
            sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming
            nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set.
            For more information on nonqueued messages, see Nonqueued Messages.
            </para>
            <para>
            An accessibility application can use <c>SendMessage</c> to send WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying Keyboard Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessage``1(Vanara.PInvoke.HWND,``0,System.IntPtr,System.Text.StringBuilder)">
            <summary>
            <para>
            Sends the specified message to a window or windows. The <c>SendMessage</c> function calls the window procedure for the specified
            window and does not return until the window procedure has processed the message.
            </para>
            <para>
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a
            thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </para>
            </summary>
            <typeparam name="TMsg">The type of the message. This can be any type that converts to <see cref="T:System.UInt32"/>.</typeparam>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            <para>
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of
            lesser or equal integrity level.
            </para>
            </param>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshalling.
            </para>
            <para>
            If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the
            specified window was created by a different thread, the system switches to that thread and calls the appropriate window
            procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The
            sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming
            nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set.
            For more information on nonqueued messages, see Nonqueued Messages.
            </para>
            <para>
            An accessibility application can use <c>SendMessage</c> to send WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying Keyboard Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessage``2(Vanara.PInvoke.HWND,``0,``1,System.Text.StringBuilder)">
            <summary>
            <para>
            Sends the specified message to a window or windows. The <c>SendMessage</c> function calls the window procedure for the specified
            window and does not return until the window procedure has processed the message.
            </para>
            <para>
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a
            thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </para>
            </summary>
            <typeparam name="TMsg">The type of the message. This can be any type that converts to <see cref="T:System.UInt32"/>.</typeparam>
            <typeparam name="TWP">The type of the <paramref name="wParam"/> parameter. This can be any type that converts to <see cref="T:System.Int64" />.</typeparam>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            <para>
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of
            lesser or equal integrity level.
            </para>
            </param>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshalling.
            </para>
            <para>
            If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the
            specified window was created by a different thread, the system switches to that thread and calls the appropriate window
            procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The
            sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming
            nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set.
            For more information on nonqueued messages, see Nonqueued Messages.
            </para>
            <para>
            An accessibility application can use <c>SendMessage</c> to send WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying Keyboard Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessage``2(Vanara.PInvoke.HWND,``0,System.IntPtr,``1)">
            <summary>
            <para>
            Sends the specified message to a window or windows. The <c>SendMessage</c> function calls the window procedure for the specified
            window and does not return until the window procedure has processed the message.
            </para>
            <para>
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a
            thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </para>
            </summary>
            <typeparam name="TMsg">The type of the message. This can be any type that converts to <see cref="T:System.UInt32"/>.</typeparam>
            <typeparam name="TLP">The type of the <paramref name="lParam"/> parameter. This can be any type that converts to <see cref="T:System.Int64" />.</typeparam>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            <para>
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of
            lesser or equal integrity level.
            </para>
            </param>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshalling.
            </para>
            <para>
            If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the
            specified window was created by a different thread, the system switches to that thread and calls the appropriate window
            procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The
            sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming
            nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set.
            For more information on nonqueued messages, see Nonqueued Messages.
            </para>
            <para>
            An accessibility application can use <c>SendMessage</c> to send WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying Keyboard Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessage``2(Vanara.PInvoke.HWND,``0,System.IntPtr,``1@)">
            <summary>
            <para>
            Sends the specified message to a window or windows. The <c>SendMessage</c> function calls the window procedure for the specified
            window and does not return until the window procedure has processed the message.
            </para>
            <para>
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a
            thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </para>
            </summary>
            <typeparam name="TMsg">The type of the message. This can be any type that converts to <see cref="T:System.UInt32"/>.</typeparam>
            <typeparam name="TLP">The type of the <paramref name="lParam"/> parameter. This must be a type that can be marshaled to memory.</typeparam>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            <para>
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of
            lesser or equal integrity level.
            </para>
            </param>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshalling.
            </para>
            <para>
            If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the
            specified window was created by a different thread, the system switches to that thread and calls the appropriate window
            procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The
            sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming
            nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set.
            For more information on nonqueued messages, see Nonqueued Messages.
            </para>
            <para>
            An accessibility application can use <c>SendMessage</c> to send WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying Keyboard Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessage``3(Vanara.PInvoke.HWND,``0,``1,``2@)">
            <summary>
            <para>
            Sends the specified message to a window or windows. The <c>SendMessage</c> function calls the window procedure for the specified
            window and does not return until the window procedure has processed the message.
            </para>
            <para>
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a
            thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </para>
            </summary>
            <typeparam name="TMsg">The type of the message. This can be any type that converts to <see cref="T:System.UInt32"/>.</typeparam>
            <typeparam name="TWP">The type of the <paramref name="wParam"/> parameter. This can be any type that converts to <see cref="T:System.Int64" />.</typeparam>
            <typeparam name="TLP">The type of the <paramref name="lParam"/> parameter. This must be a type that can be marshaled to memory.</typeparam>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            <para>
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of
            lesser or equal integrity level.
            </para>
            </param>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshalling.
            </para>
            <para>
            If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the
            specified window was created by a different thread, the system switches to that thread and calls the appropriate window
            procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The
            sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming
            nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set.
            For more information on nonqueued messages, see Nonqueued Messages.
            </para>
            <para>
            An accessibility application can use <c>SendMessage</c> to send WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying Keyboard Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessage``3(Vanara.PInvoke.HWND,``0,``1@,``2@)">
            <summary>
            <para>
            Sends the specified message to a window or windows. The <c>SendMessage</c> function calls the window procedure for the specified
            window and does not return until the window procedure has processed the message.
            </para>
            <para>
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a
            thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </para>
            </summary>
            <typeparam name="TMsg">The type of the message. This can be any type that converts to <see cref="T:System.UInt32"/>.</typeparam>
            <typeparam name="TWP">The type of the <paramref name="wParam"/> parameter. This must be a type that can be marshaled to memory.</typeparam>
            <typeparam name="TLP">The type of the <paramref name="lParam"/> parameter. This must be a type that can be marshaled to memory.</typeparam>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            <para>
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of
            lesser or equal integrity level.
            </para>
            </param>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>LRESULT</c></para>
            <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshalling.
            </para>
            <para>
            If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the
            specified window was created by a different thread, the system switches to that thread and calls the appropriate window
            procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The
            sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming
            nonqueued messages while waiting for its message to be processed. To prevent this, use SendMessageTimeout with SMTO_BLOCK set.
            For more information on nonqueued messages, see Nonqueued Messages.
            </para>
            <para>
            An accessibility application can use <c>SendMessage</c> to send WM_APPCOMMAND messages to the shell to launch applications. This
            functionality is not guaranteed to work for other types of applications.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying Keyboard Input.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessageCallback(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr,Vanara.PInvoke.User32.Sendasyncproc,System.UIntPtr)">
            <summary>
            Sends the specified message to a window or windows. It calls the window procedure for the specified window and returns
            immediately if the window belongs to another thread. After the window procedure processes the message, the system calls the
            specified callback function, passing the result of the message processing and an application-defined value to the callback function.
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            </param>
            <param name="Msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lpResultCallBack">
            <para>Type: <c>SENDASYNCPROC</c></para>
            <para>
            A pointer to a callback function that the system calls after the window procedure processes the message. For more information,
            see SendAsyncProc.
            </para>
            <para>
            If hWnd is <c>HWND_BROADCAST</c> ((HWND)0xffff), the system calls the SendAsyncProc callback function once for each top-level window.
            </para>
            </param>
            <param name="dwData">
            <para>Type: <c>ULONG_PTR</c></para>
            <para>An application-defined value to be sent to the callback function pointed to by the lpCallBack parameter.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the target window belongs to the same thread as the caller, then the window procedure is called synchronously, and the
            callback function is called immediately after the window procedure returns. If the target window belongs to a different thread
            from the caller, then the callback function is called only when the thread that called <c>SendMessageCallback</c> also calls
            GetMessage, PeekMessage, or WaitMessage.
            </para>
            <para>
            If you send a message in the range below WM_USER to the asynchronous message functions (PostMessage, SendNotifyMessage, and
            <c>SendMessageCallback</c>), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions
            will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used.
            </para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshaling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshaling.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessageTimeout(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr,Vanara.PInvoke.User32.SMTO,System.UInt32,System.IntPtr@)">
            <summary>Sends the specified message to one or more windows.</summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose window procedure will receive the message.</para>
            <para>
            If this parameter is <c>HWND_BROADCAST</c> ((HWND)0xffff), the message is sent to all top-level windows in the system, including
            disabled or invisible unowned windows. The function does not return until each window has timed out. Therefore, the total wait
            time can be up to the value of uTimeout multiplied by the number of top-level windows.
            </para>
            </param>
            <param name="Msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Any additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Any additional message-specific information.</para>
            </param>
            <param name="fuFlags">
            <para>Type: <c>UINT</c></para>
            <para>The behavior of this function. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SMTO_ABORTIFHUNG 0x0002</term>
            <term>
            The function returns without waiting for the time-out period to elapse if the receiving thread appears to not respond or "hangs."
            </term>
            </item>
            <item>
            <term>SMTO_BLOCK 0x0001</term>
            <term>Prevents the calling thread from processing any other requests until the function returns.</term>
            </item>
            <item>
            <term>SMTO_NORMAL 0x0000</term>
            <term>The calling thread is not prevented from processing other requests while waiting for the function to return.</term>
            </item>
            <item>
            <term>SMTO_NOTIMEOUTIFNOTHUNG 0x0008</term>
            <term>The function does not enforce the time-out period as long as the receiving thread is processing messages.</term>
            </item>
            <item>
            <term>SMTO_ERRORONEXIT 0x0020</term>
            <term>
            The function should return 0 if the receiving window is destroyed or its owning thread dies while the message is being processed.
            </term>
            </item>
            </list>
            </param>
            <param name="uTimeout">
            <para>Type: <c>UINT</c></para>
            <para>
            The duration of the time-out period, in milliseconds. If the message is a broadcast message, each window can use the full
            time-out period. For example, if you specify a five second time-out period and there are three top-level windows that fail to
            process the message, you could have up to a 15 second delay.
            </para>
            </param>
            <param name="lpdwResult">
            <para>Type: <c>PDWORD_PTR</c></para>
            <para>The result of the message processing. The value of this parameter depends on the message that is specified.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>LRESULT</c></c></para>
            <para>
            If the function succeeds, the return value is nonzero. <c>SendMessageTimeout</c> does not provide information about individual
            windows timing out if <c>HWND_BROADCAST</c> is used.
            </para>
            <para>
            If the function fails or times out, the return value is 0. To get extended error information, call GetLastError. If
            <c>GetLastError</c> returns <c>ERROR_TIMEOUT</c>, then the function timed out.
            </para>
            <para><c>Windows 2000:</c> If GetLastError returns 0, then the function timed out.</para>
            </returns>
            <remarks>
            <para>
            The function calls the window procedure for the specified window and, if the specified window belongs to a different thread, does
            not return until the window procedure has processed the message or the specified time-out period has elapsed. If the window
            receiving the message belongs to the same queue as the current thread, the window procedure is called directly—the time-out value
            is ignored.
            </para>
            <para>
            This function considers that a thread is not responding if it has not called GetMessage or a similar function within five seconds.
            </para>
            <para>
            The system only does marshaling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshaling.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendMessageUnsafe(System.Void*,System.UInt32,System.Void*,System.Void*)">
            <summary>
            <para>
            Sends the specified message to a window or windows. The <c>SendMessage</c> function calls the window procedure for the specified
            window and does not return until the window procedure has processed the message.
            </para>
            <para>
            To send a message and return immediately, use the <c>SendMessageCallback</c> or <c>SendNotifyMessage</c> function. To post a
            message to a thread's message queue and return immediately, use the <c>PostMessage</c> or <c>PostThreadMessage</c> function.
            </para>
            </summary>
            <param name="hWnd">
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            <para>
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of
            lesser or equal integrity level.
            </para>
            </param>
            <param name="msg">
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">Additional message-specific information.</param>
            <param name="lParam">Additional message-specific information.</param>
            <returns>The return value specifies the result of the message processing; it depends on the message sent.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SendNotifyMessage(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Sends the specified message to a window or windows. If the window was created by the calling thread, <c>SendNotifyMessage</c>
            calls the window procedure for the window and does not return until the window procedure has processed the message. If the window
            was created by a different thread, <c>SendNotifyMessage</c> passes the message to the window procedure and returns immediately;
            it does not wait for the window procedure to finish processing the message.
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose window procedure will receive the message. If this parameter is <c>HWND_BROADCAST</c>
            ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows; but the message is not sent to child windows.
            </para>
            </param>
            <param name="Msg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be sent.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If you send a message in the range below WM_USER to the asynchronous message functions (PostMessage, <c>SendNotifyMessage</c>,
            and SendMessageCallback), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will
            return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used.
            </para>
            <para>
            Applications that need to communicate using <c>HWND_BROADCAST</c> should use the RegisterWindowMessage function to obtain a
            unique message for inter-application communication.
            </para>
            <para>
            The system only does marshaling for system messages (those in the range 0 to (WM_USER-1)). To send other messages (those &gt;=
            <c>WM_USER</c>) to another process, you must do custom marshaling.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetMessageExtraInfo(System.IntPtr)">
            <summary>
            Sets the extra message information for the current thread. Extra message information is an application- or driver-defined value
            associated with the current thread's message queue. An application can use the GetMessageExtraInfo function to retrieve a
            thread's extra message information.
            </summary>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>The value to be associated with the current thread.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>LPARAM</c></c></para>
            <para>The return value is the previous value associated with the current thread.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.TranslateMessage(Vanara.PInvoke.MSG@)">
            <summary>
            Translates virtual-key messages into character messages. The character messages are posted to the calling thread's message queue,
            to be read the next time the thread calls the GetMessage or PeekMessage function.
            </summary>
            <param name="lpMsg">
            <para>Type: <c>const MSG*</c></para>
            <para>
            A pointer to an MSG structure that contains message information retrieved from the calling thread's message queue by using the
            GetMessage or PeekMessage function.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>
            If the message is translated (that is, a character message is posted to the thread's message queue), the return value is nonzero.
            </para>
            <para>
            If the message is WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, or WM_SYSKEYUP, the return value is nonzero, regardless of the translation.
            </para>
            <para>
            If the message is not translated (that is, a character message is not posted to the thread's message queue), the return value is zero.
            </para>
            </returns>
            <remarks>
            <para>The <c>TranslateMessage</c> function does not modify the message pointed to by the lpMsg parameter.</para>
            <para>
            WM_KEYDOWN and WM_KEYUP combinations produce a WM_CHAR or WM_DEADCHAR message. WM_SYSKEYDOWN and WM_SYSKEYUP combinations produce
            a WM_SYSCHAR or WM_SYSDEADCHAR message.
            </para>
            <para><c>TranslateMessage</c> produces WM_CHAR messages only for keys that are mapped to ASCII characters by the keyboard driver.</para>
            <para>
            If applications process virtual-key messages for some other purpose, they should not call <c>TranslateMessage</c>. For instance,
            an application should not call <c>TranslateMessage</c> if the TranslateAccelerator function returns a nonzero value. Note that
            the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main
            message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must
            call IsDialogMessage. For more information, see Dialog Box Keyboard Interface.
            </para>
            <para>Examples</para>
            <para>For an example, see Creating a Message Loop.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.UnpackDDElParam(System.UInt32,System.IntPtr,System.IntPtr@,System.IntPtr@)">
            <summary>Unpacks a Dynamic Data Exchange (DDE)lParam value received from a posted DDE message.</summary>
            <param name="msg">
            <para>Type: <c>UINT</c></para>
            <para>The posted DDE message.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>
            The lParam parameter of the posted DDE message that was received. The application must free the memory object specified by the
            lParam parameter by calling the FreeDDElParam function.
            </para>
            </param>
            <param name="puiLo">
            <para>Type: <c>PUINT_PTR</c></para>
            <para>A pointer to a variable that receives the low-order word of lParam.</para>
            </param>
            <param name="puiHi">
            <para>Type: <c>PUINT_PTR</c></para>
            <para>A pointer to a variable that receives the high-order word of lParam.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>PackDDElParam eases the porting of 16-bit DDE applications to 32-bit DDE applications.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.WaitMessage">
            <summary>
            Yields control to other threads when a thread has no other messages in its message queue. The <c>WaitMessage</c> function
            suspends the thread and does not return until a new message is placed in the thread's message queue.
            </summary>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            Note that <c>WaitMessage</c> does not return if there is unread input in the message queue after the thread has called a function
            to check the queue. This is because functions such as PeekMessage, GetMessage, GetQueueStatus, <c>WaitMessage</c>,
            MsgWaitForMultipleObjects, and MsgWaitForMultipleObjectsEx check the queue and then change the state information for the queue so
            that the input is no longer considered new. A subsequent call to <c>WaitMessage</c> will not return until new input of the
            specified type arrives. The existing unread input (received prior to the last time the thread checked the queue) is ignored.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.BSMINFO">
            <summary>Contains information about a window that denied a request from BroadcastSystemMessageEx.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSMINFO.cbSize">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The size, in bytes, of this structure.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSMINFO.hdesk">
            <summary>
            <para>Type: <c>HDESK</c></para>
            <para>
            A desktop handle to the window specified by <c>hwnd</c>. This value is returned only if BroadcastSystemMessageEx specifies
            <c>BSF_RETURNHDESK</c> and <c>BSF_QUERY</c>.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSMINFO.hwnd">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that denied the request. This value is returned if BroadcastSystemMessageEx specifies <c>BSF_QUERY</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BSMINFO.luid">
            <summary>
            <para>Type: <c>LUID</c></para>
            <para>A locally unique identifier (LUID) for the window.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ENUM_CURRENT_SETTINGS">
            <summary>Retrieve the current settings for the display device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ENUM_REGISTRY_SETTINGS">
            <summary>Retrieve the settings for the display device that are currently stored in the registry.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MonitorEnumProc">
            <summary>
            <para>
            A <c>MonitorEnumProc</c> function is an application-defined callback function that is called by the EnumDisplayMonitors function.
            </para>
            <para>A value of type <c>MONITORENUMPROC</c> is a pointer to a <c>MonitorEnumProc</c> function.</para>
            </summary>
            <param name="Arg1"/>
            <param name="Arg2"/>
            <param name="Arg3"/>
            <param name="Arg4"/>
            <returns>
            <para>To continue the enumeration, return <c>TRUE</c>.</para>
            <para>To stop the enumeration, return <c>FALSE</c>.</para>
            </returns>
            <remarks>
            <para>
            You can use the EnumDisplayMonitors function to enumerate the set of display monitors that intersect the visible region of a
            specified device context and, optionally, a clipping rectangle. To do this, set the hdc parameter to a non- <c>NULL</c> value,
            and set the lprcClip parameter as needed.
            </para>
            <para>
            You can also use the EnumDisplayMonitors function to enumerate one or more of the display monitors on the desktop, without
            supplying a device context. To do this, set the hdc parameter of <c>EnumDisplayMonitors</c> to <c>NULL</c> and set the lprcClip
            parameter as needed.
            </para>
            <para>
            In all cases, EnumDisplayMonitors calls a specified <c>MonitorEnumProc</c> function once for each display monitor in the
            calculated enumeration set. The <c>MonitorEnumProc</c> function always receives a handle to the display monitor.
            </para>
            <para>
            If the hdc parameter of EnumDisplayMonitors is non- <c>NULL</c>, the <c>MonitorEnumProc</c> function also receives a handle to a
            device context whose color format is appropriate for the display monitor. You can then paint into the device context in a manner
            that is optimal for the display monitor.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.EDD">
            <summary>Flags for <see cref="M:Vanara.PInvoke.User32.EnumDisplayDevices(System.String,System.UInt32,Vanara.PInvoke.Gdi32.DISPLAY_DEVICE@,Vanara.PInvoke.User32.EDD)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EDD.EDD_GET_DEVICE_INTERFACE_NAME">
            <summary>
            Retrieve the device interface name for GUID_DEVINTERFACE_MONITOR, which is registered by the operating system on a per
            monitor basis. The value is placed in the DeviceID member of the DISPLAY_DEVICE structure returned in lpDisplayDevice. The
            resulting device interface name can be used with SetupAPI functions and serves as a link between GDI monitor devices and
            SetupAPI monitor devices.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.EDS">
            <summary>Flags for <see cref="M:Vanara.PInvoke.User32.EnumDisplaySettingsEx(System.String,System.UInt32,Vanara.PInvoke.DEVMODE@,Vanara.PInvoke.User32.EDS)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EDS.EDS_RAWMODE">
            <summary>
            If set, the function will return all graphics modes reported by the adapter driver, regardless of monitor capabilities.
            Otherwise, it will only return modes that are compatible with current monitors.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.EDS.EDS_ROTATEDMODE">
            <summary>
            If set, the function will return graphics modes in all orientations. Otherwise, it will only return modes that have the same
            orientation as the one currently set for the requested display.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MonitorFlags">
            <summary>Determines the function's return value if the point is not contained within any display monitor.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MonitorFlags.MONITOR_DEFAULTTONULL">
            <summary>Returns NULL.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MonitorFlags.MONITOR_DEFAULTTOPRIMARY">
            <summary>Returns a handle to the primary display monitor.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MonitorFlags.MONITOR_DEFAULTTONEAREST">
            <summary>Returns a handle to the display monitor that is nearest to the point.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MonitorInfoFlags">
            <summary>Flags for <see cref="F:Vanara.PInvoke.User32.MONITORINFO.dwFlags"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MonitorInfoFlags.MONITORINFOF_PRIMARY">
            <summary>This is the primary display monitor.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnumDisplayDevices(System.String,System.UInt32,Vanara.PInvoke.Gdi32.DISPLAY_DEVICE@,Vanara.PInvoke.User32.EDD)">
            <summary>The <c>EnumDisplayDevices</c> function lets you obtain information about the display devices in the current session.</summary>
            <param name="lpDevice">
            <para>
            A pointer to the device name. If <c>NULL</c>, function returns information for the display adapter(s) on the machine, based on iDevNum.
            </para>
            <para>For more information, see Remarks.</para>
            </param>
            <param name="iDevNum">
            <para>An index value that specifies the display device of interest.</para>
            <para>
            The operating system identifies each display device in the current session with an index value. The index values are consecutive
            integers, starting at 0. If the current session has three display devices, for example, they are specified by the index values 0,
            1, and 2.
            </para>
            </param>
            <param name="lpDisplayDevice">
            <para>A pointer to a DISPLAY_DEVICE structure that receives information about the display device specified by iDevNum.</para>
            <para>
            Before calling <c>EnumDisplayDevices</c>, you must initialize the <c>cb</c> member of DISPLAY_DEVICE to the size, in bytes, of <c>DISPLAY_DEVICE</c>.
            </para>
            </param>
            <param name="dwFlags">
            Set this flag to EDD_GET_DEVICE_INTERFACE_NAME (0x00000001) to retrieve the device interface name for GUID_DEVINTERFACE_MONITOR,
            which is registered by the operating system on a per monitor basis. The value is placed in the DeviceID member of the
            DISPLAY_DEVICE structure returned in lpDisplayDevice. The resulting device interface name can be used with SetupAPI functions and
            serves as a link between GDI monitor devices and SetupAPI monitor devices.
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. The function fails if iDevNum is greater than the largest device index.</para>
            </returns>
            <remarks>
            <para>
            To query all display devices in the current session, call this function in a loop, starting with iDevNum set to 0, and
            incrementing iDevNum until the function fails. To select all display devices in the desktop, use only the display devices that
            have the DISPLAY_DEVICE_ATTACHED_TO_DESKTOP flag in the DISPLAY_DEVICE structure.
            </para>
            <para>
            To get information on the display adapter, call <c>EnumDisplayDevices</c> with lpDevice set to <c>NULL</c>. For example,
            DISPLAY_DEVICE. <c>DeviceString</c> contains the adapter name.
            </para>
            <para>
            To obtain information on a display monitor, first call <c>EnumDisplayDevices</c> with lpDevice set to <c>NULL</c>. Then call
            <c>EnumDisplayDevices</c> with lpDevice set to DISPLAY_DEVICE. <c>DeviceName</c> from the first call to <c>EnumDisplayDevices</c>
            and with iDevNum set to zero. Then <c>DISPLAY_DEVICE</c>. <c>DeviceString</c> is the monitor name.
            </para>
            <para>
            To query all monitor devices associated with an adapter, call <c>EnumDisplayDevices</c> in a loop with lpDevice set to the
            adapter name, iDevNum set to start at 0, and iDevNum set to increment until the function fails. Note that
            <c>DISPLAY_DEVICE.DeviceName</c> changes with each call for monitor information, so you must save the adapter name. The function
            fails when there are no more monitors for the adapter.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnumDisplayMonitors(Vanara.PInvoke.HDC,Vanara.PInvoke.PRECT,Vanara.PInvoke.User32.MonitorEnumProc,System.IntPtr)">
            <summary>
            The <c>EnumDisplayMonitors</c> function enumerates display monitors (including invisible pseudo-monitors associated with the
            mirroring drivers) that intersect a region formed by the intersection of a specified clipping rectangle and the visible region of a
            device context. <c>EnumDisplayMonitors</c> calls an application-defined MonitorEnumProc callback function once for each monitor that
            is enumerated. Note that GetSystemMetrics (SM_CMONITORS) counts only the display monitors.
            </summary>
            <param name="hdc">
            <para>A handle to a display device context that defines the visible region of interest.</para>
            <para>
            If this parameter is <c>NULL</c>, the hdcMonitor parameter passed to the callback function will be <c>NULL</c>, and the visible
            region of interest is the virtual screen that encompasses all the displays on the desktop.
            </para>
            </param>
            <param name="lprcClip">
            <para>
            A pointer to a RECT structure that specifies a clipping rectangle. The region of interest is the intersection of the clipping
            rectangle with the visible region specified by hdc.
            </para>
            <para>
            If hdc is non- <c>NULL</c>, the coordinates of the clipping rectangle are relative to the origin of the hdc. If hdc is <c>NULL</c>,
            the coordinates are virtual-screen coordinates.
            </para>
            <para>This parameter can be <c>NULL</c> if you don't want to clip the region specified by hdc.</para>
            </param>
            <param name="lpfnEnum">A pointer to a MonitorEnumProc application-defined callback function.</param>
            <param name="dwData">Application-defined data that <c>EnumDisplayMonitors</c> passes directly to the MonitorEnumProc function.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>There are two reasons to call the <c>EnumDisplayMonitors</c> function:</para>
            <list type="bullet">
            <item>
            <term>
            You want to draw optimally into a device context that spans several display monitors, and the monitors have different color formats.
            </term>
            </item>
            <item>
            <term>You want to obtain a handle and position rectangle for one or more display monitors.</term>
            </item>
            </list>
            <para>To determine whether all the display monitors in a system share the same color format, call GetSystemMetrics (SM_SAMEDISPLAYFORMAT).</para>
            <para>
            You do not need to use the <c>EnumDisplayMonitors</c> function when a window spans display monitors that have different color
            formats. You can continue to paint under the assumption that the entire screen has the color properties of the primary monitor. Your
            windows will look fine. <c>EnumDisplayMonitors</c> just lets you make them look better.
            </para>
            <para>
            Setting the hdc parameter to <c>NULL</c> lets you use the <c>EnumDisplayMonitors</c> function to obtain a handle and position
            rectangle for one or more display monitors. The following table shows how the four combinations of <c>NULL</c> and non- <c>NULL</c>
            hdc and lprcClip values affect the behavior of the <c>EnumDisplayMonitors</c> function.
            </para>
            <list type="table">
            <listheader>
            <term>hdc</term>
            <term>lprcRect</term>
            <term>EnumDisplayMonitors behavior</term>
            </listheader>
            <item>
            <term>NULL</term>
            <term>NULL</term>
            <term>Enumerates all display monitors.The callback function receives a NULL HDC.</term>
            </item>
            <item>
            <term>NULL</term>
            <term>non-NULL</term>
            <term>
            Enumerates all display monitors that intersect the clipping rectangle. Use virtual screen coordinates for the clipping rectangle.The
            callback function receives a NULL HDC.
            </term>
            </item>
            <item>
            <term>non-NULL</term>
            <term>NULL</term>
            <term>
            Enumerates all display monitors that intersect the visible region of the device context.The callback function receives a handle to a
            DC for the specific display monitor.
            </term>
            </item>
            <item>
            <term>non-NULL</term>
            <term>non-NULL</term>
            <term>
            Enumerates all display monitors that intersect the visible region of the device context and the clipping rectangle. Use device
            context coordinates for the clipping rectangle.The callback function receives a handle to a DC for the specific display monitor.
            </term>
            </item>
            </list>
            <para>Examples</para>
            <para>
            To paint in response to a WM_PAINT message, using the capabilities of each monitor, you can use code like this in a window procedure:
            </para>
            <para>To paint the top half of a window using the capabilities of each monitor, you can use code like this:</para>
            <para>To paint the entire virtual screen optimally for each display monitor, you can use code like this:</para>
            <para>To retrieve information about all of the display monitors, use code like this:</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnumDisplaySettings(System.String,System.UInt32,Vanara.PInvoke.DEVMODE@)">
            <summary>
            <para>
            The <c>EnumDisplaySettings</c> function retrieves information about one of the graphics modes for a display device. To retrieve
            information for all the graphics modes of a display device, make a series of calls to this function.
            </para>
            <para>
            <c>Note</c> Apps that you design to target Windows 8 and later can no longer query or set display modes that are less than 32 bits
            per pixel (bpp); these operations will fail. These apps have a compatibility manifest that targets Windows 8. Windows 8 still
            supports 8-bit and 16-bit color modes for desktop apps that were built without a Windows 8 manifest; Windows 8 emulates these modes
            but still runs in 32-bit color mode.
            </para>
            </summary>
            <param name="lpszDeviceName">
            <para>
            A pointer to a null-terminated string that specifies the display device about whose graphics mode the function will obtain information.
            </para>
            <para>
            This parameter is either <c>NULL</c> or a DISPLAY_DEVICE. <c>DeviceName</c> returned from EnumDisplayDevices. A <c>NULL</c> value
            specifies the current display device on the computer on which the calling thread is running.
            </para>
            </param>
            <param name="iModeNum">
            <para>The type of information to be retrieved. This value can be a graphics mode index or one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ENUM_CURRENT_SETTINGS</term>
            <term>Retrieve the current settings for the display device.</term>
            </item>
            <item>
            <term>ENUM_REGISTRY_SETTINGS</term>
            <term>Retrieve the settings for the display device that are currently stored in the registry.</term>
            </item>
            </list>
            <para>
            Graphics mode indexes start at zero. To obtain information for all of a display device's graphics modes, make a series of calls to
            <c>EnumDisplaySettings</c>, as follows: Set iModeNum to zero for the first call, and increment iModeNum by one for each subsequent
            call. Continue calling the function until the return value is zero.
            </para>
            <para>
            When you call <c>EnumDisplaySettings</c> with iModeNum set to zero, the operating system initializes and caches information about the
            display device. When you call <c>EnumDisplaySettings</c> with iModeNum set to a nonzero value, the function returns the information
            that was cached the last time the function was called with iModeNum set to zero.
            </para>
            </param>
            <param name="lpDevMode">
            <para>
            A pointer to a DEVMODE structure into which the function stores information about the specified graphics mode. Before calling
            <c>EnumDisplaySettings</c>, set the <c>dmSize</c> member to , and set the <c>dmDriverExtra</c> member to indicate the size, in bytes,
            of the additional space available to receive private driver data.
            </para>
            <para>The <c>EnumDisplaySettings</c> function sets values for the following five DEVMODE members:</para>
            <list type="bullet">
            <item>
            <term><c>dmBitsPerPel</c></term>
            </item>
            <item>
            <term><c>dmPelsWidth</c></term>
            </item>
            <item>
            <term><c>dmPelsHeight</c></term>
            </item>
            <item>
            <term><c>dmDisplayFlags</c></term>
            </item>
            <item>
            <term><c>dmDisplayFrequency</c></term>
            </item>
            </list>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            The function fails if iModeNum is greater than the index of the display device's last graphics mode. As noted in the description of
            the iModeNum parameter, you can use this behavior to enumerate all of a display device's graphics modes.
            </para>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. The output given is always in terms of physical pixels, and is not related to
            the calling context.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnumDisplaySettingsEx(System.String,System.UInt32,Vanara.PInvoke.DEVMODE@,Vanara.PInvoke.User32.EDS)">
            <summary>
            <para>
            The <c>EnumDisplaySettingsEx</c> function retrieves information about one of the graphics modes for a display device. To retrieve
            information for all the graphics modes for a display device, make a series of calls to this function.
            </para>
            <para>This function differs from EnumDisplaySettings in that there is a dwFlags parameter.</para>
            <para>
            <c>Note</c> Apps that you design to target Windows 8 and later can no longer query or set display modes that are less than 32 bits
            per pixel (bpp); these operations will fail. These apps have a compatibility manifest that targets Windows 8. Windows 8 still
            supports 8-bit and 16-bit color modes for desktop apps that were built without a Windows 8 manifest; Windows 8 emulates these modes
            but still runs in 32-bit color mode.
            </para>
            </summary>
            <param name="lpszDeviceName">
            <para>
            A pointer to a null-terminated string that specifies the display device about which graphics mode the function will obtain information.
            </para>
            <para>
            This parameter is either <c>NULL</c> or a DISPLAY_DEVICE. <c>DeviceName</c> returned from EnumDisplayDevices. A <c>NULL</c> value
            specifies the current display device on the computer that the calling thread is running on.
            </para>
            </param>
            <param name="iModeNum">
            <para>Indicates the type of information to be retrieved. This value can be a graphics mode index or one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ENUM_CURRENT_SETTINGS</term>
            <term>Retrieve the current settings for the display device.</term>
            </item>
            <item>
            <term>ENUM_REGISTRY_SETTINGS</term>
            <term>Retrieve the settings for the display device that are currently stored in the registry.</term>
            </item>
            </list>
            <para>
            Graphics mode indexes start at zero. To obtain information for all of a display device's graphics modes, make a series of calls to
            <c>EnumDisplaySettingsEx</c>, as follows: Set iModeNum to zero for the first call, and increment iModeNum by one for each subsequent
            call. Continue calling the function until the return value is zero.
            </para>
            <para>
            When you call <c>EnumDisplaySettingsEx</c> with iModeNum set to zero, the operating system initializes and caches information about
            the display device. When you call <c>EnumDisplaySettingsEx</c> with iModeNum set to a nonzero value, the function returns the
            information that was cached the last time the function was called with iModeNum set to zero.
            </para>
            </param>
            <param name="lpDevMode">
            <para>
            A pointer to a DEVMODE structure into which the function stores information about the specified graphics mode. Before calling
            <c>EnumDisplaySettingsEx</c>, set the <c>dmSize</c> member to <c>sizeof</c> (DEVMODE), and set the <c>dmDriverExtra</c> member to
            indicate the size, in bytes, of the additional space available to receive private driver data.
            </para>
            <para>
            The <c>EnumDisplaySettingsEx</c> function will populate the <c>dmFields</c> member of the <c>lpDevMode</c> and one or more other
            members of the DEVMODE structure. To determine which members were set by the call to <c>EnumDisplaySettingsEx</c>, inspect the
            dmFields bitmask. Some of the fields typically populated by this function include:
            </para>
            <list type="bullet">
            <item>
            <term><c>dmBitsPerPel</c></term>
            </item>
            <item>
            <term><c>dmPelsWidth</c></term>
            </item>
            <item>
            <term><c>dmPelsHeight</c></term>
            </item>
            <item>
            <term><c>dmDisplayFlags</c></term>
            </item>
            <item>
            <term><c>dmDisplayFrequency</c></term>
            </item>
            <item>
            <term><c>dmPosition</c></term>
            </item>
            <item>
            <term><c>dmDisplayOrientation</c></term>
            </item>
            </list>
            </param>
            <param name="dwFlags">
            <para>This parameter can be the following value.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>EDS_RAWMODE</term>
            <term>
            If set, the function will return all graphics modes reported by the adapter driver, regardless of monitor capabilities. Otherwise, it
            will only return modes that are compatible with current monitors.
            </term>
            </item>
            <item>
            <term>EDS_ROTATEDMODE</term>
            <term>
            If set, the function will return graphics modes in all orientations. Otherwise, it will only return modes that have the same
            orientation as the one currently set for the requested display.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            The function fails if iModeNum is greater than the index of the display device's last graphics mode. As noted in the description of
            the iModeNum parameter, you can use this behavior to enumerate all of a display device's graphics modes.
            </para>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. The output given is always in terms of physical pixels, and is not related to
            the calling context.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMonitorInfo(Vanara.PInvoke.HMONITOR,Vanara.PInvoke.User32.MONITORINFO@)">
            <summary>The <c>GetMonitorInfo</c> function retrieves information about a display monitor.</summary>
            <param name="hMonitor">A handle to the display monitor of interest.</param>
            <param name="lpmi">
            <para>A pointer to a MONITORINFO or MONITORINFOEX structure that receives information about the specified display monitor.</para>
            <para>
            You must set the <c>cbSize</c> member of the structure to sizeof(MONITORINFO) or sizeof(MONITORINFOEX) before calling the
            <c>GetMonitorInfo</c> function. Doing so lets the function determine the type of structure you are passing to it. You can do this by
            calling <see cref="P:Vanara.PInvoke.User32.MONITORINFO.Default"/> to get a new instance with properly set of <see cref="F:Vanara.PInvoke.User32.MONITORINFO.cbSize"/>.
            </para>
            <para>
            The MONITORINFOEX structure is a superset of the MONITORINFO structure. It has one additional member: a string that contains a name
            for the display monitor. Most applications have no use for a display monitor name, and so can save some bytes by using a
            <c>MONITORINFO</c> structure.
            </para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMonitorInfo(Vanara.PInvoke.HMONITOR,Vanara.PInvoke.User32.MONITORINFOEX@)">
            <summary>The <c>GetMonitorInfo</c> function retrieves information about a display monitor.</summary>
            <param name="hMonitor">A handle to the display monitor of interest.</param>
            <param name="lpmi">
            <para>A pointer to a MONITORINFO or MONITORINFOEX structure that receives information about the specified display monitor.</para>
            <para>
            You must set the <c>cbSize</c> member of the structure to sizeof(MONITORINFO) or sizeof(MONITORINFOEX) before calling the
            <c>GetMonitorInfo</c> function. Doing so lets the function determine the type of structure you are passing to it. You can do this by
            calling <see cref="P:Vanara.PInvoke.User32.MONITORINFOEX.Default"/> to get a new instance with properly set of <see cref="F:Vanara.PInvoke.User32.MONITORINFOEX.cbSize"/>.
            </para>
            <para>
            The MONITORINFOEX structure is a superset of the MONITORINFO structure. It has one additional member: a string that contains a name
            for the display monitor. Most applications have no use for a display monitor name, and so can save some bytes by using a
            <c>MONITORINFO</c> structure.
            </para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.MonitorFromPoint(Vanara.PInvoke.POINT,Vanara.PInvoke.User32.MonitorFlags)">
            <summary>The <c>MonitorFromPoint</c> function retrieves a handle to the display monitor that contains a specified point.</summary>
            <param name="pt">A POINT structure that specifies the point of interest in virtual-screen coordinates.</param>
            <param name="dwFlags">
            <para>Determines the function's return value if the point is not contained within any display monitor.</para>
            <para>This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MONITOR_DEFAULTTONEAREST</term>
            <term>Returns a handle to the display monitor that is nearest to the point.</term>
            </item>
            <item>
            <term>MONITOR_DEFAULTTONULL</term>
            <term>Returns NULL.</term>
            </item>
            <item>
            <term>MONITOR_DEFAULTTOPRIMARY</term>
            <term>Returns a handle to the primary display monitor.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>If the point is contained by a display monitor, the return value is an <c>HMONITOR</c> handle to that display monitor.</para>
            <para>If the point is not contained by a display monitor, the return value depends on the value of dwFlags.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.MonitorFromRect(Vanara.PInvoke.RECT@,Vanara.PInvoke.User32.MonitorFlags)">
            <summary>
            The <c>MonitorFromRect</c> function retrieves a handle to the display monitor that has the largest area of intersection with a
            specified rectangle.
            </summary>
            <param name="lprc">A pointer to a RECT structure that specifies the rectangle of interest in virtual-screen coordinates.</param>
            <param name="dwFlags">
            <para>Determines the function's return value if the rectangle does not intersect any display monitor.</para>
            <para>This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MONITOR_DEFAULTTONEAREST</term>
            <term>Returns a handle to the display monitor that is nearest to the rectangle.</term>
            </item>
            <item>
            <term>MONITOR_DEFAULTTONULL</term>
            <term>Returns NULL.</term>
            </item>
            <item>
            <term>MONITOR_DEFAULTTOPRIMARY</term>
            <term>Returns a handle to the primary display monitor.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>
            If the rectangle intersects one or more display monitor rectangles, the return value is an <c>HMONITOR</c> handle to the display
            monitor that has the largest area of intersection with the rectangle.
            </para>
            <para>If the rectangle does not intersect a display monitor, the return value depends on the value of dwFlags.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.MonitorFromWindow(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.MonitorFlags)">
            <summary>
            The <c>MonitorFromWindow</c> function retrieves a handle to the display monitor that has the largest area of intersection with the
            bounding rectangle of a specified window.
            </summary>
            <param name="hwnd">A handle to the window of interest.</param>
            <param name="dwFlags">
            <para>Determines the function's return value if the window does not intersect any display monitor.</para>
            <para>This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MONITOR_DEFAULTTONEAREST</term>
            <term>Returns a handle to the display monitor that is nearest to the window.</term>
            </item>
            <item>
            <term>MONITOR_DEFAULTTONULL</term>
            <term>Returns NULL.</term>
            </item>
            <item>
            <term>MONITOR_DEFAULTTOPRIMARY</term>
            <term>Returns a handle to the primary display monitor.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>
            If the window intersects one or more display monitor rectangles, the return value is an <c>HMONITOR</c> handle to the display monitor
            that has the largest area of intersection with the window.
            </para>
            <para>If the window does not intersect a display monitor, the return value depends on the value of dwFlags.</para>
            </returns>
            <remarks>If the window is currently minimized, <c>MonitorFromWindow</c> uses the rectangle of the window before it was minimized.</remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.MONITORINFO">
            <summary>
            <para>The <c>MONITORINFO</c> structure contains information about a display monitor.</para>
            <para>The GetMonitorInfo function stores information in a <c>MONITORINFO</c> structure or a MONITORINFOEX structure.</para>
            <para>
            The <c>MONITORINFO</c> structure is a subset of the MONITORINFOEX structure. The <c>MONITORINFOEX</c> structure adds a string member
            to contain a name for the display monitor.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MONITORINFO.cbSize">
            <summary>
            <para>The size of the structure, in bytes.</para>
            <para>
            Set this member to before calling the GetMonitorInfo function. Doing so lets the function determine the type of structure you
            are passing to it.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MONITORINFO.rcMonitor">
            <summary>
            A RECT structure that specifies the display monitor rectangle, expressed in virtual-screen coordinates. Note that if the
            monitor is not the primary display monitor, some of the rectangle's coordinates may be negative values.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MONITORINFO.rcWork">
            <summary>
            A RECT structure that specifies the work area rectangle of the display monitor, expressed in virtual-screen coordinates. Note
            that if the monitor is not the primary display monitor, some of the rectangle's coordinates may be negative values.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MONITORINFO.dwFlags">
            <summary>
            <para>A set of flags that represent attributes of the display monitor.</para>
            <para>The following flag is defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MONITORINFOF_PRIMARY</term>
            <term>This is the primary display monitor.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.MONITORINFO.Default">
            <summary>Gets an instance of <see cref="T:Vanara.PInvoke.User32.MONITORINFO"/> structure with <see cref="F:Vanara.PInvoke.User32.MONITORINFO.cbSize"/> set correctly.</summary>
            <returns>Returns new instance of properly initialized <see cref="T:Vanara.PInvoke.User32.MONITORINFO"/> structure.</returns>
            <seealso cref="M:Vanara.PInvoke.User32.GetMonitorInfo(Vanara.PInvoke.HMONITOR,Vanara.PInvoke.User32.MONITORINFO@)"/>
        </member>
        <member name="T:Vanara.PInvoke.User32.MONITORINFOEX">
            <summary>
            <para>The <c>MONITORINFOEX</c> structure contains information about a display monitor.</para>
            <para>The GetMonitorInfo function stores information into a <c>MONITORINFOEX</c> structure or a MONITORINFO structure.</para>
            <para>
            The <c>MONITORINFOEX</c> structure is a superset of the MONITORINFO structure. The <c>MONITORINFOEX</c> structure adds a string
            member to contain a name for the display monitor.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MONITORINFOEX.cbSize">
            <summary>
            <para>The size of the structure, in bytes.</para>
            <para>
            Set this member to before calling the GetMonitorInfo function. Doing so lets the function determine the type of structure you
            are passing to it.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MONITORINFOEX.rcMonitor">
            <summary>
            A RECT structure that specifies the display monitor rectangle, expressed in virtual-screen coordinates. Note that if the
            monitor is not the primary display monitor, some of the rectangle's coordinates may be negative values.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MONITORINFOEX.rcWork">
            <summary>
            A RECT structure that specifies the work area rectangle of the display monitor, expressed in virtual-screen coordinates. Note
            that if the monitor is not the primary display monitor, some of the rectangle's coordinates may be negative values.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MONITORINFOEX.dwFlags">
            <summary>
            <para>A set of flags that represent attributes of the display monitor.</para>
            <para>The following flag is defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MONITORINFOF_PRIMARY</term>
            <term>This is the primary display monitor.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MONITORINFOEX.szDevice">
            <summary>
            A string that specifies the device name of the monitor being used. Most applications have no use for a display monitor name,
            and so can save some bytes by using a MONITORINFO structure.
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.MONITORINFOEX.Default">
            <summary>Gets an instance of <see cref="T:Vanara.PInvoke.User32.MONITORINFOEX"/> structure with <see cref="F:Vanara.PInvoke.User32.MONITORINFOEX.cbSize"/> set correctly.</summary>
            <returns>Returns new instance of properly initialized <see cref="T:Vanara.PInvoke.User32.MONITORINFOEX"/> structure.</returns>
            <seealso cref="M:Vanara.PInvoke.User32.GetMonitorInfo(Vanara.PInvoke.HMONITOR,Vanara.PInvoke.User32.MONITORINFOEX@)"/>
        </member>
        <member name="T:Vanara.PInvoke.User32.GMMP">
            <summary>The resolution desired.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GMMP.GMMP_USE_DISPLAY_POINTS">
            <summary>Retrieves the points using the display resolution.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GMMP.GMMP_USE_HIGH_RESOLUTION_POINTS">
            <summary>
            Retrieves high resolution points. Points can range from zero to 65,535 (0xFFFF) in both x- and y-coordinates. This is the
            resolution provided by absolute coordinate pointing devices such as drawing tablets.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MouseActivateCode">
            <summary>
            The return value specifies whether the window should be activated and whether the identifier of the mouse message should be discarded.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MouseActivateCode.MA_ACTIVATE">
            <summary>Activates the window, and does not discard the mouse message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MouseActivateCode.MA_ACTIVATEANDEAT">
            <summary>Activates the window, and discards the mouse message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MouseActivateCode.MA_NOACTIVATE">
            <summary>Does not activate the window, and does not discard the mouse message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MouseActivateCode.MA_NOACTIVATEANDEAT">
            <summary>Does not activate the window, but discards the mouse message.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MOUSEEVENTF">
            <summary>Controls various aspects of mouse motion and button clicking.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_ABSOLUTE">
            <summary>
            The dx and dy parameters contain normalized absolute coordinates. If not set, those parameters contain relative data: the
            change in position since the last reported position. This flag can be set, or not set, regardless of what kind of mouse or
            mouse-like device, if any, is connected to the system. For further information about relative mouse motion, see the following
            Remarks section.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_LEFTDOWN">
            <summary>The left button is down.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_LEFTUP">
            <summary>The left button is up.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_MIDDLEDOWN">
            <summary>The middle button is down.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_MIDDLEUP">
            <summary>The middle button is up.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_MOVE">
            <summary>Movement occurred.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_RIGHTDOWN">
            <summary>The right button is down.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_RIGHTUP">
            <summary>The right button is up.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_WHEEL">
            <summary>The wheel has been moved, if the mouse has a wheel. The amount of movement is specified in dwData</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_XDOWN">
            <summary>An X button was pressed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_XUP">
            <summary>An X button was released.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_HWHEEL">
            <summary>The wheel button is tilted.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_MOVE_NOCOALESCE">
            <summary>Do not coalesce mouse moves.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_VIRTUALDESK">
            <summary>Map to entire virtual desktop</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TME">
            <summary>The services requested in a <see cref="T:Vanara.PInvoke.User32.TRACKMOUSEEVENT"/> structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TME.TME_CANCEL">
            <summary>
            The caller wants to cancel a prior tracking request. The caller should also specify the type of tracking that it wants to
            cancel. For example, to cancel hover tracking, the caller must pass the TME_CANCEL and TME_HOVER flags.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TME.TME_HOVER">
            <summary>
            The caller wants hover notification. Notification is delivered as a WM_MOUSEHOVER message.
            <para>If the caller requests hover tracking while hover tracking is already active, the hover timer will be reset.</para>
            <para>This flag is ignored if the mouse pointer is not over the specified window or area.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TME.TME_LEAVE">
            <summary>
            The caller wants leave notification. Notification is delivered as a WM_MOUSELEAVE message. If the mouse is not over the
            specified window or area, a leave notification is generated immediately and no further tracking is performed.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TME.TME_NONCLIENT">
            <summary>
            The caller wants hover and leave notification for the nonclient areas. Notification is delivered as WM_NCMOUSEHOVER and
            WM_NCMOUSELEAVE messages.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TME.TME_QUERY">
            <summary>
            The function fills in the structure instead of treating it as a tracking request. The structure is filled such that had that
            structure been passed to TrackMouseEvent, it would generate the current tracking. The only anomaly is that the hover time-out
            returned is always the actual time-out and not HOVER_DEFAULT, if HOVER_DEFAULT was specified during the original
            TrackMouseEvent request.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetDoubleClickTime">
            <summary>
            Retrieves the current double-click time for the mouse. A double-click is a series of two clicks of the mouse button, the second
            occurring within a specified time after the first. The double-click time is the maximum number of milliseconds that may occur
            between the first and second click of a double-click. The maximum double-click time is 5000 milliseconds.
            </summary>
            <returns>
            <para>Type: <c>UINT</c></para>
            <para>The return value specifies the current double-click time, in milliseconds. The maximum return value is 5000 milliseconds.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetMouseMovePointsEx(System.UInt32,Vanara.PInvoke.User32.MOUSEMOVEPOINT@,Vanara.PInvoke.User32.MOUSEMOVEPOINT[],System.Int32,Vanara.PInvoke.User32.GMMP)">
            <summary>Retrieves a history of up to 64 previous coordinates of the mouse or pen.</summary>
            <param name="cbSize">
            <para>Type: <c>UINT</c></para>
            <para>The size, in bytes, of the MOUSEMOVEPOINT structure.</para>
            </param>
            <param name="lppt">
            <para>Type: <c>LPMOUSEMOVEPOINT</c></para>
            <para>
            A pointer to a MOUSEMOVEPOINT structure containing valid mouse coordinates (in screen coordinates). It may also contain a time stamp.
            </para>
            <para>
            The <c>GetMouseMovePointsEx</c> function searches for the point in the mouse coordinates history. If the function finds the
            point, it returns the last nBufPoints prior to and including the supplied point.
            </para>
            <para>
            If your application supplies a time stamp, the <c>GetMouseMovePointsEx</c> function will use it to differentiate between two
            equal points that were recorded at different times.
            </para>
            <para>
            An application should call this function using the mouse coordinates received from the WM_MOUSEMOVE message and convert them to
            screen coordinates.
            </para>
            </param>
            <param name="lpptBuf">
            <para>Type: <c>LPMOUSEMOVEPOINT</c></para>
            <para>A pointer to a buffer that will receive the points. It should be at least cbSize* nBufPoints in size.</para>
            </param>
            <param name="nBufPoints">
            <para>Type: <c>int</c></para>
            <para>The number of points to be retrieved.</para>
            </param>
            <param name="resolution">
            <para>Type: <c>DWORD</c></para>
            <para>The resolution desired. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>GMMP_USE_DISPLAY_POINTS 1</term>
            <term>Retrieves the points using the display resolution.</term>
            </item>
            <item>
            <term>GMMP_USE_HIGH_RESOLUTION_POINTS 2</term>
            <term>
            Retrieves high resolution points. Points can range from zero to 65,535 (0xFFFF) in both x- and y-coordinates. This is the
            resolution provided by absolute coordinate pointing devices such as drawing tablets.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            If the function succeeds, the return value is the number of points in the buffer. Otherwise, the function returns –1. For
            extended error information, your application can call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            The system retains the last 64 mouse coordinates and their time stamps. If your application supplies a mouse coordinate to
            <c>GetMouseMovePointsEx</c> and the coordinate exists in the system's mouse coordinate history, the function retrieves the
            specified number of coordinates from the systems' history. You can also supply a time stamp, which will be used to differentiate
            between identical points in the history.
            </para>
            <para>
            The <c>GetMouseMovePointsEx</c> function will return points that eventually were dispatched not only to the calling thread but
            also to other threads.
            </para>
            <para><c>GetMouseMovePointsEx</c> may fail or return erroneous values in the following cases:</para>
            <list type="bullet">
            <item>
            <term>If negative coordinates are passed in the MOUSEMOVEPOINT structure.</term>
            </item>
            <item>
            <term>If <c>GetMouseMovePointsEx</c> retrieves a coordinate with a negative value.</term>
            </item>
            </list>
            <para>
            These situations can occur if multiple monitors are present. To correct this, first call GetSystemMetrics to get the following values:
            </para>
            <list type="bullet">
            <item>
            <term>SM_XVIRTUALSCREEN,</term>
            </item>
            <item>
            <term>SM_YVIRTUALSCREEN,</term>
            </item>
            <item>
            <term>SM_CXVIRTUALSCREEN, and</term>
            </item>
            <item>
            <term>SM_CYVIRTUALSCREEN.</term>
            </item>
            </list>
            <para>Then, for each point that is returned from <c>GetMouseMovePointsEx</c>, perform the following transform:</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.mouse_event(Vanara.PInvoke.User32.MOUSEEVENTF,System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            <para>The <c>mouse_event</c> function synthesizes mouse motion and button clicks.</para>
            <para><c>Note</c> This function has been superseded. Use SendInput instead.</para>
            </summary>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>
            Controls various aspects of mouse motion and button clicking. This parameter can be certain combinations of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MOUSEEVENTF_ABSOLUTE 0x8000</term>
            <term>
            The dx and dy parameters contain normalized absolute coordinates. If not set, those parameters contain relative data: the change
            in position since the last reported position. This flag can be set, or not set, regardless of what kind of mouse or mouse-like
            device, if any, is connected to the system. For further information about relative mouse motion, see the following Remarks section.
            </term>
            </item>
            <item>
            <term>MOUSEEVENTF_LEFTDOWN 0x0002</term>
            <term>The left button is down.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_LEFTUP 0x0004</term>
            <term>The left button is up.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_MIDDLEDOWN 0x0020</term>
            <term>The middle button is down.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_MIDDLEUP 0x0040</term>
            <term>The middle button is up.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_MOVE 0x0001</term>
            <term>Movement occurred.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_RIGHTDOWN 0x0008</term>
            <term>The right button is down.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_RIGHTUP 0x0010</term>
            <term>The right button is up.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_WHEEL 0x0800</term>
            <term>The wheel has been moved, if the mouse has a wheel. The amount of movement is specified in dwData</term>
            </item>
            <item>
            <term>MOUSEEVENTF_XDOWN 0x0080</term>
            <term>An X button was pressed.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_XUP 0x0100</term>
            <term>An X button was released.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_WHEEL 0x0800</term>
            <term>The wheel button is rotated.</term>
            </item>
            <item>
            <term>MOUSEEVENTF_HWHEEL 0x01000</term>
            <term>The wheel button is tilted.</term>
            </item>
            </list>
            <para>
            The values that specify mouse button status are set to indicate changes in status, not ongoing conditions. For example, if the
            left mouse button is pressed and held down, <c>MOUSEEVENTF_LEFTDOWN</c> is set when the left button is first pressed, but not for
            subsequent motions. Similarly, <c>MOUSEEVENTF_LEFTUP</c> is set only when the button is first released.
            </para>
            <para>
            You cannot specify both <c>MOUSEEVENTF_WHEEL</c> and either <c>MOUSEEVENTF_XDOWN</c> or <c>MOUSEEVENTF_XUP</c> simultaneously in
            the dwFlags parameter, because they both require use of the dwData field.
            </para>
            </param>
            <param name="dx">
            <para>Type: <c>DWORD</c></para>
            <para>
            The mouse's absolute position along the x-axis or its amount of motion since the last mouse event was generated, depending on the
            setting of <c>MOUSEEVENTF_ABSOLUTE</c>. Absolute data is specified as the mouse's actual x-coordinate; relative data is specified
            as the number of mickeys moved. A mickey is the amount that a mouse has to move for it to report that it has moved.
            </para>
            </param>
            <param name="dy">
            <para>Type: <c>DWORD</c></para>
            <para>
            The mouse's absolute position along the y-axis or its amount of motion since the last mouse event was generated, depending on the
            setting of <c>MOUSEEVENTF_ABSOLUTE</c>. Absolute data is specified as the mouse's actual y-coordinate; relative data is specified
            as the number of mickeys moved.
            </para>
            </param>
            <param name="dwData">
            <para>Type: <c>DWORD</c></para>
            <para>
            If dwFlags contains <c>MOUSEEVENTF_WHEEL</c>, then dwData specifies the amount of wheel movement. A positive value indicates that
            the wheel was rotated forward, away from the user; a negative value indicates that the wheel was rotated backward, toward the
            user. One wheel click is defined as <c>WHEEL_DELTA</c>, which is 120.
            </para>
            <para>
            If dwFlags contains <c>MOUSEEVENTF_HWHEEL</c>, then dwData specifies the amount of wheel movement. A positive value indicates
            that the wheel was tilted to the right; a negative value indicates that the wheel was tilted to the left.
            </para>
            <para>
            If dwFlags contains <c>MOUSEEVENTF_XDOWN</c> or <c>MOUSEEVENTF_XUP</c>, then dwData specifies which X buttons were pressed or
            released. This value may be any combination of the following flags.
            </para>
            <para>
            If dwFlags is not <c>MOUSEEVENTF_WHEEL</c>, <c>MOUSEEVENTF_XDOWN</c>, or <c>MOUSEEVENTF_XUP</c>, then dwData should be zero.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>XBUTTON1 0x0001</term>
            <term>Set if the first X button was pressed or released.</term>
            </item>
            <item>
            <term>XBUTTON2 0x0002</term>
            <term>Set if the second X button was pressed or released.</term>
            </item>
            </list>
            </param>
            <param name="dwExtraInfo">
            <para>Type: <c>ULONG_PTR</c></para>
            <para>An additional value associated with the mouse event. An application calls GetMessageExtraInfo to obtain this extra information.</para>
            </param>
            <remarks>
            <para>
            If the mouse has moved, indicated by <c>MOUSEEVENTF_MOVE</c> being set, dx and dy hold information about that motion. The
            information is specified as absolute or relative integer values.
            </para>
            <para>
            If <c>MOUSEEVENTF_ABSOLUTE</c> value is specified, dx and dy contain normalized absolute coordinates between 0 and 65,535. The
            event procedure maps these coordinates onto the display surface. Coordinate (0,0) maps onto the upper-left corner of the display
            surface, (65535,65535) maps onto the lower-right corner.
            </para>
            <para>
            If the <c>MOUSEEVENTF_ABSOLUTE</c> value is not specified, dx and dy specify relative motions from when the last mouse event was
            generated (the last reported position). Positive values mean the mouse moved right (or down); negative values mean the mouse
            moved left (or up).
            </para>
            <para>
            Relative mouse motion is subject to the settings for mouse speed and acceleration level. An end user sets these values using the
            Mouse application in Control Panel. An application obtains and sets these values with the SystemParametersInfo function.
            </para>
            <para>
            The system applies two tests to the specified relative mouse motion when applying acceleration. If the specified distance along
            either the x or y axis is greater than the first mouse threshold value, and the mouse acceleration level is not zero, the
            operating system doubles the distance. If the specified distance along either the x- or y-axis is greater than the second mouse
            threshold value, and the mouse acceleration level is equal to two, the operating system doubles the distance that resulted from
            applying the first threshold test. It is thus possible for the operating system to multiply relatively-specified mouse motion
            along the x- or y-axis by up to four times.
            </para>
            <para>
            Once acceleration has been applied, the system scales the resultant value by the desired mouse speed. Mouse speed can range from
            1 (slowest) to 20 (fastest) and represents how much the pointer moves based on the distance the mouse moves. The default value is
            10, which results in no additional modification to the mouse motion.
            </para>
            <para>
            The <c>mouse_event</c> function is used to synthesize mouse events by applications that need to do so. It is also used by
            applications that need to obtain more information from the mouse than its position and button state. For example, if a tablet
            manufacturer wants to pass pen-based information to its own applications, it can write a DLL that communicates directly to the
            tablet hardware, obtains the extra information, and saves it in a queue. The DLL then calls <c>mouse_event</c> with the standard
            button and x/y position data, along with, in the dwExtraInfo parameter, some pointer or index to the queued extra information.
            When the application needs the extra information, it calls the DLL with the pointer or index stored in dwExtraInfo, and the DLL
            returns the extra information.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetDoubleClickTime(System.UInt32)">
            <summary>
            Sets the double-click time for the mouse. A double-click is a series of two clicks of a mouse button, the second occurring within
            a specified time after the first. The double-click time is the maximum number of milliseconds that may occur between the first
            and second clicks of a double-click.
            </summary>
            <param name="Arg1">
            <para>Type: <c>UINT</c></para>
            <para>
            The number of milliseconds that may occur between the first and second clicks of a double-click. If this parameter is set to 0,
            the system uses the default double-click time of 500 milliseconds. If this parameter value is greater than 5000 milliseconds, the
            system sets the value to 5000 milliseconds.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>The <c>SetDoubleClickTime</c> function alters the double-click time for all windows in the system.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SwapMouseButton(System.Boolean)">
            <summary>Reverses or restores the meaning of the left and right mouse buttons.</summary>
            <param name="fSwap">
            <para>Type: <c>BOOL</c></para>
            <para>
            If this parameter is <c>TRUE</c>, the left button generates right-button messages and the right button generates left-button
            messages. If this parameter is <c>FALSE</c>, the buttons are restored to their original meanings.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the meaning of the mouse buttons was reversed previously, before the function was called, the return value is nonzero.</para>
            <para>If the meaning of the mouse buttons was not reversed, the return value is zero.</para>
            </returns>
            <remarks>
            Button swapping is provided as a convenience to people who use the mouse with their left hands. The <c>SwapMouseButton</c>
            function is usually called by Control Panel only. Although an application is free to call the function, the mouse is a shared
            resource and reversing the meaning of its buttons affects all applications.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.TrackMouseEvent(Vanara.PInvoke.User32.TRACKMOUSEEVENT@)">
            <summary>Posts messages when the mouse pointer leaves a window or hovers over a window for a specified amount of time.</summary>
            <param name="lpEventTrack">
            <para>Type: <c>LPTRACKMOUSEEVENT</c></para>
            <para>A pointer to a <c>TRACKMOUSEEVENT</c> structure that contains tracking information.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero .</para>
            <para>If the function fails, return value is zero. To get extended error information, call <c>GetLastError</c>.</para>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.User32.MOUSEMOVEPOINT">
            <summary>Contains information about the mouse's location in screen coordinates.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEMOVEPOINT.x">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The x-coordinate of the mouse.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEMOVEPOINT.y">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The y-coordinate of the mouse.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEMOVEPOINT.time">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The time stamp of the mouse coordinate.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEMOVEPOINT.dwExtraInfo">
            <summary>
            <para>Type: <c>ULONG_PTR</c></para>
            <para>Additional information associated with this coordinate.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TRACKMOUSEEVENT">
            <summary>
            Used by the TrackMouseEvent function to track when the mouse pointer leaves a window or hovers over a window for a specified
            amount of time.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TRACKMOUSEEVENT.cbSize">
            <summary>The size of the TRACKMOUSEEVENT structure, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TRACKMOUSEEVENT.dwFlags">
            <summary>The services requested</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TRACKMOUSEEVENT.hwndTrack">
            <summary>A handle to the window to track.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TRACKMOUSEEVENT.dwHoverTime">
            <summary>
            The hover time-out (if TME_HOVER was specified in dwFlags), in milliseconds. Can be HOVER_DEFAULT, which means to use the
            system default hover time-out.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ODA">
            <summary>The owner-draw required drawing action.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODA.ODA_DRAWENTIRE">
            <summary>The entire control needs to be drawn.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODA.ODA_SELECT">
            <summary>The selection status has changed. The itemState member should be checked to determine the new selection state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODA.ODA_FOCUS">
            <summary>
            The control has lost or gained the keyboard focus. The itemState member should be checked to determine whether the control
            has the focus.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ODS">
            <summary>The visual state of the item after the current drawing action takes place.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODS.ODS_SELECTED">
            <summary>The menu item's status is selected.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODS.ODS_GRAYED">
            <summary>The item is to be grayed. This bit is used only in a menu.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODS.ODS_DISABLED">
            <summary>The item is to be drawn as disabled.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODS.ODS_CHECKED">
            <summary>The menu item is to be checked. This bit is used only in a menu.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODS.ODS_FOCUS">
            <summary>The item has the keyboard focus.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODS.ODS_DEFAULT">
            <summary>The item is the default item.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODS.ODS_COMBOBOXEDIT">
            <summary>The drawing takes place in the selection field (edit control) of an owner-drawn combo box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODS.ODS_HOTLIGHT">
            <summary>The item is being hot-tracked, that is, the item will be highlighted when the mouse is on the item.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODS.ODS_INACTIVE">
            <summary>The item is inactive and the window associated with the menu is inactive.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODS.ODS_NOACCEL">
            <summary>The control is drawn without the keyboard accelerator cues.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODS.ODS_NOFOCUSRECT">
            <summary>The control is drawn without focus indicator cues.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ODT">
            <summary>The owner-draw control type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODT.ODT_MENU">
            <summary>Owner-drawn menu item</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODT.ODT_LISTBOX">
            <summary>Owner-drawn list box</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODT.ODT_COMBOBOX">
            <summary>Owner-drawn combo box</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODT.ODT_BUTTON">
            <summary>Owner-drawn button</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODT.ODT_STATIC">
            <summary>Owner-drawn static control</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODT.ODT_HEADER">
            <summary>Owner-drawn header</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODT.ODT_TAB">
            <summary>Tab control</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ODT.ODT_LISTVIEW">
            <summary>List-view control</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.COMPAREITEMSTRUCT">
            <summary>
            <para>Supplies the identifiers and application-supplied data for two items in a sorted, owner-drawn list box or combo box.</para>
            <para>
            Whenever an application adds a new item to an owner-drawn list box or combo box created with the CBS_SORT or LBS_SORT style, the
            system sends the owner a WM_COMPAREITEM message. The lParam parameter of the message contains a long pointer to a
            <c>COMPAREITEMSTRUCT</c> structure. Upon receiving the message, the owner compares the two items and returns a value indicating
            which item sorts before the other.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.COMPAREITEMSTRUCT.CtlType">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>An ODT_LISTBOX (owner-drawn list box) or ODT_COMBOBOX (an owner-drawn combo box).</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.COMPAREITEMSTRUCT.CtlID">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The identifier of the list box or combo box.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.COMPAREITEMSTRUCT.hwndItem">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the control.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.COMPAREITEMSTRUCT.itemID1">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>
            The index of the first item in the list box or combo box being compared. This member will be –1 if the item has not been
            inserted or when searching for a potential item in the list box or combo box.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.COMPAREITEMSTRUCT.itemData1">
            <summary>
            <para>Type: <c>ULONG_PTR</c></para>
            <para>
            Application-supplied data for the first item being compared. (This value was passed as the lParam parameter of the message
            that added the item to the list box or combo box.)
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.COMPAREITEMSTRUCT.itemID2">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The index of the second item in the list box or combo box being compared.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.COMPAREITEMSTRUCT.itemData2">
            <summary>
            <para>Type: <c>ULONG_PTR</c></para>
            <para>
            Application-supplied data for the second item being compared. This value was passed as the lParam parameter of the message
            that added the item to the list box or combo box. This member will be –1 if the item has not been inserted or when searching
            for a potential item in the list box or combo box.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.COMPAREITEMSTRUCT.dwLocaleId">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The locale identifier. To create a locale identifier, use the MAKELCID macro.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DELETEITEMSTRUCT">
            <summary>
            <para>
            Describes a deleted list box or combo box item. The lParam parameter of a WM_DELETEITEM message contains a pointer to this
            structure. When an item is removed from a list box or combo box or when a list box or combo box is destroyed, the system sends
            the <c>WM_DELETEITEM</c> message to the owner for each deleted item.
            </para>
            <para>
            The system sends a WM_DELETEITEM message only for items deleted from an owner-drawn list box (with the LBS_OWNERDRAWFIXED or
            LBS_OWNERDRAWVARIABLE style) or owner-drawn combo box (with the CBS_OWNERDRAWFIXED or CBS_OWNERDRAWVARIABLE style).
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DELETEITEMSTRUCT.CtlType">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>Specifies whether the item was deleted from a list box or a combo box. One of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ODT_LISTBOX</term>
            <term>A list box.</term>
            </item>
            <item>
            <term>ODT_COMBOBOX</term>
            <term>A combo box.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DELETEITEMSTRUCT.CtlID">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The identifier of the list box or combo box.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DELETEITEMSTRUCT.itemID">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The index of the item in the list box or combo box being removed.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DELETEITEMSTRUCT.hwndItem">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the control.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DELETEITEMSTRUCT.itemData">
            <summary>
            <para>Type: <c>ULONG_PTR</c></para>
            <para>
            Application-defined data for the item. This value is passed to the control in the lParam parameter of the message that adds
            the item to the list box or combo box.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DRAWITEMSTRUCT">
            <summary>
            Provides information that the owner window uses to determine how to paint an owner-drawn control or menu item. The owner window
            of the owner-drawn control or menu item receives a pointer to this structure as the lParam parameter of the WM_DRAWITEM message.
            </summary>
            <remarks>Some control types, such as status bars, do not set the value of <c>CtlType</c>.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.DRAWITEMSTRUCT.CtlType">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The control type. This member can be one of the following values. See Remarks.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ODT_BUTTON</term>
            <term>Owner-drawn button</term>
            </item>
            <item>
            <term>ODT_COMBOBOX</term>
            <term>Owner-drawn combo box</term>
            </item>
            <item>
            <term>ODT_LISTBOX</term>
            <term>Owner-drawn list box</term>
            </item>
            <item>
            <term>ODT_LISTVIEW</term>
            <term>List-view control</term>
            </item>
            <item>
            <term>ODT_MENU</term>
            <term>Owner-drawn menu item</term>
            </item>
            <item>
            <term>ODT_STATIC</term>
            <term>Owner-drawn static control</term>
            </item>
            <item>
            <term>ODT_TAB</term>
            <term>Tab control</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DRAWITEMSTRUCT.CtlID">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The identifier of the combo box, list box, button, or static control. This member is not used for a menu item.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DRAWITEMSTRUCT.itemID">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>
            The menu item identifier for a menu item or the index of the item in a list box or combo box. For an empty list box or combo
            box, this member can be
            <code>-1</code>
            . This allows the application to draw only the focus rectangle at the coordinates specified by the <c>rcItem</c> member even
            though there are no items in the control. This indicates to the user whether the list box or combo box has the focus. How
            the bits are set in the <c>itemAction</c> member determines whether the rectangle is to be drawn as though the list box or
            combo box has the focus.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DRAWITEMSTRUCT.itemAction">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The required drawing action. This member can be one or more of the values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ODA_DRAWENTIRE</term>
            <term>The entire control needs to be drawn.</term>
            </item>
            <item>
            <term>ODA_FOCUS</term>
            <term>
            The control has lost or gained the keyboard focus. The itemState member should be checked to determine whether the control
            has the focus.
            </term>
            </item>
            <item>
            <term>ODA_SELECT</term>
            <term>The selection status has changed. The itemState member should be checked to determine the new selection state.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DRAWITEMSTRUCT.itemState">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>
            The visual state of the item after the current drawing action takes place. This member can be a combination of the values
            shown in the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ODS_CHECKED</term>
            <term>The menu item is to be checked. This bit is used only in a menu.</term>
            </item>
            <item>
            <term>ODS_COMBOBOXEDIT</term>
            <term>The drawing takes place in the selection field (edit control) of an owner-drawn combo box.</term>
            </item>
            <item>
            <term>ODS_DEFAULT</term>
            <term>The item is the default item.</term>
            </item>
            <item>
            <term>ODS_DISABLED</term>
            <term>The item is to be drawn as disabled.</term>
            </item>
            <item>
            <term>ODS_FOCUS</term>
            <term>The item has the keyboard focus.</term>
            </item>
            <item>
            <term>ODS_GRAYED</term>
            <term>The item is to be grayed. This bit is used only in a menu.</term>
            </item>
            <item>
            <term>ODS_HOTLIGHT</term>
            <term>The item is being hot-tracked, that is, the item will be highlighted when the mouse is on the item.</term>
            </item>
            <item>
            <term>ODS_INACTIVE</term>
            <term>The item is inactive and the window associated with the menu is inactive.</term>
            </item>
            <item>
            <term>ODS_NOACCEL</term>
            <term>The control is drawn without the keyboard accelerator cues.</term>
            </item>
            <item>
            <term>ODS_NOFOCUSRECT</term>
            <term>The control is drawn without focus indicator cues.</term>
            </item>
            <item>
            <term>ODS_SELECTED</term>
            <term>The menu item's status is selected.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DRAWITEMSTRUCT.hwndItem">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the control for combo boxes, list boxes, buttons, and static controls. For menus, this member is a handle to the
            menu that contains the item.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DRAWITEMSTRUCT.hDC">
            <summary>
            <para>Type: <c>HDC</c></para>
            <para>A handle to a device context; this device context must be used when performing drawing operations on the control.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DRAWITEMSTRUCT.rcItem">
            <summary>
            <para>Type: <c>RECT</c></para>
            <para>
            A rectangle that defines the boundaries of the control to be drawn. This rectangle is in the device context specified by the
            <c>hDC</c> member. The system automatically clips anything that the owner window draws in the device context for combo
            boxes, list boxes, and buttons, but does not clip menu items. When drawing menu items, the owner window must not draw
            outside the boundaries of the rectangle defined by the <c>rcItem</c> member.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DRAWITEMSTRUCT.itemData">
            <summary>
            <para>Type: <c>ULONG_PTR</c></para>
            <para>
            The application-defined value associated with the menu item. For a control, this parameter specifies the value last assigned
            to the list box or combo box by the LB_SETITEMDATA or CB_SETITEMDATA message. If the list box or combo box has the
            LBS_HASSTRINGS or CBS_HASSTRINGS style, this value is initially zero. Otherwise, this value is initially the value that was
            passed to the list box or combo box in the lParam parameter of one of the following messages:
            </para>
            <list type="bullet">
            <item>
            <term>CB_ADDSTRING</term>
            </item>
            <item>
            <term>CB_INSERTSTRING</term>
            </item>
            <item>
            <term>LB_ADDSTRING</term>
            </item>
            <item>
            <term>LB_INSERTSTRING</term>
            </item>
            </list>
            <para>If</para>
            <para>CtlType</para>
            <para>is</para>
            <para>ODT_BUTTON</para>
            <para>or</para>
            <para>ODT_STATIC</para>
            <para>,</para>
            <para>itemData</para>
            <para>is zero.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MEASUREITEMSTRUCT">
            <summary>
            Informs the system of the dimensions of an owner-drawn control or menu item. This allows the system to process user interaction
            with the control correctly.
            </summary>
            <remarks>
            <para>
            The owner window of an owner-drawn control receives a pointer to the <c>MEASUREITEMSTRUCT</c> structure as the lParam parameter
            of a WM_MEASUREITEM message. The owner-drawn control sends this message to its owner window when the control is created. The
            owner then fills in the appropriate members in the structure for the control and returns. This structure is common to all
            owner-drawn controls except the owner-drawn button control whose size is predetermined by its window.
            </para>
            <para>
            If an application does not fill the appropriate members of <c>MEASUREITEMSTRUCT</c>, the control or menu item may not be drawn properly.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.MEASUREITEMSTRUCT.CtlType">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The control type. This member can be one of the values shown in the following table.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ODT_COMBOBOX</term>
            <term>Owner-drawn combo box</term>
            </item>
            <item>
            <term>ODT_LISTBOX</term>
            <term>Owner-drawn list box</term>
            </item>
            <item>
            <term>ODT_LISTVIEW</term>
            <term>Owner-draw list-view control</term>
            </item>
            <item>
            <term>ODT_MENU</term>
            <term>Owner-drawn menu</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MEASUREITEMSTRUCT.CtlID">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The identifier of the combo box or list box. This member is not used for a menu.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MEASUREITEMSTRUCT.itemID">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>
            The identifier for a menu item or the position of a list box or combo box item. This value is specified for a list box only
            if it has the LBS_OWNERDRAWVARIABLE style; this value is specified for a combo box only if it has the CBS_OWNERDRAWVARIABLE style.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MEASUREITEMSTRUCT.itemWidth">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>
            The width, in pixels, of a menu item. Before returning from the message, the owner of the owner-drawn menu item must fill
            this member.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MEASUREITEMSTRUCT.itemHeight">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>
            The height, in pixels, of an individual item in a list box or a menu. Before returning from the message, the owner of the
            owner-drawn combo box, list box, or menu item must fill out this member.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MEASUREITEMSTRUCT.itemData">
            <summary>
            <para>Type: <c>ULONG_PTR</c></para>
            <para>
            The application-defined value associated with the menu item. For a control, this member specifies the value last assigned to
            the list box or combo box by the LB_SETITEMDATA or CB_SETITEMDATA message. If the list box or combo box has the
            LB_HASSTRINGS or CB_HASSTRINGS style, this value is initially zero. Otherwise, this value is initially the value passed to
            the list box or combo box in the lParam parameter of one of the following messages:
            </para>
            <list type="bullet">
            <item>
            <term>CB_ADDSTRING</term>
            </item>
            <item>
            <term>CB_INSERTSTRING</term>
            </item>
            <item>
            <term>LB_ADDSTRING</term>
            </item>
            <item>
            <term>LB_INSERTSTRING</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DrawStateProc">
            <summary>
            The <c>DrawStateProc</c> function is an application-defined callback function that renders a complex image for the DrawState
            function. The <c>DRAWSTATEPROC</c> type defines a pointer to this callback function. <c>DrawStateProc</c> is a placeholder for
            the application-defined function name.
            </summary>
            <param name="hdc">
            A handle to the device context to draw in. The device context is a memory device context with a bitmap selected, the dimensions
            of which are at least as great as those specified by the <c>cx</c> and <c>cy</c> parameters.
            </param>
            <param name="lData">Specifies information about the image, which the application passed to DrawState.</param>
            <param name="wData">Specifies information about the image, which the application passed to DrawState.</param>
            <param name="cx">The image width, in device units, as specified by the call to DrawState.</param>
            <param name="cy">The image height, in device units, as specified by the call to DrawState.</param>
            <returns>
            <para>If the function succeeds, the return value is <c>TRUE</c>.</para>
            <para>If the function fails, the return value is <c>FALSE</c>.</para>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.User32.OutputProc">
            <summary>
            The <c>OutputProc</c> function is an application-defined callback function used with the GrayString function. It is used to draw
            a string. The <c>GRAYSTRINGPROC</c> type defines a pointer to this callback function. <c>OutputProc</c> is a placeholder for the
            application-defined or library-defined function name.
            </summary>
            <param name="hdc">
            A handle to a device context with a bitmap of at least the width and height specified by the nWidth and nHeight parameters passed
            to GrayString.
            </param>
            <param name="lpData">A pointer to the string to be drawn.</param>
            <param name="cchData">The length, in characters, of the string.</param>
            <returns>
            <para>If it succeeds, the callback function should return <c>TRUE</c>.</para>
            <para>If the function fails, the return value is <c>FALSE</c>.</para>
            </returns>
            <remarks>The callback function must draw an image relative to the coordinates (0,0).</remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.BorderFlags">
            <summary>Flags used by the <see cref="M:Vanara.PInvoke.User32.DrawEdge(Vanara.PInvoke.HDC,Vanara.PInvoke.RECT@,Vanara.PInvoke.User32.BorderStyles3D,Vanara.PInvoke.User32.BorderFlags)"/> method.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_LEFT">
            <summary>Left side of border rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_TOP">
            <summary>Top of border rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_RIGHT">
            <summary>Right side of border rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_BOTTOM">
            <summary>Bottom of border rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_TOPLEFT">
            <summary>Top and left side of border rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_TOPRIGHT">
            <summary>Top and right side of border rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_BOTTOMLEFT">
            <summary>Bottom and left side of border rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_BOTTOMRIGHT">
            <summary>Bottom and right side of border rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_RECT">
            <summary>Entire border rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_DIAGONAL">
            <summary>Diagonal border.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_DIAGONAL_ENDTOPRIGHT">
            <summary>Diagonal border. The end point is the top-right corner of the rectangle; the origin is lower-left corner.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_DIAGONAL_ENDTOPLEFT">
            <summary>Diagonal border. The end point is the top-left corner of the rectangle; the origin is lower-right corner.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_DIAGONAL_ENDBOTTOMLEFT">
            <summary>Diagonal border. The end point is the lower-left corner of the rectangle; the origin is top-right corner.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_DIAGONAL_ENDBOTTOMRIGHT">
            <summary>Diagonal border. The end point is the lower-right corner of the rectangle; the origin is top-left corner.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_MIDDLE">
            <summary>Interior of rectangle to be filled.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_SOFT">
            <summary>Soft buttons instead of tiles.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_ADJUST">
            <summary>
            The rectangle pointed to by the pDestRect parameter is shrunk to exclude the edges that were drawn; otherwise the rectangle
            does not change.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_FLAT">
            <summary>Flat border.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderFlags.BF_MONO">
            <summary>One-dimensional border.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.BorderStyles3D">
            <summary>Styles used by the <see cref="M:Vanara.PInvoke.User32.DrawEdge(Vanara.PInvoke.HDC,Vanara.PInvoke.RECT@,Vanara.PInvoke.User32.BorderStyles3D,Vanara.PInvoke.User32.BorderFlags)"/> method.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderStyles3D.BDR_RAISEDOUTER">
            <summary>Raised outer edge</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderStyles3D.BDR_SUNKENOUTER">
            <summary>Sunken outer edge</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderStyles3D.BDR_RAISEDINNER">
            <summary>Raised inner edge</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderStyles3D.BDR_SUNKENINNER">
            <summary>Sunken inner edge</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderStyles3D.BDR_OUTER">
            <summary>Combination of BDR_RAISEDOUTER and BDR_SUNKENINNER</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderStyles3D.BDR_INNER">
            <summary>Combination of BDR_RAISEDINNER and BDR_SUNKENINNER</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderStyles3D.BDR_RAISED">
            <summary>Combination of BDR_RAISEDOUTER and BDR_RAISEDINNER</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderStyles3D.BDR_SUNKEN">
            <summary>Combination of BDR_SUNKENOUTER and BDR_SUNKENINNER</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderStyles3D.EDGE_RAISED">
            <summary>Combination of BDR_RAISEDOUTER and BDR_RAISEDINNER</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderStyles3D.EDGE_SUNKEN">
            <summary>Combination of BDR_SUNKENOUTER and BDR_SUNKENINNER</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderStyles3D.EDGE_ETCHED">
            <summary>Combination of BDR_SUNKENOUTER and BDR_RAISEDINNER</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.BorderStyles3D.EDGE_BUMP">
            <summary>Combination of BDR_RAISEDOUTER and BDR_SUNKENINNER</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DrawCaptionFlags">
            <summary>Flags used by <see cref="M:Vanara.PInvoke.User32.DrawCaption(Vanara.PInvoke.HWND,Vanara.PInvoke.HDC,Vanara.PInvoke.RECT@,Vanara.PInvoke.User32.DrawCaptionFlags)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawCaptionFlags.DC_ACTIVE">
            <summary>The function uses the colors that denote an active caption.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawCaptionFlags.DC_SMALLCAP">
            <summary>The function draws a small caption, using the current small caption font.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawCaptionFlags.DC_ICON">
            <summary>The function draws the icon when drawing the caption text.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawCaptionFlags.DC_TEXT">
            <summary>The function draws the caption text when drawing the caption.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawCaptionFlags.DC_INBUTTON">
            <summary>The function draws the caption as a button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawCaptionFlags.DC_GRADIENT">
            <summary>
            When this flag is set, the function uses COLOR_GRADIENTACTIVECAPTION (if the DC_ACTIVE flag was set) or
            COLOR_GRADIENTINACTIVECAPTION for the title-bar color.
            <para>If this flag is not set, the function uses COLOR_ACTIVECAPTION or COLOR_INACTIVECAPTION for both colors.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawCaptionFlags.DC_BUTTONS">
            <summary>If set, the function draws the buttons in the caption bar (to minimize, restore, or close an application).</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DrawStateFlags">
            <summary>Flags used by <see cref="M:Vanara.PInvoke.User32.DrawState(Vanara.PInvoke.HDC,Vanara.PInvoke.HBRUSH,Vanara.PInvoke.User32.DrawStateProc,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.User32.DrawStateFlags)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawStateFlags.DST_COMPLEX">
            <summary>
            The image is application defined. To render the image, DrawState calls the callback function specified by the lpOutputFunc parameter.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawStateFlags.DST_TEXT">
            <summary>
            The image is text. The lData parameter is a pointer to the string, and the wData parameter specifies the length. If wData is
            zero, the string must be null-terminated.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawStateFlags.DST_PREFIXTEXT">
            <summary>The image is text that may contain an accelerator mnemonic. DrawState interprets the ampersand (&amp;) prefix character
            as a directive to underscore the character that follows. The lData parameter is a pointer to the string, and the wData
            parameter specifies the length. If wData is zero, the string must be null-terminated.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawStateFlags.DST_ICON">
            <summary>The image is an icon. The lData parameter is the icon handle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawStateFlags.DST_BITMAP">
            <summary>
            The image is a bitmap. The lData parameter is the bitmap handle. Note that the bitmap cannot already be selected into an
            existing device context.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawStateFlags.DSS_NORMAL">
            <summary>Draws the image without any modification.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawStateFlags.DSS_UNION">
            <summary>Dithers the image.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawStateFlags.DSS_DISABLED">
            <summary>Embosses the image.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawStateFlags.DSS_MONO">
            <summary>Draws the image using the brush specified by the hbr parameter.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawStateFlags.DSS_HIDEPREFIX">
            <summary>Ignores the ampersand (&amp;) prefix character in the text, thus the letter that follows will not be underlined. This
            must be used with DST_PREFIXTEXT.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawStateFlags.DSS_PREFIXONLY">
            <summary>Draws only the underline at the position of the letter after the ampersand (&amp;) prefix character. No text in the
            string is drawn. This must be used with DST_PREFIXTEXT.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DrawStateFlags.DSS_RIGHT">
            <summary>Aligns the text to the right.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.FrameControlState">
            <summary>State of the control to draw with <see cref="M:Vanara.PInvoke.User32.DrawFrameControl(Vanara.PInvoke.HDC,Vanara.PInvoke.RECT@,Vanara.PInvoke.User32.FrameControlType,Vanara.PInvoke.User32.FrameControlState)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_CAPTIONCLOSE">
            <summary>Close button</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_CAPTIONMIN">
            <summary>Minimize button</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_CAPTIONMAX">
            <summary>Maximize button</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_CAPTIONRESTORE">
            <summary>Restore button</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_CAPTIONHELP">
            <summary>Help button</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_MENUARROW">
            <summary>Submenu arrow</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_MENUCHECK">
            <summary>Check mark</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_MENUBULLET">
            <summary>Bullet</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_MENUARROWRIGHT">
            <summary>
            Submenu arrow pointing left. This is used for the right-to-left cascading menus used with right-to-left languages such as
            Arabic or Hebrew.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_SCROLLUP">
            <summary>Up arrow of scroll bar</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_SCROLLDOWN">
            <summary>Down arrow of scroll bar</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_SCROLLLEFT">
            <summary>Left arrow of scroll bar</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_SCROLLRIGHT">
            <summary>Right arrow of scroll bar</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_SCROLLCOMBOBOX">
            <summary>Combo box scroll bar</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_SCROLLSIZEGRIP">
            <summary>Size grip in lower-right corner of window</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_SCROLLSIZEGRIPRIGHT">
            <summary>Size grip in lower-left corner of window. This is used with right-to-left languages such as Arabic or Hebrew.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_BUTTONCHECK">
            <summary>Check box</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_BUTTONRADIOIMAGE">
            <summary>Image for radio button (nonsquare needs image)</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_BUTTONRADIOMASK">
            <summary>Mask for radio button (nonsquare needs mask)</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_BUTTONRADIO">
            <summary>Radio button</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_BUTTON3STATE">
            <summary>Three-state button</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_BUTTONPUSH">
            <summary>Push button</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_INACTIVE">
            <summary>Button is inactive (grayed).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_PUSHED">
            <summary>Button is pushed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_CHECKED">
            <summary>Button is checked.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_TRANSPARENT">
            <summary>The background remains untouched. This flag can only be combined with DFCS_MENUARROWUP or DFCS_MENUARROWDOWN.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_HOT">
            <summary>Button is hot-tracked.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_ADJUSTRECT">
            <summary>Bounding rectangle is adjusted to exclude the surrounding edge of the push button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_FLAT">
            <summary>Button has a flat border.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlState.DFCS_MONO">
            <summary>Button has a monochrome border.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.FrameControlType">
            <summary>Type of control to draw with <see cref="M:Vanara.PInvoke.User32.DrawFrameControl(Vanara.PInvoke.HDC,Vanara.PInvoke.RECT@,Vanara.PInvoke.User32.FrameControlType,Vanara.PInvoke.User32.FrameControlState)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlType.DFC_CAPTION">
            <summary>Title bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlType.DFC_MENU">
            <summary>Menu bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlType.DFC_SCROLL">
            <summary>Scroll bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlType.DFC_BUTTON">
            <summary>Standard button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FrameControlType.DFC_POPUPMENU">
            <summary>Popup menu item.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.IDANI">
            <summary>Flags used by <see cref="M:Vanara.PInvoke.User32.DrawAnimatedRects(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.IDANI,Vanara.PInvoke.RECT@,Vanara.PInvoke.RECT@)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDANI.IDANI_OPEN">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.IDANI.IDANI_CAPTION">
            <summary>
            The window caption will animate from the position specified by lprcFrom to the position specified by lprcTo. The effect is
            similar to minimizing or maximizing a window.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.RedrawWindowFlags">
            <summary>Flags used to invalidate or validate a window, control repainting, and control which windows are affected by RedrawWindow.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RedrawWindowFlags.RDW_INVALIDATE">
            <summary>Invalidates lprcUpdate or hrgnUpdate (only one may be non-NULL). If both are NULL, the entire window is invalidated.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RedrawWindowFlags.RDW_INTERNALPAINT">
            <summary>Causes a WM_PAINT message to be posted to the window regardless of whether any portion of the window is invalid.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RedrawWindowFlags.RDW_ERASE">
            <summary>
            Causes the window to receive a WM_ERASEBKGND message when the window is repainted. The RDW_INVALIDATE flag must also be
            specified; otherwise, RDW_ERASE has no effect.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RedrawWindowFlags.RDW_VALIDATE">
            <summary>
            Validates lprcUpdate or hrgnUpdate (only one may be non-NULL). If both are NULL, the entire window is validated. This flag
            does not affect internal WM_PAINT messages.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RedrawWindowFlags.RDW_NOINTERNALPAINT">
            <summary>
            Suppresses any pending internal WM_PAINT messages. This flag does not affect WM_PAINT messages resulting from a non-NULL
            update area.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RedrawWindowFlags.RDW_NOERASE">
            <summary>Suppresses any pending WM_ERASEBKGND messages.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RedrawWindowFlags.RDW_NOCHILDREN">
            <summary>Excludes child windows, if any, from the repainting operation.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RedrawWindowFlags.RDW_ALLCHILDREN">
            <summary>Includes child windows, if any, in the repainting operation.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RedrawWindowFlags.RDW_UPDATENOW">
            <summary>
            Causes the affected windows (as specified by the RDW_ALLCHILDREN and RDW_NOCHILDREN flags) to receive WM_NCPAINT,
            WM_ERASEBKGND, and WM_PAINT messages, if necessary, before the function returns.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RedrawWindowFlags.RDW_ERASENOW">
            <summary>
            Causes the affected windows (as specified by the RDW_ALLCHILDREN and RDW_NOCHILDREN flags) to receive WM_NCPAINT and
            WM_ERASEBKGND messages, if necessary, before the function returns. WM_PAINT messages are received at the ordinary time.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RedrawWindowFlags.RDW_FRAME">
            <summary>
            Causes any part of the nonclient area of the window that intersects the update region to receive a WM_NCPAINT message. The
            RDW_INVALIDATE flag must also be specified; otherwise, RDW_FRAME has no effect. The WM_NCPAINT message is typically not sent
            during the execution of RedrawWindow unless either RDW_UPDATENOW or RDW_ERASENOW is specified.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.RedrawWindowFlags.RDW_NOFRAME">
            <summary>
            Suppresses any pending WM_NCPAINT messages. This flag must be used with RDW_VALIDATE and is typically used with
            RDW_NOCHILDREN. RDW_NOFRAME should be used with care, as it could cause parts of a window to be painted improperly.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.BeginPaint(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.PAINTSTRUCT@)">
            <summary>
            The <c>BeginPaint</c> function prepares the specified window for painting and fills a PAINTSTRUCT structure with information
            about the painting.
            </summary>
            <param name="hWnd">Handle to the window to be repainted.</param>
            <param name="lpPaint">Pointer to the PAINTSTRUCT structure that will receive painting information.</param>
            <returns>
            <para>If the function succeeds, the return value is the handle to a display device context for the specified window.</para>
            <para>If the function fails, the return value is <c>NULL</c>, indicating that no display device context is available.</para>
            </returns>
            <remarks>
            <para>
            The <c>BeginPaint</c> function automatically sets the clipping region of the device context to exclude any area outside the
            update region. The update region is set by the InvalidateRect or InvalidateRgn function and by the system after sizing, moving,
            creating, scrolling, or any other operation that affects the client area. If the update region is marked for erasing,
            <c>BeginPaint</c> sends a <c>WM_ERASEBKGND</c> message to the window.
            </para>
            <para>
            An application should not call <c>BeginPaint</c> except in response to a <c>WM_PAINT</c> message. Each call to <c>BeginPaint</c>
            must have a corresponding call to the EndPaint function.
            </para>
            <para>If the caret is in the area to be painted, <c>BeginPaint</c> automatically hides the caret to prevent it from being erased.</para>
            <para>
            If the window's class has a background brush, <c>BeginPaint</c> uses that brush to erase the background of the update region
            before returning.
            </para>
            <para>DPI Virtualization</para>
            <para>This API does not participate in DPI virtualization. The output returned is always in terms of physical pixels.</para>
            <para>Examples</para>
            <para>For an example, see Drawing in the Client Area.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DrawAnimatedRects(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.IDANI,Vanara.PInvoke.RECT@,Vanara.PInvoke.RECT@)">
            <summary>Animates the caption of a window to indicate the opening of an icon or the minimizing or maximizing of a window.</summary>
            <param name="hwnd">
            A handle to the window whose caption should be animated on the screen. The animation will be clipped to the parent of this window.
            </param>
            <param name="idAni">
            The type of animation. This must be IDANI_CAPTION. With the IDANI_CAPTION animation type, the window caption will animate from
            the position specified by lprcFrom to the position specified by lprcTo. The effect is similar to minimizing or maximizing a window.
            </param>
            <param name="lprcFrom">
            A pointer to a RECT structure specifying the location and size of the icon or minimized window. Coordinates are relative to the
            clipping window hwnd.
            </param>
            <param name="lprcTo">
            A pointer to a RECT structure specifying the location and size of the restored window. Coordinates are relative to the clipping
            window hwnd.
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.DrawCaption(Vanara.PInvoke.HWND,Vanara.PInvoke.HDC,Vanara.PInvoke.RECT@,Vanara.PInvoke.User32.DrawCaptionFlags)">
            <summary>The <c>DrawCaption</c> function draws a window caption.</summary>
            <param name="hwnd">A handle to a window that supplies text and an icon for the window caption.</param>
            <param name="hdc">A handle to a device context. The function draws the window caption into this device context.</param>
            <param name="lprect">
            A pointer to a RECT structure that specifies the bounding rectangle for the window caption in logical coordinates.
            </param>
            <param name="flags">
            <para>The drawing options. This parameter can be zero or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DC_ACTIVE</term>
            <term>The function uses the colors that denote an active caption.</term>
            </item>
            <item>
            <term>DC_BUTTONS</term>
            <term>If set, the function draws the buttons in the caption bar (to minimize, restore, or close an application).</term>
            </item>
            <item>
            <term>DC_GRADIENT</term>
            <term>
            When this flag is set, the function uses COLOR_GRADIENTACTIVECAPTION (if the DC_ACTIVE flag was set) or
            COLOR_GRADIENTINACTIVECAPTION for the title-bar color. If this flag is not set, the function uses COLOR_ACTIVECAPTION or
            COLOR_INACTIVECAPTION for both colors.
            </term>
            </item>
            <item>
            <term>DC_ICON</term>
            <term>The function draws the icon when drawing the caption text.</term>
            </item>
            <item>
            <term>DC_INBUTTON</term>
            <term>The function draws the caption as a button.</term>
            </item>
            <item>
            <term>DC_SMALLCAP</term>
            <term>The function draws a small caption, using the current small caption font.</term>
            </item>
            <item>
            <term>DC_TEXT</term>
            <term>The function draws the caption text when drawing the caption.</term>
            </item>
            </list>
            <para>If DC_SMALLCAP is specified, the function draws a normal window caption.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.DrawEdge(Vanara.PInvoke.HDC,Vanara.PInvoke.RECT@,Vanara.PInvoke.User32.BorderStyles3D,Vanara.PInvoke.User32.BorderFlags)">
            <summary>The <c>DrawEdge</c> function draws one or more edges of rectangle.</summary>
            <param name="hdc">A handle to the device context.</param>
            <param name="qrc">A pointer to a <c>RECT</c> structure that contains the logical coordinates of the rectangle.</param>
            <param name="edge">
            <para>
            The type of inner and outer edges to draw. This parameter must be a combination of one inner-border flag and one outer-border
            flag. The inner-border flags are as follows.
            </para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>BDR_RAISEDINNER</term>
            <term>Raised inner edge.</term>
            </item>
            <item>
            <term>BDR_SUNKENINNER</term>
            <term>Sunken inner edge.</term>
            </item>
            </list>
            </para>
            <para>The outer-border flags are as follows.</para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>BDR_RAISEDOUTER</term>
            <term>Raised outer edge.</term>
            </item>
            <item>
            <term>BDR_SUNKENOUTER</term>
            <term>Sunken outer edge.</term>
            </item>
            </list>
            </para>
            <para>Alternatively, the edge parameter can specify one of the following flags.</para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>EDGE_BUMP</term>
            <term>Combination of BDR_RAISEDOUTER and BDR_SUNKENINNER.</term>
            </item>
            <item>
            <term>EDGE_ETCHED</term>
            <term>Combination of BDR_SUNKENOUTER and BDR_RAISEDINNER.</term>
            </item>
            <item>
            <term>EDGE_RAISED</term>
            <term>Combination of BDR_RAISEDOUTER and BDR_RAISEDINNER.</term>
            </item>
            <item>
            <term>EDGE_SUNKEN</term>
            <term>Combination of BDR_SUNKENOUTER and BDR_SUNKENINNER.</term>
            </item>
            </list>
            </para>
            </param>
            <param name="grfFlags">
            <para>The type of border. This parameter can be a combination of the following values.</para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>BF_ADJUST</term>
            <term>
            If this flag is passed, shrink the rectangle pointed to by the qrc parameter to exclude the edges that were drawn.If this flag is
            not passed, then do not change the rectangle pointed to by the qrc parameter.
            </term>
            </item>
            <item>
            <term>BF_BOTTOM</term>
            <term>Bottom of border rectangle.</term>
            </item>
            <item>
            <term>BF_BOTTOMLEFT</term>
            <term>Bottom and left side of border rectangle.</term>
            </item>
            <item>
            <term>BF_BOTTOMRIGHT</term>
            <term>Bottom and right side of border rectangle.</term>
            </item>
            <item>
            <term>BF_DIAGONAL</term>
            <term>Diagonal border.</term>
            </item>
            <item>
            <term>BF_DIAGONAL_ENDBOTTOMLEFT</term>
            <term>Diagonal border. The end point is the lower-left corner of the rectangle; the origin is top-right corner.</term>
            </item>
            <item>
            <term>BF_DIAGONAL_ENDBOTTOMRIGHT</term>
            <term>Diagonal border. The end point is the lower-right corner of the rectangle; the origin is top-left corner.</term>
            </item>
            <item>
            <term>BF_DIAGONAL_ENDTOPLEFT</term>
            <term>Diagonal border. The end point is the top-left corner of the rectangle; the origin is lower-right corner.</term>
            </item>
            <item>
            <term>BF_DIAGONAL_ENDTOPRIGHT</term>
            <term>Diagonal border. The end point is the top-right corner of the rectangle; the origin is lower-left corner.</term>
            </item>
            <item>
            <term>BF_FLAT</term>
            <term>Flat border.</term>
            </item>
            <item>
            <term>BF_LEFT</term>
            <term>Left side of border rectangle.</term>
            </item>
            <item>
            <term>BF_MIDDLE</term>
            <term>Interior of rectangle to be filled.</term>
            </item>
            <item>
            <term>BF_MONO</term>
            <term>One-dimensional border.</term>
            </item>
            <item>
            <term>BF_RECT</term>
            <term>Entire border rectangle.</term>
            </item>
            <item>
            <term>BF_RIGHT</term>
            <term>Right side of border rectangle.</term>
            </item>
            <item>
            <term>BF_SOFT</term>
            <term>Soft buttons instead of tiles.</term>
            </item>
            <item>
            <term>BF_TOP</term>
            <term>Top of border rectangle.</term>
            </item>
            <item>
            <term>BF_TOPLEFT</term>
            <term>Top and left side of border rectangle.</term>
            </item>
            <item>
            <term>BF_TOPRIGHT</term>
            <term>Top and right side of border rectangle.</term>
            </item>
            </list>
            </para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.DrawFocusRect(Vanara.PInvoke.HDC,Vanara.PInvoke.RECT@)">
            <summary>The <c>DrawFocusRect</c> function draws a rectangle in the style used to indicate that the rectangle has the focus.</summary>
            <param name="hDC">A handle to the device context.</param>
            <param name="lprc">A pointer to a RECT structure that specifies the logical coordinates of the rectangle.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para><c>DrawFocusRect</c> works only in MM_TEXT mode.</para>
            <para>
            Because <c>DrawFocusRect</c> is an XOR function, calling it a second time with the same rectangle removes the rectangle from the screen.
            </para>
            <para>
            This function draws a rectangle that cannot be scrolled. To scroll an area containing a rectangle drawn by this function, call
            <c>DrawFocusRect</c> to remove the rectangle from the screen, scroll the area, and then call <c>DrawFocusRect</c> again to draw
            the rectangle in the new position.
            </para>
            <para>
            <c>Windows XP:</c> The focus rectangle can now be thicker than 1 pixel, so it is more visible for high-resolution, high-density
            displays and accessibility needs. This is handled by the SPI_SETFOCUSBORDERWIDTH and SPI_SETFOCUSBORDERHEIGHT in SystemParametersInfo.
            </para>
            <para>Examples</para>
            <para>For an example, see "Creating an Owner-Drawn List Box" in Using List Boxes.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DrawFrameControl(Vanara.PInvoke.HDC,Vanara.PInvoke.RECT@,Vanara.PInvoke.User32.FrameControlType,Vanara.PInvoke.User32.FrameControlState)">
            <summary>The <c>DrawFrameControl</c> function draws a frame control of the specified type and style.</summary>
            <param name="hdc">Handle to the device context of the window in which to draw the control.</param>
            <param name="lprc">
            Long pointer to a RECT structure that contains the logical coordinates of the bounding rectangle for frame control.
            </param>
            <param name="uType">Specifies the type of frame control to draw.</param>
            <param name="uState">Specifies the initial state of the frame control.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            If uType is either DFC_MENU or DFC_BUTTON and uState is not DFCS_BUTTONPUSH, the frame control is a black-on-white mask (that is,
            a black frame control on a white background). In such cases, the application must pass a handle to a bitmap memory device
            control. The application can then use the associated bitmap as the hbmMask parameter to the MaskBlt function, or it can use the
            device context as a parameter to the BitBlt function using ROPs such as SRCAND and SRCINVERT.
            </para>
            <para>DPI Virtualization</para>
            <para>
            This API does not participate in DPI virtualization. The input given is always in terms of physical pixels, and is not related to
            the calling context.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DrawState(Vanara.PInvoke.HDC,Vanara.PInvoke.HBRUSH,Vanara.PInvoke.User32.DrawStateProc,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.User32.DrawStateFlags)">
            <summary>
            The <c>DrawState</c> function displays an image and applies a visual effect to indicate a state, such as a disabled or default state.
            </summary>
            <param name="hdc">A handle to the device context to draw in.</param>
            <param name="hbrFore">
            A handle to the brush used to draw the image, if the state specified by the fuFlags parameter is DSS_MONO. This parameter is
            ignored for other states.
            </param>
            <param name="qfnCallBack">
            A pointer to an application-defined callback function used to render the image. This parameter is required if the image type in
            fuFlags is DST_COMPLEX. It is optional and can be <c>NULL</c> if the image type is DST_TEXT. For all other image types, this
            parameter is ignored. For more information about the callback function, see the DrawStateProc function.
            </param>
            <param name="lData">Information about the image. The meaning of this parameter depends on the image type.</param>
            <param name="wData">
            Information about the image. The meaning of this parameter depends on the image type. It is, however, zero extended for use with
            the DrawStateProc function.
            </param>
            <param name="x">The horizontal location, in device units, at which to draw the image.</param>
            <param name="y">The vertical location, in device units, at which to draw the image.</param>
            <param name="cx">
            The width of the image, in device units. This parameter is required if the image type is DST_COMPLEX. Otherwise, it can be zero
            to calculate the width of the image.
            </param>
            <param name="cy">
            The height of the image, in device units. This parameter is required if the image type is DST_COMPLEX. Otherwise, it can be zero
            to calculate the height of the image.
            </param>
            <param name="uFlags">
            <para>The image type and state. This parameter can be one of the following type values.</para>
            <list type="table">
            <listheader>
            <term>Value (type)</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DST_BITMAP</term>
            <term>
            The image is a bitmap. The lData parameter is the bitmap handle. Note that the bitmap cannot already be selected into an existing
            device context.
            </term>
            </item>
            <item>
            <term>DST_COMPLEX</term>
            <term>
            The image is application defined. To render the image, DrawState calls the callback function specified by the lpOutputFunc parameter.
            </term>
            </item>
            <item>
            <term>DST_ICON</term>
            <term>The image is an icon. The lData parameter is the icon handle.</term>
            </item>
            <item>
            <term>DST_PREFIXTEXT</term>
            <term>
            The image is text that may contain an accelerator mnemonic. DrawState interprets the ampersand (&amp;) prefix character as a
            directive to underscore the character that follows. The lData parameter is a pointer to the string, and the wData parameter
            specifies the length. If wData is zero, the string must be null-terminated.
            </term>
            </item>
            <item>
            <term>DST_TEXT</term>
            <term>
            The image is text. The lData parameter is a pointer to the string, and the wData parameter specifies the length. If wData is
            zero, the string must be null-terminated.
            </term>
            </item>
            </list>
            <para>This parameter can also be one of the following state values.</para>
            <list type="table">
            <listheader>
            <term>Value (state)</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DSS_DISABLED</term>
            <term>Embosses the image.</term>
            </item>
            <item>
            <term>DSS_HIDEPREFIX</term>
            <term>
            Ignores the ampersand (&amp;) prefix character in the text, thus the letter that follows will not be underlined. This must be
            used with DST_PREFIXTEXT.
            </term>
            </item>
            <item>
            <term>DSS_MONO</term>
            <term>Draws the image using the brush specified by the hbr parameter.</term>
            </item>
            <item>
            <term>DSS_NORMAL</term>
            <term>Draws the image without any modification.</term>
            </item>
            <item>
            <term>DSS_PREFIXONLY</term>
            <term>
            Draws only the underline at the position of the letter after the ampersand (&amp;) prefix character. No text in the string is
            drawn. This must be used with DST_PREFIXTEXT.
            </term>
            </item>
            <item>
            <term>DSS_RIGHT</term>
            <term>Aligns the text to the right.</term>
            </item>
            <item>
            <term>DSS_UNION</term>
            <term>Dithers the image.</term>
            </item>
            </list>
            <para>For all states except DSS_NORMAL, the image is converted to monochrome before the visual effect is applied.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.DrawState(Vanara.PInvoke.HDC,Vanara.PInvoke.HBRUSH,Vanara.PInvoke.User32.DrawStateProc,System.String,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.User32.DrawStateFlags)">
            <summary>
            The <c>DrawState</c> function displays an image and applies a visual effect to indicate a state, such as a disabled or default state.
            </summary>
            <param name="hdc">A handle to the device context to draw in.</param>
            <param name="hbrFore">
            A handle to the brush used to draw the image, if the state specified by the fuFlags parameter is DSS_MONO. This parameter is
            ignored for other states.
            </param>
            <param name="qfnCallBack">
            A pointer to an application-defined callback function used to render the image. This parameter is required if the image type in
            fuFlags is DST_COMPLEX. It is optional and can be <c>NULL</c> if the image type is DST_TEXT. For all other image types, this
            parameter is ignored. For more information about the callback function, see the DrawStateProc function.
            </param>
            <param name="lData">Information about the image. The meaning of this parameter depends on the image type.</param>
            <param name="wData">
            Information about the image. The meaning of this parameter depends on the image type. It is, however, zero extended for use with
            the DrawStateProc function.
            </param>
            <param name="x">The horizontal location, in device units, at which to draw the image.</param>
            <param name="y">The vertical location, in device units, at which to draw the image.</param>
            <param name="cx">
            The width of the image, in device units. This parameter is required if the image type is DST_COMPLEX. Otherwise, it can be zero
            to calculate the width of the image.
            </param>
            <param name="cy">
            The height of the image, in device units. This parameter is required if the image type is DST_COMPLEX. Otherwise, it can be zero
            to calculate the height of the image.
            </param>
            <param name="uFlags">
            <para>The image type and state. This parameter can be one of the following type values.</para>
            <list type="table">
            <listheader>
            <term>Value (type)</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DST_BITMAP</term>
            <term>
            The image is a bitmap. The lData parameter is the bitmap handle. Note that the bitmap cannot already be selected into an existing
            device context.
            </term>
            </item>
            <item>
            <term>DST_COMPLEX</term>
            <term>
            The image is application defined. To render the image, DrawState calls the callback function specified by the lpOutputFunc parameter.
            </term>
            </item>
            <item>
            <term>DST_ICON</term>
            <term>The image is an icon. The lData parameter is the icon handle.</term>
            </item>
            <item>
            <term>DST_PREFIXTEXT</term>
            <term>
            The image is text that may contain an accelerator mnemonic. DrawState interprets the ampersand (&amp;) prefix character as a
            directive to underscore the character that follows. The lData parameter is a pointer to the string, and the wData parameter
            specifies the length. If wData is zero, the string must be null-terminated.
            </term>
            </item>
            <item>
            <term>DST_TEXT</term>
            <term>
            The image is text. The lData parameter is a pointer to the string, and the wData parameter specifies the length. If wData is
            zero, the string must be null-terminated.
            </term>
            </item>
            </list>
            <para>This parameter can also be one of the following state values.</para>
            <list type="table">
            <listheader>
            <term>Value (state)</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DSS_DISABLED</term>
            <term>Embosses the image.</term>
            </item>
            <item>
            <term>DSS_HIDEPREFIX</term>
            <term>
            Ignores the ampersand (&amp;) prefix character in the text, thus the letter that follows will not be underlined. This must be
            used with DST_PREFIXTEXT.
            </term>
            </item>
            <item>
            <term>DSS_MONO</term>
            <term>Draws the image using the brush specified by the hbr parameter.</term>
            </item>
            <item>
            <term>DSS_NORMAL</term>
            <term>Draws the image without any modification.</term>
            </item>
            <item>
            <term>DSS_PREFIXONLY</term>
            <term>
            Draws only the underline at the position of the letter after the ampersand (&amp;) prefix character. No text in the string is
            drawn. This must be used with DST_PREFIXTEXT.
            </term>
            </item>
            <item>
            <term>DSS_RIGHT</term>
            <term>Aligns the text to the right.</term>
            </item>
            <item>
            <term>DSS_UNION</term>
            <term>Dithers the image.</term>
            </item>
            </list>
            <para>For all states except DSS_NORMAL, the image is converted to monochrome before the visual effect is applied.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.EndPaint(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.PAINTSTRUCT@)">
            <summary>
            The <c>EndPaint</c> function marks the end of painting in the specified window. This function is required for each call to the
            BeginPaint function, but only after painting is complete.
            </summary>
            <param name="hWnd">Handle to the window that has been repainted.</param>
            <param name="lpPaint">Pointer to a PAINTSTRUCT structure that contains the painting information retrieved by BeginPaint.</param>
            <returns>The return value is always nonzero.</returns>
            <remarks>
            <para>If the caret was hidden by BeginPaint, <c>EndPaint</c> restores the caret to the screen.</para>
            <para><c>EndPaint</c> releases the display device context that BeginPaint retrieved.</para>
            <para>Examples</para>
            <para>For an example, see Drawing in the Client Area.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ExcludeUpdateRgn(Vanara.PInvoke.HDC,Vanara.PInvoke.HWND)">
            <summary>
            The <c>ExcludeUpdateRgn</c> function prevents drawing within invalid areas of a window by excluding an updated region in the
            window from a clipping region.
            </summary>
            <param name="hDC">Handle to the device context associated with the clipping region.</param>
            <param name="hWnd">Handle to the window to update.</param>
            <returns>
            <para>The return value specifies the complexity of the excluded region; it can be any one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>COMPLEXREGION</term>
            <term>Region consists of more than one rectangle.</term>
            </item>
            <item>
            <term>ERROR</term>
            <term>An error occurred.</term>
            </item>
            <item>
            <term>NULLREGION</term>
            <term>Region is empty.</term>
            </item>
            <item>
            <term>SIMPLEREGION</term>
            <term>Region is a single rectangle.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.FillRect(Vanara.PInvoke.HDC,Vanara.PInvoke.RECT@,Vanara.PInvoke.HBRUSH)">
            <summary>
            The <c>FillRect</c> function fills a rectangle by using the specified brush. This function includes the left and top borders, but
            excludes the right and bottom borders of the rectangle.
            </summary>
            <param name="hDC">A handle to the device context.</param>
            <param name="lprc">A pointer to a RECT structure that contains the logical coordinates of the rectangle to be filled.</param>
            <param name="hbr">A handle to the brush used to fill the rectangle.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            The brush identified by the hbr parameter may be either a handle to a logical brush or a color value. If specifying a handle to a
            logical brush, call one of the following functions to obtain the handle: CreateHatchBrush, CreatePatternBrush, or
            CreateSolidBrush. Additionally, you may retrieve a handle to one of the stock brushes by using the GetStockObject function. If
            specifying a color value for the hbr parameter, it must be one of the standard system colors (the value 1 must be added to the
            chosen color). For example:
            </para>
            <para>For a list of all the standard system colors, see GetSysColor.</para>
            <para>
            When filling the specified rectangle, <c>FillRect</c> does not include the rectangle's right and bottom sides. GDI fills a
            rectangle up to, but not including, the right column and bottom row, regardless of the current mapping mode.
            </para>
            <para>Examples</para>
            <para>For an example, see Using Rectangles.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.FrameRect(Vanara.PInvoke.HDC,Vanara.PInvoke.RECT@,Vanara.PInvoke.HBRUSH)">
            <summary>
            The <c>FrameRect</c> function draws a border around the specified rectangle by using the specified brush. The width and height of
            the border are always one logical unit.
            </summary>
            <param name="hDC">A handle to the device context in which the border is drawn.</param>
            <param name="lprc">
            A pointer to a RECT structure that contains the logical coordinates of the upper-left and lower-right corners of the rectangle.
            </param>
            <param name="hbr">A handle to the brush used to draw the border.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            The brush identified by the hbr parameter must have been created by using the CreateHatchBrush, CreatePatternBrush, or
            CreateSolidBrush function, or retrieved by using the GetStockObject function.
            </para>
            <para>
            If the <c>bottom</c> member of the RECT structure is less than the <c>top</c> member, or if the <c>right</c> member is less than
            the <c>left</c> member, the function does not draw the rectangle.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetUpdateRect(Vanara.PInvoke.HWND,Vanara.PInvoke.PRECT,System.Boolean)">
            <summary>
            The <c>GetUpdateRect</c> function retrieves the coordinates of the smallest rectangle that completely encloses the update region
            of the specified window. <c>GetUpdateRect</c> retrieves the rectangle in logical coordinates. If there is no update region,
            <c>GetUpdateRect</c> retrieves an empty rectangle (sets all coordinates to zero).
            </summary>
            <param name="hWnd">Handle to the window whose update region is to be retrieved.</param>
            <param name="lpRect">
            <para>Pointer to the RECT structure that receives the coordinates, in device units, of the enclosing rectangle.</para>
            <para>
            An application can set this parameter to <c>NULL</c> to determine whether an update region exists for the window. If this
            parameter is <c>NULL</c>, <c>GetUpdateRect</c> returns nonzero if an update region exists, and zero if one does not. This
            provides a simple and efficient means of determining whether a <c>WM_PAINT</c> message resulted from an invalid area.
            </para>
            </param>
            <param name="bErase">
            Specifies whether the background in the update region is to be erased. If this parameter is <c>TRUE</c> and the update region is
            not empty, <c>GetUpdateRect</c> sends a <c>WM_ERASEBKGND</c> message to the specified window to erase the background.
            </param>
            <returns>
            <para>If the update region is not empty, the return value is nonzero.</para>
            <para>If there is no update region, the return value is zero.</para>
            </returns>
            <remarks>
            <para>The update rectangle retrieved by the BeginPaint function is identical to that retrieved by <c>GetUpdateRect</c>.</para>
            <para>
            BeginPaint automatically validates the update region, so any call to <c>GetUpdateRect</c> made immediately after the call to
            <c>BeginPaint</c> retrieves an empty update region.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetUpdateRgn(Vanara.PInvoke.HWND,Vanara.PInvoke.HRGN,System.Boolean)">
            <summary>
            The <c>GetUpdateRgn</c> function retrieves the update region of a window by copying it into the specified region. The coordinates
            of the update region are relative to the upper-left corner of the window (that is, they are client coordinates).
            </summary>
            <param name="hWnd">Handle to the window with an update region that is to be retrieved.</param>
            <param name="hRgn">Handle to the region to receive the update region.</param>
            <param name="bErase">
            Specifies whether the window background should be erased and whether nonclient areas of child windows should be drawn. If this
            parameter is <c>FALSE</c>, no drawing is done.
            </param>
            <returns>
            <para>The return value indicates the complexity of the resulting region; it can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>COMPLEXREGION</term>
            <term>Region consists of more than one rectangle.</term>
            </item>
            <item>
            <term>ERROR</term>
            <term>An error occurred.</term>
            </item>
            <item>
            <term>NULLREGION</term>
            <term>Region is empty.</term>
            </item>
            <item>
            <term>SIMPLEREGION</term>
            <term>Region is a single rectangle.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The BeginPaint function automatically validates the update region, so any call to <c>GetUpdateRgn</c> made immediately after the
            call to <c>BeginPaint</c> retrieves an empty update region.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowDC(Vanara.PInvoke.HWND)">
            <summary>
            <para>
            The <c>GetWindowDC</c> function retrieves the device context (DC) for the entire window, including title bar, menus, and scroll
            bars. A window device context permits painting anywhere in a window, because the origin of the device context is the upper-left
            corner of the window instead of the client area.
            </para>
            <para>
            <c>GetWindowDC</c> assigns default attributes to the window device context each time it retrieves the device context. Previous
            attributes are lost.
            </para>
            </summary>
            <param name="hWnd">
            <para>
            A handle to the window with a device context that is to be retrieved. If this value is <c>NULL</c>, <c>GetWindowDC</c> retrieves
            the device context for the entire screen.
            </para>
            <para>
            If this parameter is <c>NULL</c>, <c>GetWindowDC</c> retrieves the device context for the primary display monitor. To get the
            device context for other display monitors, use the EnumDisplayMonitors and CreateDC functions.
            </para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a handle to a device context for the specified window.</para>
            <para>If the function fails, the return value is <c>NULL</c>, indicating an error or an invalid hWnd parameter.</para>
            </returns>
            <remarks>
            <para>
            <c>GetWindowDC</c> is intended for special painting effects within a window's nonclient area. Painting in nonclient areas of any
            window is not recommended.
            </para>
            <para>
            The GetSystemMetrics function can be used to retrieve the dimensions of various parts of the nonclient area, such as the title
            bar, menu, and scroll bars.
            </para>
            <para>The GetDC function can be used to retrieve a device context for the entire screen.</para>
            <para>
            After painting is complete, the ReleaseDC function must be called to release the device context. Not releasing the window device
            context has serious effects on painting requested by applications.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowRgn(Vanara.PInvoke.HWND,Vanara.PInvoke.HRGN)">
            <summary>
            The <c>GetWindowRgn</c> function obtains a copy of the window region of a window. The window region of a window is set by calling
            the SetWindowRgn function. The window region determines the area within the window where the system permits drawing. The system
            does not display any portion of a window that lies outside of the window region
            </summary>
            <param name="hWnd">Handle to the window whose window region is to be obtained.</param>
            <param name="hRgn">Handle to the region which will be modified to represent the window region.</param>
            <returns>
            <para>The return value specifies the type of the region that the function obtains. It can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>NULLREGION</term>
            <term>The region is empty.</term>
            </item>
            <item>
            <term>SIMPLEREGION</term>
            <term>The region is a single rectangle.</term>
            </item>
            <item>
            <term>COMPLEXREGION</term>
            <term>The region is more than one rectangle.</term>
            </item>
            <item>
            <term>ERROR</term>
            <term>The specified window does not have a region, or an error occurred while attempting to return the region.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The coordinates of a window's window region are relative to the upper-left corner of the window, not the client area of the window.
            </para>
            <para>To set the window region of a window, call the SetWindowRgn function.</para>
            <para>Examples</para>
            <para>The following code shows how you pass in the handle of an existing region.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowRgnBox(Vanara.PInvoke.HWND,Vanara.PInvoke.RECT@)">
            <summary>
            The <c>GetWindowRgnBox</c> function retrieves the dimensions of the tightest bounding rectangle for the window region of a window.
            </summary>
            <param name="hWnd">Handle to the window.</param>
            <param name="lprc">
            Pointer to a RECT structure that receives the rectangle dimensions, in device units relative to the upper-left corner of the window.
            </param>
            <returns>
            <para>The return value specifies the type of the region that the function obtains. It can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>COMPLEXREGION</term>
            <term>The region is more than one rectangle.</term>
            </item>
            <item>
            <term>ERROR</term>
            <term>The specified window does not have a region, or an error occurred while attempting to return the region.</term>
            </item>
            <item>
            <term>NULLREGION</term>
            <term>The region is empty.</term>
            </item>
            <item>
            <term>SIMPLEREGION</term>
            <term>The region is a single rectangle.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The window region determines the area within the window where the system permits drawing. The system does not display any portion
            of a window that lies outside of the window region. The coordinates of a window's window region are relative to the upper-left
            corner of the window, not the client area of the window.
            </para>
            <para>To set the window region of a window, call the SetWindowRgn function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GrayString(Vanara.PInvoke.HDC,Vanara.PInvoke.HBRUSH,Vanara.PInvoke.User32.OutputProc,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            The <c>GrayString</c> function draws gray text at the specified location. The function draws the text by copying it into a memory
            bitmap, graying the bitmap, and then copying the bitmap to the screen. The function grays the text regardless of the selected
            brush and background. <c>GrayString</c> uses the font currently selected for the specified device context.
            </para>
            <para>
            If thelpOutputFuncparameter is <c>NULL</c>, GDI uses the TextOut function, and thelpDataparameter is assumed to be a pointer to
            the character string to be output. If the characters to be output cannot be handled by <c>TextOut</c> (for example, the string is
            stored as a bitmap), the application must supply its own output function.
            </para>
            </summary>
            <param name="hDC">A handle to the device context.</param>
            <param name="hBrush">
            A handle to the brush to be used for graying. If this parameter is <c>NULL</c>, the text is grayed with the same brush that was
            used to draw window text.
            </param>
            <param name="lpOutputFunc">
            A pointer to the application-defined function that will draw the string, or, if TextOut is to be used to draw the string, it is a
            <c>NULL</c> pointer. For details, see the OutputProc callback function.
            </param>
            <param name="lpData">
            A pointer to data to be passed to the output function. If the lpOutputFunc parameter is <c>NULL</c>, lpData must be a pointer to
            the string to be output.
            </param>
            <param name="nCount">
            The number of characters to be output. If the nCount parameter is zero, <c>GrayString</c> calculates the length of the string
            (assuming lpData is a pointer to the string). If nCount is 1 and the function pointed to by lpOutputFunc returns <c>FALSE</c>,
            the image is shown but not grayed.
            </param>
            <param name="X">The device x-coordinate of the starting position of the rectangle that encloses the string.</param>
            <param name="Y">The device y-coordinate of the starting position of the rectangle that encloses the string.</param>
            <param name="nWidth">
            The width, in device units, of the rectangle that encloses the string. If this parameter is zero, <c>GrayString</c> calculates
            the width of the area, assuming lpData is a pointer to the string.
            </param>
            <param name="nHeight">
            The height, in device units, of the rectangle that encloses the string. If this parameter is zero, <c>GrayString</c> calculates
            the height of the area, assuming lpData is a pointer to the string.
            </param>
            <returns>
            <para>If the string is drawn, the return value is nonzero.</para>
            <para>
            If either the TextOut function or the application-defined output function returned zero, or there was insufficient memory to
            create a memory bitmap for graying, the return value is zero.
            </para>
            </returns>
            <remarks>
            Without calling <c>GrayString</c>, an application can draw grayed strings on devices that support a solid gray color. The system
            color COLOR_GRAYTEXT is the solid-gray system color used to draw disabled text. The application can call the GetSysColor function
            to retrieve the color value of COLOR_GRAYTEXT. If the color is other than zero (black), the application can call the SetTextColor
            function to set the text color to the color value and then draw the string directly. If the retrieved color is black, the
            application must call <c>GrayString</c> to gray the text.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.InvalidateRect(Vanara.PInvoke.HWND,Vanara.PInvoke.PRECT,System.Boolean)">
            <summary>
            The <c>InvalidateRect</c> function adds a rectangle to the specified window's update region. The update region represents the
            portion of the window's client area that must be redrawn.
            </summary>
            <param name="hWnd">
            A handle to the window whose update region has changed. If this parameter is <c>NULL</c>, the system invalidates and redraws all
            windows, not just the windows for this application, and sends the WM_ERASEBKGND and WM_NCPAINT messages before the function
            returns. Setting this parameter to <c>NULL</c> is not recommended.
            </param>
            <param name="lpRect">
            A pointer to a RECT structure that contains the client coordinates of the rectangle to be added to the update region. If this
            parameter is <c>NULL</c>, the entire client area is added to the update region.
            </param>
            <param name="bErase">
            Specifies whether the background within the update region is to be erased when the update region is processed. If this parameter
            is <c>TRUE</c>, the background is erased when the BeginPaint function is called. If this parameter is <c>FALSE</c>, the
            background remains unchanged.
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            The invalidated areas accumulate in the update region until the region is processed when the next WM_PAINT message occurs or
            until the region is validated by using the ValidateRect or ValidateRgn function.
            </para>
            <para>
            The system sends a WM_PAINT message to a window whenever its update region is not empty and there are no other messages in the
            application queue for that window.
            </para>
            <para>
            If the bErase parameter is <c>TRUE</c> for any part of the update region, the background is erased in the entire region, not just
            in the specified part.
            </para>
            <para>Examples</para>
            <para>For an example, see Invalidating the Client Area.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.InvalidateRgn(Vanara.PInvoke.HWND,Vanara.PInvoke.HRGN,System.Boolean)">
            <summary>
            The <c>InvalidateRgn</c> function invalidates the client area within the specified region by adding it to the current update
            region of a window. The invalidated region, along with all other areas in the update region, is marked for painting when the next
            WM_PAINT message occurs.
            </summary>
            <param name="hWnd">A handle to the window with an update region that is to be modified.</param>
            <param name="hRgn">
            A handle to the region to be added to the update region. The region is assumed to have client coordinates. If this parameter is
            <c>NULL</c>, the entire client area is added to the update region.
            </param>
            <param name="bErase">
            Specifies whether the background within the update region should be erased when the update region is processed. If this parameter
            is <c>TRUE</c>, the background is erased when the BeginPaint function is called. If the parameter is <c>FALSE</c>, the background
            remains unchanged.
            </param>
            <returns>The return value is always nonzero.</returns>
            <remarks>
            <para>
            Invalidated areas accumulate in the update region until the next WM_PAINT message is processed or until the region is validated
            by using the ValidateRect or ValidateRgn function.
            </para>
            <para>
            The system sends a WM_PAINT message to a window whenever its update region is not empty and there are no other messages in the
            application queue for that window.
            </para>
            <para>The specified region must have been created by using one of the region functions.</para>
            <para>
            If the bErase parameter is <c>TRUE</c> for any part of the update region, the background in the entire region is erased, not just
            in the specified part.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.LockWindowUpdate(Vanara.PInvoke.HWND)">
            <summary>
            The <c>LockWindowUpdate</c> function disables or enables drawing in the specified window. Only one window can be locked at a time.
            </summary>
            <param name="hWndLock">
            The window in which drawing will be disabled. If this parameter is <c>NULL</c>, drawing in the locked window is enabled.
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero, indicating that an error occurred or another window was already locked.</para>
            </returns>
            <remarks>
            <para>
            The purpose of the <c>LockWindowUpdate</c> function is to permit drag/drop feedback to be drawn over a window without
            interference from the window itself. The intent is that the window is locked when feedback is drawn and unlocked when feedback is
            complete. <c>LockWindowUpdate</c> is not intended for general-purpose suppression of window redraw. Use the WM_SETREDRAW message
            to disable redrawing of a particular window.
            </para>
            <para>
            If an application with a locked window (or any locked child windows) calls the GetDC, GetDCEx, or BeginPaint function, the called
            function returns a device context with a visible region that is empty. This will occur until the application unlocks the window
            by calling <c>LockWindowUpdate</c>, specifying a value of <c>NULL</c> for hWndLock.
            </para>
            <para>
            If an application attempts to draw within a locked window, the system records the extent of the attempted operation in a bounding
            rectangle. When the window is unlocked, the system invalidates the area within this bounding rectangle, forcing an eventual
            WM_PAINT message to be sent to the previously locked window and its child windows. If no drawing has occurred while the window
            updates were locked, no area is invalidated.
            </para>
            <para><c>LockWindowUpdate</c> does not make the specified window invisible and does not clear the WS_VISIBLE style bit.</para>
            <para>A locked window cannot be moved.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.PaintDesktop(Vanara.PInvoke.HDC)">
            <summary>
            The <c>PaintDesktop</c> function fills the clipping region in the specified device context with the desktop pattern or wallpaper.
            The function is provided primarily for shell desktops.
            </summary>
            <param name="hdc">Handle to the device context.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.RedrawWindow(Vanara.PInvoke.HWND,Vanara.PInvoke.PRECT,Vanara.PInvoke.HRGN,Vanara.PInvoke.User32.RedrawWindowFlags)">
            <summary>The <c>RedrawWindow</c> function updates the specified rectangle or region in a window's client area.</summary>
            <param name="hWnd">A handle to the window to be redrawn. If this parameter is <c>NULL</c>, the desktop window is updated.</param>
            <param name="lprcUpdate">
            A pointer to a RECT structure containing the coordinates, in device units, of the update rectangle. This parameter is ignored if
            the hrgnUpdate parameter identifies a region.
            </param>
            <param name="hrgnUpdate">
            A handle to the update region. If both the hrgnUpdate and lprcUpdate parameters are <c>NULL</c>, the entire client area is added
            to the update region.
            </param>
            <param name="flags">
            <para>
            One or more redraw flags. This parameter can be used to invalidate or validate a window, control repainting, and control which
            windows are affected by <c>RedrawWindow</c>.
            </para>
            <para>The following flags are used to invalidate the window.</para>
            <list type="table">
            <listheader>
            <term>Flag (invalidation)</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>RDW_ERASE</term>
            <term>
            Causes the window to receive a WM_ERASEBKGND message when the window is repainted. The RDW_INVALIDATE flag must also be
            specified; otherwise, RDW_ERASE has no effect.
            </term>
            </item>
            <item>
            <term>RDW_FRAME</term>
            <term>
            Causes any part of the nonclient area of the window that intersects the update region to receive a WM_NCPAINT message. The
            RDW_INVALIDATE flag must also be specified; otherwise, RDW_FRAME has no effect. The WM_NCPAINT message is typically not sent
            during the execution of RedrawWindow unless either RDW_UPDATENOW or RDW_ERASENOW is specified.
            </term>
            </item>
            <item>
            <term>RDW_INTERNALPAINT</term>
            <term>Causes a WM_PAINT message to be posted to the window regardless of whether any portion of the window is invalid.</term>
            </item>
            <item>
            <term>RDW_INVALIDATE</term>
            <term>Invalidates lprcUpdate or hrgnUpdate (only one may be non-NULL). If both are NULL, the entire window is invalidated.</term>
            </item>
            </list>
            <para>The following flags are used to validate the window.</para>
            <list type="table">
            <listheader>
            <term>Flag (validation)</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>RDW_NOERASE</term>
            <term>Suppresses any pending WM_ERASEBKGND messages.</term>
            </item>
            <item>
            <term>RDW_NOFRAME</term>
            <term>
            Suppresses any pending WM_NCPAINT messages. This flag must be used with RDW_VALIDATE and is typically used with RDW_NOCHILDREN.
            RDW_NOFRAME should be used with care, as it could cause parts of a window to be painted improperly.
            </term>
            </item>
            <item>
            <term>RDW_NOINTERNALPAINT</term>
            <term>
            Suppresses any pending internal WM_PAINT messages. This flag does not affect WM_PAINT messages resulting from a non-NULL update area.
            </term>
            </item>
            <item>
            <term>RDW_VALIDATE</term>
            <term>
            Validates lprcUpdate or hrgnUpdate (only one may be non-NULL). If both are NULL, the entire window is validated. This flag does
            not affect internal WM_PAINT messages.
            </term>
            </item>
            </list>
            <para>
            The following flags control when repainting occurs. <c>RedrawWindow</c> will not repaint unless one of these flags is specified.
            </para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>RDW_ERASENOW</term>
            <term>
            Causes the affected windows (as specified by the RDW_ALLCHILDREN and RDW_NOCHILDREN flags) to receive WM_NCPAINT and
            WM_ERASEBKGND messages, if necessary, before the function returns. WM_PAINT messages are received at the ordinary time.
            </term>
            </item>
            <item>
            <term>RDW_UPDATENOW</term>
            <term>
            Causes the affected windows (as specified by the RDW_ALLCHILDREN and RDW_NOCHILDREN flags) to receive WM_NCPAINT, WM_ERASEBKGND,
            and WM_PAINT messages, if necessary, before the function returns.
            </term>
            </item>
            </list>
            <para>
            By default, the windows affected by <c>RedrawWindow</c> depend on whether the specified window has the WS_CLIPCHILDREN style.
            Child windows that are not the WS_CLIPCHILDREN style are unaffected; non-WS_CLIPCHILDREN windows are recursively validated or
            invalidated until a WS_CLIPCHILDREN window is encountered. The following flags control which windows are affected by the
            <c>RedrawWindow</c> function.
            </para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>RDW_ALLCHILDREN</term>
            <term>Includes child windows, if any, in the repainting operation.</term>
            </item>
            <item>
            <term>RDW_NOCHILDREN</term>
            <term>Excludes child windows, if any, from the repainting operation.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            When <c>RedrawWindow</c> is used to invalidate part of the desktop window, the desktop window does not receive a WM_PAINT
            message. To repaint the desktop, an application uses the RDW_ERASE flag to generate a WM_ERASEBKGND message.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetWindowRgn(Vanara.PInvoke.HWND,Vanara.PInvoke.HRGN,System.Boolean)">
            <summary>
            The <c>SetWindowRgn</c> function sets the window region of a window. The window region determines the area within the window
            where the system permits drawing. The system does not display any portion of a window that lies outside of the window region
            </summary>
            <param name="hWnd">A handle to the window whose window region is to be set.</param>
            <param name="hRgn">
            <para>A handle to a region. The function sets the window region of the window to this region.</para>
            <para>If hRgn is <c>NULL</c>, the function sets the window region to <c>NULL</c>.</para>
            </param>
            <param name="bRedraw">
            <para>
            Specifies whether the system redraws the window after setting the window region. If bRedraw is <c>TRUE</c>, the system does so;
            otherwise, it does not.
            </para>
            <para>Typically, you set bRedraw to <c>TRUE</c> if the window is visible.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            When this function is called, the system sends the WM_WINDOWPOSCHANGING and <c>WM_WINDOWPOSCHANGING</c> messages to the window.
            </para>
            <para>
            The coordinates of a window's window region are relative to the upper-left corner of the window, not the client area of the window.
            </para>
            <para>
            <c>Note</c> If the window layout is right-to-left (RTL), the coordinates are relative to the upper-right corner of the window.
            See Window Layout and Mirroring.
            </para>
            <para>
            After a successful call to <c>SetWindowRgn</c>, the system owns the region specified by the region handle hRgn. The system does
            not make a copy of the region. Thus, you should not make any further function calls with this region handle. In particular, do
            not delete this region handle. The system deletes the region handle when it no longer needed.
            </para>
            <para>To obtain the window region of a window, call the GetWindowRgn function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.UpdateWindow(Vanara.PInvoke.HWND)">
            <summary>
            The <c>UpdateWindow</c> function updates the client area of the specified window by sending a WM_PAINT message to the window if
            the window's update region is not empty. The function sends a <c>WM_PAINT</c> message directly to the window procedure of the
            specified window, bypassing the application queue. If the update region is empty, no message is sent.
            </summary>
            <param name="hWnd">Handle to the window to be updated.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.ValidateRect(Vanara.PInvoke.HWND,Vanara.PInvoke.PRECT)">
            <summary>
            The <c>ValidateRect</c> function validates the client area within a rectangle by removing the rectangle from the update region of
            the specified window.
            </summary>
            <param name="hWnd">
            Handle to the window whose update region is to be modified. If this parameter is <c>NULL</c>, the system invalidates and redraws
            all windows and sends the <c>WM_ERASEBKGND</c> and <c>WM_NCPAINT</c> messages to the window procedure before the function returns.
            </param>
            <param name="lpRect">
            Pointer to a RECT structure that contains the client coordinates of the rectangle to be removed from the update region. If this
            parameter is <c>NULL</c>, the entire client area is removed.
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            The BeginPaint function automatically validates the entire client area. Neither the <c>ValidateRect</c> nor ValidateRgn function
            should be called if a portion of the update region must be validated before the next WM_PAINT message is generated.
            </para>
            <para>The system continues to generate WM_PAINT messages until the current update region is validated.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ValidateRgn(Vanara.PInvoke.HWND,Vanara.PInvoke.HRGN)">
            <summary>
            The <c>ValidateRgn</c> function validates the client area within a region by removing the region from the current update region
            of the specified window.
            </summary>
            <param name="hWnd">Handle to the window whose update region is to be modified.</param>
            <param name="hRgn">
            Handle to a region that defines the area to be removed from the update region. If this parameter is <c>NULL</c>, the entire
            client area is removed.
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>The specified region must have been created by a region function. The region coordinates are assumed to be client coordinates.</para>
            <para>
            The BeginPaint function automatically validates the entire client area. Neither the ValidateRect nor <c>ValidateRgn</c> function
            should be called if a portion of the update region must be validated before the next WM_PAINT message is generated.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.PAINTSTRUCT">
            <summary>
            <para>
            The <c>PAINTSTRUCT</c> structure contains information for an application. This information can be used to paint the client area
            of a window owned by that application.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PAINTSTRUCT.hdc">
            <summary>
            <para>A handle to the display DC to be used for painting.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PAINTSTRUCT.fErase">
            <summary>
            <para>
            Indicates whether the background must be erased. This value is nonzero if the application should erase the background. The
            application is responsible for erasing the background if a window class is created without a background brush. For more
            information, see the description of the <c>hbrBackground</c> member of the WNDCLASS structure.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PAINTSTRUCT.rcPaint">
            <summary>
            <para>
            A RECT structure that specifies the upper left and lower right corners of the rectangle in which the painting is requested,
            in device units relative to the upper-left corner of the client area.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PAINTSTRUCT.fRestore">
            <summary>
            <para>Reserved; used internally by the system.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PAINTSTRUCT.fIncUpdate">
            <summary>
            <para>Reserved; used internally by the system.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PAINTSTRUCT.rgbReserved">
            <summary>
            <para>Reserved; used internally by the system.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.PEN_FLAGS">
            <summary>Lists the flags that may appear in the <c>penFlags</c> field of the <c>POINTER_PEN_INFO</c> structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PEN_FLAGS.PEN_FLAG_NONE">
            <summary>There is no pen flag. This is the default.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PEN_FLAGS.PEN_FLAG_BARREL">
            <summary>The barrel button is pressed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PEN_FLAGS.PEN_FLAG_INVERTED">
            <summary>The pen is inverted.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PEN_FLAGS.PEN_FLAG_ERASER">
            <summary>The eraser button is pressed.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.PEN_MASK">
            <summary>Values that can appear in the penMask field of the POINTER_PEN_INFO structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PEN_MASK.PEN_MASK_NONE">
            <summary>Default. None of the optional fields are valid.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PEN_MASK.PEN_MASK_PRESSURE">
            <summary>pressure of the POINTER_PEN_INFO structure is valid.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PEN_MASK.PEN_MASK_ROTATION">
            <summary>rotation of the POINTER_PEN_INFO structure is valid.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PEN_MASK.PEN_MASK_TILT_X">
            <summary>tiltX of the POINTER_PEN_INFO structure is valid.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PEN_MASK.PEN_MASK_TILT_Y">
            <summary>tiltY of the POINTER_PEN_INFO structure is valid.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.POINTER_BUTTON_CHANGE_TYPE">
            <summary>Identifies a change in the state of a button associated with a pointer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_NONE">
            <summary>No change in button state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIRSTBUTTON_DOWN">
            <summary>The first button (see POINTER_FLAG_FIRSTBUTTON) transitioned to a pressed state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIRSTBUTTON_UP">
            <summary>The first button (see POINTER_FLAG_FIRSTBUTTON) transitioned to a released state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_SECONDBUTTON_DOWN">
            <summary>The second button (see POINTER_FLAG_SECONDBUTTON) transitioned to a pressed state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_SECONDBUTTON_UP">
            <summary>The second button (see POINTER_FLAG_SECONDBUTTON) transitioned to a released state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_THIRDBUTTON_DOWN">
            <summary>The third button (see POINTER_FLAG_THIRDBUTTON) transitioned to a pressed state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_THIRDBUTTON_UP">
            <summary>The third button (see POINTER_FLAG_THIRDBUTTON) transitioned to a released state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FOURTHBUTTON_DOWN">
            <summary>The fourth button (see POINTER_FLAG_FOURTHBUTTON) transitioned to a pressed state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FOURTHBUTTON_UP">
            <summary>The fourth button (see POINTER_FLAG_FOURTHBUTTON) transitioned to a released state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIFTHBUTTON_DOWN">
            <summary>The fifth button (see POINTER_FLAG_FIFTHBUTTON) transitioned to a pressed state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIFTHBUTTON_UP">
            <summary>The fifth button (see POINTER_FLAG_FIFTHBUTTON) transitioned to a released state.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.POINTER_DEVICE_CURSOR_TYPE">
            <summary>Identifies the pointer device cursor types.</summary>
            <remarks>
            Cursor objects represent pointing and selecting devices used with digitizer devices, most commonly tactile contacts on touch
            digitizers and tablet pens on pen digitizers. Physical pens may have multiple tips (such as normal and eraser ends), with each
            pen tip representing a different cursor object. Each cursor object has an associated cursor identifier.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_CURSOR_TYPE.POINTER_DEVICE_CURSOR_TYPE_UNKNOWN">
            <summary>Unidentified cursor.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_CURSOR_TYPE.POINTER_DEVICE_CURSOR_TYPE_TIP">
            <summary>Pen tip.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_CURSOR_TYPE.POINTER_DEVICE_CURSOR_TYPE_ERASER">
            <summary>Pen eraser.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.POINTER_DEVICE_TYPE">
            <summary>Identifies the pointer device types.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_INTEGRATED_PEN">
            <summary>Direct pen digitizer (integrated into display).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_EXTERNAL_PEN">
            <summary>Indirect pen digitizer (not integrated into display).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_TOUCH">
            <summary>Touch digitizer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_TOUCH_PAD">
            <summary>Touchpad digitizer (Windows 8.1 and later).</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.POINTER_FEEDBACK_MODE">
            <summary>Identifies the visual feedback behaviors available to CreateSyntheticPointerDevice.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FEEDBACK_MODE.POINTER_FEEDBACK_DEFAULT">
            <summary>Visual feedback might be suppressed by the user's pen (Settings -> Devices -> Pen &amp; Windows Ink) and touch
            (Settings -> Ease of Access -> Cursor &amp; pointer size) settings.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FEEDBACK_MODE.POINTER_FEEDBACK_INDIRECT">
            <summary>Visual feedback overrides the user's pen and touch settings.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FEEDBACK_MODE.POINTER_FEEDBACK_NONE">
            <summary>Visual feedback is disabled.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.POINTER_FLAGS">
            <summary>Values that can appear in the <c>pointerFlags</c> field of the <c>POINTER_INFO</c> structure.</summary>
            <remarks>
            XBUTTON1 and XBUTTON2 are additional buttons used on many mouse devices. They return the same data as standard mouse buttons.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_NONE">
            <summary>Default</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_NEW">
            <summary>Indicates the arrival of a new pointer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_INRANGE">
            <summary>
            Indicates that this pointer continues to exist. When this flag is not set, it indicates the pointer has left detection range.
            <para>
            This flag is typically not set only when a hovering pointer leaves detection range (POINTER_FLAG_UPDATE is set) or when a
            pointer in contact with a window surface leaves detection range(POINTER_FLAG_UP is set).
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_INCONTACT">
            <summary>
            Indicates that this pointer is in contact with the digitizer surface. When this flag is not set, it indicates a hovering pointer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_FIRSTBUTTON">
            <summary>
            Indicates a primary action, analogous to a left mouse button down.
            <para>A touch pointer has this flag set when it is in contact with the digitizer surface.</para>
            <para>A pen pointer has this flag set when it is in contact with the digitizer surface with no buttons pressed.</para>
            <para>A mouse pointer has this flag set when the left mouse button is down.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_SECONDBUTTON">
            <summary>
            Indicates a secondary action, analogous to a right mouse button down.
            <para>A touch pointer does not use this flag.</para>
            <para>A pen pointer has this flag set when it is in contact with the digitizer surface with the pen barrel button pressed.</para>
            <para>A mouse pointer has this flag set when the right mouse button is down.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_THIRDBUTTON">
            <summary>
            Analogous to a mouse wheel button down.
            <para>A touch pointer does not use this flag.</para>
            <para>A pen pointer does not use this flag.</para>
            <para>A mouse pointer has this flag set when the mouse wheel button is down.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_FOURTHBUTTON">
            <summary>
            Analogous to a first extended mouse (XButton1) button down.
            <para>A touch pointer does not use this flag.</para>
            <para>A pen pointer does not use this flag.</para>
            <para>A mouse pointer has this flag set when the first extended mouse(XBUTTON1) button is down.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_FIFTHBUTTON">
            <summary>
            Analogous to a second extended mouse (XButton2) button down.
            <para>A touch pointer does not use this flag.</para>
            <para>A pen pointer does not use this flag.</para>
            <para>A mouse pointer has this flag set when the second extended mouse(XBUTTON2) button is down.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_PRIMARY">
            <summary>
            Indicates that this pointer has been designated as the primary pointer. A primary pointer is a single pointer that can
            perform actions beyond those available to non-primary pointers. For example, when a primary pointer makes contact with a
            window s surface, it may provide the window an opportunity to activate by sending it a WM_POINTERACTIVATE message.
            <para>
            The primary pointer is identified from all current user interactions on the system(mouse, touch, pen, and so on). As such,
            the primary pointer might not be associated with your app.The first contact in a multi-touch interaction is set as the
            primary pointer.Once a primary pointer is identified, all contacts must be lifted before a new contact can be identified as
            a primary pointer.For apps that don't process pointer input, only the primary pointer's events are promoted to mouse events.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_CONFIDENCE">
            <summary>
            Confidence is a suggestion from the source device about whether the pointer represents an intended or accidental
            interaction, which is especially relevant for PT_TOUCH pointers where an accidental interaction (such as with the palm of
            the hand) can trigger input. The presence of this flag indicates that the source device has high confidence that this input
            is part of an intended interaction.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_CANCELED">
            <summary>
            Indicates that the pointer is departing in an abnormal manner, such as when the system receives invalid input for the
            pointer or when a device with active pointers departs abruptly. If the application receiving the input is in a position to
            do so, it should treat the interaction as not completed and reverse any effects of the concerned pointer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_DOWN">
            <summary>Indicates that this pointer transitioned to a down state; that is, it made contact with the digitizer surface.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_UPDATE">
            <summary>Indicates that this is a simple update that does not include pointer state changes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_UP">
            <summary>Indicates that this pointer transitioned to an up state; that is, contact with the digitizer surface ended.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_WHEEL">
            <summary>
            Indicates input associated with a pointer wheel. For mouse pointers, this is equivalent to the action of the mouse scroll
            wheel (WM_MOUSEHWHEEL).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_HWHEEL">
            <summary>
            Indicates input associated with a pointer h-wheel. For mouse pointers, this is equivalent to the action of the mouse
            horizontal scroll wheel (WM_MOUSEHWHEEL).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_CAPTURECHANGED">
            <summary>
            Indicates that this pointer was captured by (associated with) another element and the original element has lost capture (see WM_POINTERCAPTURECHANGED).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_FLAGS.POINTER_FLAG_HASTRANSFORM">
            <summary>Indicates that this pointer has an associated transform.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.POINTER_INPUT_TYPE">
            <summary>Identifies the pointer input types.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INPUT_TYPE.PT_POINTER">
            <summary>
            Generic pointer type. This type never appears in pointer messages or pointer data. Some data query functions allow the
            caller to restrict the query to specific pointer type. The PT_POINTER type can be used in these functions to specify that
            the query is to include pointers of all types
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INPUT_TYPE.PT_TOUCH">
            <summary>Touch pointer type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INPUT_TYPE.PT_PEN">
            <summary>Pen pointer type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INPUT_TYPE.PT_MOUSE">
            <summary>Mouse pointer type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INPUT_TYPE.PT_TOUCHPAD">
            <summary>Touchpad pointer type (Windows 8.1 and later).</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TOUCH_FLAGS">
            <summary>Values that can appear in the touchFlags field of the POINTER_TOUCH_INFO structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_FLAGS.TOUCH_FLAGS_NONE">
            <summary>Indicates that no flags are set.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TOUCH_MASK">
            <summary>Values that can appear in the touchMask field of the POINTER_TOUCH_INFO structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_MASK.TOUCH_MASK_NONE">
            <summary>Default. None of the optional fields are valid.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_MASK.TOUCH_MASK_CONTACTAREA">
            <summary>rcContact of the POINTER_TOUCH_INFO structure is valid.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_MASK.TOUCH_MASK_ORIENTATION">
            <summary>orientation of the POINTER_TOUCH_INFO structure is valid.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_MASK.TOUCH_MASK_PRESSURE">
            <summary>pressure of the POINTER_TOUCH_INFO structure is valid.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateSyntheticPointerDevice(Vanara.PInvoke.User32.POINTER_INPUT_TYPE,System.UInt32,Vanara.PInvoke.User32.POINTER_FEEDBACK_MODE)">
            <summary>
            Configures the pointer injection device for the calling application, and initializes the maximum number of simultaneous pointers
            that the app can inject.
            </summary>
            <param name="pointerType">The pointer injection device type. Must be either PT_TOUCH or <c>PT_PEN</c>.</param>
            <param name="maxCount">
            <para>The maximum number of contacts.</para>
            <para>For PT_TOUCH this value must be greater than 0 and less than or equal to MAX_TOUCH_COUNT.</para>
            <para>For PT_PEN this value must be 1.</para>
            </param>
            <param name="mode">The contact visualization mode.</param>
            <returns>
            If the function succeeds, the return value is a handle to the pointer injection device. Otherwise, it returns null. To retrieve
            extended error information, call the GetLastError function.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.DestroySyntheticPointerDevice(Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE)">
            <summary>Destroys the specified pointer injection device.</summary>
            <param name="device">A handle to the pointer injection device.</param>
            <returns>This function does not return a value.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnableMouseInPointer(System.Boolean)">
            <summary>Enables the mouse to act as a pointer input device and send WM_POINTER messages.</summary>
            <param name="fEnable"><c>TRUE</c> to turn on mouse input support in WM_POINTER.</param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            This function can be called only once in the context of a process lifetime. Prior to the first call, Windows Store apps run with
            mouse-in-pointer enabled, as do any desktop applications that consume mshtml.dll. All other desktop applications run with
            mouse-in-pointer disabled.
            </para>
            <para>On the first call in the process lifetime, the state is changed as specified and the call succeeds.</para>
            <para>On subsequent calls, the state will not change. If the current state is not equal to the specified state, the call fails.</para>
            <para>Call IsMouseInPointerEnabled to verify the mouse-in-pointer state.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerCursorId(System.UInt32,System.UInt32@)">
            <summary>Retrieves the cursor identifier associated with the specified pointer.</summary>
            <param name="pointerId">An identifier of the pointer for which to retrieve the cursor identifier.</param>
            <param name="cursorId">
            An address of a <c>UINT32</c> to receive the tablet cursor identifier, if any, associated with the specified pointer.
            </param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Cursor objects represent pointing and selecting devices used with digitizer devices, most commonly tactile contacts on touch
            digitizers and tablet pens on pen digitizers. Physical pens may have multiple tips (such as normal and eraser ends), with each
            pen tip representing a different cursor object. Each cursor object has an associated cursor identifier.
            </para>
            <para>
            For pointer types that derive from these cursor objects, an application can use the <c>GetPointerCursorId</c> function to
            retrieve the cursor identifier associated with a pointer.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerDevice(Vanara.PInvoke.HANDLE,Vanara.PInvoke.User32.POINTER_DEVICE_INFO@)">
            <summary>Gets information about the pointer device.</summary>
            <param name="device">The handle to the device.</param>
            <param name="pointerDevice">A POINTER_DEVICE_INFO structure that contains information about the pointer device.</param>
            <returns>
            <para>If this function succeeds, it returns TRUE.</para>
            <para>Otherwise, it returns FALSE. To retrieve extended error information, call the GetLastError function.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerDeviceCursors(Vanara.PInvoke.HANDLE,System.UInt32@,Vanara.PInvoke.User32.POINTER_DEVICE_CURSOR_INFO[])">
            <summary>Gets the cursor IDs that are mapped to the cursors associated with a pointer device.</summary>
            <param name="device">The device handle.</param>
            <param name="cursorCount">The number of cursors associated with the pointer device.</param>
            <param name="deviceCursors">
            An array of POINTER_DEVICE_CURSOR_INFO structures that contain info about the cursors. If NULL, cursorCount returns the number
            of cursors associated with the pointer device.
            </param>
            <returns>
            TRUE if the function succeeds; otherwise, FALSE. If the function fails, call the GetLastError function for more information.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerDeviceProperties(Vanara.PInvoke.HANDLE,System.UInt32@,Vanara.PInvoke.User32.POINTER_DEVICE_PROPERTY[])">
            <summary>Gets device properties that aren't included in the POINTER_DEVICE_INFO structure.</summary>
            <param name="device">
            <para>The pointer device to query properties from.</para>
            <para>A call to the GetPointerDevices function returns this handle in the POINTER_DEVICE_INFO structure.</para>
            </param>
            <param name="propertyCount">
            <para>The number of properties.</para>
            <para>Returns the count that's written or needed if pointerProperties is NULL.</para>
            <para>
            If this value is less than the number of properties that the pointer device supports and pointerProperties is not NULL, the
            function returns the actual number of properties in this variable and fails.
            </para>
            </param>
            <param name="pointerProperties">The array of properties.</param>
            <returns>
            TRUE if the function succeeds; otherwise, FALSE. If the function fails, call the GetLastError function for more information.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerDeviceRects(Vanara.PInvoke.HANDLE,Vanara.PInvoke.RECT@,Vanara.PInvoke.RECT@)">
            <summary>
            Gets the x and y range for the pointer device (in himetric) and the x and y range (current resolution) for the display that the
            pointer device is mapped to.
            </summary>
            <param name="device">The handle to the pointer device.</param>
            <param name="pointerDeviceRect">The structure for retrieving the device's physical range data.</param>
            <param name="displayRect">The structure for retrieving the display resolution.</param>
            <returns>
            TRUE if the function succeeds; otherwise, FALSE. If the function fails, call the GetLastError function for more information.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerDevices(System.UInt32@,Vanara.PInvoke.User32.POINTER_DEVICE_INFO[])">
            <summary>Gets information about the pointer devices attached to the system.</summary>
            <param name="deviceCount">
            If pointerDevices is NULL, deviceCount returns the total number of attached pointer devices. Otherwise, deviceCount specifies
            the number of POINTER_DEVICE_INFO structures pointed to by pointerDevices.
            </param>
            <param name="pointerDevices">
            Array of POINTER_DEVICE_INFO structures for the pointer devices attached to the system. If NULL, the total number of attached
            pointer devices is returned in deviceCount.
            </param>
            <returns>
            <para>If this function succeeds, it returns TRUE.</para>
            <para>Otherwise, it returns FALSE. To retrieve extended error information, call the GetLastError function.</para>
            </returns>
            <remarks>
            <para>Windows 8 supports the following:</para>
            <list type="bullet">
            <item>
            <term>256 contacts per pointer device.</term>
            </item>
            <item>
            <term>
            2560 total contacts per system session, regardless of the number of attached devices. For example, 10 pointer devices with 256
            contacts each, 20 pointer devices with 128 contacts each, and so on.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerFrameInfo(System.UInt32,System.UInt32@,Vanara.PInvoke.User32.POINTER_INFO[])">
            <summary>Gets the entire frame of information for the specified pointers associated with the current message.</summary>
            <param name="pointerId">An identifier of the pointer for which to retrieve frame information.</param>
            <param name="pointerCount">
            A pointer to a variable that specifies the count of structures in the buffer to which pointerInfo points. If
            <c>GetPointerFrameInfo</c> succeeds, pointerCount is updated with the total count of pointers in the frame.
            </param>
            <param name="pointerInfo">
            Address of an array of POINTER_INFO structures to receive the pointer information. This parameter can be <c>NULL</c> if
            *pointerCount is zero.
            </param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Parallel-mode devices may report pointer input in frames, that is, they may report the state and position of all pointers from
            that device in a single input report to the system. Ideally, applications should view the entire frame as a single input unless
            the application-specific requirements dictate otherwise.
            </para>
            <para>
            <c>GetPointerFrameInfo</c> retrieves the entire pointer input frame associated with a pointer message. Use GetPointerInfo to
            retrieve information for a single pointer associated with a pointer message.
            </para>
            <para>The frame contains only pointers that are currently owned by the same window as the specified pointer.</para>
            <para>
            The information returned by <c>GetPointerFrameInfo</c> is associated with the most recent pointer message retrieved by the
            calling thread. When the next message is retrieved by the calling thread, the information associated with the previous message
            may no longer be available.
            </para>
            <para>
            If the application does not process pointer input messages as fast as they are generated, some messages may be coalesced into a
            WM_POINTERUPDATE message. Use GetPointerFrameInfoHistory to retrieve the message history from the most recent
            <c>WM_POINTERUPDATE</c> message.
            </para>
            <para>
            Having retrieved the entire frame of information, the application can then call the SkipPointerFrameMessages function to skip
            remaining pointer messages associated with this frame that are pending retrieval. This saves the application the overhead of
            retrieving and processing the remaining messages one by one. However, the <c>SkipPointerFrameMessages</c> function should be
            used with care and only when the caller can be sure that no other entity on the caller’s thread is expecting to see the
            remaining pointer messages one by one as they are retrieved.
            </para>
            <para>
            Note that the information retrieved is associated with the pointer frame most recently retrieved by the calling thread. Once the
            calling thread retrieves its next message, the information associated with the previous pointer frame may no longer be available.
            </para>
            <para>
            If the pointer frame contains no additional pointers besides the specified pointer, this function succeeds and returns only the
            information for the specified pointer.
            </para>
            <para>
            If the information associated with the pointer frame is no longer available, this function fails with the last error set to <c>ERROR_NO_DATA</c>.
            </para>
            <para>
            If the calling thread does not own the window (where the input was originally delivered or where the message was forwarded) to
            which the pointer message has been delivered, this function fails with the last error set to <c>ERROR_ACCESS_DENIED</c>.
            </para>
            <para>
            For apps that have both client and non-client areas, the input frame can include both client and non-client data. To
            differentiate between client and non-client data, you must perform hit testing on the target window.
            </para>
            <para>We recommend the following if you want to filter data from the input frame:</para>
            <list type="bullet">
            <item>
            <term>
            For each update that does not include a pointer contact (a POINTER_FLAG_UPDATE without <c>POINTER_FLAG_INCONTACT</c>), hit test
            to determine if the input is client or non-client.
            </term>
            </item>
            <item>
            <term>For each new contact (POINTER_FLAG_DOWN), hit test to determine if the input is client or non-client and track this info.</term>
            </item>
            <item>
            <term>
            For each update that includes a pointer contact (a POINTER_FLAG_UPDATE with <c>POINTER_FLAG_INCONTACT</c>), use the tracking
            info to determine whether the input is client or non-client.
            </term>
            </item>
            <item>
            <term>
            For each POINTER_FLAG_UP, use the tracking info to determine whether the input is client or non-client and then clear this
            pointer from the tracking data.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerFrameInfoHistory(System.UInt32,System.UInt32@,System.UInt32@,Vanara.PInvoke.User32.POINTER_INFO[0:,0:])">
            <summary>
            Gets the entire frame of information (including coalesced input frames) for the specified pointers associated with the current message.
            </summary>
            <param name="pointerId">An identifier of the pointer for which to retrieve frame information.</param>
            <param name="entriesCount">
            A pointer to a variable that specifies the count of rows in the two-dimensional array to which pointerInfo points. If
            <c>GetPointerFrameInfoHistory</c> succeeds, entriesCount is updated with the total count of frames available in the history.
            </param>
            <param name="pointerCount">
            A pointer to a variable that specifies the count of columns in the two-dimensional array to which pointerInfo points. If
            <c>GetPointerFrameInfoHistory</c> succeeds, pointerCount is updated with the total count of pointers in each frame.
            </param>
            <param name="pointerInfo">
            <para>
            Address of a two-dimensional array of POINTER_INFO structures to receive the pointer information. This parameter can be NULL if
            *entriesCount and *pointerCount are both zero.
            </para>
            <para>This array is interpreted as .</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Parallel-mode devices may report pointer input in frames, that is, they may report the state and position of all pointers from
            that device in a single input report to the system. Ideally, applications should view the entire frame as a single input unless
            the application-specific requirements dictate otherwise.
            </para>
            <para>
            The information returned by GetPointerFrameInfo is associated with the most recent pointer message retrieved by the calling
            thread. When the next message is retrieved by the calling thread, the information associated with the previous message may no
            longer be available.
            </para>
            <para>
            If the application does not process pointer input messages as fast as they are generated, some messages may be coalesced into a
            WM_POINTERUPDATE message. Use <c>GetPointerFrameInfoHistory</c> to retrieve the message history (including coalesced input
            frames) from the most recent <c>WM_POINTERUPDATE</c> message.
            </para>
            <para>
            Having retrieved the entire frame of information, the application can then call the SkipPointerFrameMessages function to skip
            remaining pointer messages associated with this frame that are pending retrieval. This saves the application the overhead of
            retrieving and processing the remaining messages one by one. However, the <c>SkipPointerFrameMessages</c> function should be
            used with care and only when the caller can be sure that no other entity on the caller’s thread is expecting to see the
            remaining pointer messages one by one as they are retrieved.
            </para>
            <para>The frame contains only pointers that are currently owned by the same window as the specified pointer.</para>
            <para>
            The information retrieved represents a two-dimensional array with one row for each history entry and one column for each pointer
            in the frame.
            </para>
            <para>
            The information retrieved appears in reverse chronological order, with the most recent entry in the first row of the returned
            array. The most recent entry is the same as that returned by the GetPointerFrameInfo function.
            </para>
            <para>
            If the count of rows in the buffer provided is insufficient to hold all available history entries, this function succeeds with
            the buffer containing the most recent entries and *entriesCount containing the total count of entries available.
            </para>
            <para>
            If the pointer frame contains no additional pointers besides the specified pointer, this function succeeds and returns only the
            information for the specified pointer.
            </para>
            <para>
            If the information associated with the pointer frame is no longer available, this function fails with the last error set to <c>ERROR_NO_DATA</c>.
            </para>
            <para>
            If the calling thread does not own the window (where the input was originally delivered or where the message was forwarded) to
            which the pointer message has been delivered, this function fails with the last error set to <c>ERROR_ACCESS_DENIED</c>.
            </para>
            <para>
            For apps that have both client and non-client areas, the input frame can include both client and non-client data. To
            differentiate between client and non-client data, you must perform hit testing on the target window.
            </para>
            <para>We recommend the following if you want to filter data from the input frame:</para>
            <list type="bullet">
            <item>
            <term>
            For each update that does not include a pointer contact (a POINTER_FLAG_UPDATE without <c>POINTER_FLAG_INCONTACT</c>), hit test
            to determine if the input is client or non-client.
            </term>
            </item>
            <item>
            <term>For each new contact (POINTER_FLAG_DOWN), hit test to determine if the input is client or non-client and track this info.</term>
            </item>
            <item>
            <term>
            For each update that includes a pointer contact (a POINTER_FLAG_UPDATE with <c>POINTER_FLAG_INCONTACT</c>), use the tracking
            info to determine whether the input is client or non-client.
            </term>
            </item>
            <item>
            <term>
            For each POINTER_FLAG_UP, use the tracking info to determine whether the input is client or non-client and then clear this
            pointer from the tracking data.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerFramePenInfo(System.UInt32,System.UInt32@,Vanara.PInvoke.User32.POINTER_PEN_INFO[])">
            <summary>
            Gets the entire frame of pen-based information for the specified pointers (of type PT_PEN) associated with the current message.
            </summary>
            <param name="pointerId">An identifier of the pointer for which to retrieve frame information.</param>
            <param name="pointerCount">
            A pointer to a variable that specifies the count of structures in the buffer to which penInfo points. If
            <c>GetPointerFramePenInfo</c> succeeds, pointerCount is updated with the total count of pointers in the frame.
            </param>
            <param name="penInfo">
            Address of an array of POINTER_PEN_INFO structures to receive the pointer information. This parameter can be NULL if
            *pointerCount is zero.
            </param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Parallel-mode devices may report pointer input in frames, that is, they may report the state and position of all pointers from
            that device in a single input report to the system. Ideally, applications should view the entire frame as a single input unless
            the application-specific requirements dictate otherwise.
            </para>
            <para>
            <c>GetPointerFramePenInfo</c> retrieves the entire pointer input frame associated with a pointer (of type PT_PEN) message. Use
            GetPointerPenInfo to retrieve information for a single pointer associated with a pointer message.
            </para>
            <para>The frame contains only pointers that are currently owned by the same window as the specified pointer.</para>
            <para>
            The information returned by GetPointerFrameInfo is associated with the most recent pointer message retrieved by the calling
            thread. When the next message is retrieved by the calling thread, the information associated with the previous message may no
            longer be available.
            </para>
            <para>
            If the application does not process pointer input messages as fast as they are generated, some messages may be coalesced into a
            WM_POINTERUPDATE message. Use GetPointerFramePenInfoHistory to retrieve the message history from the most recent
            <c>WM_POINTERUPDATE</c> message.
            </para>
            <para>
            Having retrieved the entire frame of information, the application can then call the SkipPointerFrameMessages function to skip
            remaining pointer messages associated with this frame that are pending retrieval. This saves the application the overhead of
            retrieving and processing the remaining messages one by one. However, the <c>SkipPointerFrameMessages</c> function should be
            used with care and only when the caller can be sure that no other entity on the caller’s thread is expecting to see the
            remaining pointer messages one by one as they are retrieved.
            </para>
            <para>
            Note that the information retrieved is associated with the pointer frame most recently retrieved by the calling thread. Once the
            calling thread retrieves its next message, the information associated with the previous pointer frame may no longer be available.
            </para>
            <para>
            If the pointer frame contains no additional pointers besides the specified pointer, this function succeeds and returns only the
            information for the specified pointer.
            </para>
            <para>
            If the information associated with the pointer frame is no longer available, this function fails with the last error set to <c>ERROR_NO_DATA</c>.
            </para>
            <para>
            If the calling thread does not own the window to which the pointer message has been delivered, this function fails with the last
            error set to <c>ERROR_ACCESS_DENIED</c>.
            </para>
            <para>If the specified pointer is not of type PT_PEN, this function fails with the last error set to <c>ERROR_DATATYPE_MISMATCH</c>.</para>
            <para>
            For apps that have both client and non-client areas, the input frame can include both client and non-client data. To
            differentiate between client and non-client data, you must perform hit testing on the target window.
            </para>
            <para>We recommend the following if you want to filter data from the input frame:</para>
            <list type="bullet">
            <item>
            <term>
            For each update that does not include a pointer contact (a POINTER_FLAG_UPDATE without <c>POINTER_FLAG_INCONTACT</c>), hit test
            to determine if the input is client or non-client.
            </term>
            </item>
            <item>
            <term>For each new contact (POINTER_FLAG_DOWN), hit test to determine if the input is client or non-client and track this info.</term>
            </item>
            <item>
            <term>
            For each update that includes a pointer contact (a POINTER_FLAG_UPDATE with <c>POINTER_FLAG_INCONTACT</c>), use the tracking
            info to determine whether the input is client or non-client.
            </term>
            </item>
            <item>
            <term>
            For each POINTER_FLAG_UP, use the tracking info to determine whether the input is client or non-client and then clear this
            pointer from the tracking data.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerFramePenInfoHistory(System.UInt32,System.UInt32@,System.UInt32@,Vanara.PInvoke.User32.POINTER_PEN_INFO[0:,0:])">
            <summary>
            Gets the entire frame of pen-based information (including coalesced input frames) for the specified pointers (of type PT_PEN)
            associated with the current message.
            </summary>
            <param name="pointerId">The identifier of the pointer for which to retrieve frame information.</param>
            <param name="entriesCount">
            A pointer to a variable that specifies the count of rows in the two-dimensional array to which penInfo points. If
            <c>GetPointerFramePenInfoHistory</c> succeeds, entriesCount is updated with the total count of frames available in the history.
            </param>
            <param name="pointerCount">
            A pointer to a variaable that specifies the count of columns in the two-dimensional array to which penInfo points. If
            <c>GetPointerFramePenInfoHistory</c> succeeds, pointerCount is updated with the total count of pointers in each frame.
            </param>
            <param name="penInfo">
            <para>
            Address of a two-dimensional array of POINTER_PEN_INFO structures to receive the pointer information. This parameter can be NULL
            if *entriesCount and *pointerCount are both zero.
            </para>
            <para>This array is interpreted as POINTER_PEN_INFO[*entriesCount][*pointerCount].</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Parallel-mode devices may report pointer input in frames, that is, they may report the state and position of all pointers from
            that device in a single input report to the system. Ideally, applications should view the entire frame as a single input unless
            the application-specific requirements dictate otherwise.
            </para>
            <para>
            The information returned by GetPointerFramePenInfo is associated with the most recent pointer (PT_PEN) message retrieved by the
            calling thread. When the next message is retrieved by the calling thread, the information associated with the previous message
            may no longer be available.
            </para>
            <para>
            If the application does not process pointer input messages as fast as they are generated, some messages may be coalesced into a
            WM_POINTERUPDATE message. Use <c>GetPointerFramePenInfoHistory</c> to retrieve the message history (including coalesced input
            frames) from the most recent <c>WM_POINTERUPDATE</c> message.
            </para>
            <para>
            Having retrieved the entire frame of information, the application can then call the SkipPointerFrameMessages function to skip
            remaining pointer messages associated with this frame that are pending retrieval. This saves the application the overhead of
            retrieving and processing the remaining messages one by one. However, the <c>SkipPointerFrameMessages</c> function should be
            used with care and only when the caller can be sure that no other entity on the caller’s thread is expecting to see the
            remaining pointer messages one by one as they are retrieved.
            </para>
            <para>The frame contains only pointers that are currently owned by the same window as the specified pointer.</para>
            <para>
            The information retrieved represents a two-dimensional array with one row for each history entry and one column for each pointer
            in the frame.
            </para>
            <para>
            The information retrieved appears in reverse chronological order, with the most recent entry in the first row of the returned
            array. The most recent entry is the same as that returned by the GetPointerFramePenInfo function.
            </para>
            <para>
            If the count of rows in the buffer provided is insufficient to hold all available history entries, this function succeeds with
            the buffer containing the most recent entries and *entriesCount containing the total count of entries available.
            </para>
            <para>
            If the pointer frame contains no additional pointers besides the specified pointer, this function succeeds and returns only the
            information for the specified pointer.
            </para>
            <para>
            If the information associated with the pointer frame is no longer available, this function fails with the last error set to <c>ERROR_NO_DATA</c>.
            </para>
            <para>
            If the calling thread does not own the window (where the input was originally delivered or where the message was forwarded) to
            which the pointer message has been delivered, this function fails with the last error set to <c>ERROR_ACCESS_DENIED</c>.
            </para>
            <para>If the specified pointer is not of type PT_PEN, this function fails with the last error set to <c>ERROR_DATATYPE_MISMATCH</c>.</para>
            <para>
            For apps that have both client and non-client areas, the input frame can include both client and non-client data. To
            differentiate between client and non-client data, you must perform hit testing on the target window.
            </para>
            <para>We recommend the following if you want to filter data from the input frame:</para>
            <list type="bullet">
            <item>
            <term>
            For each update that does not include a pointer contact (a POINTER_FLAG_UPDATE without <c>POINTER_FLAG_INCONTACT</c>), hit test
            to determine if the input is client or non-client.
            </term>
            </item>
            <item>
            <term>For each new contact (POINTER_FLAG_DOWN), hit test to determine if the input is client or non-client and track this info.</term>
            </item>
            <item>
            <term>
            For each update that includes a pointer contact (a POINTER_FLAG_UPDATE with <c>POINTER_FLAG_INCONTACT</c>), use the tracking
            info to determine whether the input is client or non-client.
            </term>
            </item>
            <item>
            <term>
            For each POINTER_FLAG_UP, use the tracking info to determine whether the input is client or non-client and then clear this
            pointer from the tracking data.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerFrameTouchInfo(System.UInt32,System.UInt32@,Vanara.PInvoke.User32.POINTER_TOUCH_INFO[])">
            <summary>
            Gets the entire frame of touch-based information for the specified pointers (of type PT_TOUCH) associated with the current message.
            </summary>
            <param name="pointerId">An identifier of the pointer for which to retrieve frame information.</param>
            <param name="pointerCount">
            A pointer to a variable that specifies the count of structures in the buffer to which touchInfo points. If
            <c>GetPointerFrameTouchInfo</c> succeeds, pointerCount is updated with the total count of pointers in the frame.
            </param>
            <param name="touchInfo">
            Address of an array of POINTER_TOUCH_INFO structures to receive the pointer information. This parameter can be NULL if
            *pointerCount is zero.
            </param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Parallel-mode devices may report pointer input in frames, that is, they may report the state and position of all pointers from
            that device in a single input report to the system. Ideally, applications should view the entire frame as a single input unless
            the application-specific requirements dictate otherwise.
            </para>
            <para>
            <c>GetPointerFrameTouchInfo</c> retrieves the entire pointer input frame associated with a pointer (of type PT_TOUCH) message.
            Use GetPointerTouchInfo to retrieve information for a single pointer associated with a pointer message.
            </para>
            <para>The frame contains only pointers that are currently owned by the same window as the specified pointer.</para>
            <para>
            The information returned by <c>GetPointerFrameTouchInfo</c> is associated with the most recent pointer message retrieved by the
            calling thread. When the next message is retrieved by the calling thread, the information associated with the previous message
            may no longer be available.
            </para>
            <para>
            If the application does not process pointer input messages as fast as they are generated, some messages may be coalesced into a
            WM_POINTERUPDATE message. Use GetPointerFrameTouchInfoHistory to retrieve the message history from the most recent
            <c>WM_POINTERUPDATE</c> message.
            </para>
            <para>
            Having retrieved the entire frame of information, the application can then call the SkipPointerFrameMessages function to skip
            remaining pointer messages associated with this frame that are pending retrieval. This saves the application the overhead of
            retrieving and processing the remaining messages one by one. However, the <c>SkipPointerFrameMessages</c> function should be
            used with care and only when the caller can be sure that no other entity on the caller’s thread is expecting to see the
            remaining pointer messages one by one as they are retrieved.
            </para>
            <para>
            Note that the information retrieved is associated with the pointer frame most recently retrieved by the calling thread. Once the
            calling thread retrieves its next message, the information associated with the previous pointer frame may no longer be available.
            </para>
            <para>
            If the pointer frame contains no additional pointers besides the specified pointer, this function succeeds and returns only the
            information for the specified pointer.
            </para>
            <para>
            If the information associated with the pointer frame is no longer available, this function fails with the last error set to <c>ERROR_NO_DATA</c>.
            </para>
            <para>
            If the calling thread does not own the window to which the pointer message has been delivered, this function fails with the last
            error set to <c>ERROR_ACCESS_DENIED</c>.
            </para>
            <para>If the specified pointer is not of type PT_TOUCH, this function fails with the last error set to <c>ERROR_DATATYPE_MISMATCH</c>.</para>
            <para>
            For apps that have both client and non-client areas, the input frame can include both client and non-client data. To
            differentiate between client and non-client data, you must perform hit testing on the target window.
            </para>
            <para>We recommend the following if you want to filter data from the input frame:</para>
            <list type="bullet">
            <item>
            <term>
            For each update that does not include a pointer contact (a POINTER_FLAG_UPDATE without <c>POINTER_FLAG_INCONTACT</c>), hit test
            to determine if the input is client or non-client.
            </term>
            </item>
            <item>
            <term>For each new contact (POINTER_FLAG_DOWN), hit test to determine if the input is client or non-client and track this info.</term>
            </item>
            <item>
            <term>
            For each update that includes a pointer contact (a POINTER_FLAG_UPDATE with <c>POINTER_FLAG_INCONTACT</c>), use the tracking
            info to determine whether the input is client or non-client.
            </term>
            </item>
            <item>
            <term>
            For each POINTER_FLAG_UP, use the tracking info to determine whether the input is client or non-client and then clear this
            pointer from the tracking data.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerFrameTouchInfoHistory(System.UInt32,System.UInt32@,System.UInt32@,Vanara.PInvoke.User32.POINTER_TOUCH_INFO[0:,0:])">
            <summary>
            Gets the entire frame of touch-based information (including coalesced input frames) for the specified pointers (of type
            PT_TOUCH) associated with the current message.
            </summary>
            <param name="pointerId">An identifier of the pointer for which to retrieve frame information.</param>
            <param name="entriesCount">
            A pointer to variable that specifies the count of rows in the two-dimensional array to which touchInfo points. If
            <c>GetPointerFrameTouchInfoHistory</c> succeeds, entriesCount is updated with the total count of frames available in the history.
            </param>
            <param name="pointerCount">
            A pointer to a variable that specifies the count of columns in the two-dimensional array to which touchInfo points. If
            <c>GetPointerFrameTouchInfoHistory</c> succeeds, pointerCount is updated with the total count of pointers in each frame.
            </param>
            <param name="touchInfo">
            <para>
            Address of a two-dimensional array of POINTER_TOUCH_INFO structures to receive the pointer information. This parameter can be
            NULL if *entriesCount and *pointerCount are both zero.
            </para>
            <para>This array is interpreted as .</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Parallel-mode devices may report pointer input in frames, that is, they may report the state and position of all pointers from
            that device in a single input report to the system. Ideally, applications should view the entire frame as a single input unless
            the application-specific requirements dictate otherwise.
            </para>
            <para>
            The information returned by GetPointerFrameTouchInfo is associated with the most recent pointer (PT_TOUCH) message retrieved by
            the calling thread. When the next message is retrieved by the calling thread, the information associated with the previous
            message may no longer be available.
            </para>
            <para>
            If the application does not process pointer input messages as fast as they are generated, some messages may be coalesced into a
            WM_POINTERUPDATE message. Use <c>GetPointerFrameTouchInfoHistory</c> to retrieve the message history (including coalesced input
            frames) from the most recent <c>WM_POINTERUPDATE</c> message.
            </para>
            <para>
            Having retrieved the entire frame of information, the application can then call the SkipPointerFrameMessages function to skip
            remaining pointer messages associated with this frame that are pending retrieval. This saves the application the overhead of
            retrieving and processing the remaining messages one by one. However, the <c>SkipPointerFrameMessages</c> function should be
            used with care and only when the caller can be sure that no other entity on the caller’s thread is expecting to see the
            remaining pointer messages one by one as they are retrieved.
            </para>
            <para>The frame contains only pointers that are currently owned by the same window as the specified pointer.</para>
            <para>
            The information retrieved represents a two-dimensional array with one row for each history entry and one column for each pointer
            in the frame.
            </para>
            <para>
            The information retrieved appears in reverse chronological order, with the most recent entry in the first row of the returned
            array. The most recent entry is the same as that returned by the GetPointerFrameTouchInfo function.
            </para>
            <para>
            If the count of rows in the buffer provided is insufficient to hold all available history entries, this function succeeds with
            the buffer containing the most recent entries and *entriesCount containing the total count of entries available.
            </para>
            <para>
            If the pointer frame contains no additional pointers besides the specified pointer, this function succeeds and returns only the
            information for the specified pointer.
            </para>
            <para>
            If the information associated with the pointer frame is no longer available, this function fails with the last error set to <c>ERROR_NO_DATA</c>.
            </para>
            <para>
            If the calling thread does not own the window (where the input was originally delivered or where the message was forwarded) to
            which the pointer message has been delivered, this function fails with the last error set to <c>ERROR_ACCESS_DENIED</c>.
            </para>
            <para>If the specified pointer is not of type PT_TOUCH, this function fails with the last error set to <c>ERROR_DATATYPE_MISMATCH</c>.</para>
            <para>
            For apps that have both client and non-client areas, the input frame can include both client and non-client data. To
            differentiate between client and non-client data, you must perform hit testing on the target window.
            </para>
            <para>We recommend the following if you want to filter data from the input frame:</para>
            <list type="bullet">
            <item>
            <term>
            For each update that does not include a pointer contact (a POINTER_FLAG_UPDATE without <c>POINTER_FLAG_INCONTACT</c>), hit test
            to determine if the input is client or non-client.
            </term>
            </item>
            <item>
            <term>For each new contact (POINTER_FLAG_DOWN), hit test to determine if the input is client or non-client and track this info.</term>
            </item>
            <item>
            <term>
            For each update that includes a pointer contact (a POINTER_FLAG_UPDATE with <c>POINTER_FLAG_INCONTACT</c>), use the tracking
            info to determine whether the input is client or non-client.
            </term>
            </item>
            <item>
            <term>
            For each POINTER_FLAG_UP, use the tracking info to determine whether the input is client or non-client and then clear this
            pointer from the tracking data.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerInfo(System.UInt32,Vanara.PInvoke.User32.POINTER_INFO@)">
            <summary>
            <para>Gets the information for the specified pointer associated with the current message.</para>
            <para><c>Note</c> Use GetPointerType if you don't need the additional information exposed by <c>GetPointerInfo</c>.</para>
            </summary>
            <param name="pointerId">The pointer identifier.</param>
            <param name="pointerInfo">Address of a POINTER_INFO structure that receives the pointer information.</param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para><c>GetPointerInfo</c> retrieves information for a single pointer associated with a pointer message.</para>
            <para>Use GetPointerFrameInfo to retrieve frame information associated with a message for a set of pointers.</para>
            <para>
            The information returned by <c>GetPointerInfo</c> is associated with the most recent pointer message retrieved by the calling
            thread. When the next message is retrieved by the calling thread, the information associated with the previous message may no
            longer be available.
            </para>
            <para>
            If the application does not process pointer input messages as fast as they are generated, some messages may be coalesced into a
            WM_POINTERUPDATE message. Use GetPointerInfoHistory to retrieve the message history from the most recent <c>WM_POINTERUPDATE</c> message.
            </para>
            <para>
            If the information associated with the message is no longer available, this function fails with the last error set to <c>ERROR_NO_DATA</c>.
            </para>
            <para>
            If the calling thread does not own the window to which the pointer message has been delivered, this function fails with the last
            error set to <c>ERROR_ACCESS_DENIED</c>. Note that this may be the window to which the input was originally delivered or it may
            be a window to which the message was forwarded.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerInfoHistory(System.UInt32,System.UInt32@,Vanara.PInvoke.User32.POINTER_INFO[])">
            <summary>
            Gets the information associated with the individual inputs, if any, that were coalesced into the current message for the
            specified pointer. The most recent input is included in the returned history and is the same as the most recent input returned
            by the GetPointerInfo function.
            </summary>
            <param name="pointerId">An identifier of the pointer for which to retrieve information.</param>
            <param name="entriesCount">
            A pointer to a variable that specifies the count of structures in the buffer to which pointerInfo points. If
            <c>GetPointerInfoHistory</c> succceeds, entriesCount is updated with the total count of structures available. The total count of
            structures available is the same as the <c>historyCount</c> field of the POINTER_INFO structure returned by a call to GetPointerInfo.
            </param>
            <param name="pointerInfo">
            Address of an array of POINTER_INFO structures to receive the pointer information. This parameter can be NULL if *entriesCount
            is zero.
            </param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the application does not process pointer input messages as fast as they are generated, some moves may be coalesced. When an
            application receives a coalescable pointer message, it can use the <c>GetPointerInfoHistory</c> function to retrieve information
            for all the individual inputs, if any, that were coalesced into the message. Note that the information retrieved is associated
            with the pointer message most recently retrieved by the calling thread. Once the calling thread retrieves its next message, the
            information associated with the previous message may no longer be available.
            </para>
            <para>
            The information retrieved appears in reverse chronological order, with the most recent entry in the first row of the returned
            array. The most recent entry is the same as that returned by the GetPointerInfo function.
            </para>
            <para>
            If the count of rows in the buffer provided is insufficient to hold all available history entries, this function succeeds with
            the buffer containing the most recent entries and *entriesCount containing the total count of entries available.
            </para>
            <para>
            If the pointer frame contains no additional pointers besides the specified pointer, this function succeeds and returns only the
            information for the specified pointer.
            </para>
            <para>
            If the information associated with the pointer frame is no longer available, this function fails with the last error set to <c>ERROR_NO_DATA</c>.
            </para>
            <para>
            If the calling thread does not own the window (where the input was originally delivered or where the message was forwarded) to
            which the pointer message has been delivered, this function fails with the last error set to <c>ERROR_ACCESS_DENIED</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerInputTransform(System.UInt32,System.UInt32,Vanara.PInvoke.User32.INPUT_TRANSFORM[])">
            <summary>Gets one or more transforms for the pointer information coordinates associated with the current message.</summary>
            <param name="pointerId">An identifier of the pointer for which to retrieve information.</param>
            <param name="historyCount">
            <para>The number of INPUT_TRANSFORM structures that inputTransform can point to.</para>
            <para>
            This value must be no less than 1 and no greater than the value specified in <c>historyCount</c> of the POINTER_INFO structure
            returned by GetPointerInfo, GetPointerTouchInfo, or GetPointerPenInfo (for a single input transform) or GetPointerInfoHistory,
            GetPointerTouchInfoHistory, or GetPointerPenInfoHistory (for an array of input transforms).
            </para>
            <para>
            If <c>GetPointerInputTransform</c> succeeds, inputTransform is updated with the total count of structures available. The total
            count of structures available is the same as the <c>historyCount</c> field of the POINTER_INFO structure.
            </para>
            </param>
            <param name="inputTransform">
            Address of an array of INPUT_TRANSFORM structures to receive the transform information. This parameter cannot be NULL.
            </param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            A consumer of pointer input messages typically uses ScreenToClient or MapWindowPoints to convert screen coordinates to client coordinates.
            </para>
            <para>
            If a transform is applied on the message consumer, use <c>GetPointerInputTransform</c> to retrieve the transform on the message
            consumer at the time the input occurred. The inverse of this transform can then be used to convert pointer input coordinates
            from screen coordinates to the client coordinates of the message consumer.
            </para>
            <para>
            If an input transform is not associated with the input, the <c>GetPointerInputTransform</c> function fails with the last error
            set to <c>ERROR_NO_DATA</c>. Use ScreenToClient or MapWindowPoints instead.
            </para>
            <para>
            The input transform does not respect any right-to-left layout setting on the input target. An application that requires adjusted
            coordinates for right-to-left layout must perform the right-to-left mirroring or combine an appropriate mirroring transform with
            the input transform.
            </para>
            <para>
            The information returned by <c>GetPointerInputTransform</c> is associated with the most recent pointer message retrieved by the
            calling thread. When the next message is retrieved by the calling thread, the information associated with the previous message
            might no longer be available.
            </para>
            <para>
            If an application calls GetPointerInfo, it can call <c>GetPointerInputTransform</c> with the same pointer Id and a single
            INPUT_TRANSFORM output buffer to get the input transform associated with the data.
            </para>
            <para>
            If an application calls GetPointerFrameInfo, it can call <c>GetPointerInputTransform</c> with the same pointer Id and a single
            INPUT_TRANSFORM output buffer to get the input transform associated with the data. The same input transform applies to the
            entire frame.
            </para>
            <para>
            If an application calls GetPointerInfoHistory, it can call <c>GetPointerInputTransform</c> with the same pointer Id and an
            output buffer to hold the entries retrieved using <c>GetPointerInfoHistory</c>. Each input transform in the returned array can
            be used with the corresponding entry in the array returned by <c>GetPointerInfoHistory</c>.
            </para>
            <para>
            If an application calls GetPointerFrameInfoHistory, it can call <c>GetPointerInputTransform</c> with the same pointer Id and an
            output buffer to hold the entries retrieved using GetPointerInfoHistory. Each input transform in the returned array can be used
            with the corresponding frame in the array returned by <c>GetPointerFrameInfoHistory</c>, with the same input transform being
            applied to the entire frame.
            </para>
            <para>
            If the information associated with the message is no longer available, this function fails with the last error set to <c>ERROR_INVALID_PARAMETER</c>.
            </para>
            <para>
            If historyCount contains a value larger than the <c>historyCount</c> field of the POINTER_INFO structure returned by
            GetPointerInfo (or the first <c>POINTER_INFO</c> structure in the array returned by GetPointerInfoHistory), the function fails
            with the last error set to <c>ERROR_INVALID_PARAMETER</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerPenInfo(System.UInt32,Vanara.PInvoke.User32.POINTER_PEN_INFO@)">
            <summary>Gets the pen-based information for the specified pointer (of type PT_PEN) associated with the current message.</summary>
            <param name="pointerId">An identifier of the pointer for which to retrieve information.</param>
            <param name="penInfo">Address of a POINTER_PEN_INFO structure to receive the pen-specific pointer information.</param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para><c>GetPointerPenInfo</c> retrieves information for a single pointer (of type PT_PEN) associated with a pointer message.</para>
            <para>Use GetPointerFramePenInfo to retrieve frame information associated with a message for a set of pointers.</para>
            <para>
            The information returned by GetPointerInfo is associated with the most recent pointer message retrieved by the calling thread.
            When the next message is retrieved by the calling thread, the information associated with the previous message may no longer be available.
            </para>
            <para>
            If the application does not process pointer input messages as fast as they are generated, some messages may be coalesced into a
            WM_POINTERUPDATE message. Use GetPointerPenInfoHistory to retrieve the message history from the most recent
            <c>WM_POINTERUPDATE</c> message.
            </para>
            <para>
            If the information associated with the message is no longer available, this function fails with the last error set to <c>ERROR_NO_DATA</c>.
            </para>
            <para>
            If the calling thread does not own the window to which the pointer message has been delivered, this function fails with the last
            error set to <c>ERROR_ACCESS_DENIED</c>. Note that this may be the window to which the input was originally delivered or it may
            be a window to which the message was forwarded.
            </para>
            <para>If the specified pointer is not of type PT_PEN, this function fails with the last error set to <c>ERROR_DATATYPE_MISMATCH</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerPenInfoHistory(System.UInt32,System.UInt32@,Vanara.PInvoke.User32.POINTER_PEN_INFO[])">
            <summary>
            Gets the pen-based information associated with the individual inputs, if any, that were coalesced into the current message for
            the specified pointer (of type PT_PEN). The most recent input is included in the returned history and is the same as the most
            recent input returned by the GetPointerPenInfo function.
            </summary>
            <param name="pointerId">An identifier of the pointer for which to retrieve information.</param>
            <param name="entriesCount">
            A pointer to a variable that specifies the count of structures in the buffer to which penInfo points. If
            <c>GetPointerPenInfoHistory</c> succeeds, entriesCount is updated with the total count of structures available. The total count
            of structures available is the same as the historyCount field in the POINTER_PEN_INFO structure returned by a call to GetPointerPenInfo.
            </param>
            <param name="penInfo">
            Address of an array of POINTER_PEN_INFO structures to receive the pointer information. This parameter can be NULL if
            *entriesCount is zero.
            </param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the application does not process pointer input messages as fast as they are generated, some moves may be coalesced. When an
            application receives a coalescable pointer (of type PT_PEN) message, it can use the <c>GetPointerPenInfoHistory</c> function to
            retrieve information for all the individual inputs, if any, that were coalesced into the message. Note that the information
            retrieved is associated with the pointer message most recently retrieved by the calling thread. Once the calling thread
            retrieves its next message, the information associated with the previous message may no longer be available.
            </para>
            <para>
            The information retrieved appears in reverse chronological order, with the most recent entry in the first row of the returned
            array. The most recent entry is the same as that returned by the GetPointerPenInfo function.
            </para>
            <para>
            If the count of rows in the buffer provided is insufficient to hold all available history entries, this function succeeds with
            the buffer containing the most recent entries and *entriesCount containing the total count of entries available.
            </para>
            <para>
            If the pointer frame contains no additional pointers besides the specified pointer, this function succeeds and returns only the
            information for the specified pointer.
            </para>
            <para>
            If the information associated with the pointer frame is no longer available, this function fails with the last error set to <c>ERROR_NO_DATA</c>.
            </para>
            <para>
            If the calling thread does not own the window (where the input was originally delivered or where the message was forwarded) to
            which the pointer message has been delivered, this function fails with the last error set to <c>ERROR_ACCESS_DENIED</c>.
            </para>
            <para>If the specified pointer is not of type PT_PEN, this function fails with the last error set to <c>ERROR_DATATYPE_MISMATCH</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerTouchInfo(System.UInt32,Vanara.PInvoke.User32.POINTER_TOUCH_INFO@)">
            <summary>Gets the touch-based information for the specified pointer (of type PT_TOUCH) associated with the current message.</summary>
            <param name="pointerId">An identifier of the pointer for which to retrieve information.</param>
            <param name="touchInfo">Address of a POINTER_TOUCH_INFO structure to receive the touch-specific pointer information.</param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para><c>GetPointerTouchInfo</c> retrieves information for a single pointer (of type PT_TOUCH) associated with a pointer message.</para>
            <para>Use GetPointerFrameTouchInfo to retrieve frame information associated with a message for a set of pointers.</para>
            <para>
            The information returned by <c>GetPointerTouchInfo</c> is associated with the most recent pointer message retrieved by the
            calling thread. When the next message is retrieved by the calling thread, the information associated with the previous message
            may no longer be available.
            </para>
            <para>
            If the application does not process pointer input messages as fast as they are generated, some messages may be coalesced into a
            WM_POINTERUPDATE message. Use GetPointerTouchInfoHistory to retrieve the message history from the most recent
            <c>WM_POINTERUPDATE</c> message.
            </para>
            <para>
            If the information associated with the message is no longer available, this function fails with the last error set to <c>ERROR_NO_DATA</c>.
            </para>
            <para>
            If the calling thread does not own the window to which the pointer message has been delivered, this function fails with the last
            error set to <c>ERROR_ACCESS_DENIED</c>. Note that this may be the window to which the input was originally delivered or it may
            be a window to which the message was forwarded.
            </para>
            <para>If the specified pointer is not of type PT_TOUCH, this function fails with the last error set to <c>ERROR_DATATYPE_MISMATCH</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerTouchInfoHistory(System.UInt32,System.UInt32@,Vanara.PInvoke.User32.POINTER_TOUCH_INFO[])">
            <summary>
            Gets the touch-based information associated with the individual inputs, if any, that were coalesced into the current message for
            the specified pointer (of type PT_TOUCH). The most recent input is included in the returned history and is the same as the most
            recent input returned by the GetPointerTouchInfo function.
            </summary>
            <param name="pointerId">An identifier of the pointer for which to retrieve information.</param>
            <param name="entriesCount">
            A pointer to a variable that specifies the count of structures in the buffer to which touchInfo points. If
            <c>GetPointerTouchInfoHistory</c> succeeds, entriesCount is updated with the total count of structures available. The total
            count of structures available is the same as the historyCount field in the POINTER_INFO structure returned by a call to
            GetPointerInfo or GetPointerTouchInfo.
            </param>
            <param name="touchInfo">
            Address of an array of POINTER_TOUCH_INFO structures to receive the pointer information. This parameter can be NULL if
            *entriesCount is zero.
            </param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the application does not process pointer input messages as fast as they are generated, some moves may be coalesced. When an
            application receives a coalescable pointer (of type PT_TOUCH) message, it can use the <c>GetPointerTouchInfoHistory</c> function
            to retrieve information for all the individual inputs, if any, that were coalesced into the message. Note that the information
            retrieved is associated with the pointer message most recently retrieved by the calling thread. Once the calling thread
            retrieves its next message, the information associated with the previous message may no longer be available.
            </para>
            <para>
            The information retrieved appears in reverse chronological order, with the most recent entry in the first row of the returned
            array. The most recent entry is the same as that returned by the GetPointerTouchInfo function.
            </para>
            <para>
            If the count of rows in the buffer provided is insufficient to hold all available history entries, this function succeeds with
            the buffer containing the most recent entries and *entriesCount containing the total count of entries available.
            </para>
            <para>
            If the pointer frame contains no additional pointers besides the specified pointer, this function succeeds and returns only the
            information for the specified pointer.
            </para>
            <para>
            If the information associated with the pointer frame is no longer available, this function fails with the last error set to <c>ERROR_NO_DATA</c>.
            </para>
            <para>
            If the calling thread does not own the window (where the input was originally delivered or where the message was forwarded) to
            which the pointer message has been delivered, this function fails with the last error set to <c>ERROR_ACCESS_DENIED</c>.
            </para>
            <para>If the specified pointer is not of type PT_TOUCH, this function fails with the last error set to <c>ERROR_DATATYPE_MISMATCH</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetPointerType(System.UInt32,Vanara.PInvoke.User32.POINTER_INPUT_TYPE@)">
            <summary>Retrieves the pointer type for a specified pointer.</summary>
            <param name="pointerId">An identifier of the pointer for which to retrieve pointer type.</param>
            <param name="pointerType">An address of a POINTER_INPUT_TYPE type to receive a pointer input type.</param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            An application can use the <c>GetPointerType</c> function to determine the pointer type if it wishes to react differently to
            pointers of different types.
            </para>
            <para><c>Note</c> This function will never return with the generic PT_POINTER type.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetRawPointerDeviceData(System.UInt32,System.UInt32,System.UInt32,Vanara.PInvoke.User32.POINTER_DEVICE_PROPERTY[],System.IntPtr)">
            <summary>Gets the raw input data from the pointer device.</summary>
            <param name="pointerId">An identifier of the pointer for which to retrieve information.</param>
            <param name="historyCount">The pointer history.</param>
            <param name="propertiesCount">Number of properties to retrieve.</param>
            <param name="pProperties">Array of POINTER_DEVICE_PROPERTY structures that contain raw data reported by the device.</param>
            <param name="pValues">The values for pProperties.</param>
            <returns>
            TRUE if the function succeeds; otherwise, FALSE. If the function fails, call the GetLastError function for more information.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetUnpredictedMessagePos">
            <summary>Gets pointer data before it has gone through touch prediction processing.</summary>
            <returns>The screen location of the pointer input.</returns>
            <remarks>By default, touch prediction is activated.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.InjectSyntheticPointerInput(Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE,Vanara.PInvoke.User32.POINTER_TYPE_INFO[],System.UInt32)">
            <summary>Simulates pointer input (pen or touch).</summary>
            <param name="device">A handle to the pointer injection device created by CreateSyntheticPointerDevice.</param>
            <param name="pointerInfo">
            <para>Array of injected pointers.</para>
            <para>The type must match the pointerType parameter of the CreateSyntheticPointerDevice call that created the injection device.</para>
            <para>The ptPixelLocation for each POINTER_TYPE_INFO is specified relative to top left of the virtual screen:</para>
            </param>
            <param name="count">
            <para>The number of contacts.</para>
            <para>For PT_TOUCH this value must be greater than 0 and less than or equal to MAX_TOUCH_COUNT.</para>
            <para>For PT_PEN this value must be 1.</para>
            </param>
            <returns>
            <para>If this function succeeds, it returns TRUE.</para>
            <para>Otherwise, it returns FALSE. To retrieve extended error information, call the GetLastError function.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsMouseInPointerEnabled">
            <summary>
            Indicates whether EnableMouseInPointer is set for the mouse to act as a pointer input device and send WM_POINTER messages.
            </summary>
            <returns>
            <para>If EnableMouseInPointer is set, the return value is nonzero.</para>
            <para>If EnableMouseInPointer is not set, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            EnableMouseInPointer can be called only once in the context of a process lifetime. Prior to the first call, Windows Store apps
            run with mouse-in-pointer enabled, as do any desktop applications that consume mshtml.dll. All other desktop applications run
            with mouse-in-pointer disabled.
            </para>
            <para>On the first call to EnableMouseInPointer in the process lifetime, the state is changed as specified and the call succeeds.</para>
            <para>
            On subsequent calls to EnableMouseInPointer, the state will not change. If the current state is not equal to the specified
            state, the call fails.
            </para>
            <para>Call <c>IsMouseInPointerEnabled</c> to verify the mouse-in-pointer state.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterPointerDeviceNotifications(Vanara.PInvoke.HWND,System.Boolean)">
            <summary>
            Registers a window to process the WM_POINTERDEVICECHANGE, WM_POINTERDEVICEINRANGE, and WM_POINTERDEVICEOUTOFRANGE pointer device notifications.
            </summary>
            <param name="window">
            The window that receives WM_POINTERDEVICECHANGE, WM_POINTERDEVICEINRANGE, and WM_POINTERDEVICEOUTOFRANGE notifications.
            </param>
            <param name="notifyRange">
            If set to TRUE, process the WM_POINTERDEVICEINRANGE and WM_POINTERDEVICEOUTOFRANGE messages. If set to FALSE, these messages
            aren't processed.
            </param>
            <returns>
            <para>If this function succeeds, it returns TRUE.</para>
            <para>Otherwise, it returns FALSE. To retrieve extended error information, call the GetLastError function.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterPointerInputTarget(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.POINTER_INPUT_TYPE)">
            <summary>Allows the caller to register a target window to which all pointer input of the specified type is redirected.</summary>
            <param name="hwnd">
            <para>The window to register as a global redirection target.</para>
            <para>
            Redirection can cause the foreground window to lose activation (focus). To avoid this, ensure the window is a message-only
            window or has the WS_EX_NOACTIVATE style set.
            </para>
            </param>
            <param name="pointerType">
            Type of pointer input to be redirected to the specified window. This is any valid and supported value from the
            POINTER_INPUT_TYPE enumeration. Note that the generic <c>PT_POINTER</c> type and the <c>PT_MOUSE</c> type are not valid in this parameter.
            </param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            An application with the UI Access privilege can use this function to register its own window to receive all input of the
            specified pointer input type. Each desktop allows only one such global redirection target window for each pointer input type at
            any given time. The first window to successfully register remains in effect until the window is unregistered or destroyed, at
            which point the role is available to the next qualified caller.
            </para>
            <para>
            While the registration is in effect, all input of the specified pointer type, whether from an input device or injected by an
            application, is redirected to the registered window. However, when the process that owns the registered window injects input of
            the specified pointer type, such injected is not redirected but is instead processed normally.
            </para>
            <para>
            An application that wishes to register the same window as a global redirection target for multiple pointer input types must call
            the <c>RegisterPointerInputTarget</c> function multiple times, once for each pointer input type of interest.
            </para>
            <para>If the calling thread does not have the UI Access privilege, this function fails with the last error set to <c>ERROR_ACCESS_DENIED</c>.</para>
            <para>If the specified pointer input type is not valid, this function fails with the last error set to <c>ERROR_INVALID_PARAMETER</c>.</para>
            <para>If the calling thread does not own the specified window, this function fails with the last error set to <c>ERROR_ACCESS_DENIED</c>.</para>
            <para>
            If the specified window’s desktop already has a registered global redirection target for the specified pointer input type, this
            function fails with the last error set to <c>ERROR_ACCESS_DENIED</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterPointerInputTargetEx(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.POINTER_INPUT_TYPE,System.Boolean)">
            <summary>
            <para>[ <c>RegisterPointerInputTargetEx</c> is not supported and may be altered or unavailable in the future. Instead, use RegisterPointerInputTarget.]</para>
            <para><c>RegisterPointerInputTargetEx</c> may be altered or unavailable. Instead, use RegisterPointerInputTarget.</para>
            </summary>
            <param name="hwnd">Not supported.</param>
            <param name="pointerType">Not supported.</param>
            <param name="fObserve">Not supported.</param>
            <returns>Not supported.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SkipPointerFrameMessages(System.UInt32)">
            <summary>
            Determines which pointer input frame generated the most recently retrieved message for the specified pointer and discards any
            queued (unretrieved) pointer input messages generated from the same pointer input frame. If an application has retrieved
            information for an entire frame using the GetPointerFrameInfo function, the GetPointerFrameInfoHistory function or one of their
            type-specific variants, it can use this function to avoid retrieving and discarding remaining messages from that frame one by one.
            </summary>
            <param name="pointerId">
            Identifier of the pointer. Pending messages will be skipped for the frame that includes the most recently retrieved input for
            this pointer.
            </param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Parallel-mode devices may report pointer input in frames, that is, they may report the state and position of all pointers from
            that device in a single input report to the system. Ideally, applications should view the entire frame as a single input unless
            the application-specific requirements dictate otherwise.
            </para>
            <para>
            The <c>SkipPointerFrameMessages</c> function can be used in conjunction with the GetPointerFrameInfo function (or one of its
            type-specific variants) to consume entire frames as a single input.
            </para>
            <para>
            When an application sees a pointer message, it can use the GetPointerFrameInfo function to retrieve the entire pointer input
            frame to which the pointer message belongs, hence obtaining an updated view of all of the pointers currently owned by the
            window. Note that the returned frame contains only pointers that are currently owned by the same window as the specified pointer.
            </para>
            <para>
            Having retrieved the entire frame of information, the application can then call the <c>SkipPointerFrameMessages</c> function to
            skip remaining pointer messages associated with this frame that are pending retrieval. This saves the application the overhead
            of retrieving and processing the remaining messages one by one.
            </para>
            <para>
            <c>Warning</c> The <c>SkipPointerFrameMessages</c> function should be used only when the caller can be sure that no other entity
            on the caller’s thread (such as Direct Manipulation) is expecting to retrieve pending pointer messages. For this reason,
            <c>SkipPointerFrameMessages</c> should not be used in conjunction with Direct Manipulation when processing multiple,
            simultaneous interactions.
            </para>
            <para>
            Note that the information retrieved is associated with the pointer frame most recently retrieved by the calling thread. Once the
            calling thread retrieves its next message, the information associated with the previous pointer frame may no longer be available.
            </para>
            <para>If the pointer frame contains no additional pointers besides the specified pointer, this function succeeds with no action.</para>
            <para>
            If the calling thread does not own the window to which the pointer message has been delivered, this function fails with the last
            error set to <c>ERROR_ACCESS_DENIED</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.UnregisterPointerInputTarget(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.POINTER_INPUT_TYPE)">
            <summary>Allows the caller to unregister a target window to which all pointer input of the specified type is redirected.</summary>
            <param name="hwnd">Window to be un-registered as a global redirection target on its desktop.</param>
            <param name="pointerType">
            Type of pointer input to no longer be redirected to the specified window. This is any valid and supported value from the
            POINTER_INPUT_TYPE enumeration. Note that the generic <c>PT_POINTER</c> type and the <c>PT_MOUSE</c> type are not valid in this parameter.
            </param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            An application that has successfully called the RegisterPointerInputTarget function can call this function to un-register the
            window from the role of global redirected target for the specified pointer type.
            </para>
            <para>
            An application that has registered the same window as a global redirection target for multiple pointer input types can call the
            <c>UnregisterPointerInputTarget</c> to un-register the window for one of those types while leaving the window registered for the
            remaining types.
            </para>
            <para>If the calling thread does not have the UI Access privilege, this function fails with the last error set to <c>ERROR_ACCESS_DENIED</c>.</para>
            <para>If the specified pointer input type is not valid, this function fails with the last error set to <c>ERROR_INVALID_PARAMETER</c>.</para>
            <para>If the calling thread does not own the specified window, this function fails with the last error set to <c>ERROR_ACCESS_DENIED</c>.</para>
            <para>
            If the specified window is not the registered global redirection target for the specified pointer input type on its desktop,
            this function takes no action and returns success.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE">
            <summary>Provides a handle to a synthetic pointer device.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE.op_Explicit(Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE.op_Implicit(System.IntPtr)~Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE.op_Inequality(Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE,Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE.op_Equality(Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE,Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.INPUT_TRANSFORM">
            <summary>
            Defines the matrix that represents a transform on a message consumer. This matrix can be used to transform pointer input data
            from client coordinates to screen coordinates, while the inverse can be used to transform pointer input data from screen
            coordinates to client coordinates.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_TRANSFORM._11">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_TRANSFORM._12">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_TRANSFORM._13">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_TRANSFORM._14">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_TRANSFORM._21">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_TRANSFORM._22">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_TRANSFORM._23">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_TRANSFORM._24">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_TRANSFORM._31">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_TRANSFORM._32">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_TRANSFORM._33">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_TRANSFORM._34">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_TRANSFORM._41">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_TRANSFORM._42">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_TRANSFORM._43">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.INPUT_TRANSFORM._44">
            <summary>Undocumented.</summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.INPUT_TRANSFORM.m">
            <summary>Undocumented.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.POINTER_DEVICE_CURSOR_INFO">
            <summary>Contains cursor ID mappings for pointer devices.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_CURSOR_INFO.cursorId">
            <summary>The assigned cursor ID.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_CURSOR_INFO.cursor">
            <summary>The POINTER_DEVICE_CURSOR_TYPE that the ID is mapped to.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.POINTER_DEVICE_INFO">
            <summary>
            Contains information about a pointer device. An array of these structures is returned from the GetPointerDevices function. A
            single structure is returned from a call to the GetPointerDevice function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_INFO.displayOrientation">
            <summary>
            <para>One of the values from DISPLAYCONFIG_ROTATION, which identifies the orientation of the input digitizer.</para>
            <para><c>Note</c> This value is 0 when the source of input is Touch Injection.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_INFO.device">
            <summary>The handle to the pointer device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_INFO.pointerDeviceType">
            <summary>The device type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_INFO.monitor">
            <summary>
            The HMONITOR for the display that the device is mapped to. This is not necessarily the monitor that the pointer device is
            physically connected to.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_INFO.startingCursorId">
            <summary>The lowest ID that's assigned to the device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_INFO.maxActiveContacts">
            <summary>The number of supported simultaneous contacts.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_INFO.productString">
            <summary>The string that identifies the product.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.POINTER_DEVICE_PROPERTY">
            <summary>Contains pointer-based device properties (Human Interface Device (HID) global items that correspond to HID usages).</summary>
            <remarks>
            Developers can use this function to determine the properties that a device supports beyond the standard ones that are delivered
            through Pointer Input Messages and Notifications. The properties map directly to HID usages.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_PROPERTY.logicalMin">
            <summary>The minimum value that the device can report for this property.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_PROPERTY.logicalMax">
            <summary>The maximum value that the device can report for this property.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_PROPERTY.physicalMin">
            <summary>The physical minimum in Himetric.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_PROPERTY.physicalMax">
            <summary>The physical maximum in Himetric.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_PROPERTY.unit">
            <summary>The unit.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_PROPERTY.unitExponent">
            <summary>The exponent.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_PROPERTY.usagePageId">
            <summary>The usage page for the property, as documented in the HID specification.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_DEVICE_PROPERTY.usageId">
            <summary>The usage of the property, as documented in the HID specification.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.POINTER_INFO">
            <summary>
            Contains basic pointer information common to all pointer types. Applications can retrieve this information using the
            GetPointerInfo, GetPointerFrameInfo, GetPointerInfoHistory and GetPointerFrameInfoHistory functions.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INFO.pointerType">
            <summary>
            <para>Type: <c>POINTER_INPUT_TYPE</c></para>
            <para>A value from the POINTER_INPUT_TYPE enumeration that specifies the pointer type.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INFO.pointerId">
            <summary>
            <para>Type: <c>UINT32</c></para>
            <para>
            An identifier that uniquely identifies a pointer during its lifetime. A pointer comes into existence when it is first
            detected and ends its existence when it goes out of detection range. Note that if a physical entity (finger or pen) goes out
            of detection range and then returns to be detected again, it is treated as a new pointer and may be assigned a new pointer identifier.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INFO.frameId">
            <summary>
            <para>Type: <c>UINT32</c></para>
            <para>
            An identifier common to multiple pointers for which the source device reported an update in a single input frame. For
            example, a parallel-mode multi-touch digitizer may report the positions of multiple touch contacts in a single update to the system.
            </para>
            <para>
            Note that frame identifier is assigned as input is reported to the system for all pointers across all devices. Therefore,
            this field may not contain strictly sequential values in a single series of messages that a window receives. However, this
            field will contain the same numerical value for all input updates that were reported in the same input frame by a single device.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INFO.pointerFlags">
            <summary>
            <para>Type: <c>POINTER_FLAGS</c></para>
            <para>May be any reasonable combination of flags from the Pointer Flags constants.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INFO.sourceDevice">
            <summary>
            <para>Type: <c>HANDLE</c></para>
            <para>Handle to the source device that can be used in calls to the raw input device API and the digitizer device API.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INFO.hwndTarget">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>
            Window to which this message was targeted. If the pointer is captured, either implicitly by virtue of having made contact
            over this window or explicitly using the pointer capture API, this is the capture window. If the pointer is uncaptured, this
            is the window over which the pointer was when this message was generated.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INFO.ptPixelLocation">
            <summary>
            <para>Type: <c>POINT</c></para>
            <para>The predicted screen coordinates of the pointer, in pixels.</para>
            <para>
            The predicted value is based on the pointer position reported by the digitizer and the motion of the pointer. This
            correction can compensate for visual lag due to inherent delays in sensing and processing the pointer location on the
            digitizer. This is applicable to pointers of type PT_TOUCH. For other pointer types, the predicted value will be the same as
            the non-predicted value (see <c>ptPixelLocationRaw</c>).
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INFO.ptHimetricLocation">
            <summary>
            <para>Type: <c>POINT</c></para>
            <para>The predicted screen coordinates of the pointer, in HIMETRIC units.</para>
            <para>
            The predicted value is based on the pointer position reported by the digitizer and the motion of the pointer. This
            correction can compensate for visual lag due to inherent delays in sensing and processing the pointer location on the
            digitizer. This is applicable to pointers of type PT_TOUCH. For other pointer types, the predicted value will be the same as
            the non-predicted value (see <c>ptHimetricLocationRaw</c>).
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INFO.ptPixelLocationRaw">
            <summary>
            <para>Type: <c>POINT</c></para>
            <para>The screen coordinates of the pointer, in pixels. For adjusted screen coordinates, see <c>ptPixelLocation</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INFO.ptHimetricLocationRaw">
            <summary>
            <para>Type: <c>POINT</c></para>
            <para>The screen coordinates of the pointer, in HIMETRIC units. For adjusted screen coordinates, see <c>ptHimetricLocation</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INFO.dwTime">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>0 or the time stamp of the message, based on the system tick count when the message was received.</para>
            <para>
            The application can specify the input time stamp in either <c>dwTime</c> or <c>PerformanceCount</c>. The value cannot be
            more recent than the current tick count or <c>QueryPerformanceCount (QPC)</c> value of the injection thread. Once a frame is
            injected with a time stamp, all subsequent frames must include a timestamp until all contacts in the frame go to an UP
            state. The custom timestamp value must also be provided for the first element in the contacts array. The time stamp values
            after the first element are ignored. The custom timestamp value must increment in every injection frame.
            </para>
            <para>
            When <c>PerformanceCount</c> is specified, the time stamp will be converted to the current time in .1 millisecond resolution
            upon actual injection. If a custom <c>PerformanceCount</c> resulted in the same .1 millisecond window from the previous
            injection, <c>ERROR_NOT_READY</c> is returned and injection will not occur. While injection will not be invalidated
            immediately by the error, the next successful injection must have a <c>PerformanceCount</c> value that is at least 0.1
            millisecond from the previously successful injection. This is also true if <c>dwTime</c> is used.
            </para>
            <para>If both <c>dwTime</c> and <c>PerformanceCount</c> are specified in InjectTouchInput, ERROR_INVALID_PARAMETER is returned.</para>
            <para>InjectTouchInput cannot switch between <c>dwTime</c> and <c>PerformanceCount</c> once injection has started.</para>
            <para>
            If neither <c>dwTime</c> and <c>PerformanceCount</c> are specified, InjectTouchInput allocates the timestamp based on the
            timing of the call. If <c>InjectTouchInput</c> calls are repeatedly less than 0.1 millisecond apart, ERROR_NOT_READY might
            be returned. The error will not invalidate the input immediately, but the injection application needs to retry the same
            frame again for injection to succeed.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INFO.historyCount">
            <summary>
            <para>Type: <c>UINT32</c></para>
            <para>
            Count of inputs that were coalesced into this message. This count matches the total count of entries that can be returned by
            a call to GetPointerInfoHistory. If no coalescing occurred, this count is 1 for the single input represented by the message.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INFO.InputData">
            <summary>The input data</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INFO.dwKeyStates">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            Indicates which keyboard modifier keys were pressed at the time the input was generated. May be zero or a combination of the
            following values.
            </para>
            <para>POINTER_MOD_SHIFT – A SHIFT key was pressed.</para>
            <para>POINTER_MOD_CTRL – A CTRL key was pressed.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INFO.PerformanceCount">
            <summary>
            <para>Type: <c>UINT64</c></para>
            <para>
            The value of the high-resolution performance counter when the pointer message was received (high-precision, 64 bit
            alternative to <c>dwTime</c>). The value can be calibrated when the touch digitizer hardware supports the scan timestamp
            information in its input report.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_INFO.ButtonChangeType">
            <summary>
            <para>Type: <c>POINTER_BUTTON_CHANGE_TYPE</c></para>
            <para>
            A value from the POINTER_BUTTON_CHANGE_TYPE enumeration that specifies the change in button state between this input and the
            previous input.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.POINTER_PEN_INFO">
            <summary>Defines basic pen information common to all pointer types.</summary>
            <remarks>
            Applications can retrieve this information using the GetPointerPenInfo, GetPointerFramePenInfo, GetPointerPenInfoHistory and
            GetPointerFramePenInfoHistory API functions.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_PEN_INFO.pointerInfo">
            <summary>
            <para>Type: <c>POINTER_INFO</c></para>
            <para>An embedded POINTER_INFO structure.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_PEN_INFO.penFlags">
            <summary>
            <para>Type: <c>PEN_FLAGS</c></para>
            <para>The pen flag. This member can be zero or any reasonable combination of the values from the Pen Flags constants.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_PEN_INFO.penMask">
            <summary>
            <para>Type: <c>PEN_MASK</c></para>
            <para>The pen mask. This member can be zero or any reasonable combination of the values from the Pen Mask constants.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_PEN_INFO.pressure">
            <summary>
            <para>Type: <c>UINT32</c></para>
            <para>A pen pressure normalized to a range between 0 and 1024. The default is 0 if the device does not report pressure.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_PEN_INFO.rotation">
            <summary>
            <para>Type: <c>UINT32</c></para>
            <para>The clockwise rotation, or twist, of the pointer normalized in a range of 0 to 359. The default is 0.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_PEN_INFO.tiltX">
            <summary>
            <para>Type: <c>INT32</c></para>
            <para>
            The angle of tilt of the pointer along the x-axis in a range of -90 to +90, with a positive value indicating a tilt to the
            right. The default is 0.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_PEN_INFO.tiltY">
            <summary>
            <para>Type: <c>INT32</c></para>
            <para>
            The angle of tilt of the pointer along the y-axis in a range of -90 to +90, with a positive value indicating a tilt toward
            the user. The default is 0.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.POINTER_TOUCH_INFO">
            <summary>Defines basic touch information common to all pointer types.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_TOUCH_INFO.pointerInfo">
            <summary>
            <para>Type: <c>POINTER_INFO</c></para>
            <para>An embedded POINTER_INFO header structure.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_TOUCH_INFO.touchFlags">
            <summary>
            <para>Type: <c>Touch Flags</c></para>
            <para>Currently none.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_TOUCH_INFO.touchMask">
            <summary>
            <para>Type: <c>Touch Mask</c></para>
            <para>
            Indicates which of the optional fields contain valid values. The member can be zero or any combination of the values from
            the Touch Mask constants.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_TOUCH_INFO.rcContact">
            <summary>
            <para>Type: <c>RECT</c></para>
            <para>
            The predicted screen coordinates of the contact area, in pixels. By default, if the device does not report a contact area,
            this field defaults to a 0-by-0 rectangle centered around the pointer location.
            </para>
            <para>
            The predicted value is based on the pointer position reported by the digitizer and the motion of the pointer. This
            correction can compensate for visual lag due to inherent delays in sensing and processing the pointer location on the
            digitizer. This is applicable to pointers of type PT_TOUCH.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_TOUCH_INFO.rcContactRaw">
            <summary>
            <para>Type: <c>RECT</c></para>
            <para>The raw screen coordinates of the contact area, in pixels. For adjusted screen coordinates, see <c>rcContact</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_TOUCH_INFO.orientation">
            <summary>
            <para>Type: <c>UINT32</c></para>
            <para>
            A pointer orientation, with a value between 0 and 359, where 0 indicates a touch pointer aligned with the x-axis and
            pointing from left to right; increasing values indicate degrees of rotation in the clockwise direction.
            </para>
            <para>This field defaults to 0 if the device does not report orientation.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_TOUCH_INFO.pressure">
            <summary>
            <para>Type: <c>UINT32</c></para>
            <para>A pen pressure normalized to a range between 0 and 1024. The default is 0 if the device does not report pressure.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.POINTER_TYPE_INFO">
            <summary>Contains information about the pointer input type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_TYPE_INFO.type">
            <summary>The pointer input device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_TYPE_INFO.touchInfo">
            <summary>Basic touch information common to all pointer types.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POINTER_TYPE_INFO.penInfo">
            <summary>Basic pen information common to all pointer types.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SafeHSYNTHETICPOINTERDEVICE">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <see cref="T:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE"/> that is disposed using <see cref="M:Vanara.PInvoke.User32.DestroySyntheticPointerDevice(Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHSYNTHETICPOINTERDEVICE.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHSYNTHETICPOINTERDEVICE"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHSYNTHETICPOINTERDEVICE.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHSYNTHETICPOINTERDEVICE"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHSYNTHETICPOINTERDEVICE.op_Implicit(Vanara.PInvoke.User32.SafeHSYNTHETICPOINTERDEVICE)~Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.User32.SafeHSYNTHETICPOINTERDEVICE"/> to <see cref="T:Vanara.PInvoke.User32.HSYNTHETICPOINTERDEVICE"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHSYNTHETICPOINTERDEVICE.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.PowerBroadcastType">
            <summary>The following are the power management events:</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PowerBroadcastType.PBT_APMQUERYSUSPEND">
            <summary>
            <para>
            [PBT_APMQUERYSUSPEND is available for use in the operating systems specified in the Requirements section. Support for this
            event was removed in Windows Vista. Use <c>SetThreadExecutionState</c> instead.]
            </para>
            <para>
            Requests permission to suspend the computer. An application that grants permission should carry out preparations for the
            suspension before returning.
            </para>
            <para>
            A window receives this event through the <c>WM_POWERBROADCAST</c> message. The wParam and lParam parameters are set as
            described following.
            </para>
            </summary>
            <remarks>
            <para>
            lParam: The action flags. If bit 0 is 1, the application can prompt the user for directions on how to prepare for the
                    suspension; otherwise, the application must prepare without user interaction. All other bit values are reserved.
            </para>
            <para>Return: <c>TRUE</c> to grant the request to suspend. To deny the request, return <c>BROADCAST_QUERY_DENY</c>.</para>
            <para>
            An application should process this event as quickly as possible. The application can prompt the user for directions on how
            to prepare for suspension only if bit 0 in the Flags parameter is set. However, if this message is issued because the user
            is closing the laptop lid, it will not be possible to prompt the user. Applications should respect that the user expects a
            certain behavior when they close the laptop lid or press the power button and allow the transition to succeed.
            </para>
            <para>
            The system allows approximately 20 seconds for an application to remove the <c>WM_POWERBROADCAST</c> message that is sending
            the PBT_APMQUERYSUSPEND event from the application's message queue. If an application does not remove the message from its
            queue in less than 20 seconds, the system will assume that the application is in a non-responsive state, and that the
            application agrees to the sleep request. Applications that do not process their message queues may have their operations
            interrupted. After it removes the message from the message queue, an application can take as much time as needed to perform
            any required operations before entering the sleep state. Any operations that could take longer then 20 seconds should be
            performed at this time, since the system allows only 20 seconds for operations to complete during PBT_APMSUSPEND processing.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.PowerBroadcastType.PBT_APMQUERYSTANDBY">
            <summary>
            The PBT_APMQUERYSUSPEND message is sent to request permission to suspend the computer. An application that grants permission
            should carry out preparations for the suspension before returning. Return TRUE to grant the request to suspend. To deny the
            request, return BROADCAST_QUERY_DENY.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PowerBroadcastType.PBT_APMQUERYSUSPENDFAILED">
            <summary>
            <para>
            [PBT_APMQUERYSUSPENDFAILED is available for use in the operating systems specified in the Requirements section. Support for
            this event was removed in Windows Vista. Use <c>SetThreadExecutionState</c> instead.]
            </para>
            <para>
            Notifies applications that permission to suspend the computer was denied. This event is broadcast if any application or
            driver returned <c>BROADCAST_QUERY_DENY</c> to a previous PBT_APMQUERYSUSPEND event.
            </para>
            <para>
            A window receives this event through the <c>WM_POWERBROADCAST</c> message. The wParam and lParam parameters are set as
            described following.
            </para>
            </summary>
            <remarks>
            <para>lParam: Reserved; must be zero.</para>
            <para>No return value.</para>
            <para>Applications typically respond to this event by resuming normal operation.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.PowerBroadcastType.PBT_APMQUERYSTANDBYFAILED">
            <summary>
            The PBT_APMQUERYSUSPENDFAILED message is sent to notify the application that suspension was denied by some other
            application. However, this message is only sent when we receive PBT_APMQUERY* before.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PowerBroadcastType.PBT_APMSUSPEND">
            <summary>
            <para>
            Notifies applications that the computer is about to enter a suspended state. This event is typically broadcast when all
            applications and installable drivers have returned <c>TRUE</c> to a previous PBT_APMQUERYSUSPEND event.
            </para>
            <para>
            A window receives this event through the <c>WM_POWERBROADCAST</c> message. The wParam and lParam parameters are set as
            described following.
            </para>
            </summary>
            <remarks>
            <para>lParam: Reserved; must be zero.</para>
            <para>No return value.</para>
            <para>An application should process this event by completing all tasks necessary to save data.</para>
            <para>
            The system allows approximately two seconds for an application to handle this notification. If an application is still
            performing operations after its time allotment has expired, the system may interrupt the application.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.PowerBroadcastType.PBT_APMSTANDBY">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PowerBroadcastType.PBT_APMRESUMECRITICAL">
            <summary>
            <para>
            [PBT_APMRESUMECRITICAL is available for use in the operating systems specified in the Requirements section. Support for this
            event was removed in Windows Vista. Use PBT_APMRESUMEAUTOMATIC instead.]
            </para>
            <para>
            Notifies applications that the system has resumed operation. This event can indicate that some or all applications did not
            receive a PBT_APMSUSPEND event. For example, this event can be broadcast after a critical suspension caused by a failing battery.
            </para>
            <para>
            A window receives this event through the <c>WM_POWERBROADCAST</c> message. The wParam and lParam parameters are set as
            described following.
            </para>
            </summary>
            <remarks>
            <para>lParam: Reserved; must be zero.</para>
            <para>No return value.</para>
            <para>
            Because a critical suspension occurs without prior notification, resources and data previously available may not be present
            when the application receives this event. The application should attempt to restore its state to the best of its ability.
            While in a critical suspension, the system maintains the state of the DRAM and local hard disks, but may not maintain net
            connections. An application may need to take action with respect to files that were open on the network before critical suspension.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.PowerBroadcastType.PBT_APMRESUMESUSPEND">
            <summary>
            <para>Notifies applications that the system has resumed operation after being suspended.</para>
            <para>
            A window receives this event through the <c>WM_POWERBROADCAST</c> message. The wParam and lParam parameters are set as
            described following.
            </para>
            </summary>
            <remarks>
            <para>lParam: Reserved; must be zero.</para>
            <para>No return value.</para>
            <para>
            An application can receive this event only if it received the PBT_APMSUSPEND event before the computer was suspended.
            Otherwise, the application will receive a PBT_APMRESUMECRITICAL event.
            </para>
            <para>
            If the system wakes due to user activity (such as pressing the power button) or if the system detects user interaction at
            the physical console (such as mouse or keyboard input) after waking unattended, the system first broadcasts the
            PBT_APMRESUMEAUTOMATIC event, then it broadcasts the PBT_APMRESUMESUSPEND event. In addition, the system turns on the
            display. Your application should reopen files that it closed when the system entered sleep and prepare for user input.
            </para>
            <para>
            If the system wakes due to an external wake signal (remote wake), the system broadcasts only the PBT_APMRESUMEAUTOMATIC
            event. The PBT_APMRESUMESUSPEND event is not sent.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.PowerBroadcastType.PBT_APMRESUMESTANDBY">
            <summary>
            The PBT_APMRESUMESTANDBY event is broadcast as a notification that the system has resumed operation after being standby.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PowerBroadcastType.PBT_APMBATTERYLOW">
            <summary>
            <para>
            [PBT_APMBATTERYLOW is available for use in the operating systems specified in the Requirements section. Support for this
            event was removed in Windows Vista. Use PBT_APMPOWERSTATUSCHANGE instead.]
            </para>
            <para>Notifies applications that the battery power is low.</para>
            <para>
            A window receives this event through the <c>WM_POWERBROADCAST</c> message. The wParam and lParam parameters are set as
            described following.
            </para>
            </summary>
            <remarks>
            <para>lParam: Reserved, must be zero.</para>
            <para>No return value.</para>
            <para>
            This event is broadcast when a system's APM BIOS signals an APM battery low notification. Because some APM BIOS
            implementations do not provide notifications when batteries are low, this event may never be broadcast on some computers.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.PowerBroadcastType.PBT_APMPOWERSTATUSCHANGE">
            <summary>
            <para>
            Notifies applications of a change in the power status of the computer, such as a switch from battery power to A/C. The
            system also broadcasts this event when remaining battery power slips below the threshold specified by the user or if the
            battery power changes by a specified percentage.
            </para>
            <para>
            A window receives this event through the <c>WM_POWERBROADCAST</c> message. The wParam and lParam parameters are set as
            described following.
            </para>
            </summary>
            <remarks>
            <para>lParam: Reserved; must be zero.</para>
            <para>No return value.</para>
            <para>
            An application should process this event by calling the <c>GetSystemPowerStatus</c> function to retrieve the current power
            status of the computer. In particular, the application should check the <c>ACLineStatus</c>, <c>BatteryFlag</c>,
            <c>BatteryLifeTime</c>, and <c>BatteryLifePercent</c> members of the <c>SYSTEM_POWER_STATUS</c> structure for any changes.
            This event can occur when battery life drops to less than 5 minutes, or when the percentage of battery life drops below 10
            percent, or if the battery life changes by 3 percent.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.PowerBroadcastType.PBT_APMOEMEVENT">
            <summary>
            <para>
            [PBT_APMOEMEVENT is available for use in the operating systems specified in the Requirements section. Support for this event
            was removed in Windows Vista.]
            </para>
            <para>Notifies applications that the APM BIOS has signaled an APM OEM event.</para>
            <para>
            A window receives this event through the <c>WM_POWERBROADCAST</c> message. The wParam and lParam parameters are set as
            described following.
            </para>
            </summary>
            <remarks>
            <para>
            lParam: The OEM-defined event code that was signaled by the system's APM BIOS. OEM event codes are in the range 0200h - 02FFh.
            </para>
            <para>No return value.</para>
            <para>
            Because not all APM BIOS implementations provide OEM event notifications, this event may never be broadcast on some computers.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.PowerBroadcastType.PBT_APMRESUMEAUTOMATIC">
            <summary>
            <para>
            Notifies applications that the system is resuming from sleep or hibernation. This event is delivered every time the system
            resumes and does not indicate whether a user is present.
            </para>
            <para>
            A window receives this event through the <c>WM_POWERBROADCAST</c> message. The wParam and lParam parameters are set as
            described following.
            </para>
            </summary>
            <remarks>
            <para>lParam: Reserved; must be zero.</para>
            <para>No return value.</para>
            <para>
            If the system detects any user activity after broadcasting PBT_APMRESUMEAUTOMATIC, it will broadcast a PBT_APMRESUMESUSPEND
            event to let applications know they can resume full interaction with the user.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.PowerBroadcastType.PBT_POWERSETTINGCHANGE">
            <summary>
            Power setting change event sent with a <c>WM_POWERBROADCAST</c> window message or in a <c>HandlerEx</c> notification
            callback for services.
            </summary>
            <remarks>
            <para>lParam: Pointer to a <c>POWERBROADCAST_SETTING</c> structure.</para>
            <para>No return value.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterPowerSettingNotification(Vanara.PInvoke.HANDLE,System.Guid@,Vanara.PInvoke.User32.DEVICE_NOTIFY)">
            <summary>Registers the application to receive power setting notifications for the specific power setting event.</summary>
            <param name="hRecipient">
            Handle indicating where the power setting notifications are to be sent. For interactive applications, the Flags parameter should
            be zero, and the hRecipient parameter should be a window handle. For services, the Flags parameter should be one, and the
            hRecipient parameter should be a <c>SERVICE_STATUS_HANDLE</c> as returned from RegisterServiceCtrlHandlerEx.
            </param>
            <param name="PowerSettingGuid">
            The <c>GUID</c> of the power setting for which notifications are to be sent. For more information see Registering for Power Events.
            </param>
            <param name="Flags">
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DEVICE_NOTIFY_WINDOW_HANDLE 0</term>
            <term>Notifications are sent using WM_POWERBROADCAST messages with a wParam parameter of PBT_POWERSETTINGCHANGE.</term>
            </item>
            <item>
            <term>DEVICE_NOTIFY_SERVICE_HANDLE 1</term>
            <term>
            Notifications are sent to the HandlerEx callback function with a dwControl parameter of SERVICE_CONTROL_POWEREVENT and a
            dwEventType of PBT_POWERSETTINGCHANGE.
            </term>
            </item>
            </list>
            </param>
            <returns>
            Returns a notification handle for unregistering for power notifications. If the function fails, the return value is NULL. To get
            extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterSuspendResumeNotification(Vanara.PInvoke.HANDLE,Vanara.PInvoke.User32.DEVICE_NOTIFY)">
            <summary>
            Registers to receive notification when the system is suspended or resumed. Similar to PowerRegisterSuspendResumeNotification,
            but operates in user mode and can take a window handle.
            </summary>
            <param name="hRecipient">
            <para>
            This parameter contains parameters for subscribing to a power notification or a window handle representing the subscribing process.
            </para>
            <para>
            If Flags is <c>DEVICE_NOTIFY_CALLBACK</c>, hRecipient is interpreted as a pointer to a DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS
            structure. In this case, the callback function is DeviceNotifyCallbackRoutine. When the <c>Callback</c> function executes, the
            Type parameter is set indicating the type of event that occurred. Possible values include <c>PBT_APMSUSPEND</c>,
            <c>PBT_APMRESUMESUSPEND</c>, and <c>PBT_APMRESUMEAUTOMATIC</c> - see Power Management Events for more info. The Setting
            parameter is not used with suspend/resume notifications.
            </para>
            <para>If Flags is <c>DEVICE_NOTIFY_WINDOW_HANDLE</c>, hRecipient is a handle to the window to deliver events to.</para>
            </param>
            <param name="Flags">This parameter can be <c>DEVICE_NOTIFY_WINDOW_HANDLE</c> or <c>DEVICE_NOTIFY_CALLBACK</c>.</param>
            <returns>
            <para>A handle to the registration. Use this handle to unregister for notifications.</para>
            <para>If the function fails, the return value is NULL. To get extended error information call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.UnregisterPowerSettingNotification(Vanara.PInvoke.HANDLE)">
            <summary>Unregisters the power setting notification.</summary>
            <param name="Handle">The handle returned from the RegisterPowerSettingNotification function.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.UnregisterSuspendResumeNotification(Vanara.PInvoke.HANDLE)">
            <summary>
            Cancels a registration to receive notification when the system is suspended or resumed. Similar to
            PowerUnregisterSuspendResumeNotification but operates in user mode.
            </summary>
            <param name="Handle">A handle to a registration obtained by calling the RegisterSuspendResumeNotification function.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.User32.POWERBROADCAST_SETTING">
            <summary>
            Sent with a power setting event and contains data about the specific change. For more information, see Registering for Power
            Events and Power Setting GUIDs.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POWERBROADCAST_SETTING.PowerSetting">
            <summary>
            Indicates the power setting for which this notification is being delivered. For more info, see Power Setting GUIDs.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POWERBROADCAST_SETTING.DataLength">
            <summary>The size in bytes of the data in the Data member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.POWERBROADCAST_SETTING.Data">
            <summary>The new value of the power setting. The type and possible values for this member depend on PowerSettng.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SafeHPOWERSETTINGNOTIFY">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <c>HPOWERNOTIFY</c> that is disposed using <see cref="M:Vanara.PInvoke.User32.UnregisterPowerSettingNotification(Vanara.PInvoke.HANDLE)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHPOWERSETTINGNOTIFY.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHPOWERSETTINGNOTIFY"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHPOWERSETTINGNOTIFY.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHPOWERSETTINGNOTIFY"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHPOWERSETTINGNOTIFY.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.SafeHSUSPRESUMENOTIFY">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <c>HPOWERNOTIFY</c> that is disposed using <see cref="M:Vanara.PInvoke.User32.UnregisterSuspendResumeNotification(Vanara.PInvoke.HANDLE)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHSUSPRESUMENOTIFY.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHSUSPRESUMENOTIFY"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHSUSPRESUMENOTIFY.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.SafeHSUSPRESUMENOTIFY"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHSUSPRESUMENOTIFY.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.AttachThreadInput(System.UInt32,System.UInt32,System.Boolean)">
            <summary>Attaches or detaches the input processing mechanism of one thread to that of another thread.</summary>
            <param name="idAttach">
            The identifier of the thread to be attached to another thread. The thread to be attached cannot be a system thread.
            </param>
            <param name="idAttachTo">
            <para>The identifier of the thread to which idAttach will be attached. This thread cannot be a system thread.</para>
            <para>A thread cannot attach to itself. Therefore, idAttachTo cannot equal idAttach.</para>
            </param>
            <param name="fAttach">
            If this parameter is <c>TRUE</c>, the two threads are attached. If the parameter is <c>FALSE</c>, the threads are detached.
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            <para>
            <c>Windows Server 2003 and Windows XP:</c> There is no extended error information; do not call GetLastError. This behavior
            changed as of Windows Vista.
            </para>
            </returns>
            <remarks>
            <para>
            By using the <c>AttachThreadInput</c> function, a thread can share its input states (such as keyboard states and the current
            focus window) with another thread. Keyboard and mouse events received by both threads are processed in the order they were
            received until the threads are detached by calling <c>AttachThreadInput</c> a second time and specifying <c>FALSE</c> for the
            fAttach parameter.
            </para>
            <para>
            The <c>AttachThreadInput</c> function fails if either of the specified threads does not have a message queue. The system creates
            a thread's message queue when the thread makes its first call to one of the USER or GDI functions. The <c>AttachThreadInput</c>
            function also fails if a journal record hook is installed. Journal record hooks attach all input queues together.
            </para>
            <para>
            Note that key state, which can be ascertained by calls to the GetKeyState or GetKeyboardState function, is reset after a call to
            <c>AttachThreadInput</c>. You cannot attach a thread to a thread in another desktop.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsImmersiveProcess(Vanara.PInvoke.HPROCESS)">
            <summary>
            <para>Determines whether the process belongs to a Windows Store app.</para>
            </summary>
            <param name="hProcess">
            <para>Target process handle.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetProcessRestrictionExemption(System.Boolean)">
            <summary>
            <para>
            Exempts the calling process from restrictions preventing desktop processes from interacting with the Windows Store app
            environment. This function is used by development and debugging tools.
            </para>
            <para>
            This function only succeeds if a developer license is present on the system. Once successful the calling process will be able to
            perform the following actions, subject to User Interface Privilege Isolation (UIPI) restrictions:
            </para>
            <list type="bullet">
            <item>
            <term>Attach global hooks (and event hooks) to Windows Store app processes.</term>
            </item>
            <item>
            <term>
            Attach input queues between Windows Store app processes, Windows Store app browsers, system processes, and desktop application processes.
            </term>
            </item>
            <item>
            <term>Change foreground arbitrarily between the Windows Store app and desktop environments.</term>
            </item>
            </list>
            </summary>
            <param name="fEnableExemption">When set to TRUE, indicates a request to disable exemption for the calling process.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            Any process can call this function, including desktop and Windows Store app processes and processes that use IL code.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.WaitForInputIdle(Vanara.PInvoke.HPROCESS,System.UInt32)">
            <summary>
            Waits until the specified process has finished processing its initial input and is waiting for user input with no input pending,
            or until the time-out interval has elapsed.
            </summary>
            <param name="hProcess">
            A handle to the process. If this process is a console application or does not have a message queue, <c>WaitForInputIdle</c>
            returns immediately.
            </param>
            <param name="dwMilliseconds">
            The time-out interval, in milliseconds. If dwMilliseconds is INFINITE, the function does not return until the process is idle.
            </param>
            <returns>
            <para>The following table shows the possible return values for this function.</para>
            <list type="table">
            <listheader>
            <term>Return code/value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The wait was satisfied successfully.</term>
            </item>
            <item>
            <term>WAIT_TIMEOUT</term>
            <term>The wait was terminated because the time-out interval elapsed.</term>
            </item>
            <item>
            <term>WAIT_FAILED</term>
            <term>An error occurred.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WaitForInputIdle</c> function enables a thread to suspend its execution until the specified process has finished its
            initialization and is waiting for user input with no input pending. If the process has multiple threads, the
            <c>WaitForInputIdle</c> function returns as soon as any thread becomes idle.
            </para>
            <para>
            <c>WaitForInputIdle</c> can be used at any time, not just during application startup. However, <c>WaitForInputIdle</c> waits only
            once for a process to become idle; subsequent <c>WaitForInputIdle</c> calls return immediately, whether the process is idle or busy.
            </para>
            <para>
            <c>WaitForInputIdle</c> can be useful for synchronizing a parent process and a newly created child process. When a parent process
            creates a child process, the CreateProcess function returns without waiting for the child process to finish its initialization.
            Before trying to communicate with the child process, the parent process can use the <c>WaitForInputIdle</c> function to determine
            when the child's initialization has been completed. For example, the parent process should use the <c>WaitForInputIdle</c>
            function before trying to find a window associated with the child process.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CopyRect(Vanara.PInvoke.RECT@,Vanara.PInvoke.RECT@)">
            <summary>The <c>CopyRect</c> function copies the coordinates of one rectangle to another.</summary>
            <param name="lprcDst">Pointer to the RECT structure that receives the logical coordinates of the source rectangle.</param>
            <param name="lprcSrc">Pointer to the RECT structure whose coordinates are to be copied in logical units.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure.
            Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which
            the rectangle is used determine the units of measure.
            </para>
            <para>Examples</para>
            <para>For an example, see Using Rectangles.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EqualRect(Vanara.PInvoke.RECT@,Vanara.PInvoke.RECT@)">
            <summary>
            The <c>EqualRect</c> function determines whether the two specified rectangles are equal by comparing the coordinates of their
            upper-left and lower-right corners.
            </summary>
            <param name="lprc1">Pointer to a RECT structure that contains the logical coordinates of the first rectangle.</param>
            <param name="lprc2">Pointer to a RECT structure that contains the logical coordinates of the second rectangle.</param>
            <returns>
            <para>If the two rectangles are identical, the return value is nonzero.</para>
            <para>If the two rectangles are not identical, the return value is zero.</para>
            </returns>
            <remarks>
            <para>The <c>EqualRect</c> function does not treat empty rectangles as equal if their coordinates are different.</para>
            <para>
            Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure.
            Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which
            the rectangle is used determine the units of measure.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.InflateRect(Vanara.PInvoke.RECT@,System.Int32,System.Int32)">
            <summary>
            The <c>InflateRect</c> function increases or decreases the width and height of the specified rectangle. The <c>InflateRect</c>
            function adds dx units to the left and right ends of the rectangle and dy units to the top and bottom. The dx and dy parameters
            are signed values; positive values increase the width and height, and negative values decrease them.
            </summary>
            <param name="lprc">A pointer to the RECT structure that increases or decreases in size.</param>
            <param name="dx">The amount to increase or decrease the rectangle width. This parameter must be negative to decrease the width.</param>
            <param name="dy">The amount to increase or decrease the rectangle height. This parameter must be negative to decrease the height.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure.
            Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which
            the rectangle is used determine the units of measure.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IntersectRect(Vanara.PInvoke.RECT@,Vanara.PInvoke.RECT@,Vanara.PInvoke.RECT@)">
            <summary>
            The <c>IntersectRect</c> function calculates the intersection of two source rectangles and places the coordinates of the
            intersection rectangle into the destination rectangle. If the source rectangles do not intersect, an empty rectangle (in which
            all coordinates are set to zero) is placed into the destination rectangle.
            </summary>
            <param name="lprcDst">
            A pointer to the RECT structure that is to receive the intersection of the rectangles pointed to by the lprcSrc1 and lprcSrc2
            parameters. This parameter cannot be <c>NULL</c>.
            </param>
            <param name="lprcSrc1">A pointer to the RECT structure that contains the first source rectangle.</param>
            <param name="lprcSrc2">A pointer to the RECT structure that contains the second source rectangle.</param>
            <returns>
            <para>If the rectangles intersect, the return value is nonzero.</para>
            <para>If the rectangles do not intersect, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure.
            Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which
            the rectangle is used determine the units of measure.
            </para>
            <para>Examples</para>
            <para>For an example, see Using Rectangles.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.InvertRect(Vanara.PInvoke.HDC,Vanara.PInvoke.RECT@)">
            <summary>
            The <c>InvertRect</c> function inverts a rectangle in a window by performing a logical NOT operation on the color values for each
            pixel in the rectangle's interior.
            </summary>
            <param name="hDC">A handle to the device context.</param>
            <param name="lprc">A pointer to a RECT structure that contains the logical coordinates of the rectangle to be inverted.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            On monochrome screens, <c>InvertRect</c> makes white pixels black and black pixels white. On color screens, the inversion depends
            on how colors are generated for the screen. Calling <c>InvertRect</c> twice for the same rectangle restores the display to its
            previous colors.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsRectEmpty(Vanara.PInvoke.RECT@)">
            <summary>
            The <c>IsRectEmpty</c> function determines whether the specified rectangle is empty. An empty rectangle is one that has no area;
            that is, the coordinate of the right side is less than or equal to the coordinate of the left side, or the coordinate of the
            bottom side is less than or equal to the coordinate of the top side.
            </summary>
            <param name="lprc">Pointer to a RECT structure that contains the logical coordinates of the rectangle.</param>
            <returns>
            <para>If the rectangle is empty, the return value is nonzero.</para>
            <para>If the rectangle is not empty, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure.
            Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which
            the rectangle is used determine the units of measure.
            </para>
            <para>Examples</para>
            <para>For an example, see Using Rectangles.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.OffsetRect(Vanara.PInvoke.RECT@,System.Int32,System.Int32)">
            <summary>The <c>OffsetRect</c> function moves the specified rectangle by the specified offsets.</summary>
            <param name="lprc">Pointer to a RECT structure that contains the logical coordinates of the rectangle to be moved.</param>
            <param name="dx">
            Specifies the amount to move the rectangle left or right. This parameter must be a negative value to move the rectangle to the left.
            </param>
            <param name="dy">
            Specifies the amount to move the rectangle up or down. This parameter must be a negative value to move the rectangle up.
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure.
            Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which
            the rectangle is used determine the units of measure.
            </para>
            <para>Examples</para>
            <para>For an example, see Using Rectangles.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.PtInRect(Vanara.PInvoke.RECT@,Vanara.PInvoke.POINT)">
            <summary>
            The <c>PtInRect</c> function determines whether the specified point lies within the specified rectangle. A point is within a
            rectangle if it lies on the left or top side or is within all four sides. A point on the right or bottom side is considered
            outside the rectangle.
            </summary>
            <param name="lprc">A pointer to a RECT structure that contains the specified rectangle.</param>
            <param name="pt">A POINT structure that contains the specified point.</param>
            <returns>
            <para>If the specified point lies within the rectangle, the return value is nonzero.</para>
            <para>If the specified point does not lie within the rectangle, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            The rectangle must be normalized before <c>PtInRect</c> is called. That is, lprc.right must be greater than lprc.left and
            lprc.bottom must be greater than lprc.top. If the rectangle is not normalized, a point is never considered inside of the rectangle.
            </para>
            <para>
            Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure.
            Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which
            the rectangle is used determine the units of measure.
            </para>
            <para>Examples</para>
            <para>For an example, see Using Rectangles.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetRect(Vanara.PInvoke.RECT@,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            The <c>SetRect</c> function sets the coordinates of the specified rectangle. This is equivalent to assigning the left, top,
            right, and bottom arguments to the appropriate members of the <c>RECT</c> structure.
            </summary>
            <param name="lprc">Pointer to the RECT structure that contains the rectangle to be set.</param>
            <param name="xLeft">Specifies the x-coordinate of the rectangle's upper-left corner.</param>
            <param name="yTop">Specifies the y-coordinate of the rectangle's upper-left corner.</param>
            <param name="xRight">Specifies the x-coordinate of the rectangle's lower-right corner.</param>
            <param name="yBottom">Specifies the y-coordinate of the rectangle's lower-right corner.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure.
            Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which
            the rectangle is used determine the units of measure.
            </para>
            <para>Examples</para>
            <para>For an example, see Using Rectangles.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetRectEmpty(Vanara.PInvoke.RECT@)">
            <summary>The <c>SetRectEmpty</c> function creates an empty rectangle in which all coordinates are set to zero.</summary>
            <param name="lprc">Pointer to the RECT structure that contains the coordinates of the rectangle.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure.
            Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which
            the rectangle is used determine the units of measure.
            </para>
            <para>Examples</para>
            <para>For an example, see Using Rectangles.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SubtractRect(Vanara.PInvoke.RECT@,Vanara.PInvoke.RECT@,Vanara.PInvoke.RECT@)">
            <summary>
            The <c>SubtractRect</c> function determines the coordinates of a rectangle formed by subtracting one rectangle from another.
            </summary>
            <param name="lprcDst">
            A pointer to a RECT structure that receives the coordinates of the rectangle determined by subtracting the rectangle pointed to
            by lprcSrc2 from the rectangle pointed to by lprcSrc1.
            </param>
            <param name="lprcSrc1">A pointer to a RECT structure from which the function subtracts the rectangle pointed to by lprcSrc2.</param>
            <param name="lprcSrc2">A pointer to a RECT structure that the function subtracts from the rectangle pointed to by lprcSrc1.</param>
            <returns>
            <para>If the resulting rectangle is empty, the return value is zero.</para>
            <para>If the resulting rectangle is not empty, the return value is nonzero.</para>
            </returns>
            <remarks>
            <para>
            The function only subtracts the rectangle specified by lprcSrc2 from the rectangle specified by lprcSrc1 when the rectangles
            intersect completely in either the x- or y-direction. For example, if *lprcSrc1 has the coordinates (10,10,100,100) and *lprcSrc2
            has the coordinates (50,50,150,150), the function sets the coordinates of the rectangle pointed to by lprcDst to (10,10,100,100).
            If *lprcSrc1 has the coordinates (10,10,100,100) and *lprcSrc2 has the coordinates (50,10,150,150), however, the function sets
            the coordinates of the rectangle pointed to by lprcDst to (10,10,50,100). In other words, the resulting rectangle is the bounding
            box of the geometric difference.
            </para>
            <para>
            Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure.
            Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which
            the rectangle is used determine the units of measure.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.UnionRect(Vanara.PInvoke.RECT@,Vanara.PInvoke.RECT@,Vanara.PInvoke.RECT@)">
            <summary>
            The <c>UnionRect</c> function creates the union of two rectangles. The union is the smallest rectangle that contains both source rectangles.
            </summary>
            <param name="lprcDst">
            A pointer to the RECT structure that will receive a rectangle containing the rectangles pointed to by the lprcSrc1 and lprcSrc2 parameters.
            </param>
            <param name="lprcSrc1">A pointer to the RECT structure that contains the first source rectangle.</param>
            <param name="lprcSrc2">A pointer to the RECT structure that contains the second source rectangle.</param>
            <returns>
            <para>If the specified structure contains a nonempty rectangle, the return value is nonzero.</para>
            <para>If the specified structure does not contain a nonempty rectangle, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            The system ignores the dimensions of an empty rectangle that is, a rectangle in which all coordinates are set to zero, so that it
            has no height or no width.
            </para>
            <para>
            Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure.
            Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which
            the rectangle is used determine the units of measure.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.LoadImageOptions">
            <summary>Specifies the load options for <see cref="M:Vanara.PInvoke.User32.LoadImage(Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.SafeResourceId,Vanara.PInvoke.User32.LoadImageType,System.Int32,System.Int32,Vanara.PInvoke.User32.LoadImageOptions)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LoadImageOptions.LR_DEFAULTCOLOR">
            <summary>The default flag; it does nothing. All it means is "not LR_MONOCHROME".</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LoadImageOptions.LR_MONOCHROME">
            <summary>Loads the image in black and white.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LoadImageOptions.LR_COLOR">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LoadImageOptions.LR_LOADFROMFILE">
            <summary>Loads the stand-alone image from the file specified by lpszName (icon, cursor, or bitmap file).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LoadImageOptions.LR_LOADTRANSPARENT">
            <summary>
            Retrieves the color value of the first pixel in the image and replaces the corresponding entry in the color table with the
            default window color (COLOR_WINDOW). All pixels in the image that use that entry become the default window color. This value
            applies only to images that have corresponding color tables.
            <para>Do not use this option if you are loading a bitmap with a color depth greater than 8bpp.</para>
            <para>
            If fuLoad includes both the LR_LOADTRANSPARENT and LR_LOADMAP3DCOLORS values, LR_LOADTRANSPARENT takes precedence. However,
            the color table entry is replaced with COLOR_3DFACE rather than COLOR_WINDOW.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LoadImageOptions.LR_DEFAULTSIZE">
            <summary>
            Uses the width or height specified by the system metric values for cursors or icons, if the cxDesired or cyDesired values are
            set to zero. If this flag is not specified and cxDesired and cyDesired are set to zero, the function uses the actual resource
            size. If the resource contains multiple images, the function uses the size of the first image.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LoadImageOptions.LR_VGACOLOR">
            <summary>Uses true VGA colors.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LoadImageOptions.LR_LOADMAP3DCOLORS">
            <summary>
            Searches the color table for the image and replaces the following shades of gray with the corresponding 3-D color.
            <list type="bullet">
            <item>
            <description>Dk Gray, RGB(128,128,128) with COLOR_3DSHADOW</description>
            </item>
            <item>
            <description>Gray, RGB(192,192,192) with COLOR_3DFACE</description>
            </item>
            <item>
            <description>Lt Gray, RGB(223,223,223) with COLOR_3DLIGHT</description>
            </item>
            </list>
            <para>Do not use this option if you are loading a bitmap with a color depth greater than 8bpp.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LoadImageOptions.LR_CREATEDIBSECTION">
            <summary>
            When the uType parameter specifies IMAGE_BITMAP, causes the function to return a DIB section bitmap rather than a compatible
            bitmap. This flag is useful for loading a bitmap without mapping it to the colors of the display device.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LoadImageOptions.LR_SHARED">
            <summary>
            Shares the image handle if the image is loaded multiple times. If LR_SHARED is not set, a second call to LoadImage for the
            same resource will load the image again and return a different handle.
            <para>When you use this flag, the system will destroy the resource when it is no longer needed.</para>
            <para>
            Do not use LR_SHARED for images that have non-standard sizes, that may change after loading, or that are loaded from a file.
            </para>
            <para>When loading a system icon or cursor, you must use LR_SHARED or the function will fail to load the resource.</para>
            <para>This function finds the first image in the cache with the requested resource name, regardless of the size requested.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.LoadImageType">
            <summary>Specifies the type of image to be loaded by <see cref="M:Vanara.PInvoke.User32.LoadImage(Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.SafeResourceId,Vanara.PInvoke.User32.LoadImageType,System.Int32,System.Int32,Vanara.PInvoke.User32.LoadImageOptions)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LoadImageType.IMAGE_BITMAP">
            <summary>Loads a bitmap.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LoadImageType.IMAGE_ICON">
            <summary>Loads an icon.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LoadImageType.IMAGE_CURSOR">
            <summary>Loads a cursor.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LoadImageType.IMAGE_ENHMETAFILE">
            <summary>Loads an enhanced metafile.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadImage(Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.SafeResourceId,Vanara.PInvoke.User32.LoadImageType,System.Int32,System.Int32,Vanara.PInvoke.User32.LoadImageOptions)">
            <summary>Loads an icon, cursor, animated cursor, or bitmap.</summary>
            <param name="hinst">
            A handle to the module of either a DLL or executable (.exe) that contains the image to be loaded. For more information, see
            GetModuleHandle. Note that as of 32-bit Windows, an instance handle (HINSTANCE), such as the application instance handle exposed
            by system function call of WinMain, and a module handle (HMODULE) are the same thing.
            <para>To load an OEM image, set this parameter to NULL.</para>
            <para>To load a stand-alone resource (icon, cursor, or bitmap file)—for example, c:\myimage.bmp—set this parameter to NULL.</para>
            </param>
            <param name="lpszName">
            The image to be loaded. If the hinst parameter is non-NULL and the fuLoad parameter omits LR_LOADFROMFILE, lpszName specifies the
            image resource in the hinst module. If the image resource is to be loaded by name from the module, the lpszName parameter is a
            pointer to a null-terminated string that contains the name of the image resource. If the image resource is to be loaded by
            ordinal from the module, use the MAKEINTRESOURCE macro to convert the image ordinal into a form that can be passed to the
            LoadImage function. For more information, see the Remarks section below.
            <para>
            If the hinst parameter is NULL and the fuLoad parameter omits the LR_LOADFROMFILE value, the lpszName specifies the OEM image to load.
            </para>
            <para>
            To pass these constants to the LoadImage function, use the MAKEINTRESOURCE macro. For example, to load the OCR_NORMAL cursor,
            pass MAKEINTRESOURCE(OCR_NORMAL) as the lpszName parameter, NULL as the hinst parameter, and LR_SHARED as one of the flags to the
            fuLoad parameter.
            </para>
            <para>
            If the fuLoad parameter includes the LR_LOADFROMFILE value, lpszName is the name of the file that contains the stand-alone
            resource (icon, cursor, or bitmap file). Therefore, set hinst to NULL.
            </para>
            </param>
            <param name="uType">The type of image to be loaded. This parameter can be one of the following values.</param>
            <param name="cxDesired">
            The width, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function
            uses the SM_CXICON or SM_CXCURSOR system metric value to set the width. If this parameter is zero and LR_DEFAULTSIZE is not used,
            the function uses the actual resource width.
            </param>
            <param name="cyDesired">
            The height, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function
            uses the SM_CYICON or SM_CYCURSOR system metric value to set the height. If this parameter is zero and LR_DEFAULTSIZE is not
            used, the function uses the actual resource height.
            </param>
            <param name="fuLoad">Loading options.</param>
            <returns>
            If the function succeeds, the return value is the handle of the newly loaded image. If the function fails, the return value is
            NULL.To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadImage_Bitmap(Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.SafeResourceId,System.Int32,System.Int32,Vanara.PInvoke.User32.LoadImageOptions)">
            <summary>Loads a bitmap.</summary>
            <param name="hinst">
            A handle to the module of either a DLL or executable (.exe) that contains the image to be loaded. For more information, see
            GetModuleHandle. Note that as of 32-bit Windows, an instance handle (HINSTANCE), such as the application instance handle exposed
            by system function call of WinMain, and a module handle (HMODULE) are the same thing.
            <para>To load an OEM image, set this parameter to NULL.</para>
            <para>To load a stand-alone resource (icon, cursor, or bitmap file)—for example, c:\myimage.bmp—set this parameter to NULL.</para>
            </param>
            <param name="lpszName">
            The image to be loaded. If the hinst parameter is non-NULL and the fuLoad parameter omits LR_LOADFROMFILE, lpszName specifies the
            image resource in the hinst module. If the image resource is to be loaded by name from the module, the lpszName parameter is a
            pointer to a null-terminated string that contains the name of the image resource. If the image resource is to be loaded by
            ordinal from the module, use the MAKEINTRESOURCE macro to convert the image ordinal into a form that can be passed to the
            LoadImage function. For more information, see the Remarks section below.
            <para>
            If the hinst parameter is NULL and the fuLoad parameter omits the LR_LOADFROMFILE value, the lpszName specifies the OEM image to load.
            </para>
            <para>
            To pass these constants to the LoadImage function, use the MAKEINTRESOURCE macro. For example, to load the OCR_NORMAL cursor,
            pass MAKEINTRESOURCE(OCR_NORMAL) as the lpszName parameter, NULL as the hinst parameter, and LR_SHARED as one of the flags to the
            fuLoad parameter.
            </para>
            <para>
            If the fuLoad parameter includes the LR_LOADFROMFILE value, lpszName is the name of the file that contains the stand-alone
            resource (icon, cursor, or bitmap file). Therefore, set hinst to NULL.
            </para>
            </param>
            <param name="cxDesired">
            The width, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function
            uses the SM_CXICON or SM_CXCURSOR system metric value to set the width. If this parameter is zero and LR_DEFAULTSIZE is not used,
            the function uses the actual resource width.
            </param>
            <param name="cyDesired">
            The height, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function
            uses the SM_CYICON or SM_CYCURSOR system metric value to set the height. If this parameter is zero and LR_DEFAULTSIZE is not
            used, the function uses the actual resource height.
            </param>
            <param name="fuLoad">Loading options.</param>
            <returns>
            If the function succeeds, the return value is the handle of the newly loaded image. If the function fails, the return value is
            NULL.To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadImage_Cursor(Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.SafeResourceId,System.Int32,System.Int32,Vanara.PInvoke.User32.LoadImageOptions)">
            <summary>Loads a cursor or animated cursor.</summary>
            <param name="hinst">
            A handle to the module of either a DLL or executable (.exe) that contains the image to be loaded. For more information, see
            GetModuleHandle. Note that as of 32-bit Windows, an instance handle (HINSTANCE), such as the application instance handle exposed
            by system function call of WinMain, and a module handle (HMODULE) are the same thing.
            <para>To load an OEM image, set this parameter to NULL.</para>
            <para>To load a stand-alone resource (icon, cursor, or bitmap file)—for example, c:\myimage.bmp—set this parameter to NULL.</para>
            </param>
            <param name="lpszName">
            The image to be loaded. If the hinst parameter is non-NULL and the fuLoad parameter omits LR_LOADFROMFILE, lpszName specifies the
            image resource in the hinst module. If the image resource is to be loaded by name from the module, the lpszName parameter is a
            pointer to a null-terminated string that contains the name of the image resource. If the image resource is to be loaded by
            ordinal from the module, use the MAKEINTRESOURCE macro to convert the image ordinal into a form that can be passed to the
            LoadImage function. For more information, see the Remarks section below.
            <para>
            If the hinst parameter is NULL and the fuLoad parameter omits the LR_LOADFROMFILE value, the lpszName specifies the OEM image to load.
            </para>
            <para>
            To pass these constants to the LoadImage function, use the MAKEINTRESOURCE macro. For example, to load the OCR_NORMAL cursor,
            pass MAKEINTRESOURCE(OCR_NORMAL) as the lpszName parameter, NULL as the hinst parameter, and LR_SHARED as one of the flags to the
            fuLoad parameter.
            </para>
            <para>
            If the fuLoad parameter includes the LR_LOADFROMFILE value, lpszName is the name of the file that contains the stand-alone
            resource (icon, cursor, or bitmap file). Therefore, set hinst to NULL.
            </para>
            </param>
            <param name="cxDesired">
            The width, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function
            uses the SM_CXICON or SM_CXCURSOR system metric value to set the width. If this parameter is zero and LR_DEFAULTSIZE is not used,
            the function uses the actual resource width.
            </param>
            <param name="cyDesired">
            The height, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function
            uses the SM_CYICON or SM_CYCURSOR system metric value to set the height. If this parameter is zero and LR_DEFAULTSIZE is not
            used, the function uses the actual resource height.
            </param>
            <param name="fuLoad">Loading options.</param>
            <returns>
            If the function succeeds, the return value is the handle of the newly loaded image. If the function fails, the return value is
            NULL.To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadImage_EnhMetaFile(Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.SafeResourceId,System.Int32,System.Int32,Vanara.PInvoke.User32.LoadImageOptions)">
            <summary>Loads an enhanced metafile.</summary>
            <param name="hinst">
            A handle to the module of either a DLL or executable (.exe) that contains the image to be loaded. For more information, see
            GetModuleHandle. Note that as of 32-bit Windows, an instance handle (HINSTANCE), such as the application instance handle exposed
            by system function call of WinMain, and a module handle (HMODULE) are the same thing.
            <para>To load an OEM image, set this parameter to NULL.</para>
            <para>To load a stand-alone resource (icon, cursor, or bitmap file)—for example, c:\myimage.bmp—set this parameter to NULL.</para>
            </param>
            <param name="lpszName">
            The image to be loaded. If the hinst parameter is non-NULL and the fuLoad parameter omits LR_LOADFROMFILE, lpszName specifies the
            image resource in the hinst module. If the image resource is to be loaded by name from the module, the lpszName parameter is a
            pointer to a null-terminated string that contains the name of the image resource. If the image resource is to be loaded by
            ordinal from the module, use the MAKEINTRESOURCE macro to convert the image ordinal into a form that can be passed to the
            LoadImage function. For more information, see the Remarks section below.
            <para>
            If the hinst parameter is NULL and the fuLoad parameter omits the LR_LOADFROMFILE value, the lpszName specifies the OEM image to load.
            </para>
            <para>
            To pass these constants to the LoadImage function, use the MAKEINTRESOURCE macro. For example, to load the OCR_NORMAL cursor,
            pass MAKEINTRESOURCE(OCR_NORMAL) as the lpszName parameter, NULL as the hinst parameter, and LR_SHARED as one of the flags to the
            fuLoad parameter.
            </para>
            <para>
            If the fuLoad parameter includes the LR_LOADFROMFILE value, lpszName is the name of the file that contains the stand-alone
            resource (icon, cursor, or bitmap file). Therefore, set hinst to NULL.
            </para>
            </param>
            <param name="cxDesired">
            The width, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function
            uses the SM_CXICON or SM_CXCURSOR system metric value to set the width. If this parameter is zero and LR_DEFAULTSIZE is not used,
            the function uses the actual resource width.
            </param>
            <param name="cyDesired">
            The height, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function
            uses the SM_CYICON or SM_CYCURSOR system metric value to set the height. If this parameter is zero and LR_DEFAULTSIZE is not
            used, the function uses the actual resource height.
            </param>
            <param name="fuLoad">Loading options.</param>
            <returns>
            If the function succeeds, the return value is the handle of the newly loaded image. If the function fails, the return value is
            NULL.To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadImage_Icon(Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.SafeResourceId,System.Int32,System.Int32,Vanara.PInvoke.User32.LoadImageOptions)">
            <summary>Loads an icon.</summary>
            <param name="hinst">
            A handle to the module of either a DLL or executable (.exe) that contains the image to be loaded. For more information, see
            GetModuleHandle. Note that as of 32-bit Windows, an instance handle (HINSTANCE), such as the application instance handle exposed
            by system function call of WinMain, and a module handle (HMODULE) are the same thing.
            <para>To load an OEM image, set this parameter to NULL.</para>
            <para>To load a stand-alone resource (icon, cursor, or bitmap file)—for example, c:\myimage.bmp—set this parameter to NULL.</para>
            </param>
            <param name="lpszName">
            The image to be loaded. If the hinst parameter is non-NULL and the fuLoad parameter omits LR_LOADFROMFILE, lpszName specifies the
            image resource in the hinst module. If the image resource is to be loaded by name from the module, the lpszName parameter is a
            pointer to a null-terminated string that contains the name of the image resource. If the image resource is to be loaded by
            ordinal from the module, use the MAKEINTRESOURCE macro to convert the image ordinal into a form that can be passed to the
            LoadImage function. For more information, see the Remarks section below.
            <para>
            If the hinst parameter is NULL and the fuLoad parameter omits the LR_LOADFROMFILE value, the lpszName specifies the OEM image to load.
            </para>
            <para>
            To pass these constants to the LoadImage function, use the MAKEINTRESOURCE macro. For example, to load the OCR_NORMAL cursor,
            pass MAKEINTRESOURCE(OCR_NORMAL) as the lpszName parameter, NULL as the hinst parameter, and LR_SHARED as one of the flags to the
            fuLoad parameter.
            </para>
            <para>
            If the fuLoad parameter includes the LR_LOADFROMFILE value, lpszName is the name of the file that contains the stand-alone
            resource (icon, cursor, or bitmap file). Therefore, set hinst to NULL.
            </para>
            </param>
            <param name="cxDesired">
            The width, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function
            uses the SM_CXICON or SM_CXCURSOR system metric value to set the width. If this parameter is zero and LR_DEFAULTSIZE is not used,
            the function uses the actual resource width.
            </param>
            <param name="cyDesired">
            The height, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function
            uses the SM_CYICON or SM_CYCURSOR system metric value to set the height. If this parameter is zero and LR_DEFAULTSIZE is not
            used, the function uses the actual resource height.
            </param>
            <param name="fuLoad">Loading options.</param>
            <returns>
            If the function succeeds, the return value is the handle of the newly loaded image. If the function fails, the return value is
            NULL.To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadString(Vanara.PInvoke.HINSTANCE,System.Int32,System.Text.StringBuilder,System.Int32)">
            <summary>
            Loads a string resource from the executable file associated with a specified module, copies the string into a buffer, and appends
            a terminating null character.
            </summary>
            <param name="hInstance">
            A handle to an instance of the module whose executable file contains the string resource. To get the handle to the application
            itself, call the GetModuleHandle function with NULL.
            </param>
            <param name="uID">The identifier of the string to be loaded.</param>
            <param name="lpBuffer">The buffer is to receive the string. Must be of sufficient length to hold a pointer (8 bytes).</param>
            <param name="nBufferMax">
            The size of the buffer, in characters. The string is truncated and null-terminated if it is longer than the number of characters
            specified. If this parameter is 0, then lpBuffer receives a read-only pointer to the resource itself.
            </param>
            <returns>
            If the function succeeds, the return value is the number of characters copied into the buffer, not including the terminating null
            character, or zero if the string resource does not exist. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.LoadString(Vanara.PInvoke.HINSTANCE,System.Int32,System.IntPtr@,System.Int32)">
            <summary>
            Loads a string resource from the executable file associated with a specified module, copies the string into a buffer, and appends
            a terminating null character.
            </summary>
            <param name="hInstance">
            A handle to an instance of the module whose executable file contains the string resource. To get the handle to the application
            itself, call the GetModuleHandle function with NULL.
            </param>
            <param name="uID">The identifier of the string to be loaded.</param>
            <param name="lpBuffer">The buffer is to receive the string. Must be of sufficient length to hold a pointer (8 bytes).</param>
            <param name="nBufferMax">
            The size of the buffer, in characters. The string is truncated and null-terminated if it is longer than the number of characters
            specified. If this parameter is 0, then lpBuffer receives a read-only pointer to the resource itself.
            </param>
            <returns>
            If the function succeeds, the return value is the number of characters copied into the buffer, not including the terminating null
            character, or zero if the string resource does not exist. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.User32.GRPICONDIR">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.GRPICONDIR.idReserved">
            <summary>Reserved (must be 0)</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GRPICONDIR.idType">
            <summary>Resource type</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GRPICONDIR.idCount">
            <summary>Icon count</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.GRPICONDIRENTRY">
            <summary>Represents an icon as stored in a resource</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GRPICONDIRENTRY.bWidth">
            <summary>Width, in pixels, of the image</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GRPICONDIRENTRY.bHeight">
            <summary>Height, in pixels, of the image</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GRPICONDIRENTRY.bColorCount">
            <summary>Number of colors in image (0 if &gt;= 8bpp)</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GRPICONDIRENTRY.bReserved">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GRPICONDIRENTRY.wPlanes">
            <summary>Color Planes</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GRPICONDIRENTRY.wBitCount">
            <summary>Bits per pixel</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GRPICONDIRENTRY.dwBytesInRes">
            <summary>How many bytes in this resource?</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GRPICONDIRENTRY.nId">
            <summary>The ID</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ESB_FLAGS">
            <summary>Flags used to enable or disable scroll bars.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ESB_FLAGS.ESB_DISABLE_BOTH">
            <summary>Disables both direction buttons on the specified scroll bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ESB_FLAGS.ESB_DISABLE_DOWN">
            <summary>Disables the down direction button on the vertical scroll bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ESB_FLAGS.ESB_DISABLE_LEFT">
            <summary>Disables the left direction button on the horizontal scroll bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ESB_FLAGS.ESB_DISABLE_LTUP">
            <summary>
            Disables the left direction button on the horizontal scroll bar or the up direction button on the vertical scroll bar.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ESB_FLAGS.ESB_DISABLE_RIGHT">
            <summary>Disables the right direction button on the horizontal scroll bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ESB_FLAGS.ESB_DISABLE_RTDN">
            <summary>
            Disables the right direction button on the horizontal scroll bar or the down direction button on the vertical scroll bar.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ESB_FLAGS.ESB_DISABLE_UP">
            <summary>Disables the up direction button on the vertical scroll bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ESB_FLAGS.ESB_ENABLE_BOTH">
            <summary>Enables both direction buttons on the specified scroll bar.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SB">
            <summary>Specifies the scroll bar type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SB.SB_BOTH">
            <summary>The horizontal and vertical scroll bars.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SB.SB_HORZ">
            <summary>The horizontal scroll bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SB.SB_VERT">
            <summary>The vertical scroll bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SB.SB_CTL">
            <summary>The scroll bar control.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ScrollWindowFlags">
            <summary>Specifies flags that control scrolling.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ScrollWindowFlags.SW_SCROLLCHILDREN">
            <summary>
            Scrolls all child windows that intersect the rectangle pointed to by the prcScroll parameter. The child windows are scrolled
            by the number of pixels specified by the dx and dy parameters. The system sends a WM_MOVE message to all child windows that
            intersect the prcScroll rectangle, even if they do not move.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ScrollWindowFlags.SW_INVALIDATE">
            <summary>Invalidates the region identified by the hrgnUpdate parameter after scrolling.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ScrollWindowFlags.SW_ERASE">
            <summary>
            Erases the newly invalidated region by sending a WM_ERASEBKGND message to the window when specified with the SW_INVALIDATE flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ScrollWindowFlags.SW_SMOOTHSCROLL">
            <summary>
            Scrolls using smooth scrolling. Use the HIWORD portion of the flags parameter to indicate how much time, in milliseconds, the
            smooth-scrolling operation should take.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SIF">
            <summary>Specifies the scroll bar parameters to set or retrieve.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SIF.SIF_RANGE">
            <summary>The nMin and nMax members contain the minimum and maximum values for the scrolling range.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SIF.SIF_PAGE">
            <summary>The nPage member contains the page size for a proportional scroll bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SIF.SIF_POS">
            <summary>The nPos member contains the scroll box position, which is not updated while the user drags the scroll box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SIF.SIF_DISABLENOSCROLL">
            <summary>
            This value is used only when setting a scroll bar's parameters. If the scroll bar's new parameters make the scroll bar
            unnecessary, disable the scroll bar instead of removing it.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SIF.SIF_TRACKPOS">
            <summary>The nTrackPos member contains the current position of the scroll box while the user is dragging it.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SIF.SIF_ALL">
            <summary>Combination of SIF_PAGE, SIF_POS, SIF_RANGE, and SIF_TRACKPOS.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnableScrollBar(Vanara.PInvoke.HWND,System.UInt32,System.UInt32)">
            <summary>The <c>EnableScrollBar</c> function enables or disables one or both scroll bar arrows.</summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>Handle to a window or a scroll bar control, depending on the value of the wSBflags parameter.</para>
            </param>
            <param name="wSBflags">
            <para>Type: <c>UINT</c></para>
            <para>Specifies the scroll bar type. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SB_BOTH</term>
            <term>
            Enables or disables the arrows on the horizontal and vertical scroll bars associated with the specified window. The hWnd
            parameter must be the handle to the window.
            </term>
            </item>
            <item>
            <term>SB_CTL</term>
            <term>Indicates that the scroll bar is a scroll bar control. The hWnd must be the handle to the scroll bar control.</term>
            </item>
            <item>
            <term>SB_HORZ</term>
            <term>
            Enables or disables the arrows on the horizontal scroll bar associated with the specified window. The hWnd parameter must be the
            handle to the window.
            </term>
            </item>
            <item>
            <term>SB_VERT</term>
            <term>
            Enables or disables the arrows on the vertical scroll bar associated with the specified window. The hWnd parameter must be the
            handle to the window.
            </term>
            </item>
            </list>
            </param>
            <param name="wArrows">
            <para>Type: <c>UINT</c></para>
            <para>
            Specifies whether the scroll bar arrows are enabled or disabled and indicates which arrows are enabled or disabled. This
            parameter can be one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ESB_DISABLE_BOTH</term>
            <term>Disables both arrows on a scroll bar.</term>
            </item>
            <item>
            <term>ESB_DISABLE_DOWN</term>
            <term>Disables the down arrow on a vertical scroll bar.</term>
            </item>
            <item>
            <term>ESB_DISABLE_LEFT</term>
            <term>Disables the left arrow on a horizontal scroll bar.</term>
            </item>
            <item>
            <term>ESB_DISABLE_LTUP</term>
            <term>Disables the left arrow on a horizontal scroll bar or the up arrow of a vertical scroll bar.</term>
            </item>
            <item>
            <term>ESB_DISABLE_RIGHT</term>
            <term>Disables the right arrow on a horizontal scroll bar.</term>
            </item>
            <item>
            <term>ESB_DISABLE_RTDN</term>
            <term>Disables the right arrow on a horizontal scroll bar or the down arrow of a vertical scroll bar.</term>
            </item>
            <item>
            <term>ESB_DISABLE_UP</term>
            <term>Disables the up arrow on a vertical scroll bar.</term>
            </item>
            <item>
            <term>ESB_ENABLE_BOTH</term>
            <term>Enables both arrows on a scroll bar.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the arrows are enabled or disabled as specified, the return value is nonzero.</para>
            <para>
            If the arrows are already in the requested state or an error occurs, the return value is zero. To get extended error information,
            call GetLastError.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetScrollBarInfo(Vanara.PInvoke.HWND,System.Int32,Vanara.PInvoke.User32.SCROLLBARINFO@)">
            <summary>The <c>GetScrollBarInfo</c> function retrieves information about the specified scroll bar.</summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>
            Handle to a window associated with the scroll bar whose information is to be retrieved. If the idObject parameter is
            OBJID_CLIENT, hwnd is a handle to a scroll bar control. Otherwise, hwnd is a handle to a window created with WS_VSCROLL and/or
            WS_HSCROLL style.
            </para>
            </param>
            <param name="idObject">
            <para>Type: <c>LONG</c></para>
            <para>Specifies the scroll bar object. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>OBJID_CLIENT</term>
            <term>The hwnd parameter is a handle to a scroll bar control.</term>
            </item>
            <item>
            <term>OBJID_HSCROLL</term>
            <term>The horizontal scroll bar of the hwnd window.</term>
            </item>
            <item>
            <term>OBJID_VSCROLL</term>
            <term>The vertical scroll bar of the hwnd window.</term>
            </item>
            </list>
            </param>
            <param name="psbi">
            <para>Type: <c>PSCROLLBARINFO</c></para>
            <para>
            Pointer to a SCROLLBARINFO structure to receive the information. Before calling <c>GetScrollBarInfo</c>, set the <c>cbSize</c>
            member to <c>sizeof</c>( <c>SCROLLBARINFO</c>).
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            If idObject is OBJID_CLIENT and the window specified by hwnd is not a system scroll bar control, the system sends the
            SBM_GETSCROLLBARINFO message to the window to obtain scroll bar information. This allows <c>GetScrollBarInfo</c> to operate on a
            custom control that mimics a scroll bar. If the window does not handle the <c>SBM_GETSCROLLBARINFO</c> message, the
            <c>GetScrollBarInfo</c> function fails.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetScrollInfo(Vanara.PInvoke.HWND,System.Int32,Vanara.PInvoke.User32.SCROLLINFO@)">
            <summary>
            The <c>GetScrollInfo</c> function retrieves the parameters of a scroll bar, including the minimum and maximum scrolling
            positions, the page size, and the position of the scroll box (thumb).
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the fnBar parameter.</para>
            </param>
            <param name="nBar">
            <para>Type: <c>int</c></para>
            <para>Specifies the type of scroll bar for which to retrieve parameters. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SB_CTL</term>
            <term>Retrieves the parameters for a scroll bar control. The hwnd parameter must be the handle to the scroll bar control.</term>
            </item>
            <item>
            <term>SB_HORZ</term>
            <term>Retrieves the parameters for the window's standard horizontal scroll bar.</term>
            </item>
            <item>
            <term>SB_VERT</term>
            <term>Retrieves the parameters for the window's standard vertical scroll bar.</term>
            </item>
            </list>
            </param>
            <param name="lpsi">
            <para>Type: <c>LPSCROLLINFO</c></para>
            <para>
            Pointer to a SCROLLINFO structure. Before calling <c>GetScrollInfo</c>, set the <c>cbSize</c> member to <c>sizeof</c>(
            <c>SCROLLINFO</c>), and set the <c>fMask</c> member to specify the scroll bar parameters to retrieve. Before returning, the
            function copies the specified parameters to the appropriate members of the structure.
            </para>
            <para>The <c>fMask</c> member can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SIF_PAGE</term>
            <term>Copies the scroll page to the nPage member of the SCROLLINFO structure pointed to by lpsi.</term>
            </item>
            <item>
            <term>SIF_POS</term>
            <term>Copies the scroll position to the nPos member of the SCROLLINFO structure pointed to by lpsi.</term>
            </item>
            <item>
            <term>SIF_RANGE</term>
            <term>Copies the scroll range to the nMin and nMax members of the SCROLLINFO structure pointed to by lpsi.</term>
            </item>
            <item>
            <term>SIF_TRACKPOS</term>
            <term>Copies the current scroll box tracking position to the nTrackPos member of the SCROLLINFO structure pointed to by lpsi.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function retrieved any values, the return value is nonzero.</para>
            <para>If the function does not retrieve any values, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>GetScrollInfo</c> function enables applications to use 32-bit scroll positions. Although the messages that indicate scroll
            bar position, WM_HSCROLL and WM_VSCROLL, provide only 16 bits of position data, the functions SetScrollInfo and
            <c>GetScrollInfo</c> provide 32 bits of scroll bar position data. Thus, an application can call <c>GetScrollInfo</c> while
            processing either the <c>WM_HSCROLL</c> or <c>WM_VSCROLL</c> messages to obtain 32-bit scroll bar position data.
            </para>
            <para>
            To get the 32-bit position of the scroll box (thumb) during a SB_THUMBTRACK request code in a WM_HSCROLL or WM_VSCROLL message,
            call <c>GetScrollInfo</c> with the SIF_TRACKPOS value in the <c>fMask</c> member of the SCROLLINFO structure. The function
            returns the tracking position of the scroll box in the <c>nTrackPos</c> member of the <c>SCROLLINFO</c> structure. This allows
            you to get the position of the scroll box as the user moves it. The following sample code illustrates the technique.
            </para>
            <para>
            If the fnBar parameter is SB_CTL and the window specified by the hwnd parameter is not a system scroll bar control, the system
            sends the SBM_GETSCROLLINFO message to the window to obtain scroll bar information. This allows <c>GetScrollInfo</c> to operate
            on a custom control that mimics a scroll bar. If the window does not handle the <c>SBM_GETSCROLLINFO</c> message, the
            <c>GetScrollInfo</c> function fails.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetScrollPos(Vanara.PInvoke.HWND,System.Int32)">
            <summary>
            <para>
            The <c>GetScrollPos</c> function retrieves the current position of the scroll box (thumb) in the specified scroll bar. The
            current position is a relative value that depends on the current scrolling range. For example, if the scrolling range is 0
            through 100 and the scroll box is in the middle of the bar, the current position is 50.
            </para>
            <para>
            <c>Note</c> The <c>GetScrollPos</c> function is provided for backward compatibility. New applications should use the
            GetScrollInfo function.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the nBar parameter.</para>
            </param>
            <param name="nBar">
            <para>Type: <c>int</c></para>
            <para>Specifies the scroll bar to be examined. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SB_CTL</term>
            <term>
            Retrieves the position of the scroll box in a scroll bar control. The hWnd parameter must be the handle to the scroll bar control.
            </term>
            </item>
            <item>
            <term>SB_HORZ</term>
            <term>Retrieves the position of the scroll box in a window's standard horizontal scroll bar.</term>
            </item>
            <item>
            <term>SB_VERT</term>
            <term>Retrieves the position of the scroll box in a window's standard vertical scroll bar.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>If the function succeeds, the return value is the current position of the scroll box.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>GetScrollPos</c> function enables applications to use 32-bit scroll positions. Although the messages that indicate scroll
            bar position, WM_HSCROLL and WM_VSCROLL, are limited to 16 bits of position data, the functions SetScrollPos, SetScrollRange,
            <c>GetScrollPos</c>, and GetScrollRange support 32-bit scroll bar position data. Thus, an application can call
            <c>GetScrollPos</c> while processing either the <c>WM_HSCROLL</c> or <c>WM_VSCROLL</c> messages to obtain 32-bit scroll bar
            position data.
            </para>
            <para>
            To get the 32-bit position of the scroll box (thumb) during a SB_THUMBTRACK request code in a WM_HSCROLL or WM_VSCROLL message,
            use the GetScrollInfo function.
            </para>
            <para>
            If the nBar parameter is SB_CTL and the window specified by the hWnd parameter is not a system scroll bar control, the system
            sends the SBM_GETPOS message to the window to obtain scroll bar information. This allows <c>GetScrollPos</c> to operate on a
            custom control that mimics a scroll bar. If the window does not handle the <c>SBM_GETPOS</c> message, the <c>GetScrollPos</c>
            function fails.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetScrollRange(Vanara.PInvoke.HWND,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            <para>
            The <c>GetScrollRange</c> function retrieves the current minimum and maximum scroll box (thumb) positions for the specified
            scroll bar.
            </para>
            <para>
            <c>Note</c> The <c>GetScrollRange</c> function is provided for compatibility only. New applications should use the GetScrollInfo function.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the nBar parameter.</para>
            </param>
            <param name="nBar">
            <para>Type: <c>int</c></para>
            <para>Specifies the scroll bar from which the positions are retrieved. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SB_CTL</term>
            <term>Retrieves the positions of a scroll bar control. The hWnd parameter must be the handle to the scroll bar control.</term>
            </item>
            <item>
            <term>SB_HORZ</term>
            <term>Retrieves the positions of the window's standard horizontal scroll bar.</term>
            </item>
            <item>
            <term>SB_VERT</term>
            <term>Retrieves the positions of the window's standard vertical scroll bar.</term>
            </item>
            </list>
            </param>
            <param name="lpMinPos">
            <para>Type: <c>LPINT</c></para>
            <para>Pointer to the integer variable that receives the minimum position.</para>
            </param>
            <param name="lpMaxPos">
            <para>Type: <c>LPINT</c></para>
            <para>Pointer to the integer variable that receives the maximum position.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the specified window does not have standard scroll bars or is not a scroll bar control, the <c>GetScrollRange</c> function
            copies zero to the lpMinPos and lpMaxPos parameters.
            </para>
            <para>
            The default range for a standard scroll bar is 0 through 100. The default range for a scroll bar control is empty (both values
            are zero).
            </para>
            <para>
            The messages that indicate scroll bar position, WM_HSCROLL and WM_VSCROLL, are limited to 16 bits of position data. However,
            because SetScrollInfo, SetScrollPos, SetScrollRange, GetScrollInfo, GetScrollPos, and <c>GetScrollRange</c> support 32-bit scroll
            bar position data, there is a way to circumvent the 16-bit barrier of the <c>WM_HSCROLL</c> and <c>WM_VSCROLL</c> messages. See
            the <c>GetScrollInfo</c> function for a description of the technique.
            </para>
            <para>
            If the nBar parameter is SB_CTL and the window specified by the hWnd parameter is not a system scroll bar control, the system
            sends the SBM_GETRANGE message to the window to obtain scroll bar information. This allows <c>GetScrollRange</c> to operate on a
            custom control that mimics a scroll bar. If the window does not handle the <c>SBM_GETRANGE</c> message, the <c>GetScrollRange</c>
            function fails.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ScrollDC(Vanara.PInvoke.HDC,System.Int32,System.Int32,Vanara.PInvoke.PRECT,Vanara.PInvoke.PRECT,Vanara.PInvoke.HRGN,Vanara.PInvoke.RECT@)">
            <summary>The <c>ScrollDC</c> function scrolls a rectangle of bits horizontally and vertically.</summary>
            <param name="hDC">
            <para>Type: <c>HDC</c></para>
            <para>Handle to the device context that contains the bits to be scrolled.</para>
            </param>
            <param name="dx">
            <para>Type: <c>int</c></para>
            <para>
            Specifies the amount, in device units, of horizontal scrolling. This parameter must be a negative value to scroll to the left.
            </para>
            </param>
            <param name="dy">
            <para>Type: <c>int</c></para>
            <para>Specifies the amount, in device units, of vertical scrolling. This parameter must be a negative value to scroll up.</para>
            </param>
            <param name="lprcScroll">
            <para>Type: <c>const RECT*</c></para>
            <para>
            Pointer to a RECT structure containing the coordinates of the bits to be scrolled. The only bits affected by the scroll operation
            are bits in the intersection of this rectangle and the rectangle specified by lprcClip. If lprcScroll is <c>NULL</c>, the entire
            client area is used.
            </para>
            </param>
            <param name="lprcClip">
            <para>Type: <c>const RECT*</c></para>
            <para>
            Pointer to a RECT structure containing the coordinates of the clipping rectangle. The only bits that will be painted are the bits
            that remain inside this rectangle after the scroll operation has been completed. If lprcClip is <c>NULL</c>, the entire client
            area is used.
            </para>
            </param>
            <param name="hrgnUpdate">
            <para>Type: <c>HRGN</c></para>
            <para>
            Handle to the region uncovered by the scrolling process. <c>ScrollDC</c> defines this region; it is not necessarily a rectangle.
            </para>
            </param>
            <param name="lprcUpdate">
            <para>Type: <c>LPRECT</c></para>
            <para>
            Pointer to a RECT structure that receives the coordinates of the rectangle bounding the scrolling update region. This is the
            largest rectangular area that requires repainting. When the function returns, the values in the structure are in client
            coordinates, regardless of the mapping mode for the specified device context. This allows applications to use the update region
            in a call to the InvalidateRgn function, if required.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the lprcUpdate parameter is <c>NULL</c>, the system does not compute the update rectangle. If both the hrgnUpdate and
            lprcUpdate parameters are <c>NULL</c>, the system does not compute the update region. If hrgnUpdate is not <c>NULL</c>, the
            system proceeds as though it contains a valid handle to the region uncovered by the scrolling process (defined by <c>ScrollDC</c>).
            </para>
            <para>When you must scroll the entire client area of a window, use the ScrollWindowEx function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ScrollWindow(Vanara.PInvoke.HWND,System.Int32,System.Int32,Vanara.PInvoke.PRECT,Vanara.PInvoke.RECT@)">
            <summary>
            <para>The <c>ScrollWindow</c> function scrolls the contents of the specified window's client area.</para>
            <para>
            <c>Note</c> The <c>ScrollWindow</c> function is provided for backward compatibility. New applications should use the
            ScrollWindowEx function.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>Handle to the window where the client area is to be scrolled.</para>
            </param>
            <param name="XAmount">
            <para>Type: <c>int</c></para>
            <para>
            Specifies the amount, in device units, of horizontal scrolling. If the window being scrolled has the CS_OWNDC or CS_CLASSDC
            style, then this parameter uses logical units rather than device units. This parameter must be a negative value to scroll the
            content of the window to the left.
            </para>
            </param>
            <param name="YAmount">
            <para>Type: <c>int</c></para>
            <para>
            Specifies the amount, in device units, of vertical scrolling. If the window being scrolled has the CS_OWNDC or CS_CLASSDC style,
            then this parameter uses logical units rather than device units. This parameter must be a negative value to scroll the content of
            the window up.
            </para>
            </param>
            <param name="lpRect">
            <para>Type: <c>const RECT*</c></para>
            <para>
            Pointer to the RECT structure specifying the portion of the client area to be scrolled. If this parameter is <c>NULL</c>, the
            entire client area is scrolled.
            </para>
            </param>
            <param name="lpClipRect">
            <para>Type: <c>const RECT*</c></para>
            <para>
            Pointer to the RECT structure containing the coordinates of the clipping rectangle. Only device bits within the clipping
            rectangle are affected. Bits scrolled from the outside of the rectangle to the inside are painted; bits scrolled from the inside
            of the rectangle to the outside are not painted.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the caret is in the window being scrolled, <c>ScrollWindow</c> automatically hides the caret to prevent it from being erased
            and then restores the caret after the scrolling is finished. The caret position is adjusted accordingly.
            </para>
            <para>
            The area uncovered by <c>ScrollWindow</c> is not repainted, but it is combined into the window's update region. The application
            eventually receives a WM_PAINT message notifying it that the region must be repainted. To repaint the uncovered area at the same
            time the scrolling is in action, call the UpdateWindow function immediately after calling <c>ScrollWindow</c>.
            </para>
            <para>
            If the lpRect parameter is <c>NULL</c>, the positions of any child windows in the window are offset by the amount specified by
            the XAmount and YAmount parameters; invalid (unpainted) areas in the window are also offset. <c>ScrollWindow</c> is faster when
            lpRect is <c>NULL</c>.
            </para>
            <para>
            If lpRect is not <c>NULL</c>, the positions of child windows are not changed and invalid areas in the window are not offset. To
            prevent updating problems when lpRect is not <c>NULL</c>, call UpdateWindow to repaint the window before calling <c>ScrollWindow</c>.
            </para>
            <para>Examples</para>
            <para>For an example, see Scrolling Text with the WM_PAINT Message.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ScrollWindowEx(Vanara.PInvoke.HWND,System.Int32,System.Int32,Vanara.PInvoke.PRECT,Vanara.PInvoke.PRECT,Vanara.PInvoke.HRGN,Vanara.PInvoke.RECT@,Vanara.PInvoke.User32.ScrollWindowFlags)">
            <summary>The <c>ScrollWindowEx</c> function scrolls the contents of the specified window's client area.</summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>Handle to the window where the client area is to be scrolled.</para>
            </param>
            <param name="dx">
            <para>Type: <c>int</c></para>
            <para>
            Specifies the amount, in device units, of horizontal scrolling. This parameter must be a negative value to scroll to the left.
            </para>
            </param>
            <param name="dy">
            <para>Type: <c>int</c></para>
            <para>Specifies the amount, in device units, of vertical scrolling. This parameter must be a negative value to scroll up.</para>
            </param>
            <param name="prcScroll">
            <para>Type: <c>const RECT*</c></para>
            <para>
            Pointer to a RECT structure that specifies the portion of the client area to be scrolled. If this parameter is <c>NULL</c>, the
            entire client area is scrolled.
            </para>
            </param>
            <param name="prcClip">
            <para>Type: <c>const RECT*</c></para>
            <para>
            Pointer to a RECT structure that contains the coordinates of the clipping rectangle. Only device bits within the clipping
            rectangle are affected. Bits scrolled from the outside of the rectangle to the inside are painted; bits scrolled from the inside
            of the rectangle to the outside are not painted. This parameter may be <c>NULL</c>.
            </para>
            </param>
            <param name="hrgnUpdate">
            <para>Type: <c>HRGN</c></para>
            <para>Handle to the region that is modified to hold the region invalidated by scrolling. This parameter may be <c>NULL</c>.</para>
            </param>
            <param name="prcUpdate">
            <para>Type: <c>LPRECT</c></para>
            <para>
            Pointer to a RECT structure that receives the boundaries of the rectangle invalidated by scrolling. This parameter may be <c>NULL</c>.
            </para>
            </param>
            <param name="flags">
            <para>Type: <c>UINT</c></para>
            <para>Specifies flags that control scrolling. This parameter can be a combination of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SW_ERASE</term>
            <term>
            Erases the newly invalidated region by sending a WM_ERASEBKGND message to the window when specified with the SW_INVALIDATE flag.
            </term>
            </item>
            <item>
            <term>SW_INVALIDATE</term>
            <term>Invalidates the region identified by the hrgnUpdate parameter after scrolling.</term>
            </item>
            <item>
            <term>SW_SCROLLCHILDREN</term>
            <term>
            Scrolls all child windows that intersect the rectangle pointed to by the prcScroll parameter. The child windows are scrolled by
            the number of pixels specified by the dx and dy parameters. The system sends a WM_MOVE message to all child windows that
            intersect the prcScroll rectangle, even if they do not move.
            </term>
            </item>
            <item>
            <term>SW_SMOOTHSCROLL</term>
            <term>
            Scrolls using smooth scrolling. Use the HIWORD portion of the flags parameter to indicate how much time, in milliseconds, the
            smooth-scrolling operation should take.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            If the function succeeds, the return value is SIMPLEREGION (rectangular invalidated region), COMPLEXREGION (nonrectangular
            invalidated region; overlapping rectangles), or NULLREGION (no invalidated region).
            </para>
            <para>If the function fails, the return value is ERROR. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the SW_INVALIDATE and SW_ERASE flags are not specified, <c>ScrollWindowEx</c> does not invalidate the area that is scrolled
            from. If either of these flags is set, <c>ScrollWindowEx</c> invalidates this area. The area is not updated until the application
            calls the UpdateWindow function, calls the RedrawWindow function (specifying the RDW_UPDATENOW or RDW_ERASENOW flag), or
            retrieves the WM_PAINT message from the application queue.
            </para>
            <para>
            If the window has the WS_CLIPCHILDREN style, the returned areas specified by hrgnUpdate and prcUpdate represent the total area of
            the scrolled window that must be updated, including any areas in child windows that need updating.
            </para>
            <para>
            If the SW_SCROLLCHILDREN flag is specified, the system does not properly update the screen if part of a child window is scrolled.
            The part of the scrolled child window that lies outside the source rectangle is not erased and is not properly redrawn in its new
            destination. To move child windows that do not lie completely within the rectangle specified by prcScroll, use the DeferWindowPos
            function. The cursor is repositioned if the SW_SCROLLCHILDREN flag is set and the caret rectangle intersects the scroll rectangle.
            </para>
            <para>
            All input and output coordinates (for prcScroll, prcClip, prcUpdate, and hrgnUpdate) are determined as client coordinates,
            regardless of whether the window has the CS_OWNDC or CS_CLASSDC class style. Use the LPtoDP and DPtoLP functions to convert to
            and from logical coordinates, if necessary.
            </para>
            <para>Examples</para>
            <para>For an example, see Scrolling Text with the WM_PAINT Message.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetScrollInfo(Vanara.PInvoke.HWND,System.Int32,Vanara.PInvoke.User32.SCROLLINFO@,System.Boolean)">
            <summary>
            The <c>SetScrollInfo</c> function sets the parameters of a scroll bar, including the minimum and maximum scrolling positions, the
            page size, and the position of the scroll box (thumb). The function also redraws the scroll bar, if requested.
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the fnBar parameter.</para>
            </param>
            <param name="nBar">
            <para>Type: <c>int</c></para>
            <para>Specifies the type of scroll bar for which to set parameters. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SB_CTL</term>
            <term>Sets the parameters of a scroll bar control. The hwnd parameter must be the handle to the scroll bar control.</term>
            </item>
            <item>
            <term>SB_HORZ</term>
            <term>Sets the parameters of the window's standard horizontal scroll bar.</term>
            </item>
            <item>
            <term>SB_VERT</term>
            <term>Sets the parameters of the window's standard vertical scroll bar.</term>
            </item>
            </list>
            </param>
            <param name="lpsi">
            <para>Type: <c>LPCSCROLLINFO</c></para>
            <para>
            Pointer to a SCROLLINFO structure. Before calling <c>SetScrollInfo</c>, set the <c>cbSize</c> member of the structure to
            <c>sizeof</c>( <c>SCROLLINFO</c>), set the <c>fMask</c> member to indicate the parameters to set, and specify the new parameter
            values in the appropriate members.
            </para>
            <para>The <c>fMask</c> member can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SIF_DISABLENOSCROLL</term>
            <term>Disables the scroll bar instead of removing it, if the scroll bar's new parameters make the scroll bar unnecessary.</term>
            </item>
            <item>
            <term>SIF_PAGE</term>
            <term>Sets the scroll page to the value specified in the nPage member of the SCROLLINFO structure pointed to by lpsi.</term>
            </item>
            <item>
            <term>SIF_POS</term>
            <term>Sets the scroll position to the value specified in the nPos member of the SCROLLINFO structure pointed to by lpsi.</term>
            </item>
            <item>
            <term>SIF_RANGE</term>
            <term>Sets the scroll range to the value specified in the nMin and nMax members of the SCROLLINFO structure pointed to by lpsi.</term>
            </item>
            </list>
            </param>
            <param name="redraw">
            <para>Type: <c>BOOL</c></para>
            <para>
            Specifies whether the scroll bar is redrawn to reflect the changes to the scroll bar. If this parameter is <c>TRUE</c>, the
            scroll bar is redrawn, otherwise, it is not redrawn.
            </para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>The return value is the current position of the scroll box.</para>
            </returns>
            <remarks>
            <para>
            The <c>SetScrollInfo</c> function performs range checking on the values specified by the <c>nPage</c> and <c>nPos</c> members of
            the SCROLLINFO structure. The <c>nPage</c> member must specify a value from 0 to <c>nMax</c> - <c>nMin</c> +1. The <c>nPos</c>
            member must specify a value between <c>nMin</c> and <c>nMax</c> - <c>max</c>( <c>nPage</c>– 1, 0). If either value is beyond its
            range, the function sets it to a value that is just within the range.
            </para>
            <para>
            If the fnBar parameter is SB_CTL and the window specified by the hwnd parameter is not a system scroll bar control, the system
            sends the SBM_SETSCROLLINFO message to the window to set scroll bar information (The system can optimize the message to
            SBM_SETPOS or SBM_SETRANGE if the request is solely for the position or range). This allows <c>SetScrollInfo</c> to operate on a
            custom control that mimics a scroll bar. If the window does not handle <c>SBM_SETSCROLLINFO</c> (or the optimized
            <c>SBM_SETPOS</c> message or <c>SBM_SETRANGE</c> message), then the <c>SetScrollInfo</c> function fails.
            </para>
            <para>For an example, see Scrolling Text with the WM_PAINT Message.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetScrollPos(Vanara.PInvoke.HWND,System.Int32,System.Int32,System.Boolean)">
            <summary>
            <para>
            The <c>SetScrollPos</c> function sets the position of the scroll box (thumb) in the specified scroll bar and, if requested,
            redraws the scroll bar to reflect the new position of the scroll box.
            </para>
            <para>
            <c>Note</c> The <c>SetScrollPos</c> function is provided for backward compatibility. New applications should use the
            SetScrollInfo function.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the nBar parameter.</para>
            </param>
            <param name="nBar">
            <para>Type: <c>int</c></para>
            <para>Specifies the scroll bar to be set. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SB_CTL</term>
            <term>Sets the position of the scroll box in a scroll bar control. The hwnd parameter must be the handle to the scroll bar control.</term>
            </item>
            <item>
            <term>SB_HORZ</term>
            <term>Sets the position of the scroll box in a window's standard horizontal scroll bar.</term>
            </item>
            <item>
            <term>SB_VERT</term>
            <term>Sets the position of the scroll box in a window's standard vertical scroll bar.</term>
            </item>
            </list>
            </param>
            <param name="nPos">
            <para>Type: <c>int</c></para>
            <para>
            Specifies the new position of the scroll box. The position must be within the scrolling range. For more information about the
            scrolling range, see the SetScrollRange function.
            </para>
            </param>
            <param name="bRedraw">
            <para>Type: <c>BOOL</c></para>
            <para>
            Specifies whether the scroll bar is redrawn to reflect the new scroll box position. If this parameter is <c>TRUE</c>, the scroll
            bar is redrawn. If it is <c>FALSE</c>, the scroll bar is not redrawn.
            </para>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>If the function succeeds, the return value is the previous position of the scroll box.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the scroll bar is redrawn by a subsequent call to another function, setting the bRedraw parameter to <c>FALSE</c> is useful.
            </para>
            <para>
            Because the messages that indicate scroll bar position, WM_HSCROLL and WM_VSCROLL, are limited to 16 bits of position data,
            applications that rely solely on those messages for position data have a practical maximum value of 65,535 for the
            <c>SetScrollPos</c> function's nPos parameter.
            </para>
            <para>
            However, because the SetScrollInfo, <c>SetScrollPos</c>, SetScrollRange, GetScrollInfo, GetScrollPos, and GetScrollRange
            functions support 32-bit scroll bar position data, there is a way to circumvent the 16-bit barrier of the WM_HSCROLL and
            WM_VSCROLL messages. See <c>GetScrollInfo</c> for a description of the technique.
            </para>
            <para>
            If the nBar parameter is SB_CTL and the window specified by the hWnd parameter is not a system scroll bar control, the system
            sends the SBM_SETPOS message to the window to set scroll bar information. This allows <c>SetScrollPos</c> to operate on a custom
            control that mimics a scroll bar. If the window does not handle the <c>SBM_SETPOS</c> message, the <c>SetScrollPos</c> function fails.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetScrollRange(Vanara.PInvoke.HWND,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            <para>The <c>SetScrollRange</c> function sets the minimum and maximum scroll box positions for the specified scroll bar.</para>
            <para>
            <c>Note</c> The <c>SetScrollRange</c> function is provided for backward compatibility. New applications should use the
            SetScrollInfo function.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the nBar parameter.</para>
            </param>
            <param name="nBar">
            <para>Type: <c>int</c></para>
            <para>Specifies the scroll bar to be set. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SB_CTL</term>
            <term>Sets the range of a scroll bar control. The hwnd parameter must be the handle to the scroll bar control.</term>
            </item>
            <item>
            <term>SB_HORZ</term>
            <term>Sets the range of a window's standard horizontal scroll bar.</term>
            </item>
            <item>
            <term>SB_VERT</term>
            <term>Sets the range of a window's standard vertical scroll bar.</term>
            </item>
            </list>
            </param>
            <param name="nMinPos">
            <para>Type: <c>int</c></para>
            <para>Specifies the minimum scrolling position.</para>
            </param>
            <param name="nMaxPos">
            <para>Type: <c>int</c></para>
            <para>Specifies the maximum scrolling position.</para>
            </param>
            <param name="bRedraw">
            <para>Type: <c>BOOL</c></para>
            <para>
            Specifies whether the scroll bar should be redrawn to reflect the change. If this parameter is <c>TRUE</c>, the scroll bar is
            redrawn. If it is <c>FALSE</c>, the scroll bar is not redrawn.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            You can use <c>SetScrollRange</c> to hide the scroll bar by setting nMinPos and nMaxPos to the same value. An application should
            not call the <c>SetScrollRange</c> function to hide a scroll bar while processing a scroll bar message. New applications should
            use the ShowScrollBar function to hide the scroll bar.
            </para>
            <para>
            If the call to <c>SetScrollRange</c> immediately follows a call to the SetScrollPos function, the bRedraw parameter in
            <c>SetScrollPos</c> must be zero to prevent the scroll bar from being drawn twice.
            </para>
            <para>
            The default range for a standard scroll bar is 0 through 100. The default range for a scroll bar control is empty (both the
            nMinPos and nMaxPos parameter values are zero). The difference between the values specified by the nMinPos and nMaxPos parameters
            must not be greater than the value of MAXLONG.
            </para>
            <para>
            Because the messages that indicate scroll bar position, WM_HSCROLL and WM_VSCROLL, are limited to 16 bits of position data,
            applications that rely solely on those messages for position data have a practical maximum value of 65,535 for the
            <c>SetScrollRange</c> function's nMaxPos parameter.
            </para>
            <para>
            However, because the SetScrollInfo, SetScrollPos, <c>SetScrollRange</c>, GetScrollInfo, GetScrollPos, and GetScrollRange
            functions support 32-bit scroll bar position data, there is a way to circumvent the 16-bit barrier of the WM_HSCROLL and
            WM_VSCROLL messages. See <c>GetScrollInfo</c> for a description of the technique.
            </para>
            <para>
            If the nBar parameter is SB_CTL and the window specified by the hWnd parameter is not a system scroll bar control, the system
            sends the SBM_SETRANGE message to the window to set scroll bar information. This allows <c>SetScrollRange</c> to operate on a
            custom control that mimics a scroll bar. If the window does not handle the <c>SBM_SETRANGE</c> message, the <c>SetScrollRange</c>
            function fails.
            </para>
            <para>Examples</para>
            <para>For an example, see Using the Owner-Display Clipboard Format.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ShowScrollBar(Vanara.PInvoke.HWND,System.Int32,System.Boolean)">
            <summary>The <c>ShowScrollBar</c> function shows or hides the specified scroll bar.</summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the wBar parameter.</para>
            </param>
            <param name="wBar">
            <para>Type: <c>int</c></para>
            <para>Specifies the scroll bar(s) to be shown or hidden. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SB_BOTH</term>
            <term>Shows or hides a window's standard horizontal and vertical scroll bars.</term>
            </item>
            <item>
            <term>SB_CTL</term>
            <term>Shows or hides a scroll bar control. The hwnd parameter must be the handle to the scroll bar control.</term>
            </item>
            <item>
            <term>SB_HORZ</term>
            <term>Shows or hides a window's standard horizontal scroll bars.</term>
            </item>
            <item>
            <term>SB_VERT</term>
            <term>Shows or hides a window's standard vertical scroll bar.</term>
            </item>
            </list>
            </param>
            <param name="bShow">
            <para>Type: <c>BOOL</c></para>
            <para>
            Specifies whether the scroll bar is shown or hidden. If this parameter is <c>TRUE</c>, the scroll bar is shown; otherwise, it is hidden.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>You should not call this function to hide a scroll bar while processing a scroll bar message.</remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.SCROLLBARINFO">
            <summary>The <c>SCROLLBARINFO</c> structure contains scroll bar information.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SCROLLBARINFO.cbSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            Specifies the size, in bytes, of the structure. Before calling the GetScrollBarInfo function, set <c>cbSize</c> to
            <c>sizeof</c>( <c>SCROLLBARINFO</c>).
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SCROLLBARINFO.rcScrollBar">
            <summary>
            <para>Type: <c>RECT</c></para>
            <para>Coordinates of the scroll bar as specified in a RECT structure.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SCROLLBARINFO.dxyLineButton">
            <summary>
            <para>Type: <c>int</c></para>
            <para>Height or width of the thumb.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SCROLLBARINFO.xyThumbTop">
            <summary>
            <para>Type: <c>int</c></para>
            <para>Position of the top or left of the thumb.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SCROLLBARINFO.xyThumbBottom">
            <summary>
            <para>Type: <c>int</c></para>
            <para>Position of the bottom or right of the thumb.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SCROLLBARINFO.reserved">
            <summary>
            <para>Type: <c>int</c></para>
            <para>Reserved.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SCROLLBARINFO.rgstate">
            <summary>
            <para>Type: <c>DWORD[CCHILDREN_SCROLLBAR+1]</c></para>
            <para>
            An array of <c>DWORD</c> elements. Each element indicates the state of a scroll bar component. The following values show the
            scroll bar component that corresponds to each array index.
            </para>
            <list type="table">
            <listheader>
            <term>Index</term>
            <term>Scroll bar component</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The scroll bar itself.</term>
            </item>
            <item>
            <term>1</term>
            <term>The top or right arrow button.</term>
            </item>
            <item>
            <term>2</term>
            <term>The page up or page right region.</term>
            </item>
            <item>
            <term>3</term>
            <term>The scroll box (thumb).</term>
            </item>
            <item>
            <term>4</term>
            <term>The page down or page left region.</term>
            </item>
            <item>
            <term>5</term>
            <term>The bottom or left arrow button.</term>
            </item>
            </list>
            <para>The <c>DWORD</c> element for each scroll bar component can include a combination of the following bit flags.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>STATE_SYSTEM_INVISIBLE</term>
            <term>
            For the scroll bar itself, indicates the specified vertical or horizontal scroll bar does not exist. For the page up or page
            down regions, indicates the thumb is positioned such that the region does not exist.
            </term>
            </item>
            <item>
            <term>STATE_SYSTEM_OFFSCREEN</term>
            <term>
            For the scroll bar itself, indicates the window is sized such that the specified vertical or horizontal scroll bar is not
            currently displayed.
            </term>
            </item>
            <item>
            <term>STATE_SYSTEM_PRESSED</term>
            <term>The arrow button or page region is pressed.</term>
            </item>
            <item>
            <term>STATE_SYSTEM_UNAVAILABLE</term>
            <term>The component is disabled.</term>
            </item>
            </list>
            </summary>
            <value>The <see cref="T:System.UInt32"/>.</value>
            <returns></returns>
        </member>
        <member name="T:Vanara.PInvoke.User32.SCROLLINFO">
            <summary>
            The <c>SCROLLINFO</c> structure contains scroll bar parameters to be set by the SetScrollInfo function (or SBM_SETSCROLLINFO
            message), or retrieved by the GetScrollInfo function (or SBM_GETSCROLLINFO message).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SCROLLINFO.cbSize">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>Specifies the size, in bytes, of this structure. The caller must set this to sizeof( <c>SCROLLINFO</c>).</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SCROLLINFO.fMask">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>Specifies the scroll bar parameters to set or retrieve. This member can be a combination of the following values:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SIF_ALL</term>
            <term>Combination of SIF_PAGE, SIF_POS, SIF_RANGE, and SIF_TRACKPOS.</term>
            </item>
            <item>
            <term>SIF_DISABLENOSCROLL</term>
            <term>
            This value is used only when setting a scroll bar's parameters. If the scroll bar's new parameters make the scroll bar
            unnecessary, disable the scroll bar instead of removing it.
            </term>
            </item>
            <item>
            <term>SIF_PAGE</term>
            <term>The nPage member contains the page size for a proportional scroll bar.</term>
            </item>
            <item>
            <term>SIF_POS</term>
            <term>The nPos member contains the scroll box position, which is not updated while the user drags the scroll box.</term>
            </item>
            <item>
            <term>SIF_RANGE</term>
            <term>The nMin and nMax members contain the minimum and maximum values for the scrolling range.</term>
            </item>
            <item>
            <term>SIF_TRACKPOS</term>
            <term>The nTrackPos member contains the current position of the scroll box while the user is dragging it.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SCROLLINFO.nMin">
            <summary>
            <para>Type: <c>int</c></para>
            <para>Specifies the minimum scrolling position.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SCROLLINFO.nMax">
            <summary>
            <para>Type: <c>int</c></para>
            <para>Specifies the maximum scrolling position.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SCROLLINFO.nPage">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>
            Specifies the page size, in device units. A scroll bar uses this value to determine the appropriate size of the proportional
            scroll box.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SCROLLINFO.nPos">
            <summary>
            <para>Type: <c>int</c></para>
            <para>Specifies the position of the scroll box.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SCROLLINFO.nTrackPos">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            Specifies the immediate position of a scroll box that the user is dragging. An application can retrieve this value while
            processing the SB_THUMBTRACK request code. An application cannot set the immediate scroll position; the SetScrollInfo
            function ignores this member.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.StaticMessage">
            <summary>Static Control Messages</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticMessage.STM_SETICON">
            <summary>
            An application sends the <c>STM_SETICON</c> message to associate an icon with an icon control.
            <list type="bullet">
            <item>
            <term>wParam</term>
            <description>Handle to the icon to associate with the icon control.</description>
            </item>
            <item>
            <term>lParam</term>
            <description>This parameter is not used.</description>
            </item>
            <item>
            <term>Returns</term>
            <description>
            The return value is a handle to the icon previously associated with the icon control, or zero if an error occurs.
            </description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticMessage.STM_GETICON">
            <summary>
            An application sends the <c>STM_GETICON</c> message to retrieve a handle to the icon associated with a static control that
            has the SS_ICON style.
            <list type="bullet">
            <item>
            <term>wParam</term>
            <description>Not used; must be zero.</description>
            </item>
            <item>
            <term>lParam</term>
            <description>Not used; must be zero.</description>
            </item>
            <item>
            <term>Returns</term>
            <description>
            The return value is a handle to the icon, or <c>NULL</c> if either the static control has no associated icon or if an error occurred.
            </description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticMessage.STM_SETIMAGE">
            <summary>
            An application sends an <c>STM_SETIMAGE</c> message to associate a new image with a static control.
            <list type="bullet">
            <item>
            <term>wParam</term>
            <description>
            Specifies the type of image to associate with the static control. This parameter can be one of the following values:
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <description>IMAGE_BITMAP</description>
            <description>Bitmap.</description>
            </item>
            <item>
            <description>IMAGE_CURSOR</description>
            <description>Cursor.</description>
            </item>
            <item>
            <description>IMAGE_ENHMETAFILE</description>
            <description>Enhanced metafile.</description>
            </item>
            <item>
            <description>IMAGE_ICON</description>
            <description>Icon.</description>
            </item>
            </list>
            </description>
            </item>
            <item>
            <term>lParam</term>
            <description>Handle to the image to associate with the static control.</description>
            </item>
            <item>
            <term>Returns</term>
            <description>
            The return value is a handle to the image previously associated with the static control, if any; otherwise, it is <c>NULL</c>.
            </description>
            </item>
            </list>
            </summary>
            <remarks>
            <para>
            To associate an image with a static control, the control must have the proper style. The following table shows the style
            needed for each image type.
            </para>
            <list type="table">
            <listheader>
            <term>Image type</term>
            <term>Static control style</term>
            </listheader>
            <item>
            <description>IMAGE_BITMAP</description>
            <description>SS_BITMAP</description>
            </item>
            <item>
            <description>IMAGE_CURSOR</description>
            <description>SS_ICON</description>
            </item>
            <item>
            <description>IMAGE_ENHMETAFILE</description>
            <description>SS_ENHMETAFILE</description>
            </item>
            <item>
            <description>IMAGE_ICON</description>
            <description>SS_ICON</description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticMessage.STM_GETIMAGE">
            <summary>
            An application sends an <c>STM_GETIMAGE</c> message to retrieve a handle to the image (icon or bitmap) associated with a
            static control.
            <list type="bullet">
            <item>
            <term>wParam</term>
            <description>Specifies the type of image to retrieve. This parameter can be one of the following values:
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <description>IMAGE_BITMAP</description>
            <description>Bitmap.</description>
            </item>
            <item>
            <description>IMAGE_CURSOR</description>
            <description>Cursor.</description>
            </item>
            <item>
            <description>IMAGE_ENHMETAFILE</description>
            <description>Enhanced metafile.</description>
            </item>
            <item>
            <description>IMAGE_ICON</description>
            <description>Icon.</description>
            </item>
            </list>
            </description>
            </item>
            <item>
            <term>lParam</term>
            <description>This parameter is not used.</description>
            </item>
            <item>
            <term>Returns</term>
            <description>The return value is a handle to the image, if any; otherwise, it is <c>NULL</c>.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.StaticNotification">
            <summary>Static Control Notifications</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticNotification.STN_CLICKED">
            <summary>
            <para>
            The STN_CLICKED notification code is sent when the user clicks a static control that has the <c>SS_NOTIFY</c> style. The
            parent window of the control receives this notification code through the <c>WM_COMMAND</c> message.
            </para>
            <code lang="cs">STN_CLICKED WPARAM wParam; LPARAM lParam;</code>
            <list type="bullet">
            <item>
            <term>wParam</term>
            <description>
            The <c>LOWORD</c> contains the identifier of the static control. The <c>HIWORD</c> specifies the notification code.
            </description>
            </item>
            <item>
            <term>lParam</term>
            <description>Handle to the static control.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticNotification.STN_DBLCLK">
            <summary>
            <para>
            The STN_DBLCLK notification code is sent when the user double-clicks a static control that has the <c>SS_NOTIFY</c> style.
            The parent window of the control receives this notification code through the <c>WM_COMMAND</c> message.
            </para>
            <code lang="cs">STN_DBLCLK WPARAM wParam; LPARAM lParam;</code>
            <list type="bullet">
            <item>
            <term>wParam</term>
            <description>
            The <c>LOWORD</c> contains the identifier of the static control. The <c>HIWORD</c> specifies the notification code.
            </description>
            </item>
            <item>
            <term>lParam</term>
            <description>Handle to the static control.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticNotification.STN_ENABLE">
            <summary>
            <para>
            The STN_ENABLE notification code is sent when a static control is enabled. The static control must have the <c>SS_NOTIFY</c>
            style to receive this notification code. The parent window of the control receives this notification code through the
            <c>WM_COMMAND</c> message.
            </para>
            <para>
            <code lang="cs">STN_ENABLE WPARAM wParam; LPARAM lParam;</code>
            </para>
            <list type="bullet">
            <item>
            <term>wParam</term>
            <description>
            The <c>LOWORD</c> contains the identifier of the static control. The <c>HIWORD</c> specifies the notification code.
            </description>
            </item>
            <item>
            <term>lParam</term>
            <description>Handle to the static control.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticNotification.STN_DISABLE">
            <summary>
            <para>
            The STN_DISABLE notification code is sent when a static control is disabled. The static control must have the
            <c>SS_NOTIFY</c> style to receive this notification code. The parent window of the control receives this notification code
            through the <c>WM_COMMAND</c> message.
            </para>
            <para>
            <code lang="cs">STN_DISABLE WPARAM wParam; LPARAM lParam;</code>
            </para>
            <list type="bullet">
            <item>
            <term>wParam</term>
            <description>
            The <c>LOWORD</c> contains the identifier of the static control. The <c>HIWORD</c> specifies the notification code.
            </description>
            </item>
            <item>
            <term>lParam</term>
            <description>Handle to the static control.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.StaticStyle">
            <summary>
            To create a static control using the <c>CreateWindow</c> or <c>CreateWindowEx</c> function, specify the STATIC class,
            appropriate window style constants, and a combination of the following static control styles.
            </summary>
            <remarks>
            To use a style which truncates words or strings with an ellipsis for multiline text, <c>DrawThemeText</c> or <c>DrawText</c> can
            be used on a owner-draw control with formatting flags <c>DT_WORDBREAK</c> and <c>DT_ENDELLIPSIS</c> set.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_BITMAP">
            <summary>
            A bitmap is to be displayed in the static control. The text is the name of a bitmap (not a filename) defined elsewhere in
            the resource file. The style ignores the nWidth and nHeight parameters; the control automatically sizes itself to
            accommodate the bitmap.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_BLACKFRAME">
            <summary>A box with a frame drawn in the same color as the window frames. This color is black in the default color scheme.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_BLACKRECT">
            <summary>A rectangle filled with the current window frame color. This color is black in the default color scheme.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_CENTER">
            <summary>
            A simple rectangle and centers the text in the rectangle. The text is formatted before it is displayed. Words that extend
            past the end of a line are automatically wrapped to the beginning of the next centered line. Words that are longer than the
            width of the control are truncated.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_CENTERIMAGE">
            <summary>
            A bitmap is centered in the static control that contains it. The control is not resized, so that a bitmap too large for the
            control will be clipped. If the static control contains a single line of text, the text is centered vertically in the client
            area of the control.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_EDITCONTROL">
            <summary>
            The static control duplicates the text-displaying characteristics of a multiline edit control. Specifically, the average
            character width is calculated in the same manner as with an edit control, and the function does not display a partially
            visible last line.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_ENDELLIPSIS">
            <summary>
            If the end of a string does not fit in the rectangle, it is truncated and ellipses are added. If a word that is not at the
            end of the string goes beyond the limits of the rectangle, it is truncated without ellipses. Using this style will force the
            control s text to be on one line with no word wrap. Compare with SS_PATHELLIPSIS and SS_WORDELLIPSIS.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_ENHMETAFILE">
            <summary>
            An enhanced metafile is to be displayed in the static control. The text is the name of a metafile. An enhanced metafile
            static control has a fixed size; the metafile is scaled to fit the static control's client area.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_ETCHEDFRAME">
            <summary>
            Draws the frame of the static control using the EDGE_ETCHED edge style. For more information, see the DrawEdge function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_ETCHEDHORZ">
            <summary>
            Draws the top and bottom edges of the static control using the EDGE_ETCHED edge style. For more information, see the
            DrawEdge function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_ETCHEDVERT">
            <summary>
            Draws the left and right edges of the static control using the EDGE_ETCHED edge style. For more information, see the
            DrawEdge function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_GRAYFRAME">
            <summary>
            A box with a frame drawn with the same color as the screen background (desktop). This color is gray in the default color scheme.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_GRAYRECT">
            <summary>A rectangle filled with the current screen background color. This color is gray in the default color scheme.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_ICON">
            <summary>
            An icon to be displayed in the dialog box. If the control is created as part of a dialog box, the text is the name of an
            icon (not a filename) defined elsewhere in the resource file. If the control is created via CreateWindow or a related
            function, the text is the name of an icon (not a filename) defined in the resource file associated with the module specified
            by the hInstance parameter to CreateWindow.
            <para>The icon can be an animated cursor.</para>
            <para>
            The style ignores the CreateWindow parameters nWidth and nHeight; the control automatically sizes itself to accommodate the
            icon. As it uses the LoadIcon function, the SS_ICON style can load only icons of dimensions SM_CXICON and SM_CYICON. This
            restriction can be bypassed by using the SS_REALSIZEIMAGE style in addition to SS_ICON.
            </para>
            <para>
            If an icon cannot be loaded through LoadIcon, an attempt is made to load the specified resource as a cursor using
            LoadCursor. If that too fails, an attempt is made to load from the device driver using LoadImage.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_LEFT">
            <summary>
            A simple rectangle and left-aligns the text in the rectangle. The text is formatted before it is displayed. Words that
            extend past the end of a line are automatically wrapped to the beginning of the next left-aligned line. Words that are
            longer than the width of the control are truncated.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_LEFTNOWORDWRAP">
            <summary>
            A simple rectangle and left-aligns the text in the rectangle. Tabs are expanded, but words are not wrapped. Text that
            extends past the end of a line is clipped.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_NOPREFIX">
            <summary>Prevents interpretation of any ampersand (&amp;) characters in the control's text as accelerator prefix characters.
            These are displayed with the ampersand removed and the next character in the string underlined. This static control style
            may be included with any of the defined static controls. You can combine SS_NOPREFIX with other styles. This can be useful
            when filenames or other strings that may contain an ampersand (&amp;) must be displayed in a static control in a dialog box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_NOTIFY">
            <summary>
            Sends the parent window STN_CLICKED, STN_DBLCLK, STN_DISABLE, and STN_ENABLE notification codes when the user clicks or
            double-clicks the control.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_OWNERDRAW">
            <summary>
            The owner of the static control is responsible for drawing the control. The owner window receives a WM_DRAWITEM message
            whenever the control needs to be drawn.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_PATHELLIPSIS">
            <summary>
            Replaces characters in the middle of the string with ellipses so that the result fits in the specified rectangle. If the
            string contains backslash () characters, SS_PATHELLIPSIS preserves as much as possible of the text after the last backslash.
            Using this style will force the control s text to be on one line with no word wrap. Compare with SS_ENDELLIPSIS and SS_WORDELLIPSIS.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_REALSIZECONTROL">
            <summary>
            Adjusts the bitmap to fit the size of the static control. For example, changing the locale can change the system font, and
            thus controls might be resized. If a static control had a bitmap, the bitmap would no longer fit the control. This style bit
            dictates automatic redimensioning of bitmaps to fit their controls.
            <para>
            If SS_CENTERIMAGE is specified, the bitmap or icon is centered (and clipped if needed). If SS_CENTERIMAGE is not specified,
            the bitmap or icon is stretched or shrunk.
            </para>
            <para>Note that the redimensioning in the two axes are independent, and the result may have a changed aspect ratio.</para>
            <para>Compare with SS_REALSIZEIMAGE.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_REALSIZEIMAGE">
            <summary>
            Specifies that the actual resource width is used and the icon is loaded using LoadImage. SS_REALSIZEIMAGE is always used in
            conjunction with SS_ICON.
            <para>
            SS_REALSIZEIMAGE uses LoadImage, overriding the process normally followed under SS_ICON. It does not load cursors; if
            LoadImage fails, no further attempts to load are made. It uses the actual resource width. The static control is resized
            accordingly, but the icon remains aligned to the originally specified left and top edges of the control.
            </para>
            <para>
            Note that if SS_CENTERIMAGE is also specified, the icon is centered within the control's space, which was specified using
            the CreateWindow parameters nWidth and nHeight.
            </para>
            <para>Compare with SS_REALSIZECONTROL.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_RIGHT">
            <summary>
            A simple rectangle and right-aligns the text in the rectangle. The text is formatted before it is displayed. Words that
            extend past the end of a line are automatically wrapped to the beginning of the next right-aligned line. Words that are
            longer than the width of the control are truncated.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_RIGHTJUST">
            <summary>
            The lower right corner of a static control with the SS_BITMAP or SS_ICON style is to remain fixed when the control is
            resized. Only the top and left sides are adjusted to accommodate a new bitmap or icon.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_SIMPLE">
            <summary>
            A simple rectangle and displays a single line of left-aligned text in the rectangle. The text line cannot be shortened or
            altered in any way. Also, if the control is disabled, the control does not gray its text.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_SUNKEN">
            <summary>Draws a half-sunken border around a static control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_TYPEMASK">
            <summary>
            A composite style bit that results from using the OR operator on SS_* style bits. Can be used to mask out valid SS_* bits
            from a given bitmask. Note that this is out of date and does not correctly include all valid styles. Thus, you should not
            use this style.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_WHITEFRAME">
            <summary>
            A box with a frame drawn with the same color as the window background. This color is white in the default color scheme.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_WHITERECT">
            <summary>A rectangle filled with the current window background color. This color is white in the default color scheme.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.StaticStyle.SS_WORDELLIPSIS">
            <summary>
            Truncates any word that does not fit in the rectangle and adds ellipses. Using this style will force the control s text to
            be on one line with no word wrap.
            <para>Compare with SS_ENDELLIPSIS and SS_PATHELLIPSIS.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MsgBoxCallback">
            <summary>Callback function that processes help events for the message box.</summary>
            <param name="lpHelpInfo">The help information.</param>
        </member>
        <member name="T:Vanara.PInvoke.User32.ARW">
            <summary>The starting position and direction used when arranging minimized windows.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ARW.ARW_BOTTOMLEFT">
            <summary>Start at the lower-left corner of the work area.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ARW.ARW_BOTTOMRIGHT">
            <summary>Start at the lower-right corner of the work area.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ARW.ARW_TOPLEFT">
            <summary>Start at the upper-left corner of the work area.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ARW.ARW_TOPRIGHT">
            <summary>Start at the upper-right corner of the work area.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ARW.ARW_LEFT">
            <summary>Arrange left (valid with ARW_BOTTOMRIGHT and ARW_TOPRIGHT only).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ARW.ARW_RIGHT">
            <summary>Arrange right (valid with ARW_BOTTOMLEFT and ARW_TOPLEFT only).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ARW.ARW_UP">
            <summary>Arrange up (valid with ARW_BOTTOMLEFT and ARW_BOTTOMRIGHT only).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ARW.ARW_DOWN">
            <summary>Arrange down (valid with ARW_TOPLEFT and ARW_TOPRIGHT only).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ARW.ARW_HIDE">
            <summary>Hide minimized windows by moving them off the visible area of the screen.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ATF">
            <summary>A set of bit flags that specify properties of the time-out behavior for accessibility features.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ATF.ATF_TIMEOUTON">
            <summary>
            If this flag is set, a time-out period has been set for accessibility features. If this flag is not set, the features will
            not time out even though a time-out period is specified.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ATF.ATF_ONOFFFEEDBACK">
            <summary>
            If this flag is set, the operating system plays a descending siren sound when the time-out period elapses and the
            accessibility features are turned off.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ContactVisualization">
            <summary>Enum for SystemParametersInfo</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ContactVisualization.CONTACTVISUALIZATION_OFF">
            <summary>Specifies UI feedback for all contacts is off.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ContactVisualization.CONTACTVISUALIZATION_ON">
            <summary>Specifies UI feedback for all contacts is on.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ContactVisualization.CONTACTVISUALIZATION_PRESENTATIONMODE">
            <summary>Specifies UI feedback for all contacts is on with presentation mode visuals.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ExitWindowsFlags">
            <summary>The shutdown type for the <see cref="M:Vanara.PInvoke.User32.ExitWindowsEx(Vanara.PInvoke.User32.ExitWindowsFlags,Vanara.PInvoke.SystemShutDownReason)"/> method.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ExitWindowsFlags.EWX_LOGOFF">
            <summary>
            Shuts down all processes running in the logon session of the process that called the ExitWindowsEx function. Then it logs the
            user off.
            <para>This flag can be used only by processes running in an interactive user's logon session.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ExitWindowsFlags.EWX_SHUTDOWN">
            <summary>
            Shuts down the system to a point at which it is safe to turn off the power. All file buffers have been flushed to disk, and
            all running processes have stopped.
            <para>The calling process must have the SE_SHUTDOWN_NAME privilege. For more information, see the following Remarks section.</para>
            <para>
            Specifying this flag will not turn off the power even if the system supports the power-off feature. You must specify
            EWX_POWEROFF to do this.
            </para>
            <para>Windows XP with SP1: If the system supports the power-off feature, specifying this flag turns off the power.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ExitWindowsFlags.EWX_REBOOT">
            <summary>
            Shuts down the system and then restarts the system.
            <para>The calling process must have the SE_SHUTDOWN_NAME privilege. For more information, see the following Remarks section.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ExitWindowsFlags.EWX_FORCE">
            <summary>
            This flag has no effect if terminal services is enabled. Otherwise, the system does not send the WM_QUERYENDSESSION message.
            This can cause applications to lose data. Therefore, you should only use this flag in an emergency.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ExitWindowsFlags.EWX_POWEROFF">
            <summary>
            Shuts down the system and turns off the power. The system must support the power-off feature.
            <para>The calling process must have the SE_SHUTDOWN_NAME privilege. For more information, see the following Remarks section.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ExitWindowsFlags.EWX_FORCEIFHUNG">
            <summary>
            Forces processes to terminate if they do not respond to the WM_QUERYENDSESSION or WM_ENDSESSION message within the timeout
            interval. For more information, see the Remarks.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ExitWindowsFlags.EWX_QUICKRESOLVE">
            <summary>The ewx quickresolve</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ExitWindowsFlags.EWX_RESTARTAPPS">
            <summary>
            Shuts down the system and then restarts it, as well as any applications that have been registered for restart using the
            RegisterApplicationRestart function. These application receive the WM_QUERYENDSESSION message with lParam set to the
            ENDSESSION_CLOSEAPP value. For more information, see Guidelines for Applications.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ExitWindowsFlags.EWX_HYBRID_SHUTDOWN">
            <summary>
            Beginning with Windows 8: You can prepare the system for a faster startup by combining the EWX_HYBRID_SHUTDOWN flag with the
            EWX_SHUTDOWN flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ExitWindowsFlags.EWX_BOOTOPTIONS">
            <summary>When combined with the EWX_REBOOT flag, will reboot to the boot options.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.FKF">
            <summary>A set of bit flags that specify properties of the FilterKeys feature.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FKF.FKF_AVAILABLE">
            <summary>The FilterKeys features are available.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FKF.FKF_CLICKON">
            <summary>
            The computer makes a click sound when a key is pressed or accepted. If SlowKeys is on, a click is generated when the key is
            pressed and again when the keystroke is accepted.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FKF.FKF_CONFIRMHOTKEY">
            <summary>
            Windows 95/98, Windows 2000: A confirmation dialog box appears when the FilterKeys features are activated by using the hot key.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FKF.FKF_FILTERKEYSON">
            <summary>The FilterKeys features are on.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FKF.FKF_HOTKEYACTIVE">
            <summary>The user can turn the FilterKeys feature on and off by holding down the RIGHT SHIFT key for eight seconds.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FKF.FKF_HOTKEYSOUND">
            <summary>
            If this flag is set, the computer plays a siren sound when the user turns the FilterKeys feature on or off by using the hot key.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FKF.FKF_INDICATOR">
            <summary>Windows 95, Windows 2000: A visual indicator is displayed when the FilterKeys features are on.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.GestureVisualization">
            <summary>Enum for SystemParametersInfo</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GestureVisualization.GESTUREVISUALIZATION_OFF">
            <summary>Specifies that UI feedback for all gestures is off.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GestureVisualization.GESTUREVISUALIZATION_ON">
            <summary>Specifies that UI feedback for all gestures is on.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GestureVisualization.GESTUREVISUALIZATION_TAP">
            <summary>Specifies UI feedback for a tap.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GestureVisualization.GESTUREVISUALIZATION_DOUBLETAP">
            <summary>Specifies UI feedback for a double tap.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GestureVisualization.GESTUREVISUALIZATION_PRESSANDTAP">
            <summary>Specifies UI feedback for a press and tap.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GestureVisualization.GESTUREVISUALIZATION_PRESSANDHOLD">
            <summary>Specifies UI feedback for a press and hold.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GestureVisualization.GESTUREVISUALIZATION_RIGHTTAP">
            <summary>Specifies UI feedback for a right tap.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.HANDEDNESS">
            <summary>Enum for SystemParametersInfo</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HANDEDNESS.HANDEDNESS_LEFT">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HANDEDNESS.HANDEDNESS_RIGHT">
            <summary>Undocumented</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.HELPINFOCONTEXT">
            <summary>Values used by HELPINFO.iContextType specifying the type of context for which Help is requested.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HELPINFOCONTEXT.HELPINFO_MENUITEM">
            <summary>Help requested for a menu item.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HELPINFOCONTEXT.HELPINFO_WINDOW">
            <summary>Help requested for a control or window.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.HFC">
            <summary>A set of bit flags that specify properties of the HighContrast feature.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HFC.HCF_AVAILABLE">
            <summary>The high contrast feature is available.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HFC.HCF_CONFIRMHOTKEY">
            <summary>A confirmation dialog appears when the high contrast feature is activated by using the hot key.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HFC.HCF_HIGHCONTRASTON">
            <summary>The high contrast feature is on.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HFC.HCF_HOTKEYACTIVE">
            <summary>
            The user can turn the high contrast feature on and off by simultaneously pressing the left ALT, left SHIFT, and PRINT SCREEN keys.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HFC.HCF_HOTKEYAVAILABLE">
            <summary>
            The hot key associated with the high contrast feature can be enabled. An application can retrieve this value, but cannot set it.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HFC.HCF_HOTKEYSOUND">
            <summary>A siren is played when the user turns the high contrast feature on or off by using the hot key.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HFC.HCF_INDICATOR">
            <summary>
            A visual indicator is displayed when the high contrast feature is on. This value is not currently used and is ignored.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HFC.HCF_LOGONDESKTOP">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HFC.HCF_DEFAULTDESKTOP">
            <summary>Undocumented</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MB_FLAGS">
            <summary>Specifies the contents and behavior of a message box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_ABORTRETRYIGNORE">
            <summary>The message box contains three push buttons: Abort, Retry, and Ignore.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_CANCELTRYCONTINUE">
            <summary>
            The message box contains three push buttons: Cance, Try Again, Continue. Use this message box type instead of MB_ABORTRETRYIGNORE.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_HELP">
            <summary>
            Adds a Help button to the message box. When the user clicks the Help button or presses F1, the system sends a WM_HELP message
            to the owner.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_OK">
            <summary>The message box contains one push button: OK. This is the default.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_OKCANCEL">
            <summary>The message box contains two push buttons: OK and Cancel.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_RETRYCANCEL">
            <summary>The message box contains two push buttons: Retry and Cancel.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_YESNO">
            <summary>The message box contains two push buttons: Yes and No.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_YESNOCANCEL">
            <summary>The message box contains three push buttons: Yes, No, and Cancel.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_ICONEXCLAMATION">
            <summary>An exclamation-point icon appears in the message box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_ICONWARNING">
            <summary>An exclamation-point icon appears in the message box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_ICONINFORMATION">
            <summary>An icon consisting of a lowercase letter i in a circle appears in the message box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_ICONASTERISK">
            <summary>An icon consisting of a lowercase letter i in a circle appears in the message box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_ICONQUESTION">
            <summary>
            A question-mark icon appears in the message box. The question-mark message icon is no longer recommended because it does not
            clearly represent a specific type of message and because the phrasing of a message as a question could apply to any message
            type. In addition, users can confuse the message symbol question mark with Help information. Therefore, do not use this
            question mark message symbol in your message boxes. The system continues to support its inclusion only for backward compatibility.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_ICONSTOP">
            <summary>A stop-sign icon appears in the message box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_ICONERROR">
            <summary>A stop-sign icon appears in the message box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_ICONHAND">
            <summary>A stop-sign icon appears in the message box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_DEFBUTTON1">
            <summary>
            The first button is the default button.
            <para>MB_DEFBUTTON1 is the default unless MB_DEFBUTTON2, MB_DEFBUTTON3, or MB_DEFBUTTON4 is specified.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_DEFBUTTON2">
            <summary>The second button is the default button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_DEFBUTTON3">
            <summary>The third button is the default button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_DEFBUTTON4">
            <summary>The fourth button is the default button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_APPLMODAL">
            <summary>
            The user must respond to the message box before continuing work in the window identified by the hWnd parameter. However, the
            user can move to the windows of other threads and work in those windows.
            <para>
            Depending on the hierarchy of windows in the application, the user may be able to move to other windows within the thread.
            All child windows of the parent of the message box are automatically disabled, but pop-up windows are not.
            </para>
            <para>MB_APPLMODAL is the default if neither MB_SYSTEMMODAL nor MB_TASKMODAL is specified.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_SYSTEMMODAL">
            <summary>
            Same as MB_APPLMODAL except that the message box has the WS_EX_TOPMOST style. Use system-modal message boxes to notify the
            user of serious, potentially damaging errors that require immediate attention (for example, running out of memory). This flag
            has no effect on the user's ability to interact with windows other than those associated with hWnd.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_TASKMODAL">
            <summary>
            Same as MB_APPLMODAL except that all the top-level windows belonging to the current thread are disabled if the hWnd parameter
            is NULL. Use this flag when the calling application or library does not have a window handle available but still needs to
            prevent input to other windows in the calling thread without suspending other threads.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_DEFAULT_DESKTOP_ONLY">
            <summary>
            Same as desktop of the interactive window station. For more information, see Window Stations.
            <para>
            If the current input desktop is not the default desktop, MessageBox does not return until the user switches to the default desktop.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_RIGHT">
            <summary>The text is right-justified.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_RTLREADING">
            <summary>Displays message and caption text using right-to-left reading order on Hebrew and Arabic systems.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_SETFOREGROUND">
            <summary>
            The message box becomes the foreground window. Internally, the system calls the SetForegroundWindow function for the message box.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_TOPMOST">
            <summary>The message box is created with the WS_EX_TOPMOST window style.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_FLAGS.MB_SERVICE_NOTIFICATION">
            <summary>
            The caller is a service notifying the user of an event. The function displays a message box on the current active desktop,
            even if there is no user logged on to the computer.
            <para>
            Terminal Services: If the calling thread has an impersonation token, the function directs the message box to the session
            specified in the impersonation token.
            </para>
            <para>
            If this flag is set, the hWnd parameter must be NULL. This is so that the message box can appear on a desktop other than the
            desktop corresponding to the hWnd.
            </para>
            <para>
            For information on security considerations in regard to using this flag, see Interactive Services. In particular, be aware
            that this flag can produce interactive content on a locked desktop and should therefore be used for only a very limited set
            of scenarios, such as resource exhaustion.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MB_RESULT">
            <summary>Specifies the contents and behavior of a message box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_RESULT.IDABORT">
            <summary>The Abort button was selected.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_RESULT.IDCANCEL">
            <summary>The Cancel button was selected.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_RESULT.IDCONTINUE">
            <summary>The Continue button was selected.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_RESULT.IDIGNORE">
            <summary>The Ignore button was selected.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_RESULT.IDNO">
            <summary>The No button was selected.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_RESULT.IDOK">
            <summary>The OK button was selected.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_RESULT.IDRETRY">
            <summary>The Retry button was selected.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_RESULT.IDTRYAGAIN">
            <summary>The Try Again button was selected.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_RESULT.IDYES">
            <summary>The Yes button was selected.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MB_RESULT.MB_TIMEDOUT">
            <summary>A call to <c>MessageBoxTimeout</c> has timed-out.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MKF">
            <summary>A set of bit-flags that specify properties of the MouseKeys feature.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MKF.MKF_AVAILABLE">
            <summary>If this flag is set, the MouseKeys feature is available.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MKF.MKF_CONFIRMHOTKEY">
            <summary>
            Windows 95/98, Windows 2000: A confirmation dialog box appears when the MouseKeys feature is activated by using the hot key.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MKF.MKF_HOTKEYACTIVE">
            <summary>
            If this flag is set, the user can turn the MouseKeys feature on and off by using the hot key, which is LEFT ALT+LEFT
            SHIFT+NUM LOCK.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MKF.MKF_HOTKEYSOUND">
            <summary>
            If this flag is set, the system plays a siren sound when the user turns the MouseKeys feature on or off by using the hot key.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MKF.MKF_INDICATOR">
            <summary>Windows 95/98, Windows 2000: A visual indicator is displayed when the MouseKeys feature is on.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MKF.MKF_LEFTBUTTONDOWN">
            <summary>Windows 95/98, Windows 2000: The left button is in the "down" state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MKF.MKF_LEFTBUTTONSEL">
            <summary>Windows 95/98, Windows 2000: The user has selected the left button for mouse-button actions.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MKF.MKF_MODIFIERS">
            <summary>
            Windows 95/98, Windows 2000: The CTRL key increases cursor speed by the value specified by the iCtrlSpeed member, and the
            SHIFT key causes the cursor to delay briefly after moving a single pixel, allowing fine positioning of the cursor. If this
            value is not specified, the CTRLand SHIFT keys are ignored while the user moves the mouse cursor using the arrow keys.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MKF.MKF_MOUSEKEYSON">
            <summary>If this flag is set, the MouseKeys feature is on.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MKF.MKF_MOUSEMODE">
            <summary>Windows 95/98, Windows 2000: The system is processing numeric keypad input as mouse commands.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MKF.MKF_REPLACENUMBERS">
            <summary>
            Windows 95/98, Windows 2000: The numeric keypad moves the mouse when the NUM LOCK key is on. If this flag is not specified,
            the numeric keypad moves the mouse cursor when the NUM LOCK key is off.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MKF.MKF_RIGHTBUTTONDOWN">
            <summary>Windows 95/98, Windows 2000: The right button is in the "down" state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MKF.MKF_RIGHTBUTTONSEL">
            <summary>Windows 95/98, Windows 2000: The user has selected the right button for mouse-button actions.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MouseWheelRouting">
            <summary>Enum for SystemParametersInfo</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MouseWheelRouting.MOUSEWHEEL_ROUTING_FOCUS">
            <summary>Mouse wheel input is delivered to the app with focus.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MouseWheelRouting.MOUSEWHEEL_ROUTING_HYBRID">
            <summary>
            Mouse wheel input is delivered to the app with focus (desktop apps) or the app under the mouse cursor (Windows Store apps).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MouseWheelRouting.MOUSEWHEEL_ROUTING_MOUSE_POS">
            <summary>Undocumented</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.PenArbitrationType">
            <summary>Enum for SystemParametersInfo</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PenArbitrationType.PENARBITRATIONTYPE_NONE">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PenArbitrationType.PENARBITRATIONTYPE_WIN8">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PenArbitrationType.PENARBITRATIONTYPE_FIS">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PenArbitrationType.PENARBITRATIONTYPE_SPT">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PenArbitrationType.PENARBITRATIONTYPE_MAX">
            <summary>Undocumented</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.PenVisualization">
            <summary>Enum for SystemParametersInfo</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PenVisualization.PENVISUALIZATION_OFF">
            <summary>Specifies that UI feedback for all pen gestures is off.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PenVisualization.PENVISUALIZATION_ON">
            <summary>Specifies that UI feedback for all pen gestures is on.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PenVisualization.PENVISUALIZATION_TAP">
            <summary>Specifies UI feedback for a pen tap.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PenVisualization.PENVISUALIZATION_DOUBLETAP">
            <summary>Specifies UI feedback for a pen double tap.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PenVisualization.PENVISUALIZATION_CURSOR">
            <summary>Specifies UI feedback for the pen cursor.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SERKF">
            <summary>A set of bit-flags that specify properties of the SerialKeys feature.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SERKF.SERKF_SERIALKEYSON">
            <summary>The SerialKeys feature is on.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SERKF.SERKF_AVAILABLE">
            <summary>The SerialKeys feature is available.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SERKF.SERKF_INDICATOR">
            <summary>A visual indicator is displayed when the SerialKeys feature is on. This value is not currently used and is ignored.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SKF">
            <summary>A set of bit-flags that specify properties of the StickyKeys feature.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_AUDIBLEFEEDBACK">
            <summary>
            If this flag is set, the system plays a sound when the user latches, locks, or releases modifier keys using the StickyKeys feature.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_AVAILABLE">
            <summary>If this flag is set, the StickyKeys feature is available.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_CONFIRMHOTKEY">
            <summary>
            Windows 95/98, Windows 2000: A confirmation dialog appears when the StickyKeys feature is activated by using the hot key.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_HOTKEYACTIVE">
            <summary>If this flag is set, the user can turn the StickyKeys feature on and off by pressing the SHIFT key five times.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_HOTKEYSOUND">
            <summary>
            If this flag is set, the system plays a siren sound when the user turns the StickyKeys feature on or off by using the hot key.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_INDICATOR">
            <summary>Windows 95/98, Windows 2000: A visual indicator should be displayed when the StickyKeys feature is on.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_STICKYKEYSON">
            <summary>If this flag is set, the StickyKeys feature is on.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_TRISTATE">
            <summary>
            If this flag is set, pressing a modifier key twice in a row locks down the key until the user presses it a third time.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_TWOKEYSOFF">
            <summary>
            If this flag is set, releasing a modifier key that has been pressed in combination with any other key turns off the
            StickyKeys feature.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_LALTLATCHED">
            <summary>Windows 98, Windows 2000: The left ALT key is latched.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_LCTLLATCHED">
            <summary>Windows 98, Windows 2000: The left CTRL key is latched.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_LSHIFTLATCHED">
            <summary>Windows 98, Windows 2000: The left SHIFT key is latched.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_RALTLATCHED">
            <summary>Windows 98, Windows 2000: The right ALT key is latched.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_RCTLLATCHED">
            <summary>Windows 98, Windows 2000: The right CTRL key is latched.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_RSHIFTLATCHED">
            <summary>Windows 98, Windows 2000: The right SHIFT key is latched.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_LALTLOCKED">
            <summary>Windows 98, Windows 2000: The left ALT key is locked.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_LCTLLOCKED">
            <summary>Windows 98, Windows 2000: The left CTRL key is locked.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_LSHIFTLOCKED">
            <summary>Windows 98, Windows 2000: The left SHIFT key is locked.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_RALTLOCKED">
            <summary>Windows 98, Windows 2000: The right ALT key is locked.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_RCTLLOCKED">
            <summary>Windows 98, Windows 2000: The right CTRL key is locked.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_RSHIFTLOCKED">
            <summary>Windows 98, Windows 2000: The right SHIFT key is locked.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_LWINLATCHED">
            <summary>Windows 98, Windows 2000: The left Windows key is latched.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_RWINLATCHED">
            <summary>Windows 98, Windows 2000: The right Windows key is latched.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_LWINLOCKED">
            <summary>Windows 98, Windows 2000: The left Windows key is locked.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SKF.SKF_RWINLOCKED">
            <summary>Windows 98, Windows 2000: The right Windows key is locked.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SPI">
            <summary>Enum for SystemParametersInfo</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETBEEP">
            <summary>
            Determines whether the warning beeper is on. The pvParam parameter must point to a BOOL variable that receives TRUE if the
            beeper is on, or FALSE if it is off.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETBEEP">
            <summary>Turns the warning beeper on or off. The uiParam parameter specifies TRUE for on, or FALSE for off.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMOUSE">
            <summary>
            Retrieves the two mouse threshold values and the mouse acceleration. The pvParam parameter must point to an array of three
            integers that receives these values. See mouse_event for further information.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMOUSE">
            <summary>
            Sets the two mouse threshold values and the mouse acceleration. The pvParam parameter must point to an array of three
            integers that specifies these values. See mouse_event for further information.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETBORDER">
            <summary>
            Retrieves the border multiplier factor that determines the width of a window's sizing border. The pvParam parameter must
            point to an integer variable that receives this value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETBORDER">
            <summary>
            Sets the border multiplier factor that determines the width of a window's sizing border. The uiParam parameter specifies the
            new value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETKEYBOARDSPEED">
            <summary>
            Retrieves the keyboard repeat-speed setting, which is a value in the range from 0 (approximately 2.5 repetitions per second)
            through 31 (approximately 30 repetitions per second). The actual repeat rates are hardware-dependent and may vary from a
            linear scale by as much as 20%. The pvParam parameter must point to a DWORD variable that receives the setting
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETKEYBOARDSPEED">
            <summary>
            Sets the keyboard repeat-speed setting. The uiParam parameter must specify a value in the range from 0 (approximately 2.5
            repetitions per second) through 31 (approximately 30 repetitions per second). The actual repeat rates are hardware-dependent
            and may vary from a linear scale by as much as 20%. If uiParam is greater than 31, the parameter is set to 31.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_LANGDRIVER">
            <summary>Not implemented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_ICONHORIZONTALSPACING">
            <summary>
            Sets or retrieves the width, in pixels, of an icon cell. The system uses this rectangle to arrange icons in large icon view.
            To set this value, set uiParam to the new value and set pvParam to null. You cannot set this value to less than SM_CXICON. To
            retrieve this value, pvParam must point to an integer that receives the current value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETSCREENSAVETIMEOUT">
            <summary>
            Retrieves the screen saver time-out value, in seconds. The pvParam parameter must point to an integer variable that receives
            the value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETSCREENSAVETIMEOUT">
            <summary>
            Sets the screen saver time-out value to the value of the uiParam parameter. This value is the amount of time, in seconds,
            that the system must be idle before the screen saver activates.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETSCREENSAVEACTIVE">
            <summary>
            Determines whether screen saving is enabled. The pvParam parameter must point to a bool variable that receives TRUE if screen
            saving is enabled, or FALSE otherwise.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETSCREENSAVEACTIVE">
            <summary>
            Sets the state of the screen saver. The uiParam parameter specifies TRUE to activate screen saving, or FALSE to deactivate it.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETGRIDGRANULARITY">
            <summary>
            Retrieves the current granularity value of the desktop sizing grid. The pvParam parameter must point to an integer variable
            that receives the granularity.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETGRIDGRANULARITY">
            <summary>Sets the granularity of the desktop sizing grid to the value of the uiParam parameter.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETDESKWALLPAPER">
            <summary>
            Sets the desktop wallpaper. The value of the pvParam parameter determines the new wallpaper. To specify a wallpaper bitmap,
            set pvParam to point to a null-terminated string containing the name of a bitmap file. Setting pvParam to "" removes the
            wallpaper. Setting pvParam to SETWALLPAPER_DEFAULT or null reverts to the default wallpaper.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETDESKPATTERN">
            <summary>Sets the current desktop pattern by causing Windows to read the Pattern= setting from the WIN.INI file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETKEYBOARDDELAY">
            <summary>
            Retrieves the keyboard repeat-delay setting, which is a value in the range from 0 (approximately 250 ms delay) through 3
            (approximately 1 second delay). The actual delay associated with each value may vary depending on the hardware. The pvParam
            parameter must point to an integer variable that receives the setting.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETKEYBOARDDELAY">
            <summary>
            Sets the keyboard repeat-delay setting. The uiParam parameter must specify 0, 1, 2, or 3, where zero sets the shortest delay
            (approximately 250
            ms) and 3 sets the longest delay (approximately 1 second). The actual delay associated with each value may vary depending on
            the hardware.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_ICONVERTICALSPACING">
            <summary>
            Sets or retrieves the height, in pixels, of an icon cell. To set this value, set uiParam to the new value and set pvParam to
            null. You cannot set this value to less than SM_CYICON. To retrieve this value, pvParam must point to an integer that
            receives the current value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETICONTITLEWRAP">
            <summary>
            Determines whether icon-title wrapping is enabled. The pvParam parameter must point to a bool variable that receives TRUE if
            enabled, or FALSE otherwise.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETICONTITLEWRAP">
            <summary>Turns icon-title wrapping on or off. The uiParam parameter specifies TRUE for on, or FALSE for off.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMENUDROPALIGNMENT">
            <summary>
            Determines whether pop-up menus are left-aligned or right-aligned, relative to the corresponding menu-bar item. The pvParam
            parameter must point to a bool variable that receives TRUE if left-aligned, or FALSE otherwise.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMENUDROPALIGNMENT">
            <summary>
            Sets the alignment value of pop-up menus. The uiParam parameter specifies TRUE for right alignment, or FALSE for left alignment.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETDOUBLECLKWIDTH">
            <summary>
            Sets the width of the double-click rectangle to the value of the uiParam parameter. The double-click rectangle is the
            rectangle within which the second click of a double-click must fall for it to be registered as a double-click. To retrieve
            the width of the double-click rectangle, call GetSystemMetrics with the SM_CXDOUBLECLK flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETDOUBLECLKHEIGHT">
            <summary>
            Sets the height of the double-click rectangle to the value of the uiParam parameter. The double-click rectangle is the
            rectangle within which the second click of a double-click must fall for it to be registered as a double-click. To retrieve
            the height of the double-click rectangle, call GetSystemMetrics with the SM_CYDOUBLECLK flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETICONTITLELOGFONT">
            <summary>
            Retrieves the logical font information for the current icon-title font. The uiParam parameter specifies the size of a LOGFONT
            structure, and the pvParam parameter must point to the LOGFONT structure to fill in.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETDOUBLECLICKTIME">
            <summary>
            Sets the double-click time for the mouse to the value of the uiParam parameter. The double-click time is the maximum number
            of milliseconds that can occur between the first and second clicks of a double-click. You can also call the
            SetDoubleClickTime function to set the double-click time. To get the current double-click time, call the GetDoubleClickTime function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMOUSEBUTTONSWAP">
            <summary>
            Swaps or restores the meaning of the left and right mouse buttons. The uiParam parameter specifies TRUE to swap the meanings
            of the buttons, or FALSE to restore their original meanings.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETICONTITLELOGFONT">
            <summary>
            Sets the font that is used for icon titles. The uiParam parameter specifies the size of a LOGFONT structure, and the pvParam
            parameter must point to a LOGFONT structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETFASTTASKSWITCH">
            <summary>
            This flag is obsolete. Previous versions of the system use this flag to determine whether ALT+TAB fast task switching is
            enabled. For Windows 95, Windows 98, and Windows NT version 4.0 and later, fast task switching is always enabled.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETFASTTASKSWITCH">
            <summary>
            This flag is obsolete. Previous versions of the system use this flag to enable or disable ALT+TAB fast task switching. For
            Windows 95, Windows 98, and Windows NT version 4.0 and later, fast task switching is always enabled.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETDRAGFULLWINDOWS">
            <summary>
            Sets dragging of full windows either on or off. The uiParam parameter specifies TRUE for on, or FALSE for off. Windows 95:
            This flag is supported only if Windows Plus! is installed. See SPI_GETWINDOWSEXTENSION.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETDRAGFULLWINDOWS">
            <summary>
            Determines whether dragging of full windows is enabled. The pvParam parameter must point to a BOOL variable that receives
            TRUE if enabled, or FALSE otherwise. Windows 95: This flag is supported only if Windows Plus! is installed. See SPI_GETWINDOWSEXTENSION.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETNONCLIENTMETRICS">
            <summary>
            Retrieves the metrics associated with the nonclient area of nonminimized windows. The pvParam parameter must point to a
            NONCLIENTMETRICS structure that receives the information. Set the cbSize member of this structure and the uiParam parameter
            to sizeof(NONCLIENTMETRICS).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETNONCLIENTMETRICS">
            <summary>
            Sets the metrics associated with the nonclient area of nonminimized windows. The pvParam parameter must point to a
            NONCLIENTMETRICS structure that contains the new parameters. Set the cbSize member of this structure and the uiParam
            parameter to sizeof(NONCLIENTMETRICS). Also, the lfHeight member of the LOGFONT structure must be a negative value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMINIMIZEDMETRICS">
            <summary>
            Retrieves the metrics associated with minimized windows. The pvParam parameter must point to a MINIMIZEDMETRICS structure
            that receives the information. Set the cbSize member of this structure and the uiParam parameter to sizeof(MINIMIZEDMETRICS).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMINIMIZEDMETRICS">
            <summary>
            Sets the metrics associated with minimized windows. The pvParam parameter must point to a MINIMIZEDMETRICS structure that
            contains the new parameters. Set the cbSize member of this structure and the uiParam parameter to sizeof(MINIMIZEDMETRICS).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETICONMETRICS">
            <summary>
            Retrieves the metrics associated with icons. The pvParam parameter must point to an ICONMETRICS structure that receives the
            information. Set the cbSize member of this structure and the uiParam parameter to sizeof(ICONMETRICS).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETICONMETRICS">
            <summary>
            Sets the metrics associated with icons. The pvParam parameter must point to an ICONMETRICS structure that contains the new
            parameters. Set the cbSize member of this structure and the uiParam parameter to sizeof(ICONMETRICS).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETWORKAREA">
            <summary>
            Sets the size of the work area. The work area is the portion of the screen not obscured by the system taskbar or by
            application desktop toolbars. The pvParam parameter is a pointer to a RECT structure that specifies the new work area
            rectangle, expressed in virtual screen coordinates. In a system with multiple display monitors, the function sets the work
            area of the monitor that contains the specified rectangle.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETWORKAREA">
            <summary>
            Retrieves the size of the work area on the primary display monitor. The work area is the portion of the screen not obscured
            by the system taskbar or by application desktop toolbars. The pvParam parameter must point to a RECT structure that receives
            the coordinates of the work area, expressed in virtual screen coordinates. To get the work area of a monitor other than the
            primary display monitor, call the GetMonitorInfo function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETPENWINDOWS">
            <summary>
            Windows Me/98/95: Pen windows is being loaded or unloaded. The uiParam parameter is TRUE when loading and FALSE when
            unloading pen windows. The pvParam parameter is null.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETHIGHCONTRAST">
            <summary>
            Retrieves information about the HighContrast accessibility feature. The pvParam parameter must point to a HIGHCONTRAST
            structure that receives the information. Set the cbSize member of this structure and the uiParam parameter to
            sizeof(HIGHCONTRAST). For a general discussion, see remarks. Windows NT: This value is not supported.
            </summary>
            <remarks>
            There is a difference between the High Contrast color scheme and the High Contrast Mode. The High Contrast color scheme
            changes the system colors to colors that have obvious contrast; you switch to this color scheme by using the Display Options
            in the control panel. The High Contrast Mode, which uses SPI_GETHIGHCONTRAST and SPI_SETHIGHCONTRAST, advises applications to
            modify their appearance for visually-impaired users. It involves such things as audible warning to users and customized color
            scheme (using the Accessibility Options in the control panel). For more information, see HIGHCONTRAST on MSDN. For more
            information on general accessibility features, see Accessibility on MSDN.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETHIGHCONTRAST">
            <summary>
            Sets the parameters of the HighContrast accessibility feature. The pvParam parameter must point to a HIGHCONTRAST structure
            that contains the new parameters. Set the cbSize member of this structure and the uiParam parameter to sizeof(HIGHCONTRAST).
            Windows NT: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETKEYBOARDPREF">
            <summary>
            Determines whether the user relies on the keyboard instead of the mouse, and wants applications to display keyboard
            interfaces that would otherwise be hidden. The pvParam parameter must point to a BOOL variable that receives TRUE if the user
            relies on the keyboard; or FALSE otherwise. Windows NT: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETKEYBOARDPREF">
            <summary>
            Sets the keyboard preference. The uiParam parameter specifies TRUE if the user relies on the keyboard instead of the mouse,
            and wants applications to display keyboard interfaces that would otherwise be hidden; uiParam is FALSE otherwise. Windows NT:
            This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETSCREENREADER">
            <summary>
            Determines whether a screen reviewer utility is running. A screen reviewer utility directs textual information to an output
            device, such as a speech synthesizer or Braille display. When this flag is set, an application should provide textual
            information in situations where it would otherwise present the information graphically. The pvParam parameter is a pointer to
            a BOOL variable that receives TRUE if a screen reviewer utility is running, or FALSE otherwise. Windows NT: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETSCREENREADER">
            <summary>
            Determines whether a screen review utility is running. The uiParam parameter specifies TRUE for on, or FALSE for off. Windows
            NT: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETANIMATION">
            <summary>
            Retrieves the animation effects associated with user actions. The pvParam parameter must point to an ANIMATIONINFO structure
            that receives the information. Set the cbSize member of this structure and the uiParam parameter to sizeof(ANIMATIONINFO).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETANIMATION">
            <summary>
            Sets the animation effects associated with user actions. The pvParam parameter must point to an ANIMATIONINFO structure that
            contains the new parameters. Set the cbSize member of this structure and the uiParam parameter to sizeof(ANIMATIONINFO).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETFONTSMOOTHING">
            <summary>
            Determines whether the font smoothing feature is enabled. This feature uses font antialiasing to make font curves appear
            smoother by painting pixels at different gray levels. The pvParam parameter must point to a BOOL variable that receives TRUE
            if the feature is enabled, or FALSE if it is not. Windows 95: This flag is supported only if Windows Plus! is installed. See SPI_GETWINDOWSEXTENSION.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETFONTSMOOTHING">
            <summary>
            Enables or disables the font smoothing feature, which uses font antialiasing to make font curves appear smoother by painting
            pixels at different gray levels. To enable the feature, set the uiParam parameter to TRUE. To disable the feature, set
            uiParam to FALSE. Windows 95: This flag is supported only if Windows Plus! is installed. See SPI_GETWINDOWSEXTENSION.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETDRAGWIDTH">
            <summary>
            Sets the width, in pixels, of the rectangle used to detect the start of a drag operation. Set uiParam to the new value. To
            retrieve the drag width, call GetSystemMetrics with the SM_CXDRAG flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETDRAGHEIGHT">
            <summary>
            Sets the height, in pixels, of the rectangle used to detect the start of a drag operation. Set uiParam to the new value. To
            retrieve the drag height, call GetSystemMetrics with the SM_CYDRAG flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETHANDHELD">
            <summary>Used internally; applications should not use this value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETLOWPOWERTIMEOUT">
            <summary>
            Retrieves the time-out value for the low-power phase of screen saving. The pvParam parameter must point to an integer
            variable that receives the value. This flag is supported for 32-bit applications only. Windows NT, Windows Me/98: This flag
            is supported for 16-bit and 32-bit applications. Windows 95: This flag is supported for 16-bit applications only.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETPOWEROFFTIMEOUT">
            <summary>
            Retrieves the time-out value for the power-off phase of screen saving. The pvParam parameter must point to an integer
            variable that receives the value. This flag is supported for 32-bit applications only. Windows NT, Windows Me/98: This flag
            is supported for 16-bit and 32-bit applications. Windows 95: This flag is supported for 16-bit applications only.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETLOWPOWERTIMEOUT">
            <summary>
            Sets the time-out value, in seconds, for the low-power phase of screen saving. The uiParam parameter specifies the new value.
            The pvParam parameter must be null. This flag is supported for 32-bit applications only. Windows NT, Windows Me/98: This flag
            is supported for 16-bit and 32-bit applications. Windows 95: This flag is supported for 16-bit applications only.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETPOWEROFFTIMEOUT">
            <summary>
            Sets the time-out value, in seconds, for the power-off phase of screen saving. The uiParam parameter specifies the new value.
            The pvParam parameter must be null. This flag is supported for 32-bit applications only. Windows NT, Windows Me/98: This flag
            is supported for 16-bit and 32-bit applications. Windows 95: This flag is supported for 16-bit applications only.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETLOWPOWERACTIVE">
            <summary>
            Determines whether the low-power phase of screen saving is enabled. The pvParam parameter must point to a BOOL variable that
            receives TRUE if enabled, or FALSE if disabled. This flag is supported for 32-bit applications only. Windows NT, Windows
            Me/98: This flag is supported for 16-bit and 32-bit applications. Windows 95: This flag is supported for 16-bit applications only.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETPOWEROFFACTIVE">
            <summary>
            Determines whether the power-off phase of screen saving is enabled. The pvParam parameter must point to a BOOL variable that
            receives TRUE if enabled, or FALSE if disabled. This flag is supported for 32-bit applications only. Windows NT, Windows
            Me/98: This flag is supported for 16-bit and 32-bit applications. Windows 95: This flag is supported for 16-bit applications only.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETLOWPOWERACTIVE">
            <summary>
            Activates or deactivates the low-power phase of screen saving. Set uiParam to 1 to activate, or zero to deactivate. The
            pvParam parameter must be null. This flag is supported for 32-bit applications only. Windows NT, Windows Me/98: This flag is
            supported for 16-bit and 32-bit applications. Windows 95: This flag is supported for 16-bit applications only.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETPOWEROFFACTIVE">
            <summary>
            Activates or deactivates the power-off phase of screen saving. Set uiParam to 1 to activate, or zero to deactivate. The
            pvParam parameter must be null. This flag is supported for 32-bit applications only. Windows NT, Windows Me/98: This flag is
            supported for 16-bit and 32-bit applications. Windows 95: This flag is supported for 16-bit applications only.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETCURSORS">
            <summary>Reloads the system cursors. Set the uiParam parameter to zero and the pvParam parameter to null.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETICONS">
            <summary>Reloads the system icons. Set the uiParam parameter to zero and the pvParam parameter to null.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETDEFAULTINPUTLANG">
            <summary>
            Retrieves the input locale identifier for the system default input language. The pvParam parameter must point to an HKL
            variable that receives this value. For more information, see Languages, Locales, and Keyboard Layouts on MSDN.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETDEFAULTINPUTLANG">
            <summary>
            Sets the default input language for the system shell and applications. The specified language must be displayable using the
            current system character set. The pvParam parameter must point to an HKL variable that contains the input locale identifier
            for the default language. For more information, see Languages, Locales, and Keyboard Layouts on MSDN.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETLANGTOGGLE">
            <summary>
            Sets the hot key set for switching between input languages. The uiParam and pvParam parameters are not used. The value sets
            the shortcut keys in the keyboard property sheets by reading the registry again. The registry must be set before this flag is
            used. the path in the registry is \HKEY_CURRENT_USER\keyboard layout\toggle. Valid values are "1" = ALT+SHIFT, "2" =
            CTRL+SHIFT, and "3" = none.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETWINDOWSEXTENSION">
            <summary>
            Windows 95: Determines whether the Windows extension, Windows Plus!, is installed. Set the uiParam parameter to 1. The
            pvParam parameter is not used. The function returns TRUE if the extension is installed, or FALSE if it is not.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMOUSETRAILS">
            <summary>
            Enables or disables the Mouse Trails feature, which improves the visibility of mouse cursor movements by briefly showing a
            trail of cursors and quickly erasing them. To disable the feature, set the uiParam parameter to zero or 1. To enable the
            feature, set uiParam to a value greater than 1 to indicate the number of cursors drawn in the trail. Windows 2000/NT: This
            value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMOUSETRAILS">
            <summary>
            Determines whether the Mouse Trails feature is enabled. This feature improves the visibility of mouse cursor movements by
            briefly showing a trail of cursors and quickly erasing them. The pvParam parameter must point to an integer variable that
            receives a value. If the value is zero or 1, the feature is disabled. If the value is greater than 1, the feature is enabled
            and the value indicates the number of cursors drawn in the trail. The uiParam parameter is not used. Windows 2000/NT: This
            value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETSCREENSAVERRUNNING">
            <summary>Windows Me/98: Used internally; applications should not use this flag.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SCREENSAVERRUNNING">
            <summary>Same as SPI_SETSCREENSAVERRUNNING.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETFILTERKEYS">
            <summary>
            Retrieves information about the FilterKeys accessibility feature. The pvParam parameter must point to a FILTERKEYS structure
            that receives the information. Set the cbSize member of this structure and the uiParam parameter to sizeof(FILTERKEYS).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETFILTERKEYS">
            <summary>
            Sets the parameters of the FilterKeys accessibility feature. The pvParam parameter must point to a FILTERKEYS structure that
            contains the new parameters. Set the cbSize member of this structure and the uiParam parameter to sizeof(FILTERKEYS).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETTOGGLEKEYS">
            <summary>
            Retrieves information about the ToggleKeys accessibility feature. The pvParam parameter must point to a TOGGLEKEYS structure
            that receives the information. Set the cbSize member of this structure and the uiParam parameter to sizeof(TOGGLEKEYS).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETTOGGLEKEYS">
            <summary>
            Sets the parameters of the ToggleKeys accessibility feature. The pvParam parameter must point to a TOGGLEKEYS structure that
            contains the new parameters. Set the cbSize member of this structure and the uiParam parameter to sizeof(TOGGLEKEYS).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMOUSEKEYS">
            <summary>
            Retrieves information about the MouseKeys accessibility feature. The pvParam parameter must point to a MOUSEKEYS structure
            that receives the information. Set the cbSize member of this structure and the uiParam parameter to sizeof(MOUSEKEYS).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMOUSEKEYS">
            <summary>
            Sets the parameters of the MouseKeys accessibility feature. The pvParam parameter must point to a MOUSEKEYS structure that
            contains the new parameters. Set the cbSize member of this structure and the uiParam parameter to sizeof(MOUSEKEYS).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETSHOWSOUNDS">
            <summary>
            Determines whether the Show Sounds accessibility flag is on or off. If it is on, the user requires an application to present
            information visually in situations where it would otherwise present the information only in audible form. The pvParam
            parameter must point to a BOOL variable that receives TRUE if the feature is on, or FALSE if it is off. Using this value is
            equivalent to calling GetSystemMetrics (SM_SHOWSOUNDS). That is the recommended call.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETSHOWSOUNDS">
            <summary>
            Sets the parameters of the SoundSentry accessibility feature. The pvParam parameter must point to a SOUNDSENTRY structure
            that contains the new parameters. Set the cbSize member of this structure and the uiParam parameter to sizeof(SOUNDSENTRY).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETSTICKYKEYS">
            <summary>
            Retrieves information about the StickyKeys accessibility feature. The pvParam parameter must point to a STICKYKEYS structure
            that receives the information. Set the cbSize member of this structure and the uiParam parameter to sizeof(STICKYKEYS).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETSTICKYKEYS">
            <summary>
            Sets the parameters of the StickyKeys accessibility feature. The pvParam parameter must point to a STICKYKEYS structure that
            contains the new parameters. Set the cbSize member of this structure and the uiParam parameter to sizeof(STICKYKEYS).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETACCESSTIMEOUT">
            <summary>
            Retrieves information about the time-out period associated with the accessibility features. The pvParam parameter must point
            to an ACCESSTIMEOUT structure that receives the information. Set the cbSize member of this structure and the uiParam
            parameter to sizeof(ACCESSTIMEOUT).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETACCESSTIMEOUT">
            <summary>
            Sets the time-out period associated with the accessibility features. The pvParam parameter must point to an ACCESSTIMEOUT
            structure that contains the new parameters. Set the cbSize member of this structure and the uiParam parameter to sizeof(ACCESSTIMEOUT).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETSERIALKEYS">
            <summary>
            Windows Me/98/95: Retrieves information about the SerialKeys accessibility feature. The pvParam parameter must point to a
            SERIALKEYS structure that receives the information. Set the cbSize member of this structure and the uiParam parameter to
            sizeof(SERIALKEYS). Windows Server 2003, Windows XP/2000/NT: Not supported. The user controls this feature through the
            control panel.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETSERIALKEYS">
            <summary>
            Windows Me/98/95: Sets the parameters of the SerialKeys accessibility feature. The pvParam parameter must point to a
            SERIALKEYS structure that contains the new parameters. Set the cbSize member of this structure and the uiParam parameter to
            sizeof(SERIALKEYS). Windows Server 2003, Windows XP/2000/NT: Not supported. The user controls this feature through the
            control panel.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETSOUNDSENTRY">
            <summary>
            Retrieves information about the SoundSentry accessibility feature. The pvParam parameter must point to a SOUNDSENTRY
            structure that receives the information. Set the cbSize member of this structure and the uiParam parameter to sizeof(SOUNDSENTRY).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETSOUNDSENTRY">
            <summary>
            Sets the parameters of the SoundSentry accessibility feature. The pvParam parameter must point to a SOUNDSENTRY structure
            that contains the new parameters. Set the cbSize member of this structure and the uiParam parameter to sizeof(SOUNDSENTRY).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETSNAPTODEFBUTTON">
            <summary>
            Determines whether the snap-to-default-button feature is enabled. If enabled, the mouse cursor automatically moves to the
            default button, such as OK or Apply, of a dialog box. The pvParam parameter must point to a BOOL variable that receives TRUE
            if the feature is on, or FALSE if it is off. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETSNAPTODEFBUTTON">
            <summary>
            Enables or disables the snap-to-default-button feature. If enabled, the mouse cursor automatically moves to the default
            button, such as OK or Apply, of a dialog box. Set the uiParam parameter to TRUE to enable the feature, or FALSE to disable
            it. Applications should use the ShowWindow function when displaying a dialog box so the dialog manager can position the mouse
            cursor. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMOUSEHOVERWIDTH">
            <summary>
            Retrieves the width, in pixels, of the rectangle within which the mouse pointer has to stay for TrackMouseEvent to generate a
            WM_MOUSEHOVER message. The pvParam parameter must point to a UINT variable that receives the width. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMOUSEHOVERWIDTH">
            <summary>
            Retrieves the width, in pixels, of the rectangle within which the mouse pointer has to stay for TrackMouseEvent to generate a
            WM_MOUSEHOVER message. The pvParam parameter must point to a UINT variable that receives the width. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMOUSEHOVERHEIGHT">
            <summary>
            Retrieves the height, in pixels, of the rectangle within which the mouse pointer has to stay for TrackMouseEvent to generate
            a WM_MOUSEHOVER message. The pvParam parameter must point to a UINT variable that receives the height. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMOUSEHOVERHEIGHT">
            <summary>
            Sets the height, in pixels, of the rectangle within which the mouse pointer has to stay for TrackMouseEvent to generate a
            WM_MOUSEHOVER message. Set the uiParam parameter to the new height. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMOUSEHOVERTIME">
            <summary>
            Retrieves the time, in milliseconds, that the mouse pointer has to stay in the hover rectangle for TrackMouseEvent to
            generate a WM_MOUSEHOVER message. The pvParam parameter must point to a UINT variable that receives the time. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMOUSEHOVERTIME">
            <summary>
            Sets the time, in milliseconds, that the mouse pointer has to stay in the hover rectangle for TrackMouseEvent to generate a
            WM_MOUSEHOVER message. This is used only if you pass HOVER_DEFAULT in the dwHoverTime parameter in the call to
            TrackMouseEvent. Set the uiParam parameter to the new time. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETWHEELSCROLLLINES">
            <summary>
            Retrieves the number of lines to scroll when the mouse wheel is rotated. The pvParam parameter must point to a UINT variable
            that receives the number of lines. The default value is 3. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETWHEELSCROLLLINES">
            <summary>
            Sets the number of lines to scroll when the mouse wheel is rotated. The number of lines is set from the uiParam parameter.
            The number of lines is the suggested number of lines to scroll when the mouse wheel is rolled without using modifier keys. If
            the number is 0, then no scrolling should occur. If the number of lines to scroll is greater than the number of lines
            viewable, and in particular if it is WHEEL_PAGESCROLL (#defined as UINT_MAX), the scroll operation should be interpreted as
            clicking once in the page down or page up regions of the scroll bar. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMENUSHOWDELAY">
            <summary>
            Retrieves the time, in milliseconds, that the system waits before displaying a shortcut menu when the mouse cursor is over a
            submenu item. The pvParam parameter must point to a DWORD variable that receives the time of the delay. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMENUSHOWDELAY">
            <summary>
            Sets uiParam to the time, in milliseconds, that the system waits before displaying a shortcut menu when the mouse cursor is
            over a submenu item. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETSHOWIMEUI">
            <summary>
            Determines whether the IME status window is visible (on a per-user basis). The pvParam parameter must point to a BOOL
            variable that receives TRUE if the status window is visible, or FALSE if it is not. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETSHOWIMEUI">
            <summary>
            Sets whether the IME status window is visible or not on a per-user basis. The uiParam parameter specifies TRUE for on or
            FALSE for off. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMOUSESPEED">
            <summary>
            Retrieves the current mouse speed. The mouse speed determines how far the pointer will move based on the distance the mouse
            moves. The pvParam parameter must point to an integer that receives a value which ranges between 1 (slowest) and 20
            (fastest). A value of 10 is the default. The value can be set by an end user using the mouse control panel application or by
            an application using SPI_SETMOUSESPEED. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMOUSESPEED">
            <summary>
            Sets the current mouse speed. The pvParam parameter is an integer between 1 (slowest) and 20 (fastest). A value of 10 is the
            default. This value is typically set using the mouse control panel application. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETSCREENSAVERRUNNING">
            <summary>
            Determines whether a screen saver is currently running on the window station of the calling process. The pvParam parameter
            must point to a BOOL variable that receives TRUE if a screen saver is currently running, or FALSE otherwise. Note that only
            the interactive window station, "WinSta0", can have a screen saver running. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETDESKWALLPAPER">
            <summary>
            Retrieves the full path of the bitmap file for the desktop wallpaper. The pvParam parameter must point to a buffer that
            receives a null-terminated path string. Set the uiParam parameter to the size, in characters, of the pvParam buffer. The
            returned string will not exceed MAX_PATH characters. If there is no desktop wallpaper, the returned string is empty. Windows
            NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETAUDIODESCRIPTION">
            <summary>
            Determines whether audio descriptions are enabled or disabled. The pvParam parameter is a pointer to an AUDIODESCRIPTION
            structure. Set the cbSize member of this structure and the uiParam parameter to sizeof(AUDIODESCRIPTION).
            <para>
            While it is possible for users who have visual impairments to hear the audio in video content, there is a lot of action in
            video that does not have corresponding audio. Specific audio description of what is happening in a video helps these users
            understand the content better. This flag enables you to determine whether audio descriptions have been enabled and in which language.
            </para>
            <para>Windows Server 2003 and Windows XP/2000: This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETAUDIODESCRIPTION">
            <summary>
            Turns the audio descriptions feature on or off. The pvParam parameter is a pointer to an AUDIODESCRIPTION structure.
            <para>
            While it is possible for users who are visually impaired to hear the audio in video content, there is a lot of action in
            video that does not have corresponding audio. Specific audio description of what is happening in a video helps these users
            understand the content better. This flag enables you to enable or disable audio descriptions in the languages they are
            provided in.
            </para>
            <para>Windows Server 2003 and Windows XP/2000: This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETSCREENSAVESECURE">
            <summary>
            Determines whether the screen saver requires a password to display the Windows desktop. The pvParam parameter must point to a
            BOOL variable that receives TRUE if the screen saver requires a password, or FALSE otherwise. The uiParam parameter is
            ignored. Windows Server 2003 and Windows XP/2000: This parameter is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETSCREENSAVESECURE">
            <summary>
            Sets whether the screen saver requires the user to enter a password to display the Windows desktop. The uiParam parameter is
            a BOOL variable. The pvParam parameter is ignored. Set uiParam to TRUE to require a password, or FALSE to not require a password.
            <para>If the machine has entered power saving mode or system lock state, an ERROR_OPERATION_IN_PROGRESS exception occurs.</para>
            <para>Windows Server 2003 and Windows XP/2000: This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETHUNGAPPTIMEOUT">
            <summary>
            Retrieves the number of milliseconds that a thread can go without dispatching a message before the system considers it
            unresponsive. The pvParam parameter must point to an integer variable that receives the value.
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETHUNGAPPTIMEOUT">
            <summary>
            Sets the hung application time-out to the value of the uiParam parameter. This value is the number of milliseconds that a
            thread can go without dispatching a message before the system considers it unresponsive.
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETWAITTOKILLTIMEOUT">
            <summary>
            Retrieves the number of milliseconds that the system waits before terminating an application that does not respond to a
            shutdown request. The pvParam parameter must point to an integer variable that receives the value.
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETWAITTOKILLTIMEOUT">
            <summary>
            Sets the application shutdown request time-out to the value of the uiParam parameter. This value is the number of
            milliseconds that the system waits before terminating an application that does not respond to a shutdown request.
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETWAITTOKILLSERVICETIMEOUT">
            <summary>
            Retrieves the number of milliseconds that the service control manager waits before terminating a service that does not
            respond to a shutdown request. The pvParam parameter must point to an integer variable that receives the value.
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETWAITTOKILLSERVICETIMEOUT">
            <summary>
            Sets the service shutdown request time-out to the value of the uiParam parameter. This value is the number of milliseconds
            that the system waits before terminating a service that does not respond to a shutdown request.
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMOUSEDOCKTHRESHOLD">
            <summary>
            Retrieves the threshold in pixels where docking behavior is triggered by using a mouse to drag a window to the edge of a
            monitor or monitor array. The default threshold is 1. The pvParam parameter must point to a DWORD variable that receives the value.
            <para>Use SPI_GETWINARRANGING to determine whether this behavior is enabled.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMOUSEDOCKTHRESHOLD">
            <summary>
            Sets the threshold in pixels where docking behavior is triggered by using a mouse to drag a window to the edge of a monitor
            or monitor array. The default threshold is 1. The pvParam parameter must point to a DWORD variable that contains the new value.
            <para>SPI_GETWINARRANGING must be TRUE to enable this behavior.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETPENDOCKTHRESHOLD">
            <summary>
            Retrieves the threshold in pixels where docking behavior is triggered by using a pen to drag a window to the edge of a
            monitor or monitor array. The default is 30.
            <para>Use <c>SPI_GETWINARRANGING</c> to determine whether this behavior is enabled.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETPENDOCKTHRESHOLD">
            <summary>
            Sets the threshold in pixels where docking behavior is triggered by using a pen to drag a window to the edge of a monitor or
            monitor array. The default threshold is 30. The pvParam parameter must point to a DWORD variable that contains the new value.
            <para><c>SPI_GETWINARRANGING</c> must be TRUE to enable this behavior.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETWINARRANGING">
            <summary>
            Determines whether window arrangement is enabled. The pvParam parameter must point to a BOOL variable that receives TRUE if
            enabled, or FALSE otherwise.
            <para>
            Window arrangement reduces the number of mouse, pen, or touch interactions needed to move and size top-level windows by
            simplifying the default behavior of a window when it is dragged or sized.
            </para>
            <para>The following parameters retrieve individual window arrangement settings:</para>
            <list type="bullet">
            <item>
            <term>SPI_GETDOCKMOVING</term>
            </item>
            <item>
            <term>SPI_GETMOUSEDOCKTHRESHOLD</term>
            </item>
            <item>
            <term>SPI_GETMOUSEDRAGOUTTHRESHOLD</term>
            </item>
            <item>
            <term>SPI_GETMOUSESIDEMOVETHRESHOLD</term>
            </item>
            <item>
            <term>SPI_GETPENDOCKTHRESHOLD</term>
            </item>
            <item>
            <term>SPI_GETPENDRAGOUTTHRESHOLD</term>
            </item>
            <item>
            <term>SPI_GETPENSIDEMOVETHRESHOLD</term>
            </item>
            <item>
            <term>SPI_GETSNAPSIZING</term>
            </item>
            </list>
            <para>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000: This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETWINARRANGING">
            <summary>
            Sets whether window arrangement is enabled. Set pvParam to TRUE for on or FALSE for off.
            <para>
            Window arrangement reduces the number of mouse, pen, or touch interactions needed to move and size top-level windows by
            simplifying the default behavior of a window when it is dragged or sized.
            </para>
            <para>The following parameters retrieve individual window arrangement settings:</para>
            <list type="bullet">
            <item>
            <term>SPI_GETDOCKMOVING</term>
            </item>
            <item>
            <term>SPI_GETMOUSEDOCKTHRESHOLD</term>
            </item>
            <item>
            <term>SPI_GETMOUSEDRAGOUTTHRESHOLD</term>
            </item>
            <item>
            <term>SPI_GETMOUSESIDEMOVETHRESHOLD</term>
            </item>
            <item>
            <term>SPI_GETPENDOCKTHRESHOLD</term>
            </item>
            <item>
            <term>SPI_GETPENDRAGOUTTHRESHOLD</term>
            </item>
            <item>
            <term>SPI_GETPENSIDEMOVETHRESHOLD</term>
            </item>
            <item>
            <term>SPI_GETSNAPSIZING</term>
            </item>
            </list>
            <para>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000: This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMOUSEDRAGOUTTHRESHOLD">
            <summary>
            Retrieves the threshold in pixels where undocking behavior is triggered by using a mouse to drag a window from the edge of a
            monitor or a monitor array toward the center. The default threshold is 20.
            <para>Use <c>SPI_GETWINARRANGING</c> to determine whether this behavior is enabled.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMOUSEDRAGOUTTHRESHOLD">
            <summary>
            Sets the threshold in pixels where undocking behavior is triggered by using a mouse to drag a window from the edge of a
            monitor or monitor array to its center. The default threshold is 20. The pvParam parameter must point to a DWORD variable
            that contains the new value.
            <para><c>SPI_GETWINARRANGING</c> must be TRUE to enable this behavior.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETPENDRAGOUTTHRESHOLD">
            <summary>
            Retrieves the threshold in pixels where undocking behavior is triggered by using a pen to drag a window from the edge of a
            monitor or monitor array toward its center. The default threshold is 30.
            <para>Use <c>SPI_GETWINARRANGING</c> to determine whether this behavior is enabled.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETPENDRAGOUTTHRESHOLD">
            <summary>
            Sets the threshold in pixels where undocking behavior is triggered by using a pen to drag a window from the edge of a monitor
            or monitor array to its center. The default threshold is 30. The pvParam parameter must point to a DWORD variable that
            contains the new value.
            <para><c>SPI_GETWINARRANGING</c> must be TRUE to enable this behavior.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMOUSESIDEMOVETHRESHOLD">
            <summary>
            Retrieves the threshold in pixels from the top of a monitor or a monitor array where a vertically maximized window is
            restored when dragged with the mouse. The default threshold is 50.
            <para>Use <c>SPI_GETWINARRANGING</c> to determine whether this behavior is enabled.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMOUSESIDEMOVETHRESHOLD">
            <summary>
            Sets the threshold in pixels from the top of the monitor where a vertically maximized window is restored when dragged with
            the mouse. The default threshold is 50. The pvParam parameter must point to a DWORD variable that contains the new value.
            <para><c>SPI_GETWINARRANGING</c> must be TRUE to enable this behavior.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETPENSIDEMOVETHRESHOLD">
            <summary>
            Retrieves the threshold in pixels from the top of a monitor or monitor array where a vertically maximized window is restored
            when dragged with the mouse. The default threshold is 50.
            <para>Use <c>SPI_GETWINARRANGING</c> to determine whether this behavior is enabled.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETPENSIDEMOVETHRESHOLD">
            <summary>
            Sets the threshold in pixels from the top of the monitor where a vertically maximized window is restored when dragged with a
            pen. The default threshold is 50. The pvParam parameter must point to a DWORD variable that contains the new value.
            <para><c>SPI_GETWINARRANGING</c> must be TRUE to enable this behavior.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETDRAGFROMMAXIMIZE">
            <summary>
            Determines whether a maximized window is restored when its caption bar is dragged. The pvParam parameter must point to a BOOL
            variable that receives TRUE if enabled, or FALSE otherwise.
            <para>Use <c>SPI_GETWINARRANGING</c> to determine whether this behavior is enabled.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETDRAGFROMMAXIMIZE">
            <summary>
            Sets whether a maximized window is restored when its caption bar is dragged. Set pvParam to TRUE for on or FALSE for off.
            <para><c>SPI_GETWINARRANGING</c> must be TRUE to enable this behavior.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETSNAPSIZING">
            <summary>
            Determines whether a window is vertically maximized when it is sized to the top or bottom of a monitor or monitor array. The
            pvParam parameter must point to a BOOL variable that receives TRUE if enabled, or FALSE otherwise.
            <para>Use <c>SPI_GETWINARRANGING</c> to determine whether this behavior is enabled.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETSNAPSIZING">
            <summary>
            Sets whether a window is vertically maximized when it is sized to the top or bottom of the monitor. Set pvParam to TRUE for
            on or FALSE for off.
            <para><c>SPI_GETWINARRANGING</c> must be TRUE to enable this behavior.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETDOCKMOVING">
            <summary>
            Determines whether a window is docked when it is moved to the top, left, or right edges of a monitor or monitor array. The
            pvParam parameter must point to a BOOL variable that receives TRUE if enabled, or FALSE otherwise.
            <para>Use <c>SPI_GETWINARRANGING</c> to determine whether this behavior is enabled.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETDOCKMOVING">
            <summary>
            Sets whether a window is docked when it is moved to the top, left, or right docking targets on a monitor or monitor array.
            Set pvParam to TRUE for on or FALSE for off.
            <para><c>SPI_GETWINARRANGING</c> must be TRUE to enable this behavior.</para>
            <para><c>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETTOUCHPREDICTIONPARAMETERS">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETTOUCHPREDICTIONPARAMETERS">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETLOGICALDPIOVERRIDE">
            <summary>
            Retrieves a value that determines whether Windows 8 is displaying apps using the default scaling plateau for the hardware or
            going to the next higher plateau. This value is based on the current "Make everything on your screen bigger" setting, found
            in the Ease of Access section of PC
            settings: 1 is on, 0 is off.
            <para>
            Apps can provide text and image resources for each of several scaling plateaus: 100%, 140%, and 180%. Providing separate
            resources optimized for a particular scale avoids distortion due to resizing. Windows 8 determines the appropriate scaling
            plateau based on a number of factors, including screen size and pixel density. When "Make everything on your screen bigger"
            is selected (SPI_GETLOGICALDPIOVERRIDE returns a value of 1), Windows uses resources from the next higher plateau.For
            example, in the case of hardware that Windows determines should use a scale of SCALE_100_PERCENT, this override causes
            Windows to use the SCALE_140_PERCENT scale value, assuming that it does not violate other constraints.
            </para>
            <note type="note">You should not use this value.It might be altered or unavailable in subsequent versions of Windows.
            Instead, use the GetScaleFactorForDevice function or the DisplayProperties class to retrieve the preferred scaling
            factor.Desktop applications should use desktop logical DPI rather than scale factor.Desktop logical DPI can be retrieved
            through the GetDeviceCaps function.</note>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETLOGICALDPIOVERRIDE">
            <summary>Do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMENURECT">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMENURECT">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETACTIVEWINDOWTRACKING">
            <summary>
            Determines whether active window tracking (activating the window the mouse is on) is on or off. The pvParam parameter must
            point to a BOOL variable that receives TRUE for on, or FALSE for off. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETACTIVEWINDOWTRACKING">
            <summary>
            Sets active window tracking (activating the window the mouse is on) either on or off. Set pvParam to TRUE for on or FALSE for
            off. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMENUANIMATION">
            <summary>
            Determines whether the menu animation feature is enabled. This master switch must be on to enable menu animation effects. The
            pvParam parameter must point to a BOOL variable that receives TRUE if animation is enabled and FALSE if it is disabled. If
            animation is enabled, SPI_GETMENUFADE indicates whether menus use fade or slide animation. Windows NT, Windows 95: This value
            is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMENUANIMATION">
            <summary>
            Enables or disables menu animation. This master switch must be on for any menu animation to occur. The pvParam parameter is a
            BOOL variable; set pvParam to TRUE to enable animation and FALSE to disable animation. If animation is enabled,
            SPI_GETMENUFADE indicates whether menus use fade or slide animation. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETCOMBOBOXANIMATION">
            <summary>
            Determines whether the slide-open effect for combo boxes is enabled. The pvParam parameter must point to a BOOL variable that
            receives TRUE for enabled, or FALSE for disabled. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETCOMBOBOXANIMATION">
            <summary>
            Enables or disables the slide-open effect for combo boxes. Set the pvParam parameter to TRUE to enable the gradient effect,
            or FALSE to disable it. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETLISTBOXSMOOTHSCROLLING">
            <summary>
            Determines whether the smooth-scrolling effect for list boxes is enabled. The pvParam parameter must point to a BOOL variable
            that receives TRUE for enabled, or FALSE for disabled. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETLISTBOXSMOOTHSCROLLING">
            <summary>
            Enables or disables the smooth-scrolling effect for list boxes. Set the pvParam parameter to TRUE to enable the
            smooth-scrolling effect, or FALSE to disable it. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETGRADIENTCAPTIONS">
            <summary>
            Determines whether the gradient effect for window title bars is enabled. The pvParam parameter must point to a BOOL variable
            that receives TRUE for enabled, or FALSE for disabled. For more information about the gradient effect, see the GetSysColor
            function. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETGRADIENTCAPTIONS">
            <summary>
            Enables or disables the gradient effect for window title bars. Set the pvParam parameter to TRUE to enable it, or FALSE to
            disable it. The gradient effect is possible only if the system has a color depth of more than 256 colors. For more
            information about the gradient effect, see the GetSysColor function. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETKEYBOARDCUES">
            <summary>
            Determines whether menu access keys are always underlined. The pvParam parameter must point to a BOOL variable that receives
            TRUE if menu access keys are always underlined, and FALSE if they are underlined only when the menu is activated by the
            keyboard. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETKEYBOARDCUES">
            <summary>
            Sets the underlining of menu access key letters. The pvParam parameter is a BOOL variable. Set pvParam to TRUE to always
            underline menu access keys, or FALSE to underline menu access keys only when the menu is activated from the keyboard. Windows
            NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMENUUNDERLINES">
            <summary>Same as SPI_GETKEYBOARDCUES.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMENUUNDERLINES">
            <summary>Same as SPI_SETKEYBOARDCUES.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETACTIVEWNDTRKZORDER">
            <summary>
            Determines whether windows activated through active window tracking will be brought to the top. The pvParam parameter must
            point to a BOOL variable that receives TRUE for on, or FALSE for off. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETACTIVEWNDTRKZORDER">
            <summary>
            Determines whether or not windows activated through active window tracking should be brought to the top. Set pvParam to TRUE
            for on or FALSE for off. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETHOTTRACKING">
            <summary>
            Determines whether hot tracking of user-interface elements, such as menu names on menu bars, is enabled. The pvParam
            parameter must point to a BOOL variable that receives TRUE for enabled, or FALSE for disabled. Hot tracking means that when
            the cursor moves over an item, it is highlighted but not selected. You can query this value to decide whether to use hot
            tracking in the user interface of your application. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETHOTTRACKING">
            <summary>
            Enables or disables hot tracking of user-interface elements such as menu names on menu bars. Set the pvParam parameter to
            TRUE to enable it, or FALSE to disable it. Hot-tracking means that when the cursor moves over an item, it is highlighted but
            not selected. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMENUFADE">
            <summary>
            Determines whether menu fade animation is enabled. The pvParam parameter must point to a BOOL variable that receives TRUE
            when fade animation is enabled and FALSE when it is disabled. If fade animation is disabled, menus use slide animation. This
            flag is ignored unless menu animation is enabled, which you can do using the SPI_SETMENUANIMATION flag. For more information,
            see AnimateWindow. Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMENUFADE">
            <summary>
            Enables or disables menu fade animation. Set pvParam to TRUE to enable the menu fade effect or FALSE to disable it. If fade
            animation is disabled, menus use slide animation. he The menu fade effect is possible only if the system has a color depth of
            more than 256 colors. This flag is ignored unless SPI_MENUANIMATION is also set. For more information, see AnimateWindow.
            Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETSELECTIONFADE">
            <summary>
            Determines whether the selection fade effect is enabled. The pvParam parameter must point to a BOOL variable that receives
            TRUE if enabled or FALSE if disabled. The selection fade effect causes the menu item selected by the user to remain on the
            screen briefly while fading out after the menu is dismissed. Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETSELECTIONFADE">
            <summary>
            Set pvParam to TRUE to enable the selection fade effect or FALSE to disable it. The selection fade effect causes the menu
            item selected by the user to remain on the screen briefly while fading out after the menu is dismissed. The selection fade
            effect is possible only if the system has a color depth of more than 256 colors. Windows NT, Windows Me/98/95: This value is
            not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETTOOLTIPANIMATION">
            <summary>
            Determines whether ToolTip animation is enabled. The pvParam parameter must point to a BOOL variable that receives TRUE if
            enabled or FALSE if disabled. If ToolTip animation is enabled, SPI_GETTOOLTIPFADE indicates whether ToolTips use fade or
            slide animation. Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETTOOLTIPANIMATION">
            <summary>
            Set pvParam to TRUE to enable ToolTip animation or FALSE to disable it. If enabled, you can use SPI_SETTOOLTIPFADE to specify
            fade or slide animation. Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETTOOLTIPFADE">
            <summary>
            If SPI_SETTOOLTIPANIMATION is enabled, SPI_GETTOOLTIPFADE indicates whether ToolTip animation uses a fade effect or a slide
            effect. The pvParam parameter must point to a BOOL variable that receives TRUE for fade animation or FALSE for slide
            animation. For more information on slide and fade effects, see AnimateWindow. Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETTOOLTIPFADE">
            <summary>
            If the SPI_SETTOOLTIPANIMATION flag is enabled, use SPI_SETTOOLTIPFADE to indicate whether ToolTip animation uses a fade
            effect or a slide effect. Set pvParam to TRUE for fade animation or FALSE for slide animation. The tooltip fade effect is
            possible only if the system has a color depth of more than 256 colors. For more information on the slide and fade effects,
            see the AnimateWindow function. Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETCURSORSHADOW">
            <summary>
            Determines whether the cursor has a shadow around it. The pvParam parameter must point to a BOOL variable that receives TRUE
            if the shadow is enabled, FALSE if it is disabled. This effect appears only if the system has a color depth of more than 256
            colors. Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETCURSORSHADOW">
            <summary>
            Enables or disables a shadow around the cursor. The pvParam parameter is a BOOL variable. Set pvParam to TRUE to enable the
            shadow or FALSE to disable the shadow. This effect appears only if the system has a color depth of more than 256 colors.
            Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMOUSESONAR">
            <summary>
            Retrieves the state of the Mouse Sonar feature. The pvParam parameter must point to a BOOL variable that receives TRUE if
            enabled or FALSE otherwise. For more information, see About Mouse Input on MSDN. Windows 2000/NT, Windows 98/95: This value
            is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMOUSESONAR">
            <summary>
            Turns the Sonar accessibility feature on or off. This feature briefly shows several concentric circles around the mouse
            pointer when the user presses and releases the CTRL key. The pvParam parameter specifies TRUE for on and FALSE for off. The
            default is off. For more information, see About Mouse Input. Windows 2000/NT, Windows 98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMOUSECLICKLOCK">
            <summary>
            Retrieves the state of the Mouse ClickLock feature. The pvParam parameter must point to a BOOL variable that receives TRUE if
            enabled, or FALSE otherwise. For more information, see About Mouse Input. Windows 2000/NT, Windows 98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMOUSECLICKLOCK">
            <summary>
            Turns the Mouse ClickLock accessibility feature on or off. This feature temporarily locks down the primary mouse button when
            that button is clicked and held down for the time specified by SPI_SETMOUSECLICKLOCKTIME. The uiParam parameter specifies
            TRUE for on, or FALSE for off. The default is off. For more information, see Remarks and About Mouse Input on MSDN. Windows
            2000/NT, Windows 98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMOUSEVANISH">
            <summary>
            Retrieves the state of the Mouse Vanish feature. The pvParam parameter must point to a BOOL variable that receives TRUE if
            enabled or FALSE otherwise. For more information, see About Mouse Input on MSDN. Windows 2000/NT, Windows 98/95: This value
            is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMOUSEVANISH">
            <summary>
            Turns the Vanish feature on or off. This feature hides the mouse pointer when the user types; the pointer reappears when the
            user moves the mouse. The pvParam parameter specifies TRUE for on and FALSE for off. The default is off. For more
            information, see About Mouse Input on MSDN. Windows 2000/NT, Windows 98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETFLATMENU">
            <summary>
            Determines whether native User menus have flat menu appearance. The pvParam parameter must point to a BOOL variable that
            returns TRUE if the flat menu appearance is set, or FALSE otherwise. Windows 2000/NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETFLATMENU">
            <summary>
            Enables or disables flat menu appearance for native User menus. Set pvParam to TRUE to enable flat menu appearance or FALSE
            to disable it. When enabled, the menu bar uses COLOR_MENUBAR for the menubar background, COLOR_MENU for the menu-popup
            background, COLOR_MENUHILIGHT for the fill of the current menu selection, and COLOR_HILIGHT for the outline of the current
            menu selection. If disabled, menus are drawn using the same metrics and colors as in Windows 2000 and earlier. Windows
            2000/NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETDROPSHADOW">
            <summary>
            Determines whether the drop shadow effect is enabled. The pvParam parameter must point to a BOOL variable that returns TRUE
            if enabled or FALSE if disabled. Windows 2000/NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETDROPSHADOW">
            <summary>
            Enables or disables the drop shadow effect. Set pvParam to TRUE to enable the drop shadow effect or FALSE to disable it. You
            must also have CS_DROPSHADOW in the window class style. Windows 2000/NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETBLOCKSENDINPUTRESETS">
            <summary>
            Retrieves a BOOL indicating whether an application can reset the screensaver's timer by calling the SendInput function to
            simulate keyboard or mouse input. The pvParam parameter must point to a BOOL variable that receives TRUE if the simulated
            input will be blocked, or FALSE otherwise.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETBLOCKSENDINPUTRESETS">
            <summary>
            Determines whether an application can reset the screensaver's timer by calling the SendInput function to simulate keyboard or
            mouse input. The uiParam parameter specifies TRUE if the screensaver will not be deactivated by simulated input, or FALSE if
            the screensaver will be deactivated by simulated input.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETUIEFFECTS">
            <summary>
            Determines whether UI effects are enabled or disabled. The pvParam parameter must point to a BOOL variable that receives TRUE
            if all UI effects are enabled, or FALSE if they are disabled. Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETUIEFFECTS">
            <summary>
            Enables or disables UI effects. Set the pvParam parameter to TRUE to enable all UI effects or FALSE to disable all UI
            effects. Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETDISABLEOVERLAPPEDCONTENT">
            <summary>
            Determines whether overlapped content is enabled or disabled. The pvParam parameter must point to a BOOL variable that
            receives TRUE if enabled, or FALSE otherwise.
            <para>
            Display features such as background images, textured backgrounds, water marks on documents, alpha blending, and transparency
            can reduce the contrast between the foreground and background, making it harder for users with low vision to see objects on
            the screen. This flag enables you to determine whether such overlapped content has been disabled.
            </para>
            <para><c>Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETDISABLEOVERLAPPEDCONTENT">
            <summary>
            Turns overlapped content (such as background images and watermarks) on or off. The pvParam parameter is a BOOL variable. Set
            pvParam to TRUE to disable overlapped content, or FALSE to enable overlapped content.
            <para>
            Display features such as background images, textured backgrounds, water marks on documents, alpha blending, and transparency
            can reduce the contrast between the foreground and background, making it harder for users with low vision to see objects on
            the screen. This flag enables you to determine whether such overlapped content has been disabled.
            </para>
            <para><c>Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETCLIENTAREAANIMATION">
            <summary>
            Determines whether animations are enabled or disabled. The pvParam parameter must point to a BOOL variable that receives TRUE
            if animations are enabled, or FALSE otherwise.
            <para>
            Display features such as flashing, blinking, flickering, and moving content can cause seizures in users with photo-sensitive
            epilepsy. This flag enables you to determine whether such animations have been disabled in the client area.
            </para>
            <para><c>Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETCLIENTAREAANIMATION">
            <summary>
            Turns client area animations on or off. The pvParam parameter is a BOOL variable. Set pvParam to TRUE to enable animations
            and other transient effects in the client area, or FALSE to disable them.
            <para>
            Display features such as flashing, blinking, flickering, and moving content can cause seizures in users with photo-sensitive
            epilepsy. This flag enables you to determine whether such animations have been disabled in the client area.
            </para>
            <para><c>Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETCLEARTYPE">
            <summary>
            Determines whether ClearType is enabled. The pvParam parameter must point to a BOOL variable that receives TRUE if ClearType
            is enabled, or FALSE otherwise.
            <para>ClearType is a software technology that improves the readability of text on liquid crystal display (LCD) monitors.</para>
            <para><c>Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETCLEARTYPE">
            <summary>
            Turns ClearType on or off. The pvParam parameter is a BOOL variable. Set pvParam to TRUE to enable ClearType, or FALSE to
            disable it.
            <para>ClearType is a software technology that improves the readability of text on liquid crystal display (LCD) monitors.</para>
            <para><c>Windows Server 2003 and Windows XP/2000:</c> This parameter is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETSPEECHRECOGNITION">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETSPEECHRECOGNITION">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETCARETBROWSING">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETCARETBROWSING">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETTHREADLOCALINPUTSETTINGS">
            <summary>
            <c>Starting with Windows 8:</c> Determines whether the active input settings have Local (per-thread, TRUE) or Global
            (session, FALSE) scope. The pvParam parameter must point to a BOOL variable.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETTHREADLOCALINPUTSETTINGS">
            <summary>
            <c>Starting with Windows 8:</c> Determines whether the active input settings have Local (per-thread, TRUE) or Global
            (session, FALSE) scope. The pvParam parameter must point to a BOOL variable, casted by PVOID.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETSYSTEMLANGUAGEBAR">
            <summary>
            <c>Starting with Windows 8:</c> Determines whether the system language bar is enabled or disabled. The pvParam parameter must
            point to a BOOL variable that receives TRUE if the language bar is enabled, or FALSE otherwise.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETSYSTEMLANGUAGEBAR">
            <summary>
            <c>Starting with Windows 8:</c> Turns the legacy language bar feature on or off. The pvParam parameter is a pointer to a BOOL
            variable. Set pvParam to TRUE to enable the legacy language bar, or FALSE to disable it. The flag is supported on Windows 8
            where the legacy language bar is replaced by Input Switcher and therefore turned off by default. Turning the legacy language
            bar on is provided for compatibility reasons and has no effect on the Input Switcher.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETFOREGROUNDLOCKTIMEOUT">
            <summary>
            Retrieves the amount of time following user input, in milliseconds, during which the system will not allow applications to
            force themselves into the foreground. The pvParam parameter must point to a DWORD variable that receives the time. Windows
            NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETFOREGROUNDLOCKTIMEOUT">
            <summary>
            Sets the amount of time following user input, in milliseconds, during which the system does not allow applications to force
            themselves into the foreground. Set pvParam to the new timeout value. The calling thread must be able to change the
            foreground window, otherwise the call fails. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETACTIVEWNDTRKTIMEOUT">
            <summary>
            Retrieves the active window tracking delay, in milliseconds. The pvParam parameter must point to a DWORD variable that
            receives the time. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETACTIVEWNDTRKTIMEOUT">
            <summary>
            Sets the active window tracking delay. Set pvParam to the number of milliseconds to delay before activating the window under
            the mouse pointer. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETFOREGROUNDFLASHCOUNT">
            <summary>
            Retrieves the number of times SetForegroundWindow will flash the taskbar button when rejecting a foreground switch request.
            The pvParam parameter must point to a DWORD variable that receives the value. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETFOREGROUNDFLASHCOUNT">
            <summary>
            Sets the number of times SetForegroundWindow will flash the taskbar button when rejecting a foreground switch request. Set
            pvParam to the number of times to flash. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETCARETWIDTH">
            <summary>
            Retrieves the caret width in edit controls, in pixels. The pvParam parameter must point to a DWORD that receives this value.
            Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETCARETWIDTH">
            <summary>
            Sets the caret width in edit controls. Set pvParam to the desired width, in pixels. The default and minimum value is 1.
            Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMOUSECLICKLOCKTIME">
            <summary>
            Retrieves the time delay before the primary mouse button is locked. The pvParam parameter must point to DWORD that receives
            the time delay. This is only enabled if SPI_SETMOUSECLICKLOCK is set to TRUE. For more information, see About Mouse Input on
            MSDN. Windows 2000/NT, Windows 98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMOUSECLICKLOCKTIME">
            <summary>
            Adjusts the time delay before the primary mouse button is locked. The uiParam parameter should be set to 0. The pvParam
            parameter points to a DWORD that specifies the time delay in milliseconds. For example, specify 1000 for a 1 second delay.
            The default is 1200. For more information, see About Mouse Input.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETFONTSMOOTHINGTYPE">
            <summary>
            Retrieves the type of font smoothing. The pvParam parameter must point to a UINT that receives the information. Windows
            2000/NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETFONTSMOOTHINGTYPE">
            <summary>
            Sets the font smoothing type. The pvParam parameter is either FE_FONTSMOOTHINGSTANDARD, if standard anti-aliasing is used,
            or FE_FONTSMOOTHINGCLEARTYPE, if ClearType is used. The default is FE_FONTSMOOTHINGSTANDARD.
            SPI_SETFONTSMOOTHING must also be set.
            Windows 2000:  This parameter is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETFONTSMOOTHINGCONTRAST">
            <summary>
            Retrieves a contrast value that is used in ClearType™ smoothing. The pvParam parameter must point to a UINT that receives the
            information. Windows 2000/NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETFONTSMOOTHINGCONTRAST">
            <summary>
            Sets the contrast value used in ClearType smoothing. The pvParam parameter points to a UINT that holds the contrast value.
            Valid contrast values are from 1000 to 2200. The default value is 1400. When using this option, the fWinIni parameter must be
            set to SPIF_SENDWININICHANGE | SPIF_UPDATEINIFILE; otherwise, SystemParametersInfo fails. SPI_SETFONTSMOOTHINGTYPE must also
            be set to FE_FONTSMOOTHINGCLEARTYPE. Windows 2000/NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETFOCUSBORDERWIDTH">
            <summary>
            Retrieves the width, in pixels, of the left and right edges of the focus rectangle drawn with DrawFocusRect. The pvParam
            parameter must point to a UINT. Windows 2000/NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETFOCUSBORDERWIDTH">
            <summary>
            Sets the height of the left and right edges of the focus rectangle drawn with DrawFocusRect to the value of the pvParam
            parameter. Windows 2000/NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETFOCUSBORDERHEIGHT">
            <summary>
            Retrieves the height, in pixels, of the top and bottom edges of the focus rectangle drawn with DrawFocusRect. The pvParam
            parameter must point to a UINT. Windows 2000/NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETFOCUSBORDERHEIGHT">
            <summary>
            Sets the height of the top and bottom edges of the focus rectangle drawn with DrawFocusRect to the value of the pvParam
            parameter. Windows 2000/NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETFONTSMOOTHINGORIENTATION">
            <summary>
            Retrieves the font smoothing orientation. The pvParam parameter must point to a UINT that receives the information. The
            possible values are FE_FONTSMOOTHINGORIENTATIONBGR (blue-green-red) and FE_FONTSMOOTHINGORIENTATIONRGB (red-green-blue).
            Windows XP/2000: This parameter is not supported until Windows XP with SP2.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETFONTSMOOTHINGORIENTATION">
            <summary>
            Sets the font smoothing orientation. The pvParam parameter is either FE_FONTSMOOTHINGORIENTATIONBGR (blue-green-red) or
            FE_FONTSMOOTHINGORIENTATIONRGB (red-green-blue). Windows XP/2000: This parameter is not supported until Windows XP with SP2.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMINIMUMHITRADIUS">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMINIMUMHITRADIUS">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMESSAGEDURATION">
            <summary>
            Retrieves the time that notification pop-ups should be displayed, in seconds. The pvParam parameter must point to a ULONG
            that receives the message duration. Users with visual impairments or cognitive conditions such as ADHD and dyslexia might
            need a longer time to read the text in notification messages. This flag enables you to retrieve the message duration. Windows
            Server 2003 and Windows XP/2000: This parameter is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMESSAGEDURATION">
            <summary>
            Sets the time that notification pop-ups should be displayed, in seconds. The pvParam parameter specifies the message
            duration. Users with visual impairments or cognitive conditions such as ADHD and dyslexia might need a longer time to read
            the text in notification messages. This flag enables you to set the message duration. Windows Server 2003 and Windows
            XP/2000: This parameter is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETCONTACTVISUALIZATION">
            <summary>
            Retrieves the current contact visualization setting. The pvParam parameter must point to a ULONG variable that receives the
            setting. For more information, see Contact Visualization.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETCONTACTVISUALIZATION">
            <summary>
            Sets the current contact visualization setting. The pvParam parameter must point to a ULONG variable that identifies the
            setting. For more information, see Contact Visualization.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETGESTUREVISUALIZATION">
            <summary>
            Retrieves the current gesture visualization setting. The pvParam parameter must point to a ULONG variable that receives the
            setting. For more information, see Gesture Visualization.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETGESTUREVISUALIZATION">
            <summary>
            Sets the current gesture visualization setting. The pvParam parameter must point to a ULONG variable that identifies the
            setting. For more information, see Gesture Visualization.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETMOUSEWHEELROUTING">
            <summary>
            Retrieves the routing setting for wheel button input. The routing setting determines whether wheel button input is sent to
            the app with focus (foreground) or the app under the mouse cursor. The pvParam parameter must point to a DWORD variable that
            receives the routing option. If the value is zero or MOUSEWHEEL_ROUTING_FOCUS, mouse wheel input is delivered to the app with
            focus. If the value is 1 or MOUSEWHEEL_ROUTING_HYBRID (default), mouse wheel input is delivered to the app with focus(desktop
            apps) or the app under the mouse cursor(Windows Store apps). The uiParam parameter is not used.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETMOUSEWHEELROUTING">
            <summary>
            Sets the routing setting for wheel button input. The routing setting determines whether wheel button input is sent to the app
            with focus (foreground) or the app under the mouse cursor. The pvParam parameter must point to a DWORD variable that receives
            the routing option. If the value is zero or MOUSEWHEEL_ROUTING_FOCUS, mouse wheel input is delivered to the app with focus.
            If the value is 1 or MOUSEWHEEL_ROUTING_HYBRID (default), mouse wheel input is delivered to the app with focus(desktop apps)
            or the app under the mouse cursor(Windows Store apps). Set the uiParam parameter to zero.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETPENVISUALIZATION">
            <summary>
            Retrieves the current pen gesture visualization setting. The pvParam parameter must point to a ULONG variable that receives
            the setting. For more information, see Pen Visualization.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETPENVISUALIZATION">
            <summary>
            Sets the current pen gesture visualization setting. The pvParam parameter must point to a ULONG variable that identifies the
            setting. For more information, see Pen Visualization.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETPENARBITRATIONTYPE">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETPENARBITRATIONTYPE">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETCARETTIMEOUT">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETCARETTIMEOUT">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_GETHANDEDNESS">
            <summary>Undocumented</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPI.SPI_SETHANDEDNESS">
            <summary>Undocumented</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SPIF">
            <summary>Flags for SystemParametersInfo</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPIF.None">
            <summary>No flags set.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPIF.SPIF_UPDATEINIFILE">
            <summary>Writes the new system-wide parameter setting to the user profile.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPIF.SPIF_SENDCHANGE">
            <summary>Broadcasts the WM_SETTINGCHANGE message after updating the user profile.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SPIF.SPIF_SENDWININICHANGE">
            <summary>Same as SPIF_SENDCHANGE.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SSF">
            <summary>A set of bit flags that specify properties of the SoundSentry feature.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SSF.SSF_SOUNDSENTRYON">
            <summary>If this flag is set, the SoundSentry feature is on.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SSF.SSF_AVAILABLE">
            <summary>If this flag is set, the SoundSentry feature is available.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SSF.SSF_INDICATOR">
            <summary>This flag is not implemented.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SSGF">
            <summary>
            Specifies the visual signal to present when a graphics-mode application generates a sound while running in a full-screen virtual machine.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SSGF.SSGF_NONE">
            <summary>No visual signal</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SSGF.SSGF_DISPLAY">
            <summary>Flash the entire display.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SSTF">
            <summary>
            Specifies the visual signal to present when a text-mode application generates a sound while running in a full-screen virtual machine.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SSTF.SSTF_NONE">
            <summary>No visual signal</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SSTF.SSTF_CHARS">
            <summary>Flash characters in the corner of the screen.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SSTF.SSTF_BORDER">
            <summary>Flash the screen border (that is, the overscan area), which is unavailable on some displays.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SSTF.SSTF_DISPLAY">
            <summary>Flash the entire display.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SSWF">
            <summary>
            Specifies the visual signal to display when a sound is generated by a Windows-based application or an MS-DOS application running
            in a window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SSWF.SSWF_NONE">
            <summary>No visual signal.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SSWF.SSWF_TITLE">
            <summary>Flash the title bar of the active window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SSWF.SSWF_WINDOW">
            <summary>Flash the active window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SSWF.SSWF_DISPLAY">
            <summary>Flash the entire display.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SSWF.SSWF_CUSTOM">
            <summary>Use a custom visual signal.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SystemMetric">
            <summary>The system metric or configuration setting to be retrieved by <see cref="M:Vanara.PInvoke.User32.GetSystemMetrics(Vanara.PInvoke.User32.SystemMetric)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_ARRANGE">
            <summary>
            The flags that specify how the system arranged minimized windows. For more information, see the Remarks section in this topic.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CLEANBOOT">
            <summary>
            The value that specifies how the system is started:
            <para>0 Normal boot</para>
            <para>1 Fail-safe boot</para>
            <para>2 Fail-safe with network boot</para>
            <para>A fail-safe boot (also called SafeBoot, Safe Mode, or Clean Boot) bypasses the user startup files.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CMONITORS">
            <summary>The number of display monitors on a desktop. For more information, see the Remarks section in this topic.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CMOUSEBUTTONS">
            <summary>The number of buttons on a mouse, or zero if no mouse is installed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CONVERTIBLESLATEMODE">
            <summary>
            Reflects the state of the laptop or slate mode, 0 for Slate Mode and non-zero otherwise. When this system metric changes, the
            system sends a broadcast message via WM_SETTINGCHANGE with "ConvertibleSlateMode" in the LPARAM. Note that this system metric
            doesn't apply to desktop PCs. In that case, use GetAutoRotationState.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXBORDER">
            <summary>
            The width of a window border, in pixels. This is equivalent to the SM_CXEDGE value for windows with the 3-D look.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXCURSOR">
            <summary>The width of a cursor, in pixels. The system cannot create cursors of other sizes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXDLGFRAME">
            <summary>This value is the same as SM_CXFIXEDFRAME.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXDOUBLECLK">
            <summary>
            The width of the rectangle around the location of a first click in a double-click sequence, in pixels. The second click must
            occur within the rectangle that is defined by SM_CXDOUBLECLK and SM_CYDOUBLECLK for the system to consider the two clicks a
            double-click. The two clicks must also occur within a specified time.
            <para>To set the width of the double-click rectangle, call SystemParametersInfo with SPI_SETDOUBLECLKWIDTH.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXDRAG">
            <summary>
            The number of pixels on either side of a mouse-down point that the mouse pointer can move before a drag operation begins.
            This allows the user to click and release the mouse button easily without unintentionally starting a drag operation. If this
            value is negative, it is subtracted from the left of the mouse-down point and added to the right of it.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXEDGE">
            <summary>The width of a 3-D border, in pixels. This metric is the 3-D counterpart of SM_CXBORDER.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXFIXEDFRAME">
            <summary>
            The thickness of the frame around the perimeter of a window that has a caption but is not sizable, in pixels. SM_CXFIXEDFRAME
            is the height of the horizontal border, and SM_CYFIXEDFRAME is the width of the vertical border.
            <para>This value is the same as SM_CXDLGFRAME.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXFOCUSBORDER">
            <summary>
            The width of the left and right edges of the focus rectangle that the DrawFocusRect draws. This value is in pixels.
            <para>Windows 2000: This value is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXFRAME">
            <summary>This value is the same as SM_CXSIZEFRAME.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXFULLSCREEN">
            <summary>
            The width of the client area for a full-screen window on the primary display monitor, in pixels. To get the coordinates of
            the portion of the screen that is not obscured by the system taskbar or by application desktop toolbars, call the
            SystemParametersInfo function with the SPI_GETWORKAREA value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXHSCROLL">
            <summary>The width of the arrow bitmap on a horizontal scroll bar, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXHTHUMB">
            <summary>The width of the thumb box in a horizontal scroll bar, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXICON">
            <summary>
            The default width of an icon, in pixels. The LoadIcon function can load only icons with the dimensions that SM_CXICON and
            SM_CYICON specifies.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXICONSPACING">
            <summary>
            The width of a grid cell for items in large icon view, in pixels. Each item fits into a rectangle of size SM_CXICONSPACING by
            SM_CYICONSPACING when arranged. This value is always greater than or equal to SM_CXICON.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXMAXIMIZED">
            <summary>The default width, in pixels, of a maximized top-level window on the primary display monitor.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXMAXTRACK">
            <summary>
            The default maximum width of a window that has a caption and sizing borders, in pixels. This metric refers to the entire
            desktop. The user cannot drag the window frame to a size larger than these dimensions. A window can override this value by
            processing the WM_GETMINMAXINFO message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXMENUCHECK">
            <summary>The width of the default menu check-mark bitmap, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXMENUSIZE">
            <summary>
            The width of menu bar buttons, such as the child window close button that is used in the multiple document interface, in pixels.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXMIN">
            <summary>The minimum width of a window, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXMINIMIZED">
            <summary>The width of a minimized window, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXMINSPACING">
            <summary>
            The width of a grid cell for a minimized window, in pixels. Each minimized window fits into a rectangle this size when
            arranged. This value is always greater than or equal to SM_CXMINIMIZED.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXMINTRACK">
            <summary>
            The minimum tracking width of a window, in pixels. The user cannot drag the window frame to a size smaller than these
            dimensions. A window can override this value by processing the WM_GETMINMAXINFO message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXPADDEDBORDER">
            <summary>
            The amount of border padding for captioned windows, in pixels.
            <para>Windows XP/2000: This value is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXSCREEN">
            <summary>
            The width of the screen of the primary display monitor, in pixels. This is the same value obtained by calling GetDeviceCaps
            as follows: GetDeviceCaps( hdcPrimaryMonitor, HORZRES).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXSIZE">
            <summary>The width of a button in a window caption or title bar, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXSIZEFRAME">
            <summary>
            The thickness of the sizing border around the perimeter of a window that can be resized, in pixels. SM_CXSIZEFRAME is the
            width of the horizontal border, and SM_CYSIZEFRAME is the height of the vertical border.
            <para>This value is the same as SM_CXFRAME.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXSMICON">
            <summary>
            The recommended width of a small icon, in pixels. Small icons typically appear in window captions and in small icon view.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXSMSIZE">
            <summary>The width of small caption buttons, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXVIRTUALSCREEN">
            <summary>
            The width of the virtual screen, in pixels. The virtual screen is the bounding rectangle of all display monitors. The
            SM_XVIRTUALSCREEN metric is the coordinates for the left side of the virtual screen.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CXVSCROLL">
            <summary>The width of a vertical scroll bar, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYBORDER">
            <summary>
            The height of a window border, in pixels. This is equivalent to the SM_CYEDGE value for windows with the 3-D look.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYCAPTION">
            <summary>The height of a caption area, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYCURSOR">
            <summary>The height of a cursor, in pixels. The system cannot create cursors of other sizes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYDLGFRAME">
            <summary>This value is the same as SM_CYFIXEDFRAME.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYDOUBLECLK">
            <summary>
            The height of the rectangle around the location of a first click in a double-click sequence, in pixels. The second click must
            occur within the rectangle defined by SM_CXDOUBLECLK and SM_CYDOUBLECLK for the system to consider the two clicks a
            double-click. The two clicks must also occur within a specified time.
            <para>To set the height of the double-click rectangle, call SystemParametersInfo with SPI_SETDOUBLECLKHEIGHT.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYDRAG">
            <summary>
            The number of pixels above and below a mouse-down point that the mouse pointer can move before a drag operation begins. This
            allows the user to click and release the mouse button easily without unintentionally starting a drag operation. If this value
            is negative, it is subtracted from above the mouse-down point and added below it.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYEDGE">
            <summary>The height of a 3-D border, in pixels. This is the 3-D counterpart of SM_CYBORDER.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYFIXEDFRAME">
            <summary>
            The thickness of the frame around the perimeter of a window that has a caption but is not sizable, in pixels. SM_CXFIXEDFRAME
            is the height of the horizontal border, and SM_CYFIXEDFRAME is the width of the vertical border.
            <para>This value is the same as SM_CYDLGFRAME.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYFOCUSBORDER">
            <summary>
            The height of the top and bottom edges of the focus rectangle drawn by DrawFocusRect. This value is in pixels.
            <para>Windows 2000: This value is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYFRAME">
            <summary>This value is the same as SM_CYSIZEFRAME.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYFULLSCREEN">
            <summary>
            The height of the client area for a full-screen window on the primary display monitor, in pixels. To get the coordinates of
            the portion of the screen not obscured by the system taskbar or by application desktop toolbars, call the
            SystemParametersInfo function with the SPI_GETWORKAREA value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYHSCROLL">
            <summary>The height of a horizontal scroll bar, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYICON">
            <summary>
            The default height of an icon, in pixels. The LoadIcon function can load only icons with the dimensions SM_CXICON and SM_CYICON.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYICONSPACING">
            <summary>
            The height of a grid cell for items in large icon view, in pixels. Each item fits into a rectangle of size SM_CXICONSPACING
            by SM_CYICONSPACING when arranged. This value is always greater than or equal to SM_CYICON.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYKANJIWINDOW">
            <summary>
            For double byte character set versions of the system, this is the height of the Kanji window at the bottom of the screen, in pixels.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYMAXIMIZED">
            <summary>The default height, in pixels, of a maximized top-level window on the primary display monitor.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYMAXTRACK">
            <summary>
            The default maximum height of a window that has a caption and sizing borders, in pixels. This metric refers to the entire
            desktop. The user cannot drag the window frame to a size larger than these dimensions. A window can override this value by
            processing the WM_GETMINMAXINFO message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYMENU">
            <summary>The height of a single-line menu bar, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYMENUCHECK">
            <summary>The height of the default menu check-mark bitmap, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYMENUSIZE">
            <summary>
            The height of menu bar buttons, such as the child window close button that is used in the multiple document interface, in pixels.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYMIN">
            <summary>The minimum height of a window, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYMINIMIZED">
            <summary>The height of a minimized window, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYMINSPACING">
            <summary>
            The height of a grid cell for a minimized window, in pixels. Each minimized window fits into a rectangle this size when
            arranged. This value is always greater than or equal to SM_CYMINIMIZED.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYMINTRACK">
            <summary>
            The minimum tracking height of a window, in pixels. The user cannot drag the window frame to a size smaller than these
            dimensions. A window can override this value by processing the WM_GETMINMAXINFO message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYSCREEN">
            <summary>
            The height of the screen of the primary display monitor, in pixels. This is the same value obtained by calling GetDeviceCaps
            as follows: GetDeviceCaps( hdcPrimaryMonitor, VERTRES).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYSIZE">
            <summary>The height of a button in a window caption or title bar, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYSIZEFRAME">
            <summary>
            The thickness of the sizing border around the perimeter of a window that can be resized, in pixels. SM_CXSIZEFRAME is the
            width of the horizontal border, and SM_CYSIZEFRAME is the height of the vertical border.
            <para>This value is the same as SM_CYFRAME.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYSMCAPTION">
            <summary>The height of a small caption, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYSMICON">
            <summary>
            The recommended height of a small icon, in pixels. Small icons typically appear in window captions and in small icon view.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYSMSIZE">
            <summary>The height of small caption buttons, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYVIRTUALSCREEN">
            <summary>
            The height of the virtual screen, in pixels. The virtual screen is the bounding rectangle of all display monitors. The
            SM_YVIRTUALSCREEN metric is the coordinates for the top of the virtual screen.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYVSCROLL">
            <summary>The height of the arrow bitmap on a vertical scroll bar, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_CYVTHUMB">
            <summary>The height of the thumb box in a vertical scroll bar, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_DBCSENABLED">
            <summary>Nonzero if User32.dll supports DBCS; otherwise, 0.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_DEBUG">
            <summary>Nonzero if the debug version of User.exe is installed; otherwise, 0.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_DIGITIZER">
            <summary>
            Nonzero if the current operating system is Windows 7 or Windows Server 2008 R2 and the Tablet PC Input service is started;
            otherwise, 0. The return value is a bitmask that specifies the type of digitizer input supported by the device. For more
            information, see Remarks.
            <para>Windows Server 2008, Windows Vista and Windows XP/2000: This value is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_IMMENABLED">
            <summary>
            Nonzero if Input Method Manager/Input Method Editor features are enabled; otherwise, 0.
            <para>
            SM_IMMENABLED indicates whether the system is ready to use a Unicode-based IME on a Unicode application. To ensure that a
            language-dependent IME works, check SM_DBCSENABLED and the system ANSI code page. Otherwise the ANSI-to-Unicode conversion
            may not be performed correctly, or some components like fonts or registry settings may not be present.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_MAXIMUMTOUCHES">
            <summary>
            Nonzero if there are digitizers in the system; otherwise, 0.
            <para>
            SM_MAXIMUMTOUCHES returns the aggregate maximum of the maximum number of contacts supported by every digitizer in the system.
            If the system has only single-touch digitizers, the return value is 1. If the system has multi-touch digitizers, the return
            value is the number of simultaneous contacts the hardware can provide.
            </para>
            <para>Windows Server 2008, Windows Vista and Windows XP/2000: This value is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_MEDIACENTER">
            <summary>Nonzero if the current operating system is the Windows XP, Media Center Edition, 0 if not.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_MENUDROPALIGNMENT">
            <summary>Nonzero if drop-down menus are right-aligned with the corresponding menu-bar item; 0 if the menus are left-aligned.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_MIDEASTENABLED">
            <summary>Nonzero if the system is enabled for Hebrew and Arabic languages, 0 if not.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_MOUSEPRESENT">
            <summary>
            Nonzero if a mouse is installed; otherwise, 0. This value is rarely zero, because of support for virtual mice and because
            some systems detect the presence of the port instead of the presence of a mouse.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_MOUSEHORIZONTALWHEELPRESENT">
            <summary>Nonzero if a mouse with a horizontal scroll wheel is installed; otherwise 0.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_MOUSEWHEELPRESENT">
            <summary>Nonzero if a mouse with a vertical scroll wheel is installed; otherwise 0.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_NETWORK">
            <summary>
            The least significant bit is set if a network is present; otherwise, it is cleared. The other bits are reserved for future use.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_PENWINDOWS">
            <summary>Nonzero if the Microsoft Windows for Pen computing extensions are installed; zero otherwise.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_REMOTECONTROL">
            <summary>
            This system metric is used in a Terminal Services environment to determine if the current Terminal Server session is being
            remotely controlled. Its value is nonzero if the current session is remotely controlled; otherwise, 0.
            <para>
            You can use terminal services management tools such as Terminal Services Manager (tsadmin.msc) and shadow.exe to control a
            remote session. When a session is being remotely controlled, another user can view the contents of that session and
            potentially interact with it.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_REMOTESESSION">
            <summary>
            This system metric is used in a Terminal Services environment. If the calling process is associated with a Terminal Services
            client session, the return value is nonzero. If the calling process is associated with the Terminal Services console session,
            the return value is 0.
            <para>
            Windows Server 2003 and Windows XP: The console session is not necessarily the physical console. For more information, see WTSGetActiveConsoleSessionId.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_SAMEDISPLAYFORMAT">
            <summary>
            Nonzero if all the display monitors have the same color format, otherwise, 0. Two displays can have the same bit depth, but
            different color formats. For example, the red, green, and blue pixels can be encoded with different numbers of bits, or those
            bits can be located in different places in a pixel color value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_SECURE">
            <summary>This system metric should be ignored; it always returns 0.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_SERVERR2">
            <summary>The build number if the system is Windows Server 2003 R2; otherwise, 0.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_SHOWSOUNDS">
            <summary>
            Nonzero if the user requires an application to present information visually in situations where it would otherwise present
            the information only in audible form; otherwise, 0.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_SHUTTINGDOWN">
            <summary>
            Nonzero if the current session is shutting down; otherwise, 0.
            <para>Windows 2000: This value is not supported.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_SLOWMACHINE">
            <summary>Nonzero if the computer has a low-end (slow) processor; otherwise, 0.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_STARTER">
            <summary>
            Nonzero if the current operating system is Windows 7 Starter Edition, Windows Vista Starter, or Windows XP Starter Edition;
            otherwise, 0.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_SWAPBUTTON">
            <summary>Nonzero if the meanings of the left and right mouse buttons are swapped; otherwise, 0.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_SYSTEMDOCKED">
            <summary>
            Reflects the state of the docking mode, 0 for Undocked Mode and non-zero otherwise. When this system metric changes, the
            system sends a broadcast message via WM_SETTINGCHANGE with "SystemDockMode" in the LPARAM.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_TABLETPC">
            <summary>
            Nonzero if the current operating system is the Windows XP Tablet PC edition or if the current operating system is Windows
            Vista or Windows 7 and the Tablet PC Input service is started; otherwise, 0. The SM_DIGITIZER setting indicates the type of
            digitizer input supported by a device running Windows 7 or Windows Server 2008 R2. For more information, see Remarks.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_XVIRTUALSCREEN">
            <summary>
            The coordinates for the left side of the virtual screen. The virtual screen is the bounding rectangle of all display
            monitors. The SM_CXVIRTUALSCREEN metric is the width of the virtual screen.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SystemMetric.SM_YVIRTUALSCREEN">
            <summary>
            The coordinates for the top of the virtual screen. The virtual screen is the bounding rectangle of all display monitors. The
            SM_CYVIRTUALSCREEN metric is the height of the virtual screen.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TKF">
            <summary>A set of bit flags that specify properties of the ToggleKeys feature.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TKF.TKF_AVAILABLE">
            <summary>If this flag is set, the ToggleKeys feature is available.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TKF.TKF_CONFIRMHOTKEY">
            <summary>
            Windows 95/98, Windows 2000: A confirmation dialog box appears when the ToggleKeys feature is activated by using the hot key.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TKF.TKF_HOTKEYACTIVE">
            <summary>
            If this flag is set, the user can turn the ToggleKeys feature on and off by holding down the NUM LOCK key for eight seconds.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TKF.TKF_HOTKEYSOUND">
            <summary>
            If this flag is set, the system plays a siren sound when the user turns the ToggleKeys feature on or off by using the hot key.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TKF.TKF_INDICATOR">
            <summary>This flag is not implemented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TKF.TKF_TOGGLEKEYSON">
            <summary>If this flag is set, the ToggleKeys feature is on.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.ExitWindowsEx(Vanara.PInvoke.User32.ExitWindowsFlags,Vanara.PInvoke.SystemShutDownReason)">
            <summary>
            The ExitWindowsEx function either logs off the current user, shuts down the system, or shuts down and restarts the system. It
            sends the WM_QUERYENDSESSION message to all applications to determine if they can be terminated.
            </summary>
            <param name="uFlags">Specifies the type of shutdown.</param>
            <param name="dwReason">The reason for initiating the shutdown.</param>
            <returns>
            If the function succeeds, the return value is nonzero. <br></br><br>If the function fails, the return value is zero. To get
            extended error information, call Marshal.GetLastWin32Error.</br>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetSystemMetrics(Vanara.PInvoke.User32.SystemMetric)">
            <summary>
            <para>Retrieves the specified system metric or system configuration setting.</para>
            <para>Note that all dimensions retrieved by <c>GetSystemMetrics</c> are in pixels.</para>
            </summary>
            <param name="nIndex">
            <para>Type: <c>int</c></para>
            <para>
            The system metric or configuration setting to be retrieved. This parameter can be one of the following values. Note that all
            SM_CX* values are widths and all SM_CY* values are heights. Also note that all settings designed to return Boolean data represent
            <c>TRUE</c> as any nonzero value, and <c>FALSE</c> as a zero value.
            </para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SM_ARRANGE56</term>
            <term>
            The flags that specify how the system arranged minimized windows. For more information, see the Remarks section in this topic.
            </term>
            </item>
            <item>
            <term>SM_CLEANBOOT67</term>
            <term>
            The value that specifies how the system is started: A fail-safe boot (also called SafeBoot, Safe Mode, or Clean Boot) bypasses
            the user startup files.
            </term>
            </item>
            <item>
            <term>SM_CMONITORS80</term>
            <term>The number of display monitors on a desktop. For more information, see the Remarks section in this topic.</term>
            </item>
            <item>
            <term>SM_CMOUSEBUTTONS43</term>
            <term>The number of buttons on a mouse, or zero if no mouse is installed.</term>
            </item>
            <item>
            <term>SM_CONVERTIBLESLATEMODE0x2003</term>
            <term>
            Reflects the state of the laptop or slate mode, 0 for Slate Mode and non-zero otherwise. When this system metric changes, the
            system sends a broadcast message via WM_SETTINGCHANGE with &amp;quot;ConvertibleSlateMode&amp;quot; in the LPARAM. Note that this
            system metric doesn't apply to desktop PCs. In that case, use GetAutoRotationState.
            </term>
            </item>
            <item>
            <term>SM_CXBORDER5</term>
            <term>The width of a window border, in pixels. This is equivalent to the SM_CXEDGE value for windows with the 3-D look.</term>
            </item>
            <item>
            <term>SM_CXCURSOR13</term>
            <term>The width of a cursor, in pixels. The system cannot create cursors of other sizes.</term>
            </item>
            <item>
            <term>SM_CXDLGFRAME7</term>
            <term>This value is the same as SM_CXFIXEDFRAME.</term>
            </item>
            <item>
            <term>SM_CXDOUBLECLK36</term>
            <term>
            The width of the rectangle around the location of a first click in a double-click sequence, in pixels. The second click must
            occur within the rectangle that is defined by SM_CXDOUBLECLK and SM_CYDOUBLECLK for the system to consider the two clicks a
            double-click. The two clicks must also occur within a specified time. To set the width of the double-click rectangle, call
            SystemParametersInfo with SPI_SETDOUBLECLKWIDTH.
            </term>
            </item>
            <item>
            <term>SM_CXDRAG68</term>
            <term>
            The number of pixels on either side of a mouse-down point that the mouse pointer can move before a drag operation begins. This
            allows the user to click and release the mouse button easily without unintentionally starting a drag operation. If this value is
            negative, it is subtracted from the left of the mouse-down point and added to the right of it.
            </term>
            </item>
            <item>
            <term>SM_CXEDGE45</term>
            <term>The width of a 3-D border, in pixels. This metric is the 3-D counterpart of SM_CXBORDER.</term>
            </item>
            <item>
            <term>SM_CXFIXEDFRAME7</term>
            <term>
            The thickness of the frame around the perimeter of a window that has a caption but is not sizable, in pixels. SM_CXFIXEDFRAME is
            the height of the horizontal border, and SM_CYFIXEDFRAME is the width of the vertical border. This value is the same as SM_CXDLGFRAME.
            </term>
            </item>
            <item>
            <term>SM_CXFOCUSBORDER83</term>
            <term>
            The width of the left and right edges of the focus rectangle that the DrawFocusRect draws. This value is in pixels. Windows 2000:
            This value is not supported.
            </term>
            </item>
            <item>
            <term>SM_CXFRAME32</term>
            <term>This value is the same as SM_CXSIZEFRAME.</term>
            </item>
            <item>
            <term>SM_CXFULLSCREEN16</term>
            <term>
            The width of the client area for a full-screen window on the primary display monitor, in pixels. To get the coordinates of the
            portion of the screen that is not obscured by the system taskbar or by application desktop toolbars, call the
            SystemParametersInfo function with the SPI_GETWORKAREA value.
            </term>
            </item>
            <item>
            <term>SM_CXHSCROLL21</term>
            <term>The width of the arrow bitmap on a horizontal scroll bar, in pixels.</term>
            </item>
            <item>
            <term>SM_CXHTHUMB10</term>
            <term>The width of the thumb box in a horizontal scroll bar, in pixels.</term>
            </item>
            <item>
            <term>SM_CXICON11</term>
            <term>
            The default width of an icon, in pixels. The LoadIcon function can load only icons with the dimensions that SM_CXICON and
            SM_CYICON specifies.
            </term>
            </item>
            <item>
            <term>SM_CXICONSPACING38</term>
            <term>
            The width of a grid cell for items in large icon view, in pixels. Each item fits into a rectangle of size SM_CXICONSPACING by
            SM_CYICONSPACING when arranged. This value is always greater than or equal to SM_CXICON.
            </term>
            </item>
            <item>
            <term>SM_CXMAXIMIZED61</term>
            <term>The default width, in pixels, of a maximized top-level window on the primary display monitor.</term>
            </item>
            <item>
            <term>SM_CXMAXTRACK59</term>
            <term>
            The default maximum width of a window that has a caption and sizing borders, in pixels. This metric refers to the entire desktop.
            The user cannot drag the window frame to a size larger than these dimensions. A window can override this value by processing the
            WM_GETMINMAXINFO message.
            </term>
            </item>
            <item>
            <term>SM_CXMENUCHECK71</term>
            <term>The width of the default menu check-mark bitmap, in pixels.</term>
            </item>
            <item>
            <term>SM_CXMENUSIZE54</term>
            <term>
            The width of menu bar buttons, such as the child window close button that is used in the multiple document interface, in pixels.
            </term>
            </item>
            <item>
            <term>SM_CXMIN28</term>
            <term>The minimum width of a window, in pixels.</term>
            </item>
            <item>
            <term>SM_CXMINIMIZED57</term>
            <term>The width of a minimized window, in pixels.</term>
            </item>
            <item>
            <term>SM_CXMINSPACING47</term>
            <term>
            The width of a grid cell for a minimized window, in pixels. Each minimized window fits into a rectangle this size when arranged.
            This value is always greater than or equal to SM_CXMINIMIZED.
            </term>
            </item>
            <item>
            <term>SM_CXMINTRACK34</term>
            <term>
            The minimum tracking width of a window, in pixels. The user cannot drag the window frame to a size smaller than these dimensions.
            A window can override this value by processing the WM_GETMINMAXINFO message.
            </term>
            </item>
            <item>
            <term>SM_CXPADDEDBORDER92</term>
            <term>The amount of border padding for captioned windows, in pixels.Windows XP/2000: This value is not supported.</term>
            </item>
            <item>
            <term>SM_CXSCREEN0</term>
            <term>
            The width of the screen of the primary display monitor, in pixels. This is the same value obtained by calling GetDeviceCaps as
            follows: .
            </term>
            </item>
            <item>
            <term>SM_CXSIZE30</term>
            <term>The width of a button in a window caption or title bar, in pixels.</term>
            </item>
            <item>
            <term>SM_CXSIZEFRAME32</term>
            <term>
            The thickness of the sizing border around the perimeter of a window that can be resized, in pixels. SM_CXSIZEFRAME is the width
            of the horizontal border, and SM_CYSIZEFRAME is the height of the vertical border. This value is the same as SM_CXFRAME.
            </term>
            </item>
            <item>
            <term>SM_CXSMICON49</term>
            <term>The recommended width of a small icon, in pixels. Small icons typically appear in window captions and in small icon view.</term>
            </item>
            <item>
            <term>SM_CXSMSIZE52</term>
            <term>The width of small caption buttons, in pixels.</term>
            </item>
            <item>
            <term>SM_CXVIRTUALSCREEN78</term>
            <term>
            The width of the virtual screen, in pixels. The virtual screen is the bounding rectangle of all display monitors. The
            SM_XVIRTUALSCREEN metric is the coordinates for the left side of the virtual screen.
            </term>
            </item>
            <item>
            <term>SM_CXVSCROLL2</term>
            <term>The width of a vertical scroll bar, in pixels.</term>
            </item>
            <item>
            <term>SM_CYBORDER6</term>
            <term>The height of a window border, in pixels. This is equivalent to the SM_CYEDGE value for windows with the 3-D look.</term>
            </item>
            <item>
            <term>SM_CYCAPTION4</term>
            <term>The height of a caption area, in pixels.</term>
            </item>
            <item>
            <term>SM_CYCURSOR14</term>
            <term>The height of a cursor, in pixels. The system cannot create cursors of other sizes.</term>
            </item>
            <item>
            <term>SM_CYDLGFRAME8</term>
            <term>This value is the same as SM_CYFIXEDFRAME.</term>
            </item>
            <item>
            <term>SM_CYDOUBLECLK37</term>
            <term>
            The height of the rectangle around the location of a first click in a double-click sequence, in pixels. The second click must
            occur within the rectangle defined by SM_CXDOUBLECLK and SM_CYDOUBLECLK for the system to consider the two clicks a double-click.
            The two clicks must also occur within a specified time. To set the height of the double-click rectangle, call
            SystemParametersInfo with SPI_SETDOUBLECLKHEIGHT.
            </term>
            </item>
            <item>
            <term>SM_CYDRAG69</term>
            <term>
            The number of pixels above and below a mouse-down point that the mouse pointer can move before a drag operation begins. This
            allows the user to click and release the mouse button easily without unintentionally starting a drag operation. If this value is
            negative, it is subtracted from above the mouse-down point and added below it.
            </term>
            </item>
            <item>
            <term>SM_CYEDGE46</term>
            <term>The height of a 3-D border, in pixels. This is the 3-D counterpart of SM_CYBORDER.</term>
            </item>
            <item>
            <term>SM_CYFIXEDFRAME8</term>
            <term>
            The thickness of the frame around the perimeter of a window that has a caption but is not sizable, in pixels. SM_CXFIXEDFRAME is
            the height of the horizontal border, and SM_CYFIXEDFRAME is the width of the vertical border.This value is the same as SM_CYDLGFRAME.
            </term>
            </item>
            <item>
            <term>SM_CYFOCUSBORDER84</term>
            <term>
            The height of the top and bottom edges of the focus rectangle drawn by DrawFocusRect. This value is in pixels.Windows 2000: This
            value is not supported.
            </term>
            </item>
            <item>
            <term>SM_CYFRAME33</term>
            <term>This value is the same as SM_CYSIZEFRAME.</term>
            </item>
            <item>
            <term>SM_CYFULLSCREEN17</term>
            <term>
            The height of the client area for a full-screen window on the primary display monitor, in pixels. To get the coordinates of the
            portion of the screen not obscured by the system taskbar or by application desktop toolbars, call the SystemParametersInfo
            function with the SPI_GETWORKAREA value.
            </term>
            </item>
            <item>
            <term>SM_CYHSCROLL3</term>
            <term>The height of a horizontal scroll bar, in pixels.</term>
            </item>
            <item>
            <term>SM_CYICON12</term>
            <term>
            The default height of an icon, in pixels. The LoadIcon function can load only icons with the dimensions SM_CXICON and SM_CYICON.
            </term>
            </item>
            <item>
            <term>SM_CYICONSPACING39</term>
            <term>
            The height of a grid cell for items in large icon view, in pixels. Each item fits into a rectangle of size SM_CXICONSPACING by
            SM_CYICONSPACING when arranged. This value is always greater than or equal to SM_CYICON.
            </term>
            </item>
            <item>
            <term>SM_CYKANJIWINDOW18</term>
            <term>
            For double byte character set versions of the system, this is the height of the Kanji window at the bottom of the screen, in pixels.
            </term>
            </item>
            <item>
            <term>SM_CYMAXIMIZED62</term>
            <term>The default height, in pixels, of a maximized top-level window on the primary display monitor.</term>
            </item>
            <item>
            <term>SM_CYMAXTRACK60</term>
            <term>
            The default maximum height of a window that has a caption and sizing borders, in pixels. This metric refers to the entire
            desktop. The user cannot drag the window frame to a size larger than these dimensions. A window can override this value by
            processing the WM_GETMINMAXINFO message.
            </term>
            </item>
            <item>
            <term>SM_CYMENU15</term>
            <term>The height of a single-line menu bar, in pixels.</term>
            </item>
            <item>
            <term>SM_CYMENUCHECK72</term>
            <term>The height of the default menu check-mark bitmap, in pixels.</term>
            </item>
            <item>
            <term>SM_CYMENUSIZE55</term>
            <term>
            The height of menu bar buttons, such as the child window close button that is used in the multiple document interface, in pixels.
            </term>
            </item>
            <item>
            <term>SM_CYMIN29</term>
            <term>The minimum height of a window, in pixels.</term>
            </item>
            <item>
            <term>SM_CYMINIMIZED58</term>
            <term>The height of a minimized window, in pixels.</term>
            </item>
            <item>
            <term>SM_CYMINSPACING48</term>
            <term>
            The height of a grid cell for a minimized window, in pixels. Each minimized window fits into a rectangle this size when arranged.
            This value is always greater than or equal to SM_CYMINIMIZED.
            </term>
            </item>
            <item>
            <term>SM_CYMINTRACK35</term>
            <term>
            The minimum tracking height of a window, in pixels. The user cannot drag the window frame to a size smaller than these
            dimensions. A window can override this value by processing the WM_GETMINMAXINFO message.
            </term>
            </item>
            <item>
            <term>SM_CYSCREEN1</term>
            <term>
            The height of the screen of the primary display monitor, in pixels. This is the same value obtained by calling GetDeviceCaps as
            follows: .
            </term>
            </item>
            <item>
            <term>SM_CYSIZE31</term>
            <term>The height of a button in a window caption or title bar, in pixels.</term>
            </item>
            <item>
            <term>SM_CYSIZEFRAME33</term>
            <term>
            The thickness of the sizing border around the perimeter of a window that can be resized, in pixels. SM_CXSIZEFRAME is the width
            of the horizontal border, and SM_CYSIZEFRAME is the height of the vertical border. This value is the same as SM_CYFRAME.
            </term>
            </item>
            <item>
            <term>SM_CYSMCAPTION51</term>
            <term>The height of a small caption, in pixels.</term>
            </item>
            <item>
            <term>SM_CYSMICON50</term>
            <term>The recommended height of a small icon, in pixels. Small icons typically appear in window captions and in small icon view.</term>
            </item>
            <item>
            <term>SM_CYSMSIZE53</term>
            <term>The height of small caption buttons, in pixels.</term>
            </item>
            <item>
            <term>SM_CYVIRTUALSCREEN79</term>
            <term>
            The height of the virtual screen, in pixels. The virtual screen is the bounding rectangle of all display monitors. The
            SM_YVIRTUALSCREEN metric is the coordinates for the top of the virtual screen.
            </term>
            </item>
            <item>
            <term>SM_CYVSCROLL20</term>
            <term>The height of the arrow bitmap on a vertical scroll bar, in pixels.</term>
            </item>
            <item>
            <term>SM_CYVTHUMB9</term>
            <term>The height of the thumb box in a vertical scroll bar, in pixels.</term>
            </item>
            <item>
            <term>SM_DBCSENABLED42</term>
            <term>Nonzero if User32.dll supports DBCS; otherwise, 0.</term>
            </item>
            <item>
            <term>SM_DEBUG22</term>
            <term>Nonzero if the debug version of User.exe is installed; otherwise, 0.</term>
            </item>
            <item>
            <term>SM_DIGITIZER94</term>
            <term>
            Nonzero if the current operating system is Windows 7 or Windows Server 2008 R2 and the Tablet PC Input service is started;
            otherwise, 0. The return value is a bitmask that specifies the type of digitizer input supported by the device. For more
            information, see Remarks.Windows Server 2008, Windows Vista and Windows XP/2000: This value is not supported.
            </term>
            </item>
            <item>
            <term>SM_IMMENABLED82</term>
            <term>
            Nonzero if Input Method Manager/Input Method Editor features are enabled; otherwise, 0. SM_IMMENABLED indicates whether the
            system is ready to use a Unicode-based IME on a Unicode application. To ensure that a language-dependent IME works, check
            SM_DBCSENABLED and the system ANSI code page. Otherwise the ANSI-to-Unicode conversion may not be performed correctly, or some
            components like fonts or registry settings may not be present.
            </term>
            </item>
            <item>
            <term>SM_MAXIMUMTOUCHES95</term>
            <term>
            Nonzero if there are digitizers in the system; otherwise, 0. SM_MAXIMUMTOUCHES returns the aggregate maximum of the maximum
            number of contacts supported by every digitizer in the system. If the system has only single-touch digitizers, the return value
            is 1. If the system has multi-touch digitizers, the return value is the number of simultaneous contacts the hardware can
            provide.Windows Server 2008, Windows Vista and Windows XP/2000: This value is not supported.
            </term>
            </item>
            <item>
            <term>SM_MEDIACENTER87</term>
            <term>Nonzero if the current operating system is the Windows XP, Media Center Edition, 0 if not.</term>
            </item>
            <item>
            <term>SM_MENUDROPALIGNMENT40</term>
            <term>Nonzero if drop-down menus are right-aligned with the corresponding menu-bar item; 0 if the menus are left-aligned.</term>
            </item>
            <item>
            <term>SM_MIDEASTENABLED74</term>
            <term>Nonzero if the system is enabled for Hebrew and Arabic languages, 0 if not.</term>
            </item>
            <item>
            <term>SM_MOUSEPRESENT19</term>
            <term>
            Nonzero if a mouse is installed; otherwise, 0. This value is rarely zero, because of support for virtual mice and because some
            systems detect the presence of the port instead of the presence of a mouse.
            </term>
            </item>
            <item>
            <term>SM_MOUSEHORIZONTALWHEELPRESENT91</term>
            <term>Nonzero if a mouse with a horizontal scroll wheel is installed; otherwise 0.</term>
            </item>
            <item>
            <term>SM_MOUSEWHEELPRESENT75</term>
            <term>Nonzero if a mouse with a vertical scroll wheel is installed; otherwise 0.</term>
            </item>
            <item>
            <term>SM_NETWORK63</term>
            <term>
            The least significant bit is set if a network is present; otherwise, it is cleared. The other bits are reserved for future use.
            </term>
            </item>
            <item>
            <term>SM_PENWINDOWS41</term>
            <term>Nonzero if the Microsoft Windows for Pen computing extensions are installed; zero otherwise.</term>
            </item>
            <item>
            <term>SM_REMOTECONTROL0x2001</term>
            <term>
            This system metric is used in a Terminal Services environment to determine if the current Terminal Server session is being
            remotely controlled. Its value is nonzero if the current session is remotely controlled; otherwise, 0.You can use terminal
            services management tools such as Terminal Services Manager (tsadmin.msc) and shadow.exe to control a remote session. When a
            session is being remotely controlled, another user can view the contents of that session and potentially interact with it.
            </term>
            </item>
            <item>
            <term>SM_REMOTESESSION0x1000</term>
            <term>
            This system metric is used in a Terminal Services environment. If the calling process is associated with a Terminal Services
            client session, the return value is nonzero. If the calling process is associated with the Terminal Services console session, the
            return value is 0. Windows Server 2003 and Windows XP: The console session is not necessarily the physical console. For more
            information, see WTSGetActiveConsoleSessionId.
            </term>
            </item>
            <item>
            <term>SM_SAMEDISPLAYFORMAT81</term>
            <term>
            Nonzero if all the display monitors have the same color format, otherwise, 0. Two displays can have the same bit depth, but
            different color formats. For example, the red, green, and blue pixels can be encoded with different numbers of bits, or those
            bits can be located in different places in a pixel color value.
            </term>
            </item>
            <item>
            <term>SM_SECURE44</term>
            <term>This system metric should be ignored; it always returns 0.</term>
            </item>
            <item>
            <term>SM_SERVERR289</term>
            <term>The build number if the system is Windows Server 2003 R2; otherwise, 0.</term>
            </item>
            <item>
            <term>SM_SHOWSOUNDS70</term>
            <term>
            Nonzero if the user requires an application to present information visually in situations where it would otherwise present the
            information only in audible form; otherwise, 0.
            </term>
            </item>
            <item>
            <term>SM_SHUTTINGDOWN0x2000</term>
            <term>Nonzero if the current session is shutting down; otherwise, 0. Windows 2000: This value is not supported.</term>
            </item>
            <item>
            <term>SM_SLOWMACHINE73</term>
            <term>Nonzero if the computer has a low-end (slow) processor; otherwise, 0.</term>
            </item>
            <item>
            <term>SM_STARTER88</term>
            <term>
            Nonzero if the current operating system is Windows 7 Starter Edition, Windows Vista Starter, or Windows XP Starter Edition;
            otherwise, 0.
            </term>
            </item>
            <item>
            <term>SM_SWAPBUTTON23</term>
            <term>Nonzero if the meanings of the left and right mouse buttons are swapped; otherwise, 0.</term>
            </item>
            <item>
            <term>SM_SYSTEMDOCKED0x2004</term>
            <term>
            Reflects the state of the docking mode, 0 for Undocked Mode and non-zero otherwise. When this system metric changes, the system
            sends a broadcast message via WM_SETTINGCHANGE with &amp;quot;SystemDockMode&amp;quot; in the LPARAM.
            </term>
            </item>
            <item>
            <term>SM_TABLETPC86</term>
            <term>
            Nonzero if the current operating system is the Windows XP Tablet PC edition or if the current operating system is Windows Vista
            or Windows 7 and the Tablet PC Input service is started; otherwise, 0. The SM_DIGITIZER setting indicates the type of digitizer
            input supported by a device running Windows 7 or Windows Server 2008 R2. For more information, see Remarks.
            </term>
            </item>
            <item>
            <term>SM_XVIRTUALSCREEN76</term>
            <term>
            The coordinates for the left side of the virtual screen. The virtual screen is the bounding rectangle of all display monitors.
            The SM_CXVIRTUALSCREEN metric is the width of the virtual screen.
            </term>
            </item>
            <item>
            <term>SM_YVIRTUALSCREEN77</term>
            <term>
            The coordinates for the top of the virtual screen. The virtual screen is the bounding rectangle of all display monitors. The
            SM_CYVIRTUALSCREEN metric is the height of the virtual screen.
            </term>
            </item>
            </list>
            </para>
            </param>
            <returns>
            <para>Type:</para>
            <para>If the function succeeds, the return value is the requested system metric or configuration setting.</para>
            <para>If the function fails, the return value is 0. <c>GetLastError</c> does not provide extended error information.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.LockWorkStation">
            <summary>Locks the workstation's display, protecting it from unauthorized use.</summary>
            <returns>0 on failure, non-zero for success</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.MB_GetString(System.UInt32)">
            <summary>Returns strings for standard message box buttons.</summary>
            <param name="wBtn">The id of the string to return. These are identified by the Dialog Box Command ID values listed in winuser.h.</param>
            <returns>The string, or NULL if not found.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.MessageBeep(System.UInt32)">
            <summary>
            <para>Plays a waveform sound. The waveform sound for each sound type is identified by an entry in the registry.</para>
            </summary>
            <param name="uType">
            <para>
            The sound to be played. The sounds are set by the user through the Sound control panel application, and then stored in the registry.
            </para>
            <para>This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0xFFFFFFFF</term>
            <term>A simple beep. If the sound card is not available, the sound is generated using the speaker.</term>
            </item>
            <item>
            <term>MB_ICONASTERISK 0x00000040L</term>
            <term>See MB_ICONINFORMATION.</term>
            </item>
            <item>
            <term>MB_ICONEXCLAMATION 0x00000030L</term>
            <term>See MB_ICONWARNING.</term>
            </item>
            <item>
            <term>MB_ICONERROR 0x00000010L</term>
            <term>The sound specified as the Windows Critical Stop sound.</term>
            </item>
            <item>
            <term>MB_ICONHAND 0x00000010L</term>
            <term>See MB_ICONERROR.</term>
            </item>
            <item>
            <term>MB_ICONINFORMATION 0x00000040L</term>
            <term>The sound specified as the Windows Asterisk sound.</term>
            </item>
            <item>
            <term>MB_ICONQUESTION 0x00000020L</term>
            <term>The sound specified as the Windows Question sound.</term>
            </item>
            <item>
            <term>MB_ICONSTOP 0x00000010L</term>
            <term>See MB_ICONERROR.</term>
            </item>
            <item>
            <term>MB_ICONWARNING 0x00000030L</term>
            <term>The sound specified as the Windows Exclamation sound.</term>
            </item>
            <item>
            <term>MB_OK 0x00000000L</term>
            <term>The sound specified as the Windows Default Beep sound.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>After queuing the sound, the <c>MessageBeep</c> function returns control to the calling function and plays the sound asynchronously.</para>
            <para>
            If it cannot play the specified alert sound, <c>MessageBeep</c> attempts to play the system default sound. If it cannot play the
            system default sound, the function produces a standard beep sound through the computer speaker.
            </para>
            <para>The user can disable the warning beep by using the Sound control panel application.</para>
            <para>
            <c>Note</c> To send a beep to a remote client, use the Beep function. The <c>Beep</c> function is redirected to the client,
            whereas <c>MessageBeep</c> is not.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.MessageBox(Vanara.PInvoke.HWND,System.String,System.String,Vanara.PInvoke.User32.MB_FLAGS)">
            <summary>
            Displays a modal dialog box that contains a system icon, a set of buttons, and a brief application-specific message, such as
            status or error information. The message box returns an integer value that indicates which button the user clicked.
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the owner window of the message box to be created. If this parameter is <c>NULL</c>, the message box has no owner window.
            </para>
            </param>
            <param name="lpText">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The message to be displayed. If the string consists of more than one line, you can separate the lines using a carriage return
            and/or linefeed character between each line.
            </para>
            </param>
            <param name="lpCaption">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The dialog box title. If this parameter is <c>NULL</c>, the default title is <c>Error</c>.</para>
            </param>
            <param name="uType">
            <para>Type: <c>UINT</c></para>
            <para>
            The contents and behavior of the dialog box. This parameter can be a combination of flags from the following groups of flags.
            </para>
            <para>To indicate the buttons displayed in the message box, specify one of the following values.</para>
            <list type="table">
            <listheader>
            <description>Value</description>
            <description>Meaning</description>
            </listheader>
            <item>
            <description><c>MB_ABORTRETRYIGNORE</c> 0x00000002L</description>
            <description>The message box contains three push buttons: <c>Abort</c>, <c>Retry</c>, and <c>Ignore</c>.</description>
            </item>
            <item>
            <description><c>MB_CANCELTRYCONTINUE</c> 0x00000006L</description>
            <description>
            The message box contains three push buttons: <c>Cancel</c>, <c>Try Again</c>, <c>Continue</c>. Use this message box type instead
            of MB_ABORTRETRYIGNORE.
            </description>
            </item>
            <item>
            <description><c>MB_HELP</c> 0x00004000L</description>
            <description>
            Adds a <c>Help</c> button to the message box. When the user clicks the <c>Help</c> button or presses F1, the system sends a
            WM_HELP message to the owner.
            </description>
            </item>
            <item>
            <description><c>MB_OK</c> 0x00000000L</description>
            <description>The message box contains one push button: <c>OK</c>. This is the default.</description>
            </item>
            <item>
            <description><c>MB_OKCANCEL</c> 0x00000001L</description>
            <description>The message box contains two push buttons: <c>OK</c> and <c>Cancel</c>.</description>
            </item>
            <item>
            <description><c>MB_RETRYCANCEL</c> 0x00000005L</description>
            <description>The message box contains two push buttons: <c>Retry</c> and <c>Cancel</c>.</description>
            </item>
            <item>
            <description><c>MB_YESNO</c> 0x00000004L</description>
            <description>The message box contains two push buttons: <c>Yes</c> and <c>No</c>.</description>
            </item>
            <item>
            <description><c>MB_YESNOCANCEL</c> 0x00000003L</description>
            <description>The message box contains three push buttons: <c>Yes</c>, <c>No</c>, and <c>Cancel</c>.</description>
            </item>
            </list>
            <para>Â</para>
            <para>To display an icon in the message box, specify one of the following values.</para>
            <list type="table">
            <listheader>
            <description>Value</description>
            <description>Meaning</description>
            </listheader>
            <item>
            <description><c>MB_ICONEXCLAMATION</c> 0x00000030L</description>
            <description>An exclamation-point icon appears in the message box.</description>
            </item>
            <item>
            <description><c>MB_ICONWARNING</c> 0x00000030L</description>
            <description>An exclamation-point icon appears in the message box.</description>
            </item>
            <item>
            <description><c>MB_ICONINFORMATION</c> 0x00000040L</description>
            <description>An icon consisting of a lowercase letter <c>i</c> in a circle appears in the message box.</description>
            </item>
            <item>
            <description><c>MB_ICONASTERISK</c> 0x00000040L</description>
            <description>An icon consisting of a lowercase letter <c>i</c> in a circle appears in the message box.</description>
            </item>
            <item>
            <description><c>MB_ICONQUESTION</c> 0x00000020L</description>
            <description>
            A question-mark icon appears in the message box. The question-mark message icon is no longer recommended because it does not
            clearly represent a specific type of message and because the phrasing of a message as a question could apply to any message type.
            In addition, users can confuse the message symbol question mark with Help information. Therefore, do not use this question mark
            message symbol in your message boxes. The system continues to support its inclusion only for backward compatibility.
            </description>
            </item>
            <item>
            <description><c>MB_ICONSTOP</c> 0x00000010L</description>
            <description>A stop-sign icon appears in the message box.</description>
            </item>
            <item>
            <description><c>MB_ICONERROR</c> 0x00000010L</description>
            <description>A stop-sign icon appears in the message box.</description>
            </item>
            <item>
            <description><c>MB_ICONHAND</c> 0x00000010L</description>
            <description>A stop-sign icon appears in the message box.</description>
            </item>
            </list>
            <para>Â</para>
            <para>To indicate the default button, specify one of the following values.</para>
            <list type="table">
            <listheader>
            <description>Value</description>
            <description>Meaning</description>
            </listheader>
            <item>
            <description><c>MB_DEFBUTTON1</c> 0x00000000L</description>
            <description>
            The first button is the default button. <c>MB_DEFBUTTON1</c> is the default unless <c>MB_DEFBUTTON2</c>, <c>MB_DEFBUTTON3</c>, or
            <c>MB_DEFBUTTON4</c> is specified.
            </description>
            </item>
            <item>
            <description><c>MB_DEFBUTTON2</c> 0x00000100L</description>
            <description>The second button is the default button.</description>
            </item>
            <item>
            <description><c>MB_DEFBUTTON3</c> 0x00000200L</description>
            <description>The third button is the default button.</description>
            </item>
            <item>
            <description><c>MB_DEFBUTTON4</c> 0x00000300L</description>
            <description>The fourth button is the default button.</description>
            </item>
            </list>
            <para>Â</para>
            <para>To indicate the modality of the dialog box, specify one of the following values.</para>
            <list type="table">
            <listheader>
            <description>Value</description>
            <description>Meaning</description>
            </listheader>
            <item>
            <description><c>MB_APPLMODAL</c> 0x00000000L</description>
            <description>
            The user must respond to the message box before continuing work in the window identified by the <c>hWnd</c> parameter. However,
            the user can move to the windows of other threads and work in those windows. Depending on the hierarchy of windows in the
            application, the user may be able to move to other windows within the thread. All child windows of the parent of the message box
            are automatically disabled, but pop-up windows are not. <c>MB_APPLMODAL</c> is the default if neither <c>MB_SYSTEMMODAL</c> nor
            <c>MB_TASKMODAL</c> is specified.
            </description>
            </item>
            <item>
            <description><c>MB_SYSTEMMODAL</c> 0x00001000L</description>
            <description>
            Same as MB_APPLMODAL except that the message box has the <c>WS_EX_TOPMOST</c> style. Use system-modal message boxes to notify the
            user of serious, potentially damaging errors that require immediate attention (for example, running out of memory). This flag has
            no effect on the user's ability to interact with windows other than those associated with <c>hWnd</c>.
            </description>
            </item>
            <item>
            <description><c>MB_TASKMODAL</c> 0x00002000L</description>
            <description>
            Same as <c>MB_APPLMODAL</c> except that all the top-level windows belonging to the current thread are disabled if the <c>hWnd</c>
            parameter is <c>NULL</c>. Use this flag when the calling application or library does not have a window handle available but still
            needs to prevent input to other windows in the calling thread without suspending other threads.
            </description>
            </item>
            </list>
            <para>Â</para>
            <para>To specify other options, use one or more of the following values.</para>
            <list type="table">
            <listheader>
            <description>Value</description>
            <description>Meaning</description>
            </listheader>
            <item>
            <description><c>MB_DEFAULT_DESKTOP_ONLY</c> 0x00020000L</description>
            <description>
            Same as desktop of the interactive window station. For more information, see Window Stations. If the current input desktop is not
            the default desktop, <c>MessageBox</c> does not return until the user switches to the default desktop.
            </description>
            </item>
            <item>
            <description><c>MB_RIGHT</c> 0x00080000L</description>
            <description>The text is right-justified.</description>
            </item>
            <item>
            <description><c>MB_RTLREADING</c> 0x00100000L</description>
            <description>Displays message and caption text using right-to-left reading order on Hebrew and Arabic systems.</description>
            </item>
            <item>
            <description><c>MB_SETFOREGROUND</c> 0x00010000L</description>
            <description>
            The message box becomes the foreground window. Internally, the system calls the SetForegroundWindow function for the message box.
            </description>
            </item>
            <item>
            <description><c>MB_TOPMOST</c> 0x00040000L</description>
            <description>The message box is created with the <c>WS_EX_TOPMOST</c> window style.</description>
            </item>
            <item>
            <description><c>MB_SERVICE_NOTIFICATION</c> 0x00200000L</description>
            <description>
            The caller is a service notifying the user of an event. The function displays a message box on the current active desktop, even
            if there is no user logged on to the computer. <c>Terminal Services:</c> If the calling thread has an impersonation token, the
            function directs the message box to the session specified in the impersonation token. If this flag is set, the <c>hWnd</c>
            parameter must be <c>NULL</c>. This is so that the message box can appear on a desktop other than the desktop corresponding to
            the <c>hWnd</c>. For information on security considerations in regard to using this flag, see Interactive Services. In
            particular, be aware that this flag can produce interactive content on a locked desktop and should therefore be used for only a
            very limited set of scenarios, such as resource exhaustion.
            </description>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            If a message box has a <c>Cancel</c> button, the function returns the <c>IDCANCEL</c> value if either the ESC key is pressed or
            the <c>Cancel</c> button is selected. If the message box has no <c>Cancel</c> button, pressing ESC will no effect - unless an
            MB_OK button is present. If an MB_OK button is displayed and the user presses ESC, the return value will be <c>IDOK</c>.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            <para>If the function succeeds, the return value is one of the following menu-item values.</para>
            <list type="table">
            <listheader>
            <description>Return code/value</description>
            <description>Description</description>
            </listheader>
            <item>
            <description><c>IDABORT</c> 3</description>
            <description>The <c>Abort</c> button was selected.</description>
            </item>
            <item>
            <description><c>IDCANCEL</c> 2</description>
            <description>The <c>Cancel</c> button was selected.</description>
            </item>
            <item>
            <description><c>IDCONTINUE</c> 11</description>
            <description>The <c>Continue</c> button was selected.</description>
            </item>
            <item>
            <description><c>IDIGNORE</c> 5</description>
            <description>The <c>Ignore</c> button was selected.</description>
            </item>
            <item>
            <description><c>IDNO</c> 7</description>
            <description>The <c>No</c> button was selected.</description>
            </item>
            <item>
            <description><c>IDOK</c> 1</description>
            <description>The <c>OK</c> button was selected.</description>
            </item>
            <item>
            <description><c>IDRETRY</c> 4</description>
            <description>The <c>Retry</c> button was selected.</description>
            </item>
            <item>
            <description><c>IDTRYAGAIN</c> 10</description>
            <description>The <c>Try Again</c> button was selected.</description>
            </item>
            <item>
            <description><c>IDYES</c> 6</description>
            <description>The <c>Yes</c> button was selected.</description>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The following system icons can be used in a message box by setting the <c>uType</c> parameter to the corresponding flag value.
            </para>
            <list type="table">
            <listheader>
            <description>Icon</description>
            <description>Flag values</description>
            </listheader>
            <item>
            <description/>
            <description><c>MB_ICONHAND</c>, <c>MB_ICONSTOP</c>, or <c>MB_ICONERROR</c></description>
            </item>
            <item>
            <description/>
            <description><c>MB_ICONQUESTION</c></description>
            </item>
            <item>
            <description/>
            <description><c>MB_ICONEXCLAMATION</c> or <c>MB_ICONWARNING</c></description>
            </item>
            <item>
            <description/>
            <description><c>MB_ICONASTERISK</c> or <c>MB_ICONINFORMATION</c></description>
            </item>
            </list>
            <para>Â</para>
            <para>
            Adding two right-to-left marks (RLMs), represented by Unicode formatting character U+200F, in the beginning of a MessageBox
            display string is interpreted by the MessageBox rendering engine so as to cause the reading order of the MessageBox to be
            rendered as right-to-left (RTL).
            </para>
            <para>
            When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the <c>lpText</c>
            and <c>lpCaption</c> parameters should not be taken from a resource file because an attempt to load the resource may fail.
            </para>
            <para>
            If you create a message box while a dialog box is present, use a handle to the dialog box as the <c>hWnd</c> parameter. The
            <c>hWnd</c> parameter should not identify a child window, such as a control in a dialog box.
            </para>
            <para>Examples</para>
            <para>
            In the following example, the application displays a message box that prompts the user for an action after an error condition has
            occurred. The message box displays the message that describes the error condition and how to resolve it. The
            <c>MB_CANCELTRYCONTINUE</c> style directs <c>MessageBox</c> to provide three buttons with which the user can choose how to
            proceed. The <c>MB_DEFBUTTON2</c> style sets the default focus on the second button of the message box, in this case, the <c>Try
            Again</c> button.
            </para>
            <para>The following image shows the output from the preceding code example:</para>
            <para>For another message box example, see Displaying a Message Box.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.MessageBoxIndirect(Vanara.PInvoke.User32.MSGBOXPARAMS@)">
            <summary>
            <note type="warning">This function is undocumented, but has been available since Windows XP. Use with caution.</note>
            Creates, displays, and operates a message box. The message box contains application-defined message text and title, any icon, and
            any combination of predefined push buttons.
            </summary>
            <param name="lpMsgBoxParams">A pointer to a MSGBOXPARAMS structure that contains information used to display the message box.</param>
            <returns>
            If the function succeeds, the return value is one of the following menu-item values.
            <para>
            If a message box has a Cancel button, the function returns the IDCANCEL value if either the ESC key is pressed or the Cancel
            button is selected.If the message box has no Cancel button, pressing ESC has no effect.
            </para>
            <para>If there is not enough memory to create the message box, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.MessageBoxTimeout(Vanara.PInvoke.HWND,System.String,System.String,Vanara.PInvoke.User32.MB_FLAGS,Vanara.PInvoke.LANGID,System.UInt32)">
            <summary>
            Displays a modal dialog box that contains a system icon, a set of buttons, and a brief application-specific message, such as
            status or error information. The message box returns an integer value that indicates which button the user clicked.
            </summary>
            <param name="hWnd"><para>Type: <c>HWND</c></para>
            <para>
            A handle to the owner window of the message box to be created. If this parameter is <c>NULL</c>, the message box has no owner window.
            </para></param>
            <param name="lpText"><para>Type: <c>LPCTSTR</c></para>
            <para>
            The message to be displayed. If the string consists of more than one line, you can separate the lines using a carriage return
            and/or linefeed character between each line.
            </para></param>
            <param name="lpCaption"><para>Type: <c>LPCTSTR</c></para>
            <para>The dialog box title. If this parameter is <c>NULL</c>, the default title is <c>Error</c>.</para></param>
            <param name="uType"><para>Type: <c>UINT</c></para>
            <para>
            The contents and behavior of the dialog box. This parameter can be a combination of flags from the following groups of flags.
            </para>
            <para>To indicate the buttons displayed in the message box, specify one of the following values.</para>
            <list type="table">
              <listheader>
                <description>Value</description>
                <description>Meaning</description>
              </listheader>
              <item>
                <description>
                  <c>MB_ABORTRETRYIGNORE</c> 0x00000002L</description>
                <description>The message box contains three push buttons: <c>Abort</c>, <c>Retry</c>, and <c>Ignore</c>.</description>
              </item>
              <item>
                <description>
                  <c>MB_CANCELTRYCONTINUE</c> 0x00000006L</description>
                <description>
            The message box contains three push buttons: <c>Cancel</c>, <c>Try Again</c>, <c>Continue</c>. Use this message box type instead
            of MB_ABORTRETRYIGNORE.
            </description>
              </item>
              <item>
                <description>
                  <c>MB_HELP</c> 0x00004000L</description>
                <description>
            Adds a <c>Help</c> button to the message box. When the user clicks the <c>Help</c> button or presses F1, the system sends a
            WM_HELP message to the owner.
            </description>
              </item>
              <item>
                <description>
                  <c>MB_OK</c> 0x00000000L</description>
                <description>The message box contains one push button: <c>OK</c>. This is the default.</description>
              </item>
              <item>
                <description>
                  <c>MB_OKCANCEL</c> 0x00000001L</description>
                <description>The message box contains two push buttons: <c>OK</c> and <c>Cancel</c>.</description>
              </item>
              <item>
                <description>
                  <c>MB_RETRYCANCEL</c> 0x00000005L</description>
                <description>The message box contains two push buttons: <c>Retry</c> and <c>Cancel</c>.</description>
              </item>
              <item>
                <description>
                  <c>MB_YESNO</c> 0x00000004L</description>
                <description>The message box contains two push buttons: <c>Yes</c> and <c>No</c>.</description>
              </item>
              <item>
                <description>
                  <c>MB_YESNOCANCEL</c> 0x00000003L</description>
                <description>The message box contains three push buttons: <c>Yes</c>, <c>No</c>, and <c>Cancel</c>.</description>
              </item>
            </list>
            <para>Â</para>
            <para>To display an icon in the message box, specify one of the following values.</para>
            <list type="table">
              <listheader>
                <description>Value</description>
                <description>Meaning</description>
              </listheader>
              <item>
                <description>
                  <c>MB_ICONEXCLAMATION</c> 0x00000030L</description>
                <description>An exclamation-point icon appears in the message box.</description>
              </item>
              <item>
                <description>
                  <c>MB_ICONWARNING</c> 0x00000030L</description>
                <description>An exclamation-point icon appears in the message box.</description>
              </item>
              <item>
                <description>
                  <c>MB_ICONINFORMATION</c> 0x00000040L</description>
                <description>An icon consisting of a lowercase letter <c>i</c> in a circle appears in the message box.</description>
              </item>
              <item>
                <description>
                  <c>MB_ICONASTERISK</c> 0x00000040L</description>
                <description>An icon consisting of a lowercase letter <c>i</c> in a circle appears in the message box.</description>
              </item>
              <item>
                <description>
                  <c>MB_ICONQUESTION</c> 0x00000020L</description>
                <description>
            A question-mark icon appears in the message box. The question-mark message icon is no longer recommended because it does not
            clearly represent a specific type of message and because the phrasing of a message as a question could apply to any message type.
            In addition, users can confuse the message symbol question mark with Help information. Therefore, do not use this question mark
            message symbol in your message boxes. The system continues to support its inclusion only for backward compatibility.
            </description>
              </item>
              <item>
                <description>
                  <c>MB_ICONSTOP</c> 0x00000010L</description>
                <description>A stop-sign icon appears in the message box.</description>
              </item>
              <item>
                <description>
                  <c>MB_ICONERROR</c> 0x00000010L</description>
                <description>A stop-sign icon appears in the message box.</description>
              </item>
              <item>
                <description>
                  <c>MB_ICONHAND</c> 0x00000010L</description>
                <description>A stop-sign icon appears in the message box.</description>
              </item>
            </list>
            <para>Â</para>
            <para>To indicate the default button, specify one of the following values.</para>
            <list type="table">
              <listheader>
                <description>Value</description>
                <description>Meaning</description>
              </listheader>
              <item>
                <description>
                  <c>MB_DEFBUTTON1</c> 0x00000000L</description>
                <description>
            The first button is the default button. <c>MB_DEFBUTTON1</c> is the default unless <c>MB_DEFBUTTON2</c>, <c>MB_DEFBUTTON3</c>, or
            <c>MB_DEFBUTTON4</c> is specified.
            </description>
              </item>
              <item>
                <description>
                  <c>MB_DEFBUTTON2</c> 0x00000100L</description>
                <description>The second button is the default button.</description>
              </item>
              <item>
                <description>
                  <c>MB_DEFBUTTON3</c> 0x00000200L</description>
                <description>The third button is the default button.</description>
              </item>
              <item>
                <description>
                  <c>MB_DEFBUTTON4</c> 0x00000300L</description>
                <description>The fourth button is the default button.</description>
              </item>
            </list>
            <para>Â</para>
            <para>To indicate the modality of the dialog box, specify one of the following values.</para>
            <list type="table">
              <listheader>
                <description>Value</description>
                <description>Meaning</description>
              </listheader>
              <item>
                <description>
                  <c>MB_APPLMODAL</c> 0x00000000L</description>
                <description>
            The user must respond to the message box before continuing work in the window identified by the <c>hWnd</c> parameter. However,
            the user can move to the windows of other threads and work in those windows. Depending on the hierarchy of windows in the
            application, the user may be able to move to other windows within the thread. All child windows of the parent of the message box
            are automatically disabled, but pop-up windows are not. <c>MB_APPLMODAL</c> is the default if neither <c>MB_SYSTEMMODAL</c> nor
            <c>MB_TASKMODAL</c> is specified.
            </description>
              </item>
              <item>
                <description>
                  <c>MB_SYSTEMMODAL</c> 0x00001000L</description>
                <description>
            Same as MB_APPLMODAL except that the message box has the <c>WS_EX_TOPMOST</c> style. Use system-modal message boxes to notify the
            user of serious, potentially damaging errors that require immediate attention (for example, running out of memory). This flag has
            no effect on the user's ability to interact with windows other than those associated with <c>hWnd</c>.
            </description>
              </item>
              <item>
                <description>
                  <c>MB_TASKMODAL</c> 0x00002000L</description>
                <description>
            Same as <c>MB_APPLMODAL</c> except that all the top-level windows belonging to the current thread are disabled if the <c>hWnd</c>
            parameter is <c>NULL</c>. Use this flag when the calling application or library does not have a window handle available but still
            needs to prevent input to other windows in the calling thread without suspending other threads.
            </description>
              </item>
            </list>
            <para>Â</para>
            <para>To specify other options, use one or more of the following values.</para>
            <list type="table">
              <listheader>
                <description>Value</description>
                <description>Meaning</description>
              </listheader>
              <item>
                <description>
                  <c>MB_DEFAULT_DESKTOP_ONLY</c> 0x00020000L</description>
                <description>
            Same as desktop of the interactive window station. For more information, see Window Stations. If the current input desktop is not
            the default desktop, <c>MessageBox</c> does not return until the user switches to the default desktop.
            </description>
              </item>
              <item>
                <description>
                  <c>MB_RIGHT</c> 0x00080000L</description>
                <description>The text is right-justified.</description>
              </item>
              <item>
                <description>
                  <c>MB_RTLREADING</c> 0x00100000L</description>
                <description>Displays message and caption text using right-to-left reading order on Hebrew and Arabic systems.</description>
              </item>
              <item>
                <description>
                  <c>MB_SETFOREGROUND</c> 0x00010000L</description>
                <description>
            The message box becomes the foreground window. Internally, the system calls the SetForegroundWindow function for the message box.
            </description>
              </item>
              <item>
                <description>
                  <c>MB_TOPMOST</c> 0x00040000L</description>
                <description>The message box is created with the <c>WS_EX_TOPMOST</c> window style.</description>
              </item>
              <item>
                <description>
                  <c>MB_SERVICE_NOTIFICATION</c> 0x00200000L</description>
                <description>
            The caller is a service notifying the user of an event. The function displays a message box on the current active desktop, even
            if there is no user logged on to the computer. <c>Terminal Services:</c> If the calling thread has an impersonation token, the
            function directs the message box to the session specified in the impersonation token. If this flag is set, the <c>hWnd</c>
            parameter must be <c>NULL</c>. This is so that the message box can appear on a desktop other than the desktop corresponding to
            the <c>hWnd</c>. For information on security considerations in regard to using this flag, see Interactive Services. In
            particular, be aware that this flag can produce interactive content on a locked desktop and should therefore be used for only a
            very limited set of scenarios, such as resource exhaustion.
            </description>
              </item>
            </list></param>
            <param name="wLanguageId">The language for the text displayed in the message box button(s). Specifying a value of zero (0) indicates to display the button text in the default system language. If this parameter is MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), the current language associated with the calling thread is used.
            <para>To specify a language other than the current language, use the MAKELANGID macro to create this parameter.</para>
            </param>
            <param name="dwMilliseconds">Parameter is in milliseconds so 1000 will be 1 second etc. Messagebox won't time-out if <paramref name="dwMilliseconds"/> is 0.</param>
            <returns>
            <para>Type: <c>int</c></para>
            <para>
            If a message box has a <c>Cancel</c> button, the function returns the <c>IDCANCEL</c> value if either the ESC key is pressed or
            the <c>Cancel</c> button is selected. If the message box has no <c>Cancel</c> button, pressing ESC will no effect - unless an
            MB_OK button is present. If an MB_OK button is displayed and the user presses ESC, the return value will be <c>IDOK</c>.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            <para>If the function succeeds, the return value is one of the following menu-item values.</para>
            <list type="table">
              <listheader>
                <description>Return code/value</description>
                <description>Description</description>
              </listheader>
              <item>
                <description>
                  <c>IDABORT</c> 3</description>
                <description>The <c>Abort</c> button was selected.</description>
              </item>
              <item>
                <description>
                  <c>IDCANCEL</c> 2</description>
                <description>The <c>Cancel</c> button was selected.</description>
              </item>
              <item>
                <description>
                  <c>IDCONTINUE</c> 11</description>
                <description>The <c>Continue</c> button was selected.</description>
              </item>
              <item>
                <description>
                  <c>IDIGNORE</c> 5</description>
                <description>The <c>Ignore</c> button was selected.</description>
              </item>
              <item>
                <description>
                  <c>IDNO</c> 7</description>
                <description>The <c>No</c> button was selected.</description>
              </item>
              <item>
                <description>
                  <c>IDOK</c> 1</description>
                <description>The <c>OK</c> button was selected.</description>
              </item>
              <item>
                <description>
                  <c>IDRETRY</c> 4</description>
                <description>The <c>Retry</c> button was selected.</description>
              </item>
              <item>
                <description>
                  <c>IDTRYAGAIN</c> 10</description>
                <description>The <c>Try Again</c> button was selected.</description>
              </item>
              <item>
                <description>
                  <c>IDYES</c> 6</description>
                <description>The <c>Yes</c> button was selected.</description>
              </item>
            </list>
            </returns>
            <remarks>
            <para>
            The following system icons can be used in a message box by setting the <c>uType</c> parameter to the corresponding flag value.
            </para>
            <list type="table">
              <listheader>
                <description>Icon</description>
                <description>Flag values</description>
              </listheader>
              <item>
                <description />
                <description>
                  <c>MB_ICONHAND</c>, <c>MB_ICONSTOP</c>, or <c>MB_ICONERROR</c></description>
              </item>
              <item>
                <description />
                <description>
                  <c>MB_ICONQUESTION</c>
                </description>
              </item>
              <item>
                <description />
                <description>
                  <c>MB_ICONEXCLAMATION</c> or <c>MB_ICONWARNING</c></description>
              </item>
              <item>
                <description />
                <description>
                  <c>MB_ICONASTERISK</c> or <c>MB_ICONINFORMATION</c></description>
              </item>
            </list>
            <para>Â</para>
            <para>
            Adding two right-to-left marks (RLMs), represented by Unicode formatting character U+200F, in the beginning of a MessageBox
            display string is interpreted by the MessageBox rendering engine so as to cause the reading order of the MessageBox to be
            rendered as right-to-left (RTL).
            </para>
            <para>
            When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the <c>lpText</c>
            and <c>lpCaption</c> parameters should not be taken from a resource file because an attempt to load the resource may fail.
            </para>
            <para>
            If you create a message box while a dialog box is present, use a handle to the dialog box as the <c>hWnd</c> parameter. The
            <c>hWnd</c> parameter should not identify a child window, such as a control in a dialog box.
            </para>
            <para>Examples</para>
            <para>
            In the following example, the application displays a message box that prompts the user for an action after an error condition has
            occurred. The message box displays the message that describes the error condition and how to resolve it. The
            <c>MB_CANCELTRYCONTINUE</c> style directs <c>MessageBox</c> to provide three buttons with which the user can choose how to
            proceed. The <c>MB_DEFBUTTON2</c> style sets the default focus on the second button of the message box, in this case, the <c>Try
            Again</c> button.
            </para>
            <para>The following image shows the output from the preceding code example:</para>
            <para>For another message box example, see Displaying a Message Box.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ShutdownBlockReasonCreate(Vanara.PInvoke.HWND,System.String)">
            <summary>
            Indicates that the system cannot be shut down and sets a reason string to be displayed to the user if system shutdown is initiated.
            </summary>
            <param name="hWnd">A handle to the main window of the application.</param>
            <param name="reason">
            The reason the application must block system shutdown. This string will be truncated for display purposes after
            MAX_STR_BLOCKREASON characters.
            </param>
            <returns>
            If the call succeeds, the return value is nonzero. If the call fails, the return value is zero. To get extended error
            information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.ShutdownBlockReasonDestroy(Vanara.PInvoke.HWND)">
            <summary>Indicates that the system can be shut down and frees the reason string.</summary>
            <param name="hWnd">A handle to the main window of the application.</param>
            <returns>
            If the call succeeds, the return value is nonzero. If the call fails, the return value is zero. To get extended error
            information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.ShutdownBlockReasonQuery(Vanara.PInvoke.HWND,System.Text.StringBuilder,System.UInt32@)">
            <summary>Retrieves the reason string set by the <see cref="M:Vanara.PInvoke.User32.ShutdownBlockReasonCreate(Vanara.PInvoke.HWND,System.String)"/> function.</summary>
            <param name="hWnd">A handle to the main window of the application.</param>
            <param name="pwszBuff">
            A pointer to a buffer that receives the reason string. If this parameter is NULL, the function retrieves the number of characters
            in the reason string.
            </param>
            <param name="pcchBuff">
            A pointer to a variable that specifies the size of the pwszBuff buffer, in characters. If the function succeeds, this variable
            receives the number of characters copied into the buffer, including the null-terminating character. If the buffer is too small,
            the variable receives the required buffer size, in characters, not including the null-terminating character.
            </param>
            <returns>
            If the call succeeds, the return value is nonzero. If the call fails, the return value is zero. To get extended error
            information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.ShutdownBlockReasonQuery(Vanara.PInvoke.HWND,System.String@)">
            <summary>Retrieves the reason string set by the <see cref="M:Vanara.PInvoke.User32.ShutdownBlockReasonCreate(Vanara.PInvoke.HWND,System.String)"/> function.</summary>
            <param name="hWnd">A handle to the main window of the application.</param>
            <param name="reason">On success, receives the reason string.</param>
            <returns>
            If the call succeeds, the return value is nonzero. If the call fails, the return value is zero. To get extended error
            information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SystemParametersInfo(Vanara.PInvoke.User32.SPI,System.UInt32,System.IntPtr,Vanara.PInvoke.User32.SPIF)">
            <summary>
            Retrieves or sets the value of one of the system-wide parameters. This function can also update the user profile while setting a parameter.
            </summary>
            <param name="uiAction">
            <para>Type: <c>UINT</c></para>
            <para>
            The system-wide parameter to be retrieved or set. The possible values are organized in the following tables of related parameters:
            </para>
            </param>
            <param name="uiParam">
            <para>Type: <c>UINT</c></para>
            <para>
            A parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide
            parameters, see the uiAction parameter. If not otherwise indicated, you must specify zero for this parameter.
            </para>
            </param>
            <param name="pvParam">
            <para>Type: <c>PVOID</c></para>
            <para>
            A parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide
            parameters, see the uiAction parameter. If not otherwise indicated, you must specify <c>NULL</c> for this parameter. For
            information on the <c>PVOID</c> datatype, see <c>Windows Data Types</c>.
            </para>
            </param>
            <param name="fWinIni">
            <para>Type: <c>UINT</c></para>
            <para>
            If a system parameter is being set, specifies whether the user profile is to be updated, and if so, whether the
            <c>WM_SETTINGCHANGE</c> message is to be broadcast to all top-level windows to notify them of the change.
            </para>
            <para>
            This parameter can be zero if you do not want to update the user profile or broadcast the <c>WM_SETTINGCHANGE</c> message, or it
            can be one or more of the following values.
            </para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SPIF_UPDATEINIFILE</term>
            <term>Writes the new system-wide parameter setting to the user profile.</term>
            </item>
            <item>
            <term>SPIF_SENDCHANGE</term>
            <term>Broadcasts the WM_SETTINGCHANGE message after updating the user profile.</term>
            </item>
            <item>
            <term>SPIF_SENDWININICHANGE</term>
            <term>Same as SPIF_SENDCHANGE.</term>
            </item>
            </list>
            </para>
            </param>
            <returns>
            <para>Type:</para>
            <para>If the function succeeds, the return value is a nonzero value.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call <c>GetLastError</c>.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SystemParametersInfo(Vanara.PInvoke.User32.SPI,System.UInt32,System.String,Vanara.PInvoke.User32.SPIF)">
            <summary>
            Retrieves or sets the value of one of the system-wide parameters. This function can also update the user profile while setting a parameter.
            </summary>
            <param name="uiAction">
            <para>Type: <c>UINT</c></para>
            <para>
            The system-wide parameter to be retrieved or set. The possible values are organized in the following tables of related parameters:
            </para>
            </param>
            <param name="uiParam">
            <para>Type: <c>UINT</c></para>
            <para>
            A parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide
            parameters, see the uiAction parameter. If not otherwise indicated, you must specify zero for this parameter.
            </para>
            </param>
            <param name="pvParam">
            <para>Type: <c>PVOID</c></para>
            <para>
            A parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide
            parameters, see the uiAction parameter. If not otherwise indicated, you must specify <c>NULL</c> for this parameter. For
            information on the <c>PVOID</c> datatype, see <c>Windows Data Types</c>.
            </para>
            </param>
            <param name="fWinIni">
            <para>Type: <c>UINT</c></para>
            <para>
            If a system parameter is being set, specifies whether the user profile is to be updated, and if so, whether the
            <c>WM_SETTINGCHANGE</c> message is to be broadcast to all top-level windows to notify them of the change.
            </para>
            <para>
            This parameter can be zero if you do not want to update the user profile or broadcast the <c>WM_SETTINGCHANGE</c> message, or it
            can be one or more of the following values.
            </para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SPIF_UPDATEINIFILE</term>
            <term>Writes the new system-wide parameter setting to the user profile.</term>
            </item>
            <item>
            <term>SPIF_SENDCHANGE</term>
            <term>Broadcasts the WM_SETTINGCHANGE message after updating the user profile.</term>
            </item>
            <item>
            <term>SPIF_SENDWININICHANGE</term>
            <term>Same as SPIF_SENDCHANGE.</term>
            </item>
            </list>
            </para>
            </param>
            <returns>
            <para>Type:</para>
            <para>If the function succeeds, the return value is a nonzero value.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call <c>GetLastError</c>.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SystemParametersInfo(Vanara.PInvoke.User32.SPI,System.UInt32,System.Text.StringBuilder,Vanara.PInvoke.User32.SPIF)">
            <summary>
            Retrieves or sets the value of one of the system-wide parameters. This function can also update the user profile while setting a parameter.
            </summary>
            <param name="uiAction">
            <para>Type: <c>UINT</c></para>
            <para>
            The system-wide parameter to be retrieved or set. The possible values are organized in the following tables of related parameters:
            </para>
            </param>
            <param name="uiParam">
            <para>Type: <c>UINT</c></para>
            <para>
            A parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide
            parameters, see the uiAction parameter. If not otherwise indicated, you must specify zero for this parameter.
            </para>
            </param>
            <param name="pvParam">
            <para>Type: <c>PVOID</c></para>
            <para>
            A parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide
            parameters, see the uiAction parameter. If not otherwise indicated, you must specify <c>NULL</c> for this parameter. For
            information on the <c>PVOID</c> datatype, see <c>Windows Data Types</c>.
            </para>
            </param>
            <param name="fWinIni">
            <para>Type: <c>UINT</c></para>
            <para>
            If a system parameter is being set, specifies whether the user profile is to be updated, and if so, whether the
            <c>WM_SETTINGCHANGE</c> message is to be broadcast to all top-level windows to notify them of the change.
            </para>
            <para>
            This parameter can be zero if you do not want to update the user profile or broadcast the <c>WM_SETTINGCHANGE</c> message, or it
            can be one or more of the following values.
            </para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SPIF_UPDATEINIFILE</term>
            <term>Writes the new system-wide parameter setting to the user profile.</term>
            </item>
            <item>
            <term>SPIF_SENDCHANGE</term>
            <term>Broadcasts the WM_SETTINGCHANGE message after updating the user profile.</term>
            </item>
            <item>
            <term>SPIF_SENDWININICHANGE</term>
            <term>Same as SPIF_SENDCHANGE.</term>
            </item>
            </list>
            </para>
            </param>
            <returns>
            <para>Type:</para>
            <para>If the function succeeds, the return value is a nonzero value.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call <c>GetLastError</c>.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SystemParametersInfo``1(Vanara.PInvoke.User32.SPI,``0@)">
            <summary>Retrives the value of one of the system-wide parameters.</summary>
            <typeparam name="T">The type of the value to retrieve.</typeparam>
            <param name="uiAction">The system-wide parameter to retrieve.</param>
            <param name="getValue">The value to retrieve.</param>
            <returns>
            <para>If the function succeeds, the return value is <see langword="true"/>.</para>
            <para>If the function fails, the return value is <see langword="false"/>. To get extended error information, call <c>GetLastError</c>.</para>
            </returns>
            <exception cref="T:System.ArgumentException">Type mismatch. - getValue</exception>
        </member>
        <member name="M:Vanara.PInvoke.User32.SystemParametersInfo``1(Vanara.PInvoke.User32.SPI,``0@,System.Boolean,System.Boolean)">
            <summary>Sets the value of one of the system-wide parameters. This function can also update the user profile.</summary>
            <typeparam name="T">The type of the value being set.</typeparam>
            <param name="uiAction">The system-wide parameter to be set.</param>
            <param name="setValue">The value to set.</param>
            <param name="updateUserProfile">if set to <c>true</c> writes the new system-wide parameter setting to the user profile.</param>
            <param name="broadcastChange">if set to <c>true</c> broadcasts the WM_SETTINGCHANGE message after updating the user profile.</param>
            <returns>
            <para>If the function succeeds, the return value is <see langword="true"/>.</para>
            <para>If the function fails, the return value is <see langword="false"/>. To get extended error information, call <c>GetLastError</c>.</para>
            </returns>
            <exception cref="T:System.ArgumentException">Type mismatch. - setValue</exception>
        </member>
        <member name="T:Vanara.PInvoke.User32.ACCESSTIMEOUT">
            <summary>
            Contains information about the time-out period associated with the Microsoft Win32 accessibility features.
            <para>
            The accessibility time-out period is the length of time that must pass without keyboard and mouse input before the operating
            system automatically turns off accessibility features.The accessibility time-out is designed for computers that are shared by
            several users so that options selected by one user do not inconvenience a subsequent user.
            </para>
            <para>
            The accessibility features affected by the time-out are the FilterKeys features(SlowKeys, BounceKeys, and RepeatKeys), MouseKeys,
            ToggleKeys, and StickyKeys.The accessibility time-out also affects the high contrast mode setting.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ACCESSTIMEOUT.cbSize">
            <summary>Specifies the size, in bytes, of this structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ACCESSTIMEOUT.dwFlags">
            <summary>A set of bit flags that specify properties of the time-out behavior for accessibility features.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ACCESSTIMEOUT.iTimeOutMSec">
            <summary>Specifies the time-out period, in milliseconds.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ANIMATIONINFO">
            <summary>
            Describes the animation effects associated with user actions. This structure is used with the <c>SystemParametersInfo</c>
            function when the SPI_GETANIMATION or SPI_SETANIMATION action value is specified.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ANIMATIONINFO.cbSize">
            <summary>The size of the structure, in bytes. The caller must set this to .</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ANIMATIONINFO.iMinAnimate">
            <summary>If this member is nonzero, minimize and restore animation is enabled; otherwise it is disabled.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.AUDIODESCRIPTION">
            <summary>
            Contains information associated with audio descriptions. This structure is used with the <c>SystemParametersInfo</c> function
            when the SPI_GETAUDIODESCRIPTION or SPI_SETAUDIODESCRIPTION action value is specified.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AUDIODESCRIPTION.cbSize">
            <summary>The size of the structure, in bytes. The caller must set this member to .</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AUDIODESCRIPTION.Enabled">
            <summary>If this member is <c>TRUE</c>, audio descriptions are enabled; Otherwise, this member is <c>FALSE</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AUDIODESCRIPTION.Locale">
            <summary>
            The locale identifier (LCID) of the language for the audio description. For more information, see Locales and Languages.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.FILTERKEYS">
            <summary>
            Contains information about the FilterKeys accessibility feature, which enables a user with disabilities to set the keyboard
            repeat rate (RepeatKeys), acceptance delay (SlowKeys), and bounce rate (BounceKeys).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FILTERKEYS.cbSize">
            <summary>Specifies the structure size, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FILTERKEYS.dwFlags">
            <summary>A set of bit flags that specify properties of the FilterKeys feature.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FILTERKEYS.iWaitMSec">
            <summary>
            Specifies the length of time, in milliseconds, that the user must hold down a key before it is accepted by the computer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FILTERKEYS.iDelayMSec">
            <summary>Specifies the length of time, in milliseconds, that the user must hold down a key before it begins to repeat.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FILTERKEYS.iRepeatMSec">
            <summary>Specifies the length of time, in milliseconds, between each repetition of the keystroke.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FILTERKEYS.iBounceMSec">
            <summary>
            Specifies the length of time, in milliseconds, that must elapse after releasing a key before the computer will accept a
            subsequent press of the same key.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.HELPINFO">
            <summary>Contains information about an item for which context-sensitive Help has been requested.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HELPINFO.cbSize">
            <summary>The structure size, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HELPINFO.iContextType">
            <summary>The type of context for which Help is requested. This member can be one of the following values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HELPINFO.iCtrlId">
            <summary>
            The identifier of the window or control if iContextType is HELPINFO_WINDOW, or identifier of the menu item if iContextType is HELPINFO_MENUITEM.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HELPINFO.hItemHandle">
            <summary>
            The identifier of the child window or control if iContextType is HELPINFO_WINDOW, or identifier of the associated menu if
            iContextType is HELPINFO_MENUITEM.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HELPINFO.dwContextId">
            <summary>The help context identifier of the window or control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HELPINFO.MousePos">
            <summary>
            The POINT structure that contains the screen coordinates of the mouse cursor. This is useful for providing Help based on the
            position of the mouse cursor.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.HIGHCONTRAST">
            <summary>
            Contains information about the high contrast accessibility feature. This feature sets the appearance scheme of the user interface
            for maximum visibility for a visually-impaired user, and advises applications to comply with this appearance scheme.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HIGHCONTRAST.cbSize">
            <summary>Specifies the size, in bytes, of this structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HIGHCONTRAST.dwFlags">
            <summary>A set of bit flags that specify properties of the HighContrast feature.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.HIGHCONTRAST.lpszDefaultScheme">
            <summary>Points to a string that contains the name of the color scheme that will be set to the default scheme.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ICONMETRICS">
            <summary>
            Contains the scalable metrics associated with icons. This structure is used with the SystemParametersInfo function when the
            SPI_GETICONMETRICS or SPI_SETICONMETRICS action is specified.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONMETRICS.cbSize">
            <summary>The size of the structure, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONMETRICS.iHorzSpacing">
            <summary>The horizontal space, in pixels, for each arranged icon.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONMETRICS.iVertSpacing">
            <summary>The vertical space, in pixels, for each arranged icon.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONMETRICS.iTitleWrap">
            <summary>If this member is nonzero, icon titles wrap to a new line.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ICONMETRICS.lfFont">
            <summary>The font to use for icon titles.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MINIMIZEDMETRICS">
            <summary>
            Contains the scalable metrics associated with minimized windows. This structure is used with the <c>SystemParametersInfo</c>
            function when the SPI_GETMINIMIZEDMETRICS or SPI_SETMINIMIZEDMETRICS action value is specified.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MINIMIZEDMETRICS.cbSize">
            <summary>The size of the structure, in bytes. The caller must set this to .</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MINIMIZEDMETRICS.iWidth">
            <summary>The width of minimized windows, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MINIMIZEDMETRICS.iHorzGap">
            <summary>The horizontal space between arranged minimized windows, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MINIMIZEDMETRICS.iVertGap">
            <summary>The vertical space between arranged minimized windows, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MINIMIZEDMETRICS.iArrange">
            <summary>
            <para>
            The starting position and direction used when arranging minimized windows. The starting position must be one of the following values.
            </para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ARW_BOTTOMLEFT0x0000L</term>
            <term>Start at the lower-left corner of the work area.</term>
            </item>
            <item>
            <term>ARW_BOTTOMRIGHT0x0001L</term>
            <term>Start at the lower-right corner of the work area.</term>
            </item>
            <item>
            <term>ARW_TOPLEFT0x0002L</term>
            <term>Start at the upper-left corner of the work area.</term>
            </item>
            <item>
            <term>ARW_TOPRIGHT0x0003L</term>
            <term>Start at the upper-right corner of the work area.</term>
            </item>
            </list>
            </para>
            <para>The direction must be one of the following values.</para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ARW_LEFT0x0000L</term>
            <term>Arrange left (valid with ARW_BOTTOMRIGHT and ARW_TOPRIGHT only).</term>
            </item>
            <item>
            <term>ARW_RIGHT0x0000L</term>
            <term>Arrange right (valid with ARW_BOTTOMLEFT and ARW_TOPLEFT only).</term>
            </item>
            <item>
            <term>ARW_UP0x0004L</term>
            <term>Arrange up (valid with ARW_BOTTOMLEFT and ARW_BOTTOMRIGHT only).</term>
            </item>
            <item>
            <term>ARW_DOWN0x0004L</term>
            <term>Arrange down (valid with ARW_TOPLEFT and ARW_TOPRIGHT only).</term>
            </item>
            <item>
            <term>ARW_HIDE0x0008L</term>
            <term>Hide minimized windows by moving them off the visible area of the screen.</term>
            </item>
            </list>
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MOUSEKEYS">
            <summary>
            Contains information about the MouseKeys accessibility feature. When the MouseKeys feature is active, the user can use the
            numeric keypad to control the mouse pointer, and to click, double-click, drag, and drop. By pressing NUMLOCK, the user can toggle
            the numeric keypad between mouse control mode and normal operation.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEKEYS.cbSize">
            <summary>Specifies the size, in bytes, of this structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEKEYS.dwFlags">
            <summary>A set of bit-flags that specify properties of the MouseKeys feature.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEKEYS.iMaxSpeed">
            <summary>Specifies the maximum speed the mouse cursor attains when an arrow key is held down.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEKEYS.iTimeToMaxSpeed">
            <summary>
            Specifies the length of time, in milliseconds, that it takes for the mouse cursor to reach maximum speed when an arrow key is
            held down. Valid values are from 1000 to 5000.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEKEYS.iCtrlSpeed">
            <summary>
            Specifies the multiplier to apply to the mouse cursor speed when the user holds down the CTRL key while using the arrow keys
            to move the cursor. this value is ignored if MKF_MODIFIERS is not set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEKEYS.dwReserved1">
            <summary>This member is reserved for future use. It must be set to zero.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MOUSEKEYS.dwReserved2">
            <summary>This member is reserved for future use. It must be set to zero.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MSGBOXPARAMS">
            <summary>Contains information used to display a message box. The MessageBoxIndirect function uses this structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MSGBOXPARAMS.cbSize">
            <summary>The structure size, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MSGBOXPARAMS.hwndOwner">
            <summary>A handle to the owner window. This member can be NULL.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MSGBOXPARAMS.hInstance">
            <summary>
            A handle to the module that contains the icon resource identified by the lpszIcon member, and the string resource identified
            by the lpszText or lpszCaption member.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MSGBOXPARAMS.lpszText">
            <summary>A null-terminated string, or the identifier of a string resource, that contains the message to be displayed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MSGBOXPARAMS.lpszCaption">
            <summary>
            A null-terminated string, or the identifier of a string resource, that contains the message box title. If this member is
            NULL, the default title Error is used.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MSGBOXPARAMS.dwStyle">
            <summary>
            The contents and behavior of the dialog box. This member can be a combination of flags described for the uType parameter of
            the MessageBoxEx function.
            <para>
            In addition, you can specify the MB_USERICON flag(0x00000080L) if you want the message box to display the icon specified by
            the lpszIcon member.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MSGBOXPARAMS.lpszIcon">
            <summary>
            Identifies an icon resource. This parameter can be either a null-terminated string or an integer resource identifier passed
            to the MAKEINTRESOURCE macro.
            <para>
            To load one of the standard system-defined icons, set the hInstance member to NULL and set lpszIcon to one of the values
            listed with the LoadIcon function.
            </para>
            <para>This member is ignored if the dwStyle member does not specify the MB_USERICON flag.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MSGBOXPARAMS.dwContextHelpId">
            <summary>
            Identifies a help context. If a help event occurs, this value is specified in the HELPINFO structure that the message box
            sends to the owner window or callback function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MSGBOXPARAMS.lpfnMsgBoxCallback">
            <summary>
            A pointer to the callback function that processes help events for the message box.
            <para>If this member is NULL, the message box sends WM_HELP messages to the owner window when help events occur.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MSGBOXPARAMS.dwLanguageId">
            <summary>
            The language in which to display the text contained in the predefined push buttons. This value must be in the form returned
            by the MAKELANGID macro.
            <para>
            For a list of supported language identifiers, see Language Identifiers.Note that each localized release of Windows typically
            contains resources only for a limited set of languages.Thus, for example, the U.S.version offers LANG_ENGLISH, the French
            version offers LANG_FRENCH, the German version offers LANG_GERMAN, and the Japanese version offers LANG_JAPANESE. Each
            version offers LANG_NEUTRAL. This limits the set of values that can be used with the dwLanguageId parameter. Before
            specifying a language identifier, you should enumerate the locales that are installed on a system.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.NONCLIENTMETRICS">
            <summary>
            Contains the scalable metrics associated with the nonclient area of a nonminimized window. This structure is used by the
            <c>SPI_GETNONCLIENTMETRICS</c> and <c>SPI_SETNONCLIENTMETRICS</c> actions of the <c>SystemParametersInfo</c> function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NONCLIENTMETRICS.cbSize">
            <summary>
            The size of the structure, in bytes. The caller must set this to sizeof(NONCLIENTMETRICS). For information about application
            compatibility, see Remarks.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NONCLIENTMETRICS.iBorderWidth">
            <summary>The thickness of the sizing border, in pixels. The default is 1 pixel.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NONCLIENTMETRICS.iScrollWidth">
            <summary>The width of a standard vertical scroll bar, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NONCLIENTMETRICS.iScrollHeight">
            <summary>The height of a standard horizontal scroll bar, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NONCLIENTMETRICS.iCaptionWidth">
            <summary>The width of caption buttons, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NONCLIENTMETRICS.iCaptionHeight">
            <summary>The height of caption buttons, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NONCLIENTMETRICS.lfCaptionFont">
            <summary>A <c>LOGFONT</c> structure that contains information about the caption font.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NONCLIENTMETRICS.iSMCaptionWidth">
            <summary>The width of small caption buttons, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NONCLIENTMETRICS.iSMCaptionHeight">
            <summary>The height of small captions, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NONCLIENTMETRICS.lfSMCaptionFont">
            <summary>A <c>LOGFONT</c> structure that contains information about the small caption font.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NONCLIENTMETRICS.iMenuWidth">
            <summary>The width of menu-bar buttons, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NONCLIENTMETRICS.iMenuHeight">
            <summary>The height of a menu bar, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NONCLIENTMETRICS.lfMenuFont">
            <summary>A <c>LOGFONT</c> structure that contains information about the font used in menu bars.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NONCLIENTMETRICS.lfStatusFont">
            <summary>A <c>LOGFONT</c> structure that contains information about the font used in status bars and tooltips.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NONCLIENTMETRICS.lfMessageFont">
            <summary>A <c>LOGFONT</c> structure that contains information about the font used in message boxes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.NONCLIENTMETRICS.iPaddedBorderWidth">
            <summary>
            <para>
            The thickness of the padded border, in pixels. The default value is 4 pixels. The <c>iPaddedBorderWidth</c> and
            <c>iBorderWidth</c> members are combined for both resizable and nonresizable windows in the Windows Aero desktop experience.
            To compile an application that uses this member, define <c>_WIN32_WINNT</c> as 0x0600 or later. For more information, see Remarks.
            </para>
            <para><c>Windows Server 2003 and Windows XP/2000:</c> This member is not supported.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SERIALKEYS">
            <summary>
            Contains information about the SerialKeys accessibility feature, which interprets data from a communication aid attached to a
            serial port as commands causing the system to simulate keyboard and mouse input.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SERIALKEYS.cbSize">
            <summary>Specifies the structure size, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SERIALKEYS.dwFlags">
            <summary>A set of bit-flags that specify properties of the SerialKeys feature.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SERIALKEYS.lpszActivePort">
            <summary>
            Points to a string that contains the name of the serial port that receives input from the communication aid when the
            SerialKeys feature is on. If no port is being used, this member is NULL. If this member is "Auto", the system watches all
            unused serial ports for input from communication aids.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SERIALKEYS.lpszPort">
            <summary>Reserved; must be NULL.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SERIALKEYS.iBaudRate">
            <summary>
            Specifies the baud rate setting for the serial port specified by the lpszActivePort member. This member should be set to one
            of the CBR_ values defined in the winbase.h header file. If lpszActivePort is NULL, this member is zero.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SERIALKEYS.iPortState">
            <summary>
            Specifies the state of the port specified by the lpszActivePort member. If lpszActivePort is NULL, iPortState is zero;
            otherwise, it is one of the following values:
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term>0</term>
            <description>All input on this port is ignored by the SerialKeys feature.</description>
            </item>
            <item>
            <term>1</term>
            <description>
            Input on this port is watched for SerialKeys activation sequences when no other application has the port open.
            </description>
            </item>
            <item>
            <term>2</term>
            <description>All input on this port is treated as SerialKeys commands.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SERIALKEYS.iActive">
            <summary>Specifies the active port.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SOUNDSENTRY">
            <summary>
            Contains information about the SoundSentry accessibility feature. When the SoundSentry feature is on, the computer displays a
            visual indication only when a sound is generated.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SOUNDSENTRY.cbSize">
            <summary>Specifies the size, in bytes, of this structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SOUNDSENTRY.dwFlags">
            <summary>A set of bit flags that specify properties of the SoundSentry feature.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SOUNDSENTRY.iFSTextEffect">
            <summary>
            Specifies the visual signal to present when a text-mode application generates a sound while running in a full-screen virtual machine.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SOUNDSENTRY.iFSTextEffectMSec">
            <summary>
            Specifies the duration, in milliseconds, of the visual signal that is displayed when a full-screen, text-mode application
            generates a sound.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SOUNDSENTRY.iFSTextEffectColorBits">
            <summary>
            Specifies the RGB value of the color to be used when displaying the visual signal shown when a full-screen, text-mode
            application generates a sound.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SOUNDSENTRY.iFSGrafEffect">
            <summary>
            Specifies the visual signal to present when a graphics-mode application generates a sound while running in a full-screen
            virtual machine.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SOUNDSENTRY.iFSGrafEffectMSec">
            <summary>
            Specifies the duration, in milliseconds, of the visual signal that is displayed when a full-screen, graphics-mode application
            generates a sound.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SOUNDSENTRY.iFSGrafEffectColor">
            <summary>
            Specifies the RGB value of the color to be used when displaying the visual signal shown when a full-screen, graphics-mode
            application generates a sound.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SOUNDSENTRY.iWindowsEffect">
            <summary>
            Specifies the visual signal to display when a sound is generated by a Windows-based application or an MS-DOS application
            running in a window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SOUNDSENTRY.iWindowsEffectMSec">
            <summary>
            Specifies the duration, in milliseconds, of the visual signal that is displayed when a Win32-based application (or an
            application running in a window) generates a sound.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SOUNDSENTRY.lpszWindowsEffectDLL">
            <summary>This member is reserved for future use. It should be set to NULL.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SOUNDSENTRY.iWindowsEffectOrdinal">
            <summary>This member is reserved for future use. It must be set to zero.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.STICKYKEYS">
            <summary>
            Contains information about the StickyKeys accessibility feature. When the StickyKeys feature is on, the user can press a modifier
            key (SHIFT, CTRL, or ALT) and then another key in sequence rather than at the same time, to enter shifted (modified) characters
            and other key combinations. Pressing a modifier key once latches the key down until the user presses a non-modifier key or clicks
            a mouse button. Pressing a modifier key twice locks the key until the user presses the key a third time.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.STICKYKEYS.cbSize">
            <summary>Specifies the size, in bytes, of this structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.STICKYKEYS.dwFlags">
            <summary>A set of bit-flags that specify properties of the StickyKeys feature.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TOGGLEKEYS">
            <summary>
            Contains information about the ToggleKeys accessibility feature. When the ToggleKeys feature is on, the computer emits a
            high-pitched tone whenever the user turns on the CAPS LOCK, NUM LOCK, or SCROLL LOCK key, and a low-pitched tone whenever the
            user turns off one of those keys.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOGGLEKEYS.cbSize">
            <summary>Specifies the size, in bytes, of this structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOGGLEKEYS.dwFlags">
            <summary>A set of bit flags that specify properties of the ToggleKeys feature.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TOUCHPREDICTIONPARAMETERS">
            <summary>
            Contains hardware input details that can be used to predict touch targets and help compensate for hardware latency when
            processing touch and gesture input that contains distance and velocity data.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHPREDICTIONPARAMETERS.cbSize">
            <summary>The size of this structure, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHPREDICTIONPARAMETERS.dwLatency">
            <summary>Latency in milliseconds.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHPREDICTIONPARAMETERS.dwSampleTime">
            <summary>Sample time in milliseconds (used to calculate velocity).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHPREDICTIONPARAMETERS.bUseHWTimeStamp">
            <summary>Use timestamps provided by the hardware.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.Timerproc">
            <summary>
            An application-defined callback function that processes WM_TIMER messages. The <c>TIMERPROC</c> type defines a pointer to this
            callback function. TimerProc is a placeholder for the application-defined function name.
            </summary>
            <param name="hwnd">A handle to the window associated with the timer.</param>
            <param name="uMsg">The WM_TIMER message.</param>
            <param name="idEvent">The timer's identifier.</param>
            <param name="dwTime">
            The number of milliseconds that have elapsed since the system was started. This is the value returned by the GetTickCount function.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.User32.KillTimer(Vanara.PInvoke.HWND,System.IntPtr)">
            <summary>Destroys the specified timer.</summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window associated with the specified timer. This value must be the same as the hWnd value passed to the SetTimer
            function that created the timer.
            </para>
            </param>
            <param name="uIDEvent">
            <para>Type: <c>UINT_PTR</c></para>
            <para>The timer to be destroyed. If the window handle passed to SetTimer is valid, this parameter must be the same as the nIDEvent</para>
            <para>
            value passed to <c>SetTimer</c>. If the application calls <c>SetTimer</c> with hWnd set to <c>NULL</c>, this parameter must be
            the timer identifier returned by <c>SetTimer</c>.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>The <c>KillTimer</c> function does not remove WM_TIMER messages already posted to the message queue.</para>
            <para>Examples</para>
            <para>For an example, see Destroying a Timer.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetCoalescableTimer(Vanara.PInvoke.HWND,System.UIntPtr,System.UInt32,Vanara.PInvoke.User32.Timerproc,System.UInt32)">
            <summary>Creates a timer with the specified time-out value and coalescing tolerance delay.</summary>
            <param name="hWnd"><para>Type: <c>HWND</c></para><para>A handle to the window to be associated with the timer. This window must be owned by the calling thread. If a <c>NULL</c> value for hWnd is passed in along with an nIDEvent of an existing timer, that timer will be replaced in the same way that an existing non-NULL hWnd timer will be.</para></param>
            <param name="nIDEvent"><para>Type: <c>UINT_PTR</c></para><para>A timer identifier. If the hWnd parameter is <c>NULL</c>, and the nIDEvent does not match an existing timer, then the nIDEvent is ignored and a new timer ID is generated. If the hWnd parameter is not <c>NULL</c> and the window specified by hWnd already has a timer with the value nIDEvent, then the existing timer is replaced by the new timer. When <c>SetCoalescableTimer</c> replaces a timer, the timer is reset. Therefore, a message will be sent after the current time-out value elapses, but the previously set time-out value is ignored. If the call is not intended to replace an existing timer, nIDEvent should be 0 if the hWnd is <c>NULL</c>.</para></param>
            <param name="uElapse"><para>Type: <c>UINT</c></para><para>The time-out value, in milliseconds.</para><para>If uElapse is less than <c>USER_TIMER_MINIMUM</c> (0x0000000A), the timeout is set to <c>USER_TIMER_MINIMUM</c>. If uElapse is greater than <c>USER_TIMER_MAXIMUM</c> (0x7FFFFFFF), the timeout is set to <c>USER_TIMER_MAXIMUM</c>.</para><para>If the sum of uElapse and uToleranceDelay exceeds <c>USER_TIMER_MAXIMUM</c>, an ERROR_INVALID_PARAMETER exception occurs.</para></param>
            <param name="lpTimerFunc"><para>Type: <c>TIMERPROC</c></para><para>A pointer to the function to be notified when the time-out value elapses. For more information about the function, see TimerProc. If lpTimerFunc is <c>NULL</c>, the system posts a WM_TIMER message to the application queue. The <c>hwnd</c> member of the message's MSG structure contains the value of the hWnd parameter.</para></param>
            <param name="uToleranceDelay"><para>Type: <c>ULONG</c></para><para>It can be one of the following values:</para><list type="table"><listheader><term>Value</term><term>Meaning</term></listheader><item><term> TIMERV_DEFAULT_COALESCING 0x00000000 </term><term>Uses the system default timer coalescing.</term></item><item><term> TIMERV_NO_COALESCING 0xFFFFFFFF </term><term> Uses no timer coalescing. When this value is used, the created timer is not coalesced, no matter what the system default timer coalescing is or the application compatiblity flags are. </term></item><item><term> 0x1 - 0x7FFFFFF5 </term><term> Specifies the coalescing tolerance delay, in milliseconds. Applications should set this value to the system default (TIMERV_DEFAULT_COALESCING) or the largest value possible. If the sum of uElapse and uToleranceDelay exceeds USER_TIMER_MAXIMUM (0x7FFFFFFF), an ERROR_INVALID_PARAMETER exception occurs. See Windows Timer Coalescing for more details and best practices.</term></item><item><term> Any other value </term><term> An invalid value. If uToleranceDelay is set to an invalid value, the function fails and returns zero. </term></item></list></param>
            <returns>
              <para>Type: <c>Type: <c>UINT_PTR</c> </c></para><para>If the function succeeds and the hWnd parameter is <c>NULL</c>, the return value is an integer identifying the new timer. An application can pass this value to the KillTimer function to destroy the timer.</para><para>If the function succeeds and the hWnd parameter is not <c>NULL</c>, then the return value is a nonzero integer. An application can pass the value of the nIDEvent parameter to the KillTimer function to destroy the timer.</para><para>If the function fails to create a timer, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
              <para>An application can process WM_TIMER messages by including a <c>WM_TIMER</c> case statement in the window procedure or by specifying a TimerProc callback function when creating the timer. When you specify a <c>TimerProc</c> callback function, the default window procedure calls the callback function when it processes <c>WM_TIMER</c>. Therefore, you need to dispatch messages in the calling thread, even when you use <c>TimerProc</c> instead of processing <c>WM_TIMER</c>.</para><para>The wParam parameter of the WM_TIMER message contains the value of the nIDEvent parameter.</para><para>The timer identifier, nIDEvent, is specific to the associated window. Another window can have its own timer which has the same identifier as a timer owned by another window. The timers are distinct.</para><para>SetTimer can reuse timer IDs in the case where hWnd is <c>NULL</c>.</para><para>When uToleranceDelay is set to 0, the system default timer coalescing is used and <c>SetCoalescableTimer</c> behaves the same as SetTimer.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetTimer(Vanara.PInvoke.HWND,System.IntPtr,System.UInt32,Vanara.PInvoke.User32.Timerproc)">
            <summary>Creates a timer with the specified time-out value.</summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window to be associated with the timer. This window must be owned by the calling thread. If a <c>NULL</c> value
            for hWnd is passed in along with an nIDEvent of an existing timer, that timer will be replaced in the same way that an existing
            non-NULL hWnd timer will be.
            </para>
            </param>
            <param name="nIDEvent">
            <para>Type: <c>UINT_PTR</c></para>
            <para>
            A nonzero timer identifier. If the hWnd parameter is <c>NULL</c>, and the nIDEvent does not match an existing timer then it is
            ignored and a new timer ID is generated. If the hWnd parameter is not <c>NULL</c> and the window specified by hWnd already has a
            timer with the value nIDEvent, then the existing timer is replaced by the new timer. When <c>SetTimer</c> replaces a timer, the
            timer is reset. Therefore, a message will be sent after the current time-out value elapses, but the previously set time-out value
            is ignored. If the call is not intended to replace an existing timer, nIDEvent should be 0 if the hWnd is <c>NULL</c>.
            </para>
            </param>
            <param name="uElapse">
            <para>Type: <c>UINT</c></para>
            <para>The time-out value, in milliseconds.</para>
            <para>
            If uElapse is less than <c>USER_TIMER_MINIMUM</c> (0x0000000A), the timeout is set to <c>USER_TIMER_MINIMUM</c>. If uElapse is
            greater than <c>USER_TIMER_MAXIMUM</c> (0x7FFFFFFF), the timeout is set to <c>USER_TIMER_MAXIMUM</c>.
            </para>
            </param>
            <param name="lpTimerFunc">
            <para>Type: <c>TIMERPROC</c></para>
            <para>
            A pointer to the function to be notified when the time-out value elapses. For more information about the function, see TimerProc.
            If lpTimerFunc is <c>NULL</c>, the system posts a WM_TIMER message to the application queue. The <c>hwnd</c> member of the
            message's MSG structure contains the value of the hWnd parameter.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>UINT_PTR</c></c></para>
            <para>
            If the function succeeds and the hWnd parameter is <c>NULL</c>, the return value is an integer identifying the new timer. An
            application can pass this value to the KillTimer function to destroy the timer.
            </para>
            <para>
            If the function succeeds and the hWnd parameter is not <c>NULL</c>, then the return value is a nonzero integer. An application
            can pass the value of the nIDEvent parameter to the KillTimer function to destroy the timer.
            </para>
            <para>If the function fails to create a timer, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            An application can process WM_TIMER messages by including a <c>WM_TIMER</c> case statement in the window procedure or by
            specifying a TimerProc callback function when creating the timer. When you specify a <c>TimerProc</c> callback function, the
            default window procedure calls the callback function when it processes <c>WM_TIMER</c>. Therefore, you need to dispatch messages
            in the calling thread, even when you use <c>TimerProc</c> instead of processing <c>WM_TIMER</c>.
            </para>
            <para>The wParam parameter of the WM_TIMER message contains the value of the nIDEvent parameter.</para>
            <para>
            The timer identifier, nIDEvent, is specific to the associated window. Another window can have its own timer which has the same
            identifier as a timer owned by another window. The timers are distinct.
            </para>
            <para><c>SetTimer</c> can reuse timer IDs in the case where hWnd is <c>NULL</c>.</para>
            <para>Examples</para>
            <para>For an example, see Creating a Timer.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.GC">
            <summary>Gesture configurations used by <see cref="T:Vanara.PInvoke.User32.GESTURECONFIG"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GC.GC_ALLGESTURES">
            <summary>Indicates all of the gestures.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GC.GC_ZOOM">
            <summary>Indicates the zoom gesture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GC.GC_PAN">
            <summary>Indicates all pan gestures.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GC.GC_PAN_WITH_SINGLE_FINGER_VERTICALLY">
            <summary>Indicates vertical pans with one finger.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GC.GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY">
            <summary>Indicates horizontal pans with one finger.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GC.GC_PAN_WITH_GUTTER">
            <summary>Limits perpendicular movement to primary direction until a threshold is reached to break out of the gutter.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GC.GC_PAN_WITH_INERTIA">
            <summary>Indicates panning with inertia to smoothly slow when pan gestures stop.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GC.GC_ROTATE">
            <summary>Indicates the rotation gesture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GC.GC_TWOFINGERTAP">
            <summary>Indicates the two-finger tap gesture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GC.GC_PRESSANDTAP">
            <summary>Indicates the press and tap gesture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GC.GC_ROLLOVER">
            <summary>Indicates the press and tap gesture.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.GCF">
            <summary>Flags for <see cref="M:Vanara.PInvoke.User32.GetGestureConfig(Vanara.PInvoke.HWND,System.UInt32,Vanara.PInvoke.User32.GCF,System.UInt32@,Vanara.PInvoke.User32.GESTURECONFIG[],System.UInt32)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GCF.GCF_INCLUDE_ANCESTORS">
            <summary>
            If specified, GetGestureConfig returns consolidated configuration for the specified window and its parent window chain.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.GF">
            <summary>Flags used by <see cref="T:Vanara.PInvoke.User32.GESTUREINFO"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GF.GF_BEGIN">
            <summary>A gesture is starting.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GF.GF_INERTIA">
            <summary>A gesture has triggered inertia.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GF.GF_END">
            <summary>A gesture is ending.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.GID">
            <summary>Gesture IDs used by <see cref="T:Vanara.PInvoke.User32.GESTURECONFIG"/> and <see cref="T:Vanara.PInvoke.User32.GESTUREINFO"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GID.GID_BEGIN">
            <summary>Indicates a generic gesture is beginning.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GID.GID_END">
            <summary>Indicates a generic gesture end.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GID.GID_ZOOM">
            <summary>Indicates configuration settings for the zoom gesture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GID.GID_PAN">
            <summary>Indicates the pan gesture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GID.GID_ROTATE">
            <summary>Indicates the rotation gesture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GID.GID_TWOFINGERTAP">
            <summary>Indicates the two-finger tap gesture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GID.GID_PRESSANDTAP">
            <summary>Indicates the press and tap gesture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GID.GID_ROLLOVER">
            <summary>Indicates the press and tap gesture.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TOUCH_FEEDBACK">
            <summary> Flags for <see cref="M:Vanara.PInvoke.User32.InitializeTouchInjection(System.UInt32,Vanara.PInvoke.User32.TOUCH_FEEDBACK)"/>. </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_FEEDBACK.TOUCH_FEEDBACK_DEFAULT">
            <summary>Specifies default touch visualizations.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_FEEDBACK.TOUCH_FEEDBACK_INDIRECT">
            <summary>Specifies indirect touch visualizations.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_FEEDBACK.TOUCH_FEEDBACK_NONE">
            <summary>Specifies no touch visualizations.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TOUCH_HIT_TESTING">
            <summary>Flags for <see cref="M:Vanara.PInvoke.User32.RegisterTouchHitTestingWindow(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.TOUCH_HIT_TESTING)"/></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_HIT_TESTING.TOUCH_HIT_TESTING_DEFAULT">
            <summary>The touch hit testing default</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_HIT_TESTING.TOUCH_HIT_TESTING_CLIENT">
            <summary>The touch hit testing client</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_HIT_TESTING.TOUCH_HIT_TESTING_NONE">
            <summary>The touch hit testing none</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TOUCHEVENTF">
            <summary>Flags used by <see cref="T:Vanara.PInvoke.User32.TOUCHINPUT"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHEVENTF.TOUCHEVENTF_MOVE">
            <summary>Movement has occurred. Cannot be combined with TOUCHEVENTF_DOWN.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHEVENTF.TOUCHEVENTF_DOWN">
            <summary>
            The corresponding touch point was established through a new contact. Cannot be combined with TOUCHEVENTF_MOVE or TOUCHEVENTF_UP.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHEVENTF.TOUCHEVENTF_UP">
            <summary>A touch point was removed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHEVENTF.TOUCHEVENTF_INRANGE">
            <summary>
            A touch point is in range. This flag is used to enable touch hover support on compatible hardware. Applications that do not
            want support for hover can ignore this flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHEVENTF.TOUCHEVENTF_PRIMARY">
            <summary>
            Indicates that this TOUCHINPUT structure corresponds to a primary contact point. See the following text for more information
            on primary touch points.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHEVENTF.TOUCHEVENTF_NOCOALESCE">
            <summary>When received using GetTouchInputInfo, this input was not coalesced.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHEVENTF.TOUCHEVENTF_PEN">
            <summary>The touch event came from a pen.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHEVENTF.TOUCHEVENTF_PALM">
            <summary>The touch event came from the user's palm.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TOUCHINPUTMASKF">
            <summary>Masks used by <see cref="T:Vanara.PInvoke.User32.TOUCHINPUT"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHINPUTMASKF.TOUCHINPUTMASKF_TIMEFROMSYSTEM">
            <summary>The system time was set in the TOUCHINPUT structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHINPUTMASKF.TOUCHINPUTMASKF_EXTRAINFO">
            <summary>dwExtraInfo is valid.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHINPUTMASKF.TOUCHINPUTMASKF_CONTACTAREA">
            <summary>cxContact and cyContact are valid. See the following text for more information on primary touch points.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TWF">
            <summary>Flags used by <see cref="M:Vanara.PInvoke.User32.IsTouchWindow(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.TWF@)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TWF.TWF_FINETOUCH">
            <summary>Specifies that hWnd prefers non-coalesced touch input.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TWF.TWF_WANTPALM">
            <summary>
            Clearing this flag disables palm rejection which reduces delays for getting WM_TOUCH messages. This is useful if you want as
            quick of a response as possible when a user touches your application. Setting this flag enables palm detection and will
            prevent some WM_TOUCH messages from being sent to your application. This is useful if you do not want to receive WM_TOUCH
            messages that are from palm contact.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.CloseGestureInfoHandle(Vanara.PInvoke.User32.HGESTUREINFO)">
            <summary>Closes resources associated with a gesture information handle.</summary>
            <param name="hGestureInfo">The gesture information handle.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
            </returns>
            <remarks>
            <para>
            If an application processes a WM_GESTURE message, it is responsible for closing the handle using this function. Failure to do so
            may result in process memory leaks.
            </para>
            <para>
            If the message is passed to DefWindowProc, or is forwarded using one of the PostMessage or SendMessage classes of API functions,
            the handle is transferred with the message and need not be closed by the application.
            </para>
            <para>Examples</para>
            <para>The following code shows a handler that closes the GESTUREINFO handle if the gesture has been handled.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CloseTouchInputHandle(Vanara.PInvoke.User32.HTOUCHINPUT)">
            <summary>Closes a touch input handle, frees process memory associated with it, and invalidates the handle.</summary>
            <param name="hTouchInput">
            The touch input handle received in the <c>LPARAM</c> of a touch message. The function fails with <c>ERROR_INVALID_HANDLE</c> if
            this handle is not valid. Note that the handle is not valid after it has been used in a successful call to
            <c>CloseTouchInputHandle</c> or after it has been passed to DefWindowProc, PostMessage, SendMessage or one of their variants.
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
            </returns>
            <remarks>
            Calling <c>CloseTouchInputHandle</c> will not free memory associated with values retrieved in a call to GetTouchInputInfo. Values
            in structures passed to <c>GetTouchInputInfo</c> will be valid until you delete them.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EvaluateProximityToPolygon(System.UInt32,Vanara.PInvoke.POINT[],Vanara.PInvoke.User32.TOUCH_HIT_TESTING_INPUT@,Vanara.PInvoke.User32.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION@)">
            <summary>
            Returns the score of a polygon as the probable touch target (compared to all other polygons that intersect the touch contact
            area) and an adjusted touch point within the polygon.
            </summary>
            <param name="numVertices">
            <para>The number of vertices in the polygon. This value must be greater than or equal to 3.</para>
            <para>This value indicates the size of the array, as specified by the controlPolygon parameter.</para>
            </param>
            <param name="controlPolygon">
            <para>The array of x-y screen coordinates that define the shape of the UI element.</para>
            <para>The numVertices parameter specifies the number of coordinates.</para>
            </param>
            <param name="pHitTestingInput">The TOUCH_HIT_TESTING_INPUT structure that holds the data for the touch contact area.</param>
            <param name="pProximityEval">
            The TOUCH_HIT_TESTING_PROXIMITY_EVALUATION structure that holds the score and adjusted touch-point data.
            </param>
            <returns>
            <para>If this function succeeds, it returns TRUE.</para>
            <para>Otherwise, it returns FALSE. To retrieve extended error information, call the GetLastError function.</para>
            </returns>
            <remarks>
            <para>For consistency with Windows, frameworks that handle WM_TOUCHHITTESTING should use the following principles for targeting:</para>
            <list type="bullet">
            <item>
            <term>Inclusion: If the touch point is within the boundaries of a control, the touch point is not changed.</term>
            </item>
            <item>
            <term>Intersection: Include only controls that intersect the contact geometry.</term>
            </item>
            <item>
            <term>
            Z-order: If more than one control intersects the contact geometry, and the controls overlap, the control that's highest in the
            z-order receives priority.
            </term>
            </item>
            <item>
            <term>
            Ambiguity: If more than one control intersects the contact geometry, and the controls don't overlap, the control that's closest
            to the original touch point receives priority.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EvaluateProximityToRect(Vanara.PInvoke.RECT@,Vanara.PInvoke.User32.TOUCH_HIT_TESTING_INPUT@,Vanara.PInvoke.User32.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION@)">
            <summary>
            Returns the score of a rectangle as the probable touch target, compared to all other rectangles that intersect the touch contact
            area, and an adjusted touch point within the rectangle.
            </summary>
            <param name="controlBoundingBox">The RECT structure that defines the bounding box of the UI element.</param>
            <param name="pHitTestingInput">The TOUCH_HIT_TESTING_INPUT structure that holds the data for the touch contact area.</param>
            <param name="pProximityEval">
            The TOUCH_HIT_TESTING_PROXIMITY_EVALUATION structure that holds the score and adjusted touch-point data.
            </param>
            <returns>
            <para>If this function succeeds, it returns TRUE.</para>
            <para>Otherwise, it returns FALSE. To retrieve extended error information, call the GetLastError function.</para>
            </returns>
            <remarks>
            <para>For consistency with Windows, frameworks that handle WM_TOUCHHITTESTING should use the following principles for targeting:</para>
            <list type="bullet">
            <item>
            <term>Inclusion: If the touch point is within the boundaries of a control, the touch point is not changed.</term>
            </item>
            <item>
            <term>Intersection: Include only controls that intersect the contact geometry.</term>
            </item>
            <item>
            <term>
            Z-order: If more than one control intersects the contact geometry, and the controls overlap, the control that's highest in the
            z-order receives priority.
            </term>
            </item>
            <item>
            <term>
            Ambiguity: If more than one control intersects the contact geometry, and the controls don't overlap, the control that's closest
            to the original touch point receives priority.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetGestureConfig(Vanara.PInvoke.HWND,System.UInt32,Vanara.PInvoke.User32.GCF,System.UInt32@,Vanara.PInvoke.User32.GESTURECONFIG[],System.UInt32)">
            <summary>Retrieves the configuration for which Windows Touch gesture messages are sent from a window.</summary>
            <param name="hwnd">A handle to the window to get the gesture configuration from.</param>
            <param name="dwReserved">This value is reserved and must be set to 0.</param>
            <param name="dwFlags">
            A gesture command flag value indicating options for retrieving the gesture configuration. See Remarks for additional information
            and supported values.
            </param>
            <param name="pcIDs">The size, in number of gesture configuration structures, that is in the pGestureConfig buffer.</param>
            <param name="pGestureConfig">An array of gesture configuration structures that specify the gesture configuration.</param>
            <param name="cbSize">The size of the gesture configuration (GESTURECONFIG) structure.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
            </returns>
            <remarks>
            <para>
            Passing a value other than <c>sizeof(GESTURECONFIG)</c> for the cbSize parameter will cause calls to this function to fail and
            GetLastError will return <c>ERROR_INVALID_PARAMETER</c> (87 in decimal).
            </para>
            <para>The following table lists the gesture configuration values:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GCF_INCLUDE_ANCESTORS</term>
            <term>0x00000001</term>
            <term>If specified, GetGestureConfig returns consolidated configuration for the specified window and its parent window chain.</term>
            </item>
            </list>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetGestureExtraArgs(Vanara.PInvoke.User32.HGESTUREINFO,System.UInt32,System.IntPtr)">
            <summary>Retrieves additional information about a gesture from its GESTUREINFO handle.</summary>
            <param name="hGestureInfo">The handle to the gesture information that is passed in the lParam of a WM_GESTURE message.</param>
            <param name="cbExtraArgs">A count of the bytes of data stored in the extra arguments.</param>
            <param name="pExtraArgs">A pointer to the extra argument information.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
            </returns>
            <remarks>
            This function is reserved for future use and should only be used for testing. Windows 7 gestures do not use extra arguments.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetGestureInfo(Vanara.PInvoke.User32.HGESTUREINFO,Vanara.PInvoke.User32.GESTUREINFO@)">
            <summary>Retrieves a GESTUREINFO structure given a handle to the gesture information.</summary>
            <param name="hGestureInfo">The gesture information handle.</param>
            <param name="pGestureInfo">A pointer to the gesture information structure.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
            </returns>
            <remarks>
            <para>
            The <c>cbSize</c> member of the GESTUREINFO structure passed in to the function must be set before the function is called.
            Otherwise, calls to GetLastError will return <c>ERROR_INVALID_PARAMETER</c> (87 in decimal). If an application processes a
            WM_GESTURE message, it is responsible for closing the handle using CloseGestureInfoHandle. Failure to do so may result in process
            memory leaks.
            </para>
            <para>
            If the message is passed to DefWindowProc, or is forwarded using one of the PostMessage or SendMessage classes of API functions,
            the handle is transferred with the message and need not be closed by the application.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetTouchInputInfo(Vanara.PInvoke.User32.HTOUCHINPUT,System.UInt32,Vanara.PInvoke.User32.TOUCHINPUT[],System.Int32)">
            <summary>Retrieves detailed information about touch inputs associated with a particular touch input handle.</summary>
            <param name="hTouchInput">
            The touch input handle received in the <c>LPARAM</c> of a touch message. The function fails with <c>ERROR_INVALID_HANDLE</c> if
            this handle is not valid. Note that the handle is not valid after it has been used in a successful call to CloseTouchInputHandle
            or after it has been passed to DefWindowProc, PostMessage, SendMessage or one of their variants.
            </param>
            <param name="cInputs">
            The number of structures in the pInputs array. This should ideally be at least equal to the number of touch points associated
            with the message as indicated in the message <c>WPARAM</c>. If cInputs is less than the number of touch points, the function will
            still succeed and populate the pInputs buffer with information about cInputs touch points.
            </param>
            <param name="pInputs">
            A pointer to an array of TOUCHINPUT structures to receive information about the touch points associated with the specified touch
            input handle.
            </param>
            <param name="cbSize">
            The size, in bytes, of a single TOUCHINPUT structure. If cbSize is not the size of a single <c>TOUCHINPUT</c> structure, the
            function fails with <c>ERROR_INVALID_PARAMETER</c>.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error
            information, use the GetLastError function.
            </returns>
            <remarks>
            Calling CloseTouchInputHandle will not free memory associated with values retrieved in a call to <c>GetTouchInputInfo</c>. Values
            in structures passed to <c>GetTouchInputInfo</c> will be valid until you delete them.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GID_ROTATE_ANGLE_FROM_ARGUMENT(System.UInt64)">
            <summary>
            The <c>GID_ROTATE_ANGLE_FROM_ARGUMENT</c> macro is used to interpret the <c>GID_ROTATE</c> ullArgument value when receiving the
            value in the WM_GESTURE structure.
            </summary>
            <param name="arg">A value from a WM_GESTURE message.</param>
            <returns>The angle of rotation as a double in radians.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GID_ROTATE_ANGLE_TO_ARGUMENT(System.Double)">
            <summary>Converts a radian value to an argument for rotation gesture messages.</summary>
            <param name="arg">The angle of rotation as a double in radians.</param>
            <returns>Value to pass to WM_GESTURE.</returns>
            <remarks><c>Note</c> The macro assumes that the input value for the radian value is between -2*pi and 2*pi.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.InitializeTouchInjection(System.UInt32,Vanara.PInvoke.User32.TOUCH_FEEDBACK)">
            <summary>
            Configures the touch injection context for the calling application and initializes the maximum number of simultaneous contacts
            that the app can inject.
            </summary>
            <param name="maxCount">
            <para>The maximum number of touch contacts.</para>
            <para>The maxCount parameter must be greater than 0 and less than or equal to MAX_TOUCH_COUNT (256) as defined in winuser.h.</para>
            </param>
            <param name="dwMode">
            <para>The contact visualization mode.</para>
            <para>The dwMode parameter must be TOUCH_FEEDBACK_DEFAULT, <c>TOUCH_FEEDBACK_INDIRECT</c>, or <c>TOUCH_FEEDBACK_NONE</c>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is TRUE.</para>
            <para>If the function fails, the return value is FALSE. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If TOUCH_FEEDBACK_DEFAULT is set, the injected touch feedback may get suppressed by the end-user settings in the <c>Pen and
            Touch</c> control panel.
            </para>
            <para>
            If TOUCH_FEEDBACK_INDIRECT is set, the injected touch feedback overrides the end-user settings in the <c>Pen and Touch</c>
            control panel.
            </para>
            <para>
            If TOUCH_FEEDBACK_INDIRECT or <c>TOUCH_FEEDBACK_NONE</c> are set, touch feedback provided by applications and controls may not be affected.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.InjectTouchInput(System.UInt32,Vanara.PInvoke.User32.POINTER_TOUCH_INFO[])">
            <summary>Simulates touch input.</summary>
            <param name="count">
            <para>The size of the array in contacts.</para>
            <para>The maximum value for count is specified by the maxCount parameter of the InitializeTouchInjection function.</para>
            </param>
            <param name="contacts">
            Array of POINTER_TOUCH_INFO structures that represents all contacts on the desktop. The screen coordinates of each contact must
            be within the bounds of the desktop.
            </param>
            <returns>
            <para>If the function succeeds, the return value is non-zero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>The injected input is sent to the desktop of the session where the injection process is running.</para>
            <para>
            There are two input states for touch input injection (interactive and hover) that are indicated by the following combinations of
            <c>pointerFlags</c> in contacts:
            </para>
            <list type="table">
            <listheader>
            <term>pointerFlags (POINTER_FLAG_*)</term>
            <term>Status</term>
            </listheader>
            <item>
            <term>INRANGE | UPDATE</term>
            <term>Touch hover starts or moves</term>
            </item>
            <item>
            <term>INRANGE | INCONTACT | DOWN</term>
            <term>Touch contact down</term>
            </item>
            <item>
            <term>INRANGE | INCONTACT | UPDATE</term>
            <term>Touch contact moves</term>
            </item>
            <item>
            <term>INRANGE | UP</term>
            <term>Touch contact up and transition to hover</term>
            </item>
            <item>
            <term>UPDATE</term>
            <term>Touch hover ends</term>
            </item>
            <item>
            <term>UP</term>
            <term>Touch ends</term>
            </item>
            </list>
            <para>
            <c>Note</c> Interactive state represents a touch contact that is on-screen and able to interact with any touch-capable app. Hover
            state represents touch input that is not in contact with the screen and cannot interact with applications. Touch injection can
            start in hover or interactive state, but the state can only transition through INRANGE | INCONTACT | DOWN for hover to
            interactive state, or through INRANGE | UP for interactive to hover state.
            </para>
            <para>All touch injection sequences end with either UPDATE or UP.</para>
            <para>
            The following diagram demonstrates a touch injection sequence that starts with a hover state, transitions to interactive, and
            concludes with hover.
            </para>
            <para>
            For press and hold gestures, multiple frames must be sent to ensure input is not cancelled. For a press and hold at point (x,y),
            send WM_POINTERDOWN at point (x,y) followed by WM_POINTERUPDATE messages at point(x,y).
            </para>
            <para>
            Listen for WM_DISPLAYCHANGE to handle changes to display resolution and orientation and manage screen coordinate updates. All
            active contacts are cancelled when a <c>WM_DISPLAYCHANGE</c> is received.
            </para>
            <para>
            Cancel individual contacts by setting POINTER_FLAG_CANCELED with POINTER_FLAG_UP or POINTER_FLAG_UPDATE. Cancelling touch
            injection without POINTER_FLAG_UP or POINTER_FLAG_UPDATE invalidates the injection.
            </para>
            <para>
            When POINTER_FLAG_UP is set, ptPixelLocation of POINTER_INFO should be the same as the value of the previous touch injection
            frame with POINTER_FLAG_UPDATE. Otherwise, the injection fails with ERROR_INVALID_PARAMETER and all active injection contacts are
            cancelled. The system modifies the ptPixelLocation of the WM_POINTERUP event as it cancels the injection.
            </para>
            <para>
            The input timestamp can be specified in either the dwTime or PerformanceCount field of POINTER_INFO. The value cannot be more
            recent than the current tick count or QueryPerformanceCounter value of the injection thread. Once a frame is injected with a
            timestamp, all subsequent frames must include a timestamp until all contacts in the frame go to the UP state. The custom
            timestamp value must be provided for the first element in the contacts array. The timestamp values after the first element are
            ignored. The custom timestamp value must increment in every injection frame.
            </para>
            <para>
            When a PerformanceCount field is specified, the timestamp is converted into current time in .1 millisecond resolution upon actual
            injection. If a custom PerformanceCount resulted in the same .1 millisecond window from previous injection, the API will return
            an error (ERROR_NOT_READY) and will not inject the data. While injection is not immediately invalidated by the error, next
            successful injection must have PerformanceCount value that is at least 0.1 milliseconds apart from the previously successful
            injection. Similarly a custom dwTime value must be at least 1 millisecond apart if the field was used.
            </para>
            <para>
            If both dwTime and PerformanceCount are specified in the injection parameter, InjectTouchInput fails with an Error Code
            (ERROR_INVALID_PARAMETER). Once the injection application starts with either a dwTime or PerformanceCount parameter, the
            timestamp field must be filled correctly. Injection cannot switch the custom timestamp field from one to another once the
            injection sequence has started.
            </para>
            <para>
            When neither dwTime or PerformanceCount values are specified, the InjectTouchInput allocates the timestamp based on the timing of
            the API call. If the calls are less than 0.1 millisecond apart, the API may return an error (ERROR_NOT_READY). The error will not
            invalidate the input immediately, but the injection application needs to retry the same frame again to ensure injection is successful.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsTouchWindow(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.TWF@)">
            <summary>
            Checks whether a specified window is touch-capable and, optionally, retrieves the modifier flags set for the window's touch capability.
            </summary>
            <param name="hwnd">
            The handle of the window. The function fails with <c>ERROR_ACCESS_DENIED</c> if the calling thread is not on the same desktop as
            the specified window.
            </param>
            <param name="pulFlags">
            The address of the <c>ULONG</c> variable to receive the modifier flags for the specified window's touch capability.
            </param>
            <returns>
            Returns <c>TRUE</c> if the window supports Windows Touch; returns <c>FALSE</c> if the window does not support Windows Touch.
            </returns>
            <remarks>
            <para>The following table lists the values for the pulFlags output parameter.</para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>TWF_FINETOUCH</term>
            <term>Specifies that hWnd prefers non-coalesced touch input.</term>
            </item>
            <item>
            <term>TWF_WANTPALM</term>
            <term>
            Clearing this flag disables palm rejection which reduces delays for getting WM_TOUCH messages. This is useful if you want as
            quick of a response as possible when a user touches your application. Setting this flag enables palm detection and will prevent
            some WM_TOUCH messages from being sent to your application. This is useful if you do not want to receive WM_TOUCH messages that
            are from palm contact.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.PackTouchHitTestingProximityEvaluation(Vanara.PInvoke.User32.TOUCH_HIT_TESTING_INPUT@,Vanara.PInvoke.User32.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION@)">
            <summary>
            Returns the proximity evaluation score and the adjusted touch-point coordinates as a packed value for the WM_TOUCHHITTESTING callback.
            </summary>
            <param name="pHitTestingInput">The TOUCH_HIT_TESTING_INPUT structure that holds the data for the touch contact area.</param>
            <param name="pProximityEval">
            The TOUCH_HIT_TESTING_PROXIMITY_EVALUATION structure that holds the score and adjusted touch-point data that the
            EvaluateProximityToPolygon or EvaluateProximityToRect function returns.
            </param>
            <returns>
            If this function succeeds, it returns the <c>score</c> and <c>adjustedPoint</c> values from
            TOUCH_HIT_TESTING_PROXIMITY_EVALUATION as an LRESULT. To retrieve extended error information, call the GetLastError function.
            </returns>
            <remarks>Usually, this is the last function that's called in a WM_TOUCHHITTESTING handler.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterTouchHitTestingWindow(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.TOUCH_HIT_TESTING)">
            <summary>
            <para>Registers a window to process the</para>
            <para>WM_TOUCHHITTESTING notification.</para>
            </summary>
            <param name="hwnd">The window that receives the WM_TOUCHHITTESTING notification.</param>
            <param name="value">
            <para>One of the following values:</para>
            <list type="bullet">
            <item>
            <term>TOUCH_HIT_TESTING_CLIENT: Send WM_TOUCHHITTESTING messages to the target window.</term>
            </item>
            <item>
            <term>
            TOUCH_HIT_TESTING_DEFAULT: Don't send WM_TOUCHHITTESTING messages to the target window but continue to send the messages to child windows.
            </term>
            </item>
            <item>
            <term>TOUCH_HIT_TESTING_NONE: Don't send WM_TOUCHHITTESTING messages to the target window or child windows.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>If this function succeeds, it returns TRUE.</para>
            <para>Otherwise, it returns FALSE. To retrieve extended error information, call the GetLastError function.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterTouchWindow(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.TWF)">
            <summary>Registers a window as being touch-capable.</summary>
            <param name="hwnd">
            The handle of the window being registered. The function fails with <c>ERROR_ACCESS_DENIED</c> if the calling thread does not own
            the specified window.
            </param>
            <param name="ulFlags">
            <para>A set of bit flags that specify optional modifications. This field may contain 0 or one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TWF_FINETOUCH</term>
            <term>Specifies that hWnd prefers noncoalesced touch input.</term>
            </item>
            <item>
            <term>TWF_WANTPALM</term>
            <term>
            Setting this flag disables palm rejection which reduces delays for getting WM_TOUCH messages. This is useful if you want as quick
            of a response as possible when a user touches your application. By default, palm detection is enabled and some WM_TOUCH messages
            are prevented from being sent to your application. This is useful if you do not want to receive WM_TOUCH messages that are from
            palm contact.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
            </returns>
            <remarks>
            <para>
            <c>Note</c><c>RegisterTouchWindow</c> must be called on every window that will be used for touch input. This means that if you
            have an application that has multiple windows within it, <c>RegisterTouchWindow</c> must be called on every window in that
            application that uses touch features. Also, an application can call <c>RegisterTouchWindow</c> any number of times for the same
            window if it desires to change the modifier flags. A window can be marked as no longer requiring touch input using the
            UnregisterTouchWindow function.
            </para>
            <para>
            If <c>TWF_WANTPALM</c> is enabled, packets from touch input are not buffered and palm detection is not performed before the
            packets are sent to your application. Enabling <c>TWF_WANTPALM</c> is most useful if you want minimal latencies when processing
            WM_TOUCH messages.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetGestureConfig(Vanara.PInvoke.HWND,System.UInt32,System.UInt32,Vanara.PInvoke.User32.GESTURECONFIG[],System.UInt32)">
            <summary>Configures the messages that are sent from a window for Windows Touch gestures.</summary>
            <param name="hwnd">A handle to the window to set the gesture configuration on.</param>
            <param name="dwReserved">This value is reserved and must be set to 0.</param>
            <param name="cIDs">A count of the gesture configuration structures that are being passed.</param>
            <param name="pGestureConfig">An array of gesture configuration structures that specify the gesture configuration.</param>
            <param name="cbSize">The size of the gesture configuration (GESTURECONFIG) structure.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
            </returns>
            <remarks>
            <para>
            If you don't expect to change the gesture configuration, call <c>SetGestureConfig</c> at window creation time. If you want to
            dynamically change the gesture configuration, call <c>SetGestureConfig</c> in response to WM_GESTURENOTIFY messages.
            </para>
            <para>
            The following table shows the identifiers for gestures that are supported by the dwID member of the GESTURECONFIG structure. Note
            that setting dwID to 0 indicates that global gesture configuration flags are set.
            </para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GID_ZOOM</term>
            <term>3</term>
            <term>Configuration settings for the zoom gesture.</term>
            </item>
            <item>
            <term>GID_PAN</term>
            <term>4</term>
            <term>The pan gesture.</term>
            </item>
            <item>
            <term>GID_ROTATE</term>
            <term>5</term>
            <term>The rotation gesture.</term>
            </item>
            <item>
            <term>GID_TWOFINGERTAP</term>
            <term>6</term>
            <term>The two-finger tap gesture.</term>
            </item>
            <item>
            <term>GID_PRESSANDTAP</term>
            <term>7</term>
            <term>The press and tap gesture.</term>
            </item>
            </list>
            <para>The following flags are used when dwID is set to zero.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GC_ALLGESTURES</term>
            <term>0x00000001</term>
            <term>All of the gestures.</term>
            </item>
            </list>
            <para>The following flags are used when dwID is set to GID_ZOOM.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GC_ZOOM</term>
            <term>0x00000001</term>
            <term>The zoom gesture.</term>
            </item>
            </list>
            <para>The following flags are used when dwID is set to GID_PAN.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GC_PAN</term>
            <term>0x00000001</term>
            <term>All pan gestures.</term>
            </item>
            <item>
            <term>GC_PAN_WITH_SINGLE_FINGER_VERTICALLY</term>
            <term>0x00000002</term>
            <term>Vertical pans with one finger.</term>
            </item>
            <item>
            <term>GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY</term>
            <term>0x00000004</term>
            <term>Horizontal pans with one finger.</term>
            </item>
            <item>
            <term>GC_PAN_WITH_GUTTER</term>
            <term>0x00000008</term>
            <term>
            Panning with a gutter boundary around the edges of pannable region. The gutter boundary limits perpendicular movement to a
            primary direction until a threshold is reached to break out of the gutter.
            </term>
            </item>
            <item>
            <term>GC_PAN_WITH_INTERTIA</term>
            <term>0x00000010</term>
            <term>Panning with inertia to smoothly slow when pan gestures stop.</term>
            </item>
            </list>
            <para>
            <c>Note</c> Pan gestures can be used in conjunction with each other to control behavior. For example, setting the <c>dwWant</c>
            bits to panning with single-finger horizontal and setting the <c>dwBlock</c> bits to single-finger vertical will restrict panning
            to horizontal pans. Changing the <c>dwWant</c> bit to have and removing single-finger vertical pan from the <c>dwBlock</c> bit
            will enable both vertical and horizontal panning.
            </para>
            <para><c>Note</c> By default, panning has inertia enabled.</para>
            <para><c>Note</c> A single call to <c>SetGestureConfig</c> cannot include other GIDs along with 0.</para>
            <para>The following flags are used when dwID is set to GID_ROTATE.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GC_ROTATE</term>
            <term>0x00000001</term>
            <term>The rotation gesture.</term>
            </item>
            </list>
            <para>The following flags are used when dwID is set to <c>GID_TWOFINGERTAP</c>.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GC_TWOFINGERTAP</term>
            <term>0x00000001</term>
            <term>The two-finger tap gesture.</term>
            </item>
            </list>
            <para>The following flags are used when dwID is set to <c>GID_PRESSANDTAP</c>.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GC_PRESSANDTAP</term>
            <term>0x00000001</term>
            <term>The press and tap gesture.</term>
            </item>
            </list>
            <para>
            <c>Note</c> Calling <c>SetGestureConfig</c> will change the gesture configuration for the lifetime of the Window, not just for
            the next gesture.
            </para>
            <para>Examples</para>
            <para>
            The following example shows how you could receive horizontal and vertical single-finger panning with no gutter and no inertia.
            This is a typical configuration for a 2-D navigation application such as the Microsoft PixelSense Globe application.
            </para>
            <para>
            The following example shows how to receive single-finger pan gestures and disable gutter panning. This is a typical configuration
            for applications that scroll text such as Notepad.
            </para>
            <para><c>Note</c> You should explicitly set all the flags that you want enabled or disabled when controlling single-finger panning.</para>
            <para>The following example shows how you can disable all gestures.</para>
            <para>The following example shows how you could enable all gestures.</para>
            <para>The following example shows how you could enable all Windows 7 gestures.</para>
            <para>
            The following example configuration would set the parent window to enable support for zoom, horizontal pan, and vertical pan
            while the child window would just support horizontal pan.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.TOUCH_COORD_TO_PIXEL(System.Int32)">
            <summary>Converts touch coordinates to pixels.</summary>
            <param name="l">The value to be converted from touch coordinates to pixels.</param>
            <returns>The pixel value.</returns>
            <remarks>
            <para>
            The <c>TOUCH_COORD_TO_PIXEL</c> macro is used to convert from touch coordinates (currently centipixels) to pixels. Touch
            coordinates are finer grained than pixels so that application developers can use subpixel granularity for specialized
            applications such as graphic design.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.UnregisterTouchWindow(Vanara.PInvoke.HWND)">
            <summary>Registers a window as no longer being touch-capable.</summary>
            <param name="hwnd">
            The handle of the window. The function fails with <c>ERROR_ACCESS_DENIED</c> if the calling thread does not own the specified window.
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
            </returns>
            <remarks>
            The <c>UnregisterTouchWindow</c> function succeeds even if the specified window was not previously registered as being touch-capable.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.GESTURECONFIG">
            <summary>Gets and sets the configuration for enabling gesture messages and the type of this configuration.</summary>
            <remarks>
            <para>
            It is impossible to disable two-finger panning and keep single finger panning. You must set the want bits for GC_PAN before you
            can set them for GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY or GC_PAN_WITH_SINGLE_FINGER_VERTICALLY.
            </para>
            <para>An inertia vector is included in the GID_PAN message with the GF_END flag if inertia was disabled by a call to SetGestureConfig.</para>
            <para>
            When you pass this structure, the dwID member contains information for a set of gestures. This determines what the other flags
            will mean. If you set flags for pan messages, they will be different from those flags that are set for rotation messages.
            </para>
            <para>
            The following table indicates the various identifiers for gestures that are supported by the dwID member of the
            <c>GESTURECONFIG</c> structure. Note that setting dwID to 0 indicates that global gesture configuration flags are set.
            </para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GID_ZOOM</term>
            <term>3</term>
            <term>Indicates configuration settings for the zoom gesture.</term>
            </item>
            <item>
            <term>GID_PAN</term>
            <term>4</term>
            <term>Indicates the pan gesture.</term>
            </item>
            <item>
            <term>GID_ROTATE</term>
            <term>5</term>
            <term>Indicates the rotation gesture.</term>
            </item>
            <item>
            <term>GID_TWOFINGERTAP</term>
            <term>6</term>
            <term>Indicates the two-finger tap gesture.</term>
            </item>
            <item>
            <term>GID_PRESSANDTAP</term>
            <term>7</term>
            <term>Indicates the press and tap gesture.</term>
            </item>
            </list>
            <para>The following flags are used when dwID is set to 0.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GC_ALLGESTURES</term>
            <term>0x00000001</term>
            <term>Indicates all of the gestures.</term>
            </item>
            </list>
            <para>The following flags are used when dwID is set to GID_ZOOM.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GC_ZOOM</term>
            <term>0x00000001</term>
            <term>Indicates the zoom gesture.</term>
            </item>
            </list>
            <para>The following flags are used when dwID is set to GID_PAN.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GC_PAN</term>
            <term>0x00000001</term>
            <term>Indicates all pan gestures.</term>
            </item>
            <item>
            <term>GC_PAN_WITH_SINGLE_FINGER_VERTICALLY</term>
            <term>0x00000002</term>
            <term>Indicates vertical pans with one finger.</term>
            </item>
            <item>
            <term>GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY</term>
            <term>0x00000004</term>
            <term>Indicates horizontal pans with one finger.</term>
            </item>
            <item>
            <term>GC_PAN_WITH_GUTTER</term>
            <term>0x00000008</term>
            <term>Limits perpendicular movement to primary direction until a threshold is reached to break out of the gutter.</term>
            </item>
            <item>
            <term>GC_PAN_WITH_INERTIA</term>
            <term>0x00000010</term>
            <term>Indicates panning with inertia to smoothly slow when pan gestures stop.</term>
            </item>
            </list>
            <para>
            <c>Note</c> Setting the <c>GID_PAN</c> flags in SetGestureConfig will affect the default gesture handler for panning. You should
            not have both <c>dwWant</c> and <c>dwBlock</c> set for the same flags; this will result in unexpected behavior. See Windows Touch
            Gestures for more information on panning and legacy panning support; see <c>SetGestureConfig</c> for examples of enabling and
            blocking gestures.
            </para>
            <para>The following flags are used when dwID is set to GID_ROTATE.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GC_ROTATE</term>
            <term>0x00000001</term>
            <term>Indicates the rotation gesture.</term>
            </item>
            </list>
            <para>The following flags are used when dwID is set to GID_TWOFINGERTAP.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GC_TWOFINGERTAP</term>
            <term>0x00000001</term>
            <term>Indicates the two-finger tap gesture.</term>
            </item>
            </list>
            <para>The following flags are used when dwID is set to GID_PRESSANDTAP.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GC_PRESSANDTAP</term>
            <term>0x00000001</term>
            <term>Indicates the press and tap gesture.</term>
            </item>
            </list>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTURECONFIG.dwID">
            <summary>
            The identifier for the type of configuration that will have messages enabled or disabled. For more information, see Remarks.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTURECONFIG.dwWant">
            <summary>The messages to enable.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTURECONFIG.dwBlock">
            <summary>The messages to disable.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.GESTURECONFIG.#ctor(Vanara.PInvoke.User32.GID)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.GESTURECONFIG"/> struct.</summary>
            <param name="id">The identifier for the type of configuration that will have messages enabled or disabled.</param>
        </member>
        <member name="T:Vanara.PInvoke.User32.GESTUREINFO">
            <summary>Stores information about a gesture.</summary>
            <remarks>
            <para>The <c>HIDWORD</c> of the <c>ullArguments</c> member is always 0, with the following exceptions:</para>
            <list type="bullet">
            <item>
            <term>
            For <c>GID_PAN</c>, it is 0 except when there is inertia. When <c>GF_INERTIA</c> is set, the <c>HIDWORD</c> is an inertia vector
            (two 16-bit values).
            </term>
            </item>
            <item>
            <term>For <c>GID_PRESSANDTAP</c>, it is the distance between the two points.</term>
            </item>
            </list>
            <para>
            The <c>GESTUREINFO</c> structure is retrieved by passing the handle to the gesture information structure to the GetGestureInfo function.
            </para>
            <para>The following flags indicate the various states of the gestures and are stored in <c>dwFlags</c>.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GF_BEGIN</term>
            <term>0x00000001</term>
            <term>A gesture is starting.</term>
            </item>
            <item>
            <term>GF_INERTIA</term>
            <term>0x00000002</term>
            <term>A gesture has triggered inertia.</term>
            </item>
            <item>
            <term>GF_END</term>
            <term>0x00000004</term>
            <term>A gesture has finished.</term>
            </item>
            </list>
            <para>
            <c>Note</c> Most applications should ignore the <c>GID_BEGIN</c> and <c>GID_END</c> messages and pass them to
            <c>DefWindowProc</c>. These messages are used by the default gesture handler. Application behavior is undefined when the
            <c>GID_BEGIN</c> and <c>GID_END</c> messages are consumed by a third-party application.
            </para>
            <para>The following table indicates the various identifiers for gestures.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>GID_BEGIN</term>
            <term>1</term>
            <term>A gesture is starting.</term>
            </item>
            <item>
            <term>GID_END</term>
            <term>2</term>
            <term>A gesture is ending.</term>
            </item>
            <item>
            <term>GID_ZOOM</term>
            <term>3</term>
            <term>The zoom gesture.</term>
            </item>
            <item>
            <term>GID_PAN</term>
            <term>4</term>
            <term>The pan gesture.</term>
            </item>
            <item>
            <term>GID_ROTATE</term>
            <term>5</term>
            <term>The rotation gesture.</term>
            </item>
            <item>
            <term>GID_TWOFINGERTAP</term>
            <term>6</term>
            <term>The two-finger tap gesture.</term>
            </item>
            <item>
            <term>GID_PRESSANDTAP</term>
            <term>7</term>
            <term>The press and tap gesture.</term>
            </item>
            </list>
            <para>
            <c>Note</c> The <c>GID_PAN</c> gesture has built-in inertia. At the end of a pan gesture, additional pan gesture messages are
            created by the operating system.
            </para>
            <para>The following type is defined to represent a constant pointer to a <c>GESTUREINFO</c> structure.</para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTUREINFO.cbSize">
            <summary>The size of the structure, in bytes. The caller must set this to .</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTUREINFO.dwFlags">
            <summary>The state of the gesture. For additional information, see Remarks.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTUREINFO.dwID">
            <summary>The identifier of the gesture command.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTUREINFO.hwndTarget">
            <summary>A handle to the window that is targeted by this gesture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTUREINFO.ptsLocation">
            <summary>
            A <c>POINTS</c> structure containing the coordinates associated with the gesture. These coordinates are always relative to
            the origin of the screen.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTUREINFO.dwInstanceID">
            <summary>An internally used identifier for the structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTUREINFO.dwSequenceID">
            <summary>An internally used identifier for the sequence.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTUREINFO.ullArguments">
            <summary>A 64-bit unsigned integer that contains the arguments for gestures that fit into 8 bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTUREINFO.cbExtraArgs">
            <summary>The size, in bytes, of extra arguments that accompany this gesture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTUREINFO.Default">
            <summary>A default value for <see cref="T:Vanara.PInvoke.User32.GESTUREINFO"/> with the <see cref="F:Vanara.PInvoke.User32.GESTUREINFO.cbSize"/> field value set correctly.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.GESTURENOTIFYSTRUCT">
            <summary>When transmitted with WM_GESTURENOTIFY messages, passes information about a gesture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTURENOTIFYSTRUCT.cbSize">
            <summary>The size of the structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTURENOTIFYSTRUCT.dwFlags">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTURENOTIFYSTRUCT.hwndTarget">
            <summary>The target window for the gesture notification.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTURENOTIFYSTRUCT.ptsLocation">
            <summary>The location of the gesture in physical screen coordinates.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTURENOTIFYSTRUCT.dwInstanceID">
            <summary>A specific gesture instance with gesture messages starting with <c>GID_START</c> and ending with <c>GID_END</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GESTURENOTIFYSTRUCT.Default">
            <summary>A default value for <see cref="T:Vanara.PInvoke.User32.GESTURENOTIFYSTRUCT"/> with the <see cref="F:Vanara.PInvoke.User32.GESTURENOTIFYSTRUCT.cbSize"/> field value set correctly.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.HGESTUREINFO">
            <summary>Provides a handle to a gesture info.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.HGESTUREINFO.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.HGESTUREINFO"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.User32.HGESTUREINFO.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.User32.HGESTUREINFO"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.HGESTUREINFO.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.HGESTUREINFO.op_Explicit(Vanara.PInvoke.User32.HGESTUREINFO)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.User32.HGESTUREINFO"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HGESTUREINFO.op_Implicit(System.IntPtr)~Vanara.PInvoke.User32.HGESTUREINFO">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.User32.HGESTUREINFO"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HGESTUREINFO.op_Inequality(Vanara.PInvoke.User32.HGESTUREINFO,Vanara.PInvoke.User32.HGESTUREINFO)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HGESTUREINFO.op_Equality(Vanara.PInvoke.User32.HGESTUREINFO,Vanara.PInvoke.User32.HGESTUREINFO)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HGESTUREINFO.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.HGESTUREINFO.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.HGESTUREINFO.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.HTOUCHINPUT">
            <summary>Provides a handle to a touch input.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.HTOUCHINPUT.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.User32.HTOUCHINPUT"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.User32.HTOUCHINPUT.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.User32.HTOUCHINPUT"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.User32.HTOUCHINPUT.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.HTOUCHINPUT.op_Explicit(Vanara.PInvoke.User32.HTOUCHINPUT)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.User32.HTOUCHINPUT"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HTOUCHINPUT.op_Implicit(System.IntPtr)~Vanara.PInvoke.User32.HTOUCHINPUT">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.User32.HTOUCHINPUT"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HTOUCHINPUT.op_Inequality(Vanara.PInvoke.User32.HTOUCHINPUT,Vanara.PInvoke.User32.HTOUCHINPUT)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HTOUCHINPUT.op_Equality(Vanara.PInvoke.User32.HTOUCHINPUT,Vanara.PInvoke.User32.HTOUCHINPUT)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.HTOUCHINPUT.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.HTOUCHINPUT.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.User32.HTOUCHINPUT.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.TOUCH_HIT_TESTING_INPUT">
            <summary>Contains information about the touch contact area reported by the touch digitizer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_HIT_TESTING_INPUT.pointerId">
            <summary>
            The ID of the pointer. You cannot pass this value to the input message process and retrieve additional pointer info through GetPointerInfo.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_HIT_TESTING_INPUT.point">
            <summary>The screen coordinates of the touch point that the touch digitizer reports.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_HIT_TESTING_INPUT.boundingBox">
            <summary>
            <para>
            The bounding rectangle of the touch contact area. Valid touch targets are identified and scored based on this bounding box.
            </para>
            <para><c>Note</c> This bounding box may differ from the contact area that the digitizer reports when:</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_HIT_TESTING_INPUT.nonOccludedBoundingBox">
            <summary>
            The touch contact area within a specific targeted window that's not occluded by other objects that are higher in the z-order.
            Any area that's occluded by another object is an invalid target.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_HIT_TESTING_INPUT.orientation">
            <summary>The orientation of the touch contact area.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION">
            <summary>
            Contains the hit test score that indicates whether the object is the likely target of the touch contact area, relative to other
            objects that intersect the touch contact area.
            </summary>
            <remarks>The EvaluateProximityToRect or EvaluateProximityToPolygon function returns the values.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION.score">
            <summary>The score, compared to the other objects that intersect the touch contact area.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCH_HIT_TESTING_PROXIMITY_EVALUATION.adjustedPoint">
            <summary>The adjusted touch point that hits the closest object that's identified by the value of Score.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TOUCHINPUT">
            <summary>Encapsulates data for touch input.</summary>
            <remarks>
            <para>The following table lists the flags for the <c>dwFlags</c> member.</para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>TOUCHEVENTF_MOVE</term>
            <term>0x0001</term>
            <term>Movement has occurred. Cannot be combined with TOUCHEVENTF_DOWN.</term>
            </item>
            <item>
            <term>TOUCHEVENTF_DOWN</term>
            <term>0x0002</term>
            <term>The corresponding touch point was established through a new contact. Cannot be combined with TOUCHEVENTF_MOVE or TOUCHEVENTF_UP.</term>
            </item>
            <item>
            <term>TOUCHEVENTF_UP</term>
            <term>0x0004</term>
            <term>A touch point was removed.</term>
            </item>
            <item>
            <term>TOUCHEVENTF_INRANGE</term>
            <term>0x0008</term>
            <term>
            A touch point is in range. This flag is used to enable touch hover support on compatible hardware. Applications that do not want
            support for hover can ignore this flag.
            </term>
            </item>
            <item>
            <term>TOUCHEVENTF_PRIMARY</term>
            <term>0x0010</term>
            <term>
            Indicates that this TOUCHINPUT structure corresponds to a primary contact point. See the following text for more information on
            primary touch points.
            </term>
            </item>
            <item>
            <term>TOUCHEVENTF_NOCOALESCE</term>
            <term>0x0020</term>
            <term>When received using GetTouchInputInfo, this input was not coalesced.</term>
            </item>
            <item>
            <term>TOUCHEVENTF_PALM</term>
            <term>0x0080</term>
            <term>The touch event came from the user's palm.</term>
            </item>
            </list>
            <para>
            <c>Note</c> If the target hardware on a machine does not support hover, when the <c>TOUCHEVENTF_UP</c> flag is set, the
            <c>TOUCHEVENTF_INRANGE</c> flag is cleared. If the target hardware on a machine supports hover, the <c>TOUCHEVENTF_UP</c> and
            <c>TOUCHEVENTF_INRANGE</c> flags will be set independently.
            </para>
            <para>The following table lists the flags for the <c>dwMask</c> member.</para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>TOUCHINPUTMASKF_CONTACTAREA</term>
            <term>0x0004</term>
            <term>cxContact and cyContact are valid. See the following text for more information on primary touch points.</term>
            </item>
            <item>
            <term>TOUCHINPUTMASKF_EXTRAINFO</term>
            <term>0x0002</term>
            <term>dwExtraInfo is valid.</term>
            </item>
            <item>
            <term>TOUCHINPUTMASKF_TIMEFROMSYSTEM</term>
            <term>0x0001</term>
            <term>The system time was set in the TOUCHINPUT structure.</term>
            </item>
            </list>
            <para>
            A touch point is designated as primary when it is the first touch point to be established from a previous state of no touch
            points. The <c>TOUCHEVENTF_PRIMARY</c> flag continues to be set for all subsequent events for the primary touch point until the
            primary touch point is released. Note that a <c>TOUCHEVENTF_UP</c> event on the primary touch point does not necessarily
            designate the end of a Windows Touch operation; the current Windows Touch operation proceeds from the establishment of the
            primary touch point until the last touch point is released.
            </para>
            <para>
            Note that a solitary touch point or, in a set of simultaneous touch points, the first to be detected, is designated the primary.
            The system mouse position follows the primary touch point and, in addition to touch messages, also generates
            <c>WM_LBUTTONDOWN</c>, <c>WM_MOUSEMOVE</c>, and <c>WM_LBUTTONUP</c> messages in response to actions on a primary touch point. The
            primary touch point can also generate <c>WM_RBUTTONDOWN</c> and <c>WM_RBUTTONUP</c> messages using the press and hold gesture.
            </para>
            <para>
            Note that the touch point identifier may be dynamic and is associated with a given touch point only as long as the touch point
            persists. If contact is broken and then resumed (for example, if a finger is removed from the surface and then pressed down
            again), the same touch point (the same finger, pen, or other such device) may receive a different touch point identifier.
            </para>
            <para>The following type is defined to represent a constant pointer to a <c>TOUCHINPUT</c> structure.</para>
            <para>Examples</para>
            <para>
            <c>Note</c> In the following example, the pInputs array is not sorted. Use the <c>dwID</c> value to track specific touch points.
            </para>
            <para>
            The following example shows how to get the device information from the <c>hSource</c> member. This example uses GetRawInputDevice
            to retrieve information about the device.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHINPUT.x">
            <summary>
            The x-coordinate (horizontal point) of the touch input. This member is indicated in hundredths of a pixel of physical screen coordinates.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHINPUT.y">
            <summary>
            The y-coordinate (vertical point) of the touch input. This member is indicated in hundredths of a pixel of physical screen coordinates.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHINPUT.hSource">
            <summary>
            A device handle for the source input device. Each device is given a unique provider at run time by the touch input provider.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHINPUT.dwID">
            <summary>
            A touch point identifier that distinguishes a particular touch input. This value stays consistent in a touch contact sequence
            from the point a contact comes down until it comes back up. An ID may be reused later for subsequent contacts.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHINPUT.dwFlags">
            <summary>
            A set of bit flags that specify various aspects of touch point press, release, and motion. The bits in this member can be any
            reasonable combination of the values in the Remarks section.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHINPUT.dwMask">
            <summary>
            A set of bit flags that specify which of the optional fields in the structure contain valid values. The availability of valid
            information in the optional fields is device-specific. Applications should use an optional field value only when the
            corresponding bit is set in dwMask. This field may contain a combination of the dwMask flags mentioned in the Remarks section.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHINPUT.dwTime">
            <summary>
            The time stamp for the event, in milliseconds. The consuming application should note that the system performs no validation
            on this field; when the <c>TOUCHINPUTMASKF_TIMEFROMSYSTEM</c> flag is not set, the accuracy and sequencing of values in this
            field are completely dependent on the touch input provider.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHINPUT.dwExtraInfo">
            <summary>An additional value associated with the touch event.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHINPUT.cxContact">
            <summary>
            The width of the touch contact area in hundredths of a pixel in physical screen coordinates. This value is only valid if the
            <c>dwMask</c> member has the <c>TOUCHEVENTFMASK_CONTACTAREA</c> flag set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TOUCHINPUT.cyContact">
            <summary>
            The height of the touch contact area in hundredths of a pixel in physical screen coordinates. This value is only valid if the
            <c>dwMask</c> member has the <c>TOUCHEVENTFMASK_CONTACTAREA</c> flag set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CW_USEDEFAULT">
            <summary>
            Pass this value to the x, y, nWidth and nHeight parameteres of <see cref="M:Vanara.PInvoke.User32.CreateWindow(System.String,System.String,Vanara.PInvoke.User32.WindowStyles,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.HWND,Vanara.PInvoke.HMENU,Vanara.PInvoke.HINSTANCE,System.IntPtr)"/> and <c>CreateWindowEx</c> to
            select the default position for the parameter.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.EnumWindowsProc">
            <summary>
            An application-defined callback function used with the <c>EnumChildWindows</c> function. It receives the child window handles.
            The <c>WNDENUMPROC</c> type defines a pointer to this callback function. EnumChildProc is a placeholder for the
            application-defined function name.
            </summary>
            <param name="hwnd">A handle to a child window of the parent window specified in <c>EnumChildWindows</c>.</param>
            <param name="lParam">The application-defined value given in <c>EnumChildWindows</c>.</param>
            <returns>To continue enumeration, the callback function must return <c>TRUE</c>; to stop enumeration, it must return <c>FALSE</c>.</returns>
        </member>
        <member name="T:Vanara.PInvoke.User32.WindowProc">
            <summary>
            <para>
            An application-defined function that processes messages sent to a window. The <c>WNDPROC</c> type defines a pointer to this
            callback function.
            </para>
            <para>WindowProc is a placeholder for the application-defined function name.</para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window.</para>
            </param>
            <param name="uMsg">
            <para>Type: <c>UINT</c></para>
            <para>The message.</para>
            <para>For lists of the system-provided messages, see System-Defined Messages.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message information. The contents of this parameter depend on the value of the uMsg parameter.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message information. The contents of this parameter depend on the value of the uMsg parameter.</para>
            </param>
            <returns>
            <para>Type:</para>
            <para>The return value is the result of the message processing and depends on the message sent.</para>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.User32.WinMain">
            <summary>
            <para>The user-provided entry point for a graphical Windows-based application.</para>
            <para><c>WinMain</c> is the conventional name used for the application entry point. For more information, see Remarks.</para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to the current instance of the application.</para>
            </param>
            <param name="hPrevInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>
            A handle to the previous instance of the application. This parameter is always <c>NULL</c>. If you need to detect whether another
            instance already exists, create a uniquely named mutex using the <c>CreateMutex</c> function. <c>CreateMutex</c> will succeed
            even if the mutex already exists, but the function will return <c>ERROR_ALREADY_EXISTS</c>. This indicates that another instance
            of your application exists, because it created the mutex first. However, a malicious user can create this mutex before you do and
            prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it
            can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one
            instance per user, create a locked file in the user's profile directory.
            </para>
            </param>
            <param name="lpCmdLine">
            <para>Type: <c>LPSTR</c></para>
            <para>
            The command line for the application, excluding the program name. To retrieve the entire command line, use the
            <c>GetCommandLine</c> function.
            </para>
            </param>
            <param name="nCmdShow">
            <para>Type: <c>int</c></para>
            <para>Controls how the window is to be shown. This parameter can be one of the following values.</para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SW_HIDE0</term>
            <term>Hides the window and activates another window.</term>
            </item>
            <item>
            <term>SW_MAXIMIZE3</term>
            <term>Maximizes the specified window.</term>
            </item>
            <item>
            <term>SW_MINIMIZE6</term>
            <term>Minimizes the specified window and activates the next top-level window in the Z order.</term>
            </item>
            <item>
            <term>SW_RESTORE9</term>
            <term>
            Activates and displays the window. If the window is minimized or maximized, the system restores it to its original size and
            position. An application should specify this flag when restoring a minimized window.
            </term>
            </item>
            <item>
            <term>SW_SHOW5</term>
            <term>Activates the window and displays it in its current size and position.</term>
            </item>
            <item>
            <term>SW_SHOWMAXIMIZED3</term>
            <term>Activates the window and displays it as a maximized window.</term>
            </item>
            <item>
            <term>SW_SHOWMINIMIZED2</term>
            <term>Activates the window and displays it as a minimized window.</term>
            </item>
            <item>
            <term>SW_SHOWMINNOACTIVE7</term>
            <term>Displays the window as a minimized window. This value is similar to SW_SHOWMINIMIZED, except the window is not activated.</term>
            </item>
            <item>
            <term>SW_SHOWNA8</term>
            <term>Displays the window in its current size and position. This value is similar to SW_SHOW, except the window is not activated.</term>
            </item>
            <item>
            <term>SW_SHOWNOACTIVATE4</term>
            <term>
            Displays a window in its most recent size and position. This value is similar to SW_SHOWNORMAL, except the window is not activated.
            </term>
            </item>
            <item>
            <term>SW_SHOWNORMAL1</term>
            <term>
            Activates and displays a window. If the window is minimized or maximized, the system restores it to its original size and
            position. An application should specify this flag when displaying the window for the first time.
            </term>
            </item>
            </list>
            </para>
            </param>
            <returns>
            <para>Type:</para>
            <para>
            If the function succeeds, terminating when it receives a <c>WM_QUIT</c> message, it should return the exit value contained in
            that message's wParam parameter. If the function terminates before entering the message loop, it should return zero.
            </para>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.User32.AnimateWindowFlags">
            <summary>
            The type of animation. Note that, by default, these flags take effect when showing a window. To take effect when hiding a window,
            use <c>AW_HIDE</c> and a logical OR operator with the appropriate flags.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AnimateWindowFlags.AW_ACTIVATE">
            <summary>Activates the window. Do not use this value with AW_HIDE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AnimateWindowFlags.AW_BLEND">
            <summary>Uses a fade effect. This flag can be used only if hwnd is a top-level window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AnimateWindowFlags.AW_CENTER">
            <summary>
            Makes the window appear to collapse inward if AW_HIDE is used or expand outward if the AW_HIDE is not used. The various
            direction flags have no effect.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AnimateWindowFlags.AW_HIDE">
            <summary>Hides the window. By default, the window is shown.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AnimateWindowFlags.AW_HOR_POSITIVE">
            <summary>
            Animates the window from left to right. This flag can be used with roll or slide animation. It is ignored when used with
            AW_CENTER or AW_BLEND.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AnimateWindowFlags.AW_HOR_NEGATIVE">
            <summary>
            Animates the window from right to left. This flag can be used with roll or slide animation. It is ignored when used with
            AW_CENTER or AW_BLEND.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AnimateWindowFlags.AW_SLIDE">
            <summary>Uses slide animation. By default, roll animation is used. This flag is ignored when used with AW_CENTER.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AnimateWindowFlags.AW_VER_POSITIVE">
            <summary>
            Animates the window from top to bottom. This flag can be used with roll or slide animation. It is ignored when used with
            AW_CENTER or AW_BLEND.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.AnimateWindowFlags.AW_VER_NEGATIVE">
            <summary>
            Animates the window from bottom to top. This flag can be used with roll or slide animation. It is ignored when used with
            AW_CENTER or AW_BLEND.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ChildWindowSkipOptions">
            <summary>For use with ChildWindowFromPointEx</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ChildWindowSkipOptions.CWP_ALL">
            <summary>Does not skip any child windows</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ChildWindowSkipOptions.CWP_SKIPINVISIBLE">
            <summary>Skips invisible child windows</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ChildWindowSkipOptions.CWP_SKIPDISABLED">
            <summary>Skips disabled child windows</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ChildWindowSkipOptions.CWP_SKIPTRANSPARENT">
            <summary>Skips transparent child windows</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.DefaultLayout">
            <summary>The default process layout.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DefaultLayout.LAYOUT_LTR">
            <summary>Sets the default horizontal layout to be left to right.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.DefaultLayout.LAYOUT_RTL">
            <summary>Sets the default horizontal layout to be right to left.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.FEEDBACK_TYPE">
            <summary>
            <para>Specifies the visual feedback associated with an event.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FEEDBACK_TYPE.FEEDBACK_TOUCH_CONTACTVISUALIZATION">
            <summary>Feedback for a touch contact event.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FEEDBACK_TYPE.FEEDBACK_PEN_BARRELVISUALIZATION">
            <summary>Feedback for a pen barrel-button event.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FEEDBACK_TYPE.FEEDBACK_PEN_TAP">
            <summary>Feedback for a pen tap event.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FEEDBACK_TYPE.FEEDBACK_PEN_DOUBLETAP">
            <summary>Feedback for a pen double-tap event.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FEEDBACK_TYPE.FEEDBACK_PEN_PRESSANDHOLD">
            <summary>Feedback for a pen press-and-hold event.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FEEDBACK_TYPE.FEEDBACK_PEN_RIGHTTAP">
            <summary>Feedback for a pen right-tap event.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FEEDBACK_TYPE.FEEDBACK_TOUCH_TAP">
            <summary>Feedback for a touch tap event.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FEEDBACK_TYPE.FEEDBACK_TOUCH_DOUBLETAP">
            <summary>Feedback for a touch double-tap event.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FEEDBACK_TYPE.FEEDBACK_TOUCH_PRESSANDHOLD">
            <summary>Feedback for a touch press-and-hold event.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FEEDBACK_TYPE.FEEDBACK_TOUCH_RIGHTTAP">
            <summary>Feedback for a touch right-tap event.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FEEDBACK_TYPE.FEEDBACK_GESTURE_PRESSANDTAP">
            <summary>Feedback for a press-and-tap gesture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FEEDBACK_TYPE.FEEDBACK_MAX">
            <summary>Do not use.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.FLASHW">
            <summary>The flash status.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FLASHW.FLASHW_ALL">
            <summary>
            Flash both the window caption and taskbar button. This is equivalent to setting the FLASHW_CAPTION | FLASHW_TRAY flags.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FLASHW.FLASHW_CAPTION">
            <summary>Flash the window caption.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FLASHW.FLASHW_STOP">
            <summary>Stop flashing. The system restores the window to its original state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FLASHW.FLASHW_TIMER">
            <summary>Flash continuously, until the FLASHW_STOP flag is set.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FLASHW.FLASHW_TIMERNOFG">
            <summary>Flash continuously until the window comes to the foreground.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FLASHW.FLASHW_TRAY">
            <summary>Flash the taskbar button.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.GetClassLongFlag">
            <summary>
            To retrieve any other value from the WNDCLASSEX structure using <see cref="M:Vanara.PInvoke.User32.GetClassLong(Vanara.PInvoke.HWND,System.Int32)"/>, specify one of the
            following values.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCLP_MENUNAME">
            <summary>Retrieves the address of the menu name string. The string identifies the menu resource associated with the class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCLP_HBRBACKGROUND">
            <summary>Retrieves a handle to the background brush associated with the class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCLP_HCURSOR">
            <summary>Retrieves a handle to the cursor associated with the class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCLP_HICON">
            <summary>Retrieves a handle to the icon associated with the class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCLP_HMODULE">
            <summary>Retrieves a handle to the module that registered the class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCLP_WNDPROC">
            <summary>
            Retrieves the address of the window procedure, or a handle representing the address of the window procedure. You must use the
            CallWindowProc function to call the window procedure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCLP_HICONSM">
            <summary>Retrieves a handle to the small icon associated with the class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCW_ATOM">
            <summary>
            Retrieves an ATOM value that uniquely identifies the window class. This is the same atom that the RegisterClass or
            RegisterClassEx function returns.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCL_MENUNAME">
            <summary>Retrieves the address of the menu name string. The string identifies the menu resource associated with the class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCL_HBRBACKGROUND">
            <summary>Retrieves a handle to the background brush associated with the class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCL_HCURSOR">
            <summary>Retrieves a handle to the cursor associated with the class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCL_HICON">
            <summary>Retrieves a handle to the icon associated with the class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCL_HMODULE">
            <summary>Retrieves a handle to the module that registered the class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCL_CBWNDEXTRA">
            <summary>
            Retrieves the size, in bytes, of the extra window memory associated with each window in the class. For information on how to
            access this memory, see GetWindowLong.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCL_CBCLSEXTRA">
            <summary>Retrieves the size, in bytes, of the extra memory associated with the class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCL_WNDPROC">
            <summary>
            Retrieves the address of the window procedure, or a handle representing the address of the window procedure. You must use the
            CallWindowProc function to call the window procedure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCL_STYLE">
            <summary>Retrieves the window-class style bits.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetClassLongFlag.GCL_HICONSM">
            <summary>Retrieves a handle to the small icon associated with the class.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.GCW">
            <summary>Values used by <see cref="M:Vanara.PInvoke.User32.GetWindowLong(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.WindowLongFlags)"/> to determine which value to retrieve.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GCW.GCW_ATOM">
            <summary>
            Retrieves an ATOM value that uniquely identifies the window class. This is the same atom that the RegisterClass or
            RegisterClassEx function returns.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.GetAncestorFlag">
            <summary>The ancestor to be retrieved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetAncestorFlag.GA_PARENT">
            <summary>Retrieves the parent window. This does not include the owner, as it does with the GetParent function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetAncestorFlag.GA_ROOT">
            <summary>Retrieves the root window by walking the chain of parent windows.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetAncestorFlag.GA_ROOTOWNER">
            <summary>Retrieves the owned root window by walking the chain of parent and owner windows returned by GetParent.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.GetWindowCmd">
            <summary>The relationship between the specified window and the window whose handle is to be retrieved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetWindowCmd.GW_CHILD">
            <summary>
            The retrieved handle identifies the child window at the top of the Z order, if the specified window is a parent window;
            otherwise, the retrieved handle is NULL. The function examines only child windows of the specified window. It does not
            examine descendant windows.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetWindowCmd.GW_ENABLEDPOPUP">
            <summary>
            The retrieved handle identifies the enabled popup window owned by the specified window (the search uses the first such window
            found using GW_HWNDNEXT); otherwise, if there are no enabled popup windows, the retrieved handle is that of the specified window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetWindowCmd.GW_HWNDFIRST">
            <summary>
            The retrieved handle identifies the window of the same type that is highest in the Z order. If the specified window is a
            topmost window, the handle identifies a topmost window. If the specified window is a top-level window, the handle identifies
            a top-level window. If the specified window is a child window, the handle identifies a sibling window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetWindowCmd.GW_HWNDLAST">
            <summary>
            The retrieved handle identifies the window of the same type that is lowest in the Z order. If the specified window is a
            topmost window, the handle identifies a topmost window. If the specified window is a top-level window, the handle identifies
            a top-level window. If the specified window is a child window, the handle identifies a sibling window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetWindowCmd.GW_HWNDNEXT">
            <summary>
            The retrieved handle identifies the window below the specified window in the Z order. If the specified window is a topmost
            window, the handle identifies a topmost window. If the specified window is a top-level window, the handle identifies a
            top-level window. If the specified window is a child window, the handle identifies a sibling window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetWindowCmd.GW_HWNDPREV">
            <summary>
            The retrieved handle identifies the window above the specified window in the Z order. If the specified window is a topmost
            window, the handle identifies a topmost window. If the specified window is a top-level window, the handle identifies a
            top-level window. If the specified window is a child window, the handle identifies a sibling window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GetWindowCmd.GW_OWNER">
            <summary>
            The retrieved handle identifies the specified window's owner window, if any. For more information, see Owned Windows.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.GUIThreadInfoFlags">
            <summary>The thread state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GUIThreadInfoFlags.GUI_CARETBLINKING">
            <summary>The caret's blink state. This bit is set if the caret is visible.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GUIThreadInfoFlags.GUI_INMENUMODE">
            <summary>The thread's menu state. This bit is set if the thread is in menu mode.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GUIThreadInfoFlags.GUI_INMOVESIZE">
            <summary>The thread's move state. This bit is set if the thread is in a move or size loop.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GUIThreadInfoFlags.GUI_POPUPMENUMODE">
            <summary>The thread's pop-up menu state. This bit is set if the thread has an active pop-up menu.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GUIThreadInfoFlags.GUI_SYSTEMMENUMODE">
            <summary>The thread's system menu state. This bit is set if the thread is in a system menu mode.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.GWFS">
            <summary>Flags for <see cref="M:Vanara.PInvoke.User32.GetWindowFeedbackSetting(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.FEEDBACK_TYPE,Vanara.PInvoke.User32.GWFS,System.UInt32@,System.Boolean@)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GWFS.GWFS_INCLUDE_ANCESTORS">
            <summary>Check the parent window chain until a value is found</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.LayeredWindowAttributes">
            <summary>A layering flag.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LayeredWindowAttributes.LWA_ALPHA">
            <summary>Use pbAlpha to determine the opacity of the layered window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LayeredWindowAttributes.LWA_COLORKEY">
            <summary>Use pcrKey as the transparency color.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.LSFW">
            <summary>Specifies whether to enable or disable calls to SetForegroundWindow.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LSFW.SFW_LOCK">
            <summary>Disables calls to SetForegroundWindow.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.LSFW.LSFW_UNLOCK">
            <summary>Enables calls to SetForegroundWindow.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MdiTileFlags">
            <summary>The tiling flags.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MdiTileFlags.MDITILE_VERTICAL">
            <summary>Tiles windows horizontally.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MdiTileFlags.MDITILE_HORIZONTAL">
            <summary>Tiles windows vertically.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MdiTileFlags.MDITILE_SKIPDISABLED">
            <summary>Prevents disabled MDI child windows from being cascaded.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MdiTileFlags.MDITILE_ZORDER">
            <summary>
            Arranges the windows in Z order. If this value is not specified, the windows are arranged using the order specified in the
            lpKids array.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MessageFilterExAction">
            <summary>The action to be performed on <see cref="M:Vanara.PInvoke.User32.ChangeWindowMessageFilterEx(Vanara.PInvoke.HWND,System.UInt32,Vanara.PInvoke.User32.MessageFilterExAction,Vanara.PInvoke.User32.CHANGEFILTERSTRUCT@)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MessageFilterExAction.MSGFLT_RESET">
            <summary>
            Resets the window message filter for hWnd to the default. Any message allowed globally or process-wide will get through, but
            any message not included in those two categories, and which comes from a lower privileged process, will be blocked.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MessageFilterExAction.MSGFLT_ALLOW">
            <summary>
            Allows the message through the filter. This enables the message to be received by hWnd, regardless of the source of the
            message, even it comes from a lower privileged process.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MessageFilterExAction.MSGFLT_DISALLOW">
            <summary>
            Blocks the message to be delivered to hWnd if it comes from a lower privileged process, unless the message is allowed
            process-wide by using the ChangeWindowMessageFilter function or globally.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MessageFilterFlag">
            <summary>The action to be performed on <see cref="M:Vanara.PInvoke.User32.ChangeWindowMessageFilter(System.UInt32,Vanara.PInvoke.User32.MessageFilterFlag)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MessageFilterFlag.MSGFLT_ADD">
            <summary>Adds the message to the filter. This has the effect of allowing the message to be received.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MessageFilterFlag.MSGFLT_REMOVE">
            <summary>Removes the message from the filter. This has the effect of blocking the message.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.MessageFilterInformation">
            <summary>Return values for <see cref="F:Vanara.PInvoke.User32.CHANGEFILTERSTRUCT.ExtStatus"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MessageFilterInformation.MSGFLTINFO_NONE">
            <summary>See the Remarks section of <see cref="T:Vanara.PInvoke.User32.CHANGEFILTERSTRUCT"/>. Applies to MSGFLT_ALLOW and MSGFLT_DISALLOW.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MessageFilterInformation.MSGFLTINFO_ALREADYALLOWED_FORWND">
            <summary>
            The message has already been allowed by this window's message filter, and the function thus succeeded with no change to the
            window's message filter. Applies to MSGFLT_ALLOW.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MessageFilterInformation.MSGFLTINFO_ALREADYDISALLOWED_FORWND">
            <summary>
            The message has already been blocked by this window's message filter, and the function thus succeeded with no change to the
            window's message filter. Applies to MSGFLT_DISALLOW.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.MessageFilterInformation.MSGFLTINFO_ALLOWED_HIGHER">
            <summary>The message is allowed at a scope higher than the window. Applies to MSGFLT_DISALLOW.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.ObjectState">
            <summary>
            <para>
            This topic describes the constant values used to describe the state of objects in an application UI. The state constants are
            defined in oleacc.h.
            </para>
            <para>
            An object is associated with one or more of these state values at any time. The following object state constants are not used:
            STATE_SYSTEM_ALERT_HIGH, STATE_SYSTEM_ALERT_MEDIUM, STATE_SYSTEM_ALERT_LOW, and STATE_SYSTEM_FLOATING.
            </para>
            <para>
            Clients retrieve an object's state by calling <c>IAccessible::get_accState</c>, which returns an integer that is a combination of
            the following bit flags. Clients call <c>GetStateText</c> with the state value to retrieve a localized string that describes the
            object's state.
            </para>
            <para>
            When the state of an object changes, servers should call <c>NotifyWinEvent</c> with the <c>EVENT_OBJECT_STATECHANGE</c> event
            constant. However, objects with the STATE_SYSTEM_INVISIBLE, STATE_SYSTEM_FOCUSED, and STATE_SYSTEM_ SELECTED object state
            constants have their own event constants. For these objects, do not use <c>EVENT_OBJECT_STATECHANGE</c>. Instead, use the
            individual event constant.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_NORMAL">
            <summary>Indicates that the object does not have another state assigned to it.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_ALERT_HIGH">
            <summary>
            (This object state constant is not supported.) Indicates important information to be immediately conveyed to the user. For
            example, when a battery reaches a critically low level, a level indicator generates a high-level alert. As a result, a blind
            access tool immediately announces this information to the user, and a screen magnification program scrolls the screen so that
            the battery indicator is in view. This state is also appropriate for any prompt or operation that must be completed before
            the user can continue.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_ALERT_LOW">
            <summary>
            (This object state constant is not supported.) Indicates low-priority information that is not important to the user. This
            state is used, for example, when Word changes the appearance of the TipWizard button on its toolbar to indicate that it has a
            hint for the user.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_ALERT_MEDIUM">
            <summary>
            (This object state constant is not supported.) Indicates important information that is not conveyed immediately to the user.
            For example, when a battery is starting to reach a low level, a level indicator generates a medium-level alert. A blind
            access tool then generates a sound to let the user know that important information is available, without actually
            interrupting the user's work. The user could then query the alert information when convenient.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_ANIMATED">
            <summary>
            The object's appearance changes rapidly or constantly. Graphics that are animated occasionally are described as
            ROLE_SYSTEM_GRAPHIC with the State property set to STATE_SYSTEM_ANIMATED. This state is used to indicate that the object's
            location is changing.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_BUSY">
            <summary>The control cannot accept input at this time.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_CHECKED">
            <summary>The object's check box is selected.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_COLLAPSED">
            <summary>The object's children that have the ROLE_SYSTEM_OUTLINEITEM role are hidden.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_DEFAULT">
            <summary>This state represents the default button in a window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_EXPANDED">
            <summary>The object's children that have the ROLE_SYSTEM_OUTLINEITEM role are displayed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_EXTSELECTABLE">
            <summary>
            Indicates that an object extends its selection by using SELFLAG_EXTENDSELECTION in the IAccessible::accSelect method.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_FLOATING">
            <summary>
            (This object state constant is not supported.) The object is not clipped to the boundary of its parent object, and it does
            not move automatically when the parent moves.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_FOCUSABLE">
            <summary>The object is on the active window and is ready to receive keyboard focus.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_FOCUSED">
            <summary>
            The object has the keyboard focus. Do not confuse object focus with object selection. For more information, see Selection and
            Focus Properties and Methods. For objects with this object state, send the EVENT_OBJECT_SHOW or EVENT_OBJECT_HIDE WinEvents
            to notify client applications about state changes. Do not use EVENT_OBJECT_STATECHANGE.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_HASPOPUP">
            <summary>When invoked, the object displays a pop-up menu or a window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_HOTTRACKED">
            <summary>
            The object is hot-tracked by the mouse, which means that the object's appearance has changed to indicate that the mouse
            pointer is located over it.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_INDETERMINATE">
            <summary>
            Indicates that the state of a three-state check box or toolbar button is not determined. The check box is neither selected
            nor cleared and is therefore in the third or mixed state.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_INVISIBLE">
            <summary>
            The object is programmatically hidden. For example, menu items are programmatically hidden until a user activates the menu.
            Because objects with this state are not available to users, client applications must not communicate information about the
            object to users. However, if client applications find an object with this state, they should check whether
            STATE_SYSTEM_OFFSCREEN is also set. If this second state is defined, clients can communicate the information about the object
            to users. For example, a list box can have both STATE_SYSTEM_INVISIBLE and STATE_SYSTEM_OFFSCREEN set. In this case, the
            client application can communicate all items in the list to users.
            <para>
            If a client application is navigating through an IAccessible tree and encounters a parent object that is invisible, Microsoft
            Active Accessibility will not expose information about any possible children of the parent as long as the parent is invisible.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_LINKED">
            <summary>Indicates that the object is formatted as a hyperlink. The object's role will usually be ROLE_SYSTEM_TEXT.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_MARQUEED">
            <summary>Indicates scrolling or moving text or graphics.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_MIXED">
            <summary>
            Indicates that the state of a three-state check box or toolbar button is not determined. The check box is neither selected
            nor cleared and is therefore in the third or mixed state.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_MOVEABLE">
            <summary>
            Indicates that the object can be moved. For example, a user can click the object's title bar and drag the object to a new location.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_MULTISELECTABLE">
            <summary>
            Indicates that the object accepts multiple selected items; that is, SELFLAG_ADDSELECTION for the IAccessible::accSelect
            method is valid.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_OFFSCREEN">
            <summary>
            The object is clipped or has scrolled out of view, but it is not programmatically hidden. If the user makes the viewport
            larger, more of the object will be visible on the computer screen.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_PRESSED">
            <summary>The object is pressed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_PROTECTED">
            <summary>The object is a password-protected edit control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_READONLY">
            <summary>The object is designated read-only.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_SELECTABLE">
            <summary>The object accepts selection.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_SELECTED">
            <summary>The object is selected.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_SELFVOICING">
            <summary>
            The object or child uses text-to-speech (TTS) technology for description purposes. When an object with this state has the
            focus, a speech-based accessibility aid does not announce information because the object automatically announces it.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_SIZEABLE">
            <summary>The object can be resized. For example, a user could change the size of a window by dragging it by the border.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_TRAVERSED">
            <summary>The object is a hyperlink that has been visited (previously clicked) by a user.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ObjectState.STATE_SYSTEM_UNAVAILABLE">
            <summary>The object is unavailable.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.PW">
            <summary>Flags for <see cref="M:Vanara.PInvoke.User32.PrintWindow(Vanara.PInvoke.HWND,Vanara.PInvoke.HDC,Vanara.PInvoke.User32.PW)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PW.PW_ENTIREWINDOW">
            <summary>Render the entire window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PW.PW_CLIENTONLY">
            <summary>Only the client area of the window is copied to hdcBlt. By default, the entire window is copied.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.PW.PW_RENDERFULLCONTENT">
            <summary>Undocumented</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SetWindowPosFlags">
            <summary>Window sizing and positioning flags.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SetWindowPosFlags.SWP_ASYNCWINDOWPOS">
            <summary>
            If the calling thread and the thread that owns the window are attached to different input queues, the system posts the
            request to the thread that owns the window. This prevents the calling thread from blocking its execution while other threads
            process the request.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SetWindowPosFlags.SWP_DEFERERASE">
            <summary>Prevents generation of the WM_SYNCPAINT message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SetWindowPosFlags.SWP_DRAWFRAME">
            <summary>Draws a frame (defined in the window's class description) around the window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SetWindowPosFlags.SWP_FRAMECHANGED">
            <summary>
            Applies new frame styles set using the SetWindowLong function. Sends a WM_NCCALCSIZE message to the window, even if the
            window's size is not being changed. If this flag is not specified, WM_NCCALCSIZE is sent only when the window's size is being changed.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SetWindowPosFlags.SWP_HIDEWINDOW">
            <summary>Hides the window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SetWindowPosFlags.SWP_NOACTIVATE">
            <summary>
            Does not activate the window. If this flag is not set, the window is activated and moved to the top of either the topmost or
            non-topmost group (depending on the setting of the hWndInsertAfter parameter).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SetWindowPosFlags.SWP_NOCOPYBITS">
            <summary>
            Discards the entire contents of the client area. If this flag is not specified, the valid contents of the client area are
            saved and copied back into the client area after the window is sized or repositioned.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SetWindowPosFlags.SWP_NOMOVE">
            <summary>Retains the current position (ignores X and Y parameters).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SetWindowPosFlags.SWP_NOOWNERZORDER">
            <summary>Does not change the owner window's position in the Z order.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SetWindowPosFlags.SWP_NOREDRAW">
            <summary>
            Does not redraw changes. If this flag is set, no repainting of any kind occurs. This applies to the client area, the
            nonclient area (including the title bar and scroll bars), and any part of the parent window uncovered as a result of the
            window being moved. When this flag is set, the application must explicitly invalidate or redraw any parts of the window and
            parent window that need redrawing.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SetWindowPosFlags.SWP_NOREPOSITION">
            <summary>Same as the SWP_NOOWNERZORDER flag.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SetWindowPosFlags.SWP_NOSENDCHANGING">
            <summary>Prevents the window from receiving the WM_WINDOWPOSCHANGING message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SetWindowPosFlags.SWP_NOSIZE">
            <summary>Retains the current size (ignores the cx and cy parameters).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SetWindowPosFlags.SWP_NOZORDER">
            <summary>Retains the current Z order (ignores the hWndInsertAfter parameter).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SetWindowPosFlags.SWP_SHOWWINDOW">
            <summary>Displays the window.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SysCommand">
            <summary>Commands for WM_SYSCOMMAND.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_ARRANGE">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_CLOSE">
            <summary>Closes the window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_CONTEXTHELP">
            <summary>
            Changes the cursor to a question mark with a pointer. If the user then clicks a control in the dialog box, the control
            receives a WM_HELP message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_DEFAULT">
            <summary>Selects the default item; the user double-clicked the window menu.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_HOTKEY">
            <summary>
            Activates the window associated with the application-specified hot key. The lParam parameter identifies the window to activate.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_HSCROLL">
            <summary>Scrolls horizontally.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SCF_ISSECURE">
            <summary>Indicates whether the screen saver is secure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_KEYMENU">
            <summary>Retrieves the window menu as a result of a keystroke. For more information, see the Remarks section.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_MAXIMIZE">
            <summary>Maximizes the window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_MINIMIZE">
            <summary>Minimizes the window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_MONITORPOWER">
            <summary>
            Sets the state of the display. This command supports devices that have power-saving features, such as a battery-powered
            personal computer.
            <para>The lParam parameter can have the following values:</para>
            <list type="bullet">
            <item>-1 (the display is powering on)</item>
            <item>1 (the display is going to low power)</item>
            <item>2 (the display is being shut off)</item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_MOUSEMENU">
            <summary>Retrieves the window menu as a result of a mouse click.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_MOVE">
            <summary>Moves the window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_NEXTWINDOW">
            <summary>Moves to the next window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_PREVWINDOW">
            <summary>Moves to the previous window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_RESTORE">
            <summary>Restores the window to its normal position and size.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_SCREENSAVE">
            <summary>Executes the screen saver application specified in the [boot] section of the System.ini file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_SEPARATOR">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_SIZE">
            <summary>Sizes the window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_TASKLIST">
            <summary>Activates the Start menu.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.SysCommand.SC_VSCROLL">
            <summary>Scrolls vertically.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TrackPopupMenuFlags">
            <summary>Options for functions related to popup menus and windows.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_LEFTBUTTON">
            <summary>The user can select menu items with only the left mouse button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_RIGHTBUTTON">
            <summary>The user can select menu items with both the left and right mouse buttons.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_LEFTALIGN">
            <summary>
            Positions the pop-up window so that its left edge is aligned with the coordinate specified by the anchorPoint-&gt;x parameter.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_CENTERALIGN">
            <summary>Centers pop-up window horizontally relative to the coordinate specified by the anchorPoint-&gt;x parameter.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_RIGHTALIGN">
            <summary>
            Positions the pop-up window so that its right edge is aligned with the coordinate specified by the anchorPoint-&gt;x parameter.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_TOPALIGN">
            <summary>Positions the shortcut menu so that its top side is aligned with the coordinate specified by the y parameter.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_VCENTERALIGN">
            <summary>Centers the shortcut menu vertically relative to the coordinate specified by the y parameter.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_BOTTOMALIGN">
            <summary>Positions the shortcut menu so that its bottom side is aligned with the coordinate specified by the y parameter.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_HORIZONTAL">
            <summary>
            If the menu cannot be shown at the specified location without overlapping the excluded rectangle, the system tries to
            accommodate the requested horizontal alignment before the requested vertical alignment.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_VERTICAL">
            <summary>
            If the menu cannot be shown at the specified location without overlapping the excluded rectangle, the system tries to
            accommodate the requested vertical alignment before the requested horizontal alignment.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_NONOTIFY">
            <summary>The function does not send notification messages when the user clicks a menu item.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_RETURNCMD">
            <summary>The function returns the menu item identifier of the user's selection in the return value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_RECURSE">
            <summary>Displays a menu when another menu is already displayed. This is intended to support context menus within a menu.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_HORPOSANIMATION">
            <summary>Animates the menu from left to right.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_HORNEGANIMATION">
            <summary>Animates the menu from right to left.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_VERPOSANIMATION">
            <summary>Animates the menu from top to bottom.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_VERNEGANIMATION">
            <summary>Animates the menu from bottom to top.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_NOANIMATION">
            <summary>Displays menu without animation.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_LAYOUTRTL">
            <summary>For right-to-left text layout.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TrackPopupMenuFlags.TPM_WORKAREA">
            <summary>
            Restricts the pop-up window to within the work area. If this flag is not set, the pop-up window is restricted to the work
            area only if the input point is within the work area. For more information, see the rcWork and rcMonitor members of the
            MONITORINFO structure.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.UpdateLayeredWindowFlags">
            <summary>Flags for <see cref="M:Vanara.PInvoke.User32.UpdateLayeredWindow(Vanara.PInvoke.HWND,Vanara.PInvoke.HDC,Vanara.PInvoke.POINT@,Vanara.PInvoke.SIZE@,Vanara.PInvoke.HDC,Vanara.PInvoke.POINT@,Vanara.PInvoke.COLORREF,Vanara.PInvoke.Gdi32.BLENDFUNCTION@,Vanara.PInvoke.User32.UpdateLayeredWindowFlags)"/></summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UpdateLayeredWindowFlags.ULW_COLORKEY">
            <summary>Use crKey as the transparency color.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UpdateLayeredWindowFlags.ULW_ALPHA">
            <summary>
            Use pblend as the blend function. If the display mode is 256 colors or less, the effect of this value is the same as the
            effect of ULW_OPAQUE.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UpdateLayeredWindowFlags.ULW_OPAQUE">
            <summary>Draw an opaque layered window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UpdateLayeredWindowFlags.ULW_EX_NORESIZE">
            <summary>
            Force the UpdateLayeredWindowIndirect function to fail if the current window size does not match the size specified in the psize.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.WindowClassStyles">
            <summary>Window class styles.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowClassStyles.CS_BYTEALIGNCLIENT">
            <summary>
            Aligns the window's client area on a byte boundary (in the x direction). This style affects the width of the window and its
            horizontal placement on the display.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowClassStyles.CS_BYTEALIGNWINDOW">
            <summary>
            Aligns the window on a byte boundary (in the x direction). This style affects the width of the window and its horizontal
            placement on the display.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowClassStyles.CS_CLASSDC">
            <summary>
            Allocates one device context to be shared by all windows in the class. Because window classes are process specific, it is
            possible for multiple threads of an application to create a window of the same class. It is also possible for the threads to
            attempt to use the device context simultaneously. When this happens, the system allows only one thread to successfully finish
            its drawing operation.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowClassStyles.CS_DBLCLKS">
            <summary>
            Sends a double-click message to the window procedure when the user double-clicks the mouse while the cursor is within a
            window belonging to the class.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowClassStyles.CS_DROPSHADOW">
            <summary>
            Enables the drop shadow effect on a window. The effect is turned on and off through SPI_SETDROPSHADOW. Typically, this is
            enabled for small, short-lived windows such as menus to emphasize their Z-order relationship to other windows. Windows
            created from a class with this style must be top-level windows; they may not be child windows.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowClassStyles.CS_GLOBALCLASS">
            <summary>
            Indicates that the window class is an application global class. For more information, see the "Application Global Classes"
            section of About Window Classes.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowClassStyles.CS_HREDRAW">
            <summary>Redraws the entire window if a movement or size adjustment changes the width of the client area.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowClassStyles.CS_NOCLOSE">
            <summary>Disables Close on the window menu.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowClassStyles.CS_OWNDC">
            <summary>Allocates a unique device context for each window in the class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowClassStyles.CS_PARENTDC">
            <summary>
            Sets the clipping rectangle of the child window to that of the parent window so that the child can draw on the parent. A
            window with the CS_PARENTDC style bit receives a regular device context from the system's cache of device contexts. It does
            not give the child the parent's device context or device context settings. Specifying CS_PARENTDC enhances an application's performance.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowClassStyles.CS_SAVEBITS">
            <summary>
            Saves, as a bitmap, the portion of the screen image obscured by a window of this class. When the window is removed, the
            system uses the saved bitmap to restore the screen image, including other windows that were obscured. Therefore, the system
            does not send WM_PAINT messages to windows that were obscured if the memory used by the bitmap has not been discarded and if
            other screen actions have not invalidated the stored image.
            <para>
            This style is useful for small windows (for example, menus or dialog boxes) that are displayed briefly and then removed
            before other screen activity takes place. This style increases the time required to display the window, because the system
            must first allocate memory to store the bitmap.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowClassStyles.CS_VREDRAW">
            <summary>Redraws the entire window if a movement or size adjustment changes the height of the client area.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowClassStyles.CS_IME">
            <summary>Undocumented.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.WindowDisplayAffinity">
            <summary>The display affinity setting. This setting specifies where the window's contents are can be displayed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowDisplayAffinity.WDA_NONE">
            <summary>The window's contents can be displayed anywhere.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowDisplayAffinity.WDA_MONITOR">
            <summary>The window's contents can only be displayed on a monitor.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.WindowPlacementFlags">
            <summary>Flags used by <see cref="F:Vanara.PInvoke.User32.WINDOWPLACEMENT.flags"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowPlacementFlags.WPF_SETMINPOSITION">
            <summary>
            The coordinates of the minimized window may be specified.
            <para>This flag must be specified if the coordinates are set in the ptMinPosition member.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowPlacementFlags.WPF_RESTORETOMAXIMIZED">
            <summary>
            The restored window will be maximized, regardless of whether it was maximized before it was minimized. This setting is only
            valid the next time the window is restored. It does not change the default restoration behavior.
            <para>This flag is only valid when the SW_SHOWMINIMIZED value is specified for the showCmd member.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WindowPlacementFlags.WPF_ASYNCWINDOWPLACEMENT">
            <summary>
            If the calling thread and the thread that owns the window are attached to different input queues, the system posts the
            request to the thread that owns the window. This prevents the calling thread from blocking its execution while other threads
            process the request.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.AdjustWindowRect(Vanara.PInvoke.RECT@,Vanara.PInvoke.User32.WindowStyles,System.Boolean)">
            <summary>
            <para>
            Calculates the required size of the window rectangle, based on the desired client-rectangle size. The window rectangle can then
            be passed to the CreateWindow function to create a window whose client area is the desired size.
            </para>
            <para>To specify an extended window style, use the AdjustWindowRectEx function.</para>
            </summary>
            <param name="lpRect">
            <para>Type: <c>LPRECT</c></para>
            <para>
            A pointer to a RECT structure that contains the coordinates of the top-left and bottom-right corners of the desired client area.
            When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to
            accommodate the desired client area.
            </para>
            </param>
            <param name="dwStyle">
            <para>Type: <c>DWORD</c></para>
            <para>
            The window style of the window whose required size is to be calculated. Note that you cannot specify the <c>WS_OVERLAPPED</c> style.
            </para>
            </param>
            <param name="bMenu">
            <para>Type: <c>BOOL</c></para>
            <para>Indicates whether the window has a menu.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            A client rectangle is the smallest rectangle that completely encloses a client area. A window rectangle is the smallest rectangle
            that completely encloses the window, which includes the client area and the nonclient area.
            </para>
            <para>The <c>AdjustWindowRect</c> function does not add extra space when a menu bar wraps to two or more rows.</para>
            <para>
            The <c>AdjustWindowRect</c> function does not take the <c>WS_VSCROLL</c> or <c>WS_HSCROLL</c> styles into account. To account for
            the scroll bars, call the GetSystemMetrics function with <c>SM_CXVSCROLL</c> or <c>SM_CYHSCROLL</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.AdjustWindowRectEx(Vanara.PInvoke.RECT@,Vanara.PInvoke.User32.WindowStyles,System.Boolean,Vanara.PInvoke.User32.WindowStylesEx)">
            <summary>
            <para>
            Calculates the required size of the window rectangle, based on the desired size of the client rectangle. The window rectangle can
            then be passed to the CreateWindowEx function to create a window whose client area is the desired size.
            </para>
            </summary>
            <param name="lpRect">
            <para>Type: <c>LPRECT</c></para>
            <para>
            A pointer to a RECT structure that contains the coordinates of the top-left and bottom-right corners of the desired client area.
            When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to
            accommodate the desired client area.
            </para>
            </param>
            <param name="dwStyle">
            <para>Type: <c>DWORD</c></para>
            <para>
            The window style of the window whose required size is to be calculated. Note that you cannot specify the <c>WS_OVERLAPPED</c> style.
            </para>
            </param>
            <param name="bMenu">
            <para>Type: <c>BOOL</c></para>
            <para>Indicates whether the window has a menu.</para>
            </param>
            <param name="dwExStyle">
            <para>Type: <c>DWORD</c></para>
            <para>The extended window style of the window whose required size is to be calculated.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            A client rectangle is the smallest rectangle that completely encloses a client area. A window rectangle is the smallest rectangle
            that completely encloses the window, which includes the client area and the nonclient area.
            </para>
            <para>The <c>AdjustWindowRectEx</c> function does not add extra space when a menu bar wraps to two or more rows.</para>
            <para>
            The <c>AdjustWindowRectEx</c> function does not take the <c>WS_VSCROLL</c> or <c>WS_HSCROLL</c> styles into account. To account
            for the scroll bars, call the GetSystemMetrics function with <c>SM_CXVSCROLL</c> or <c>SM_CYHSCROLL</c>.
            </para>
            <para>
            This API is not DPI aware, and should not be used if the calling thread is per-monitor DPI aware. For the DPI-aware version of
            this API, see AdjustWindowsRectExForDPI. For more information on DPI awareness, see the Windows High DPI documentation.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.AllowSetForegroundWindow(System.UInt32)">
            <summary>
            <para>
            Enables the specified process to set the foreground window using the SetForegroundWindow function. The calling process must
            already be able to set the foreground window. For more information, see Remarks later in this topic.
            </para>
            </summary>
            <param name="dwProcessId">
            <para>Type: <c>DWORD</c></para>
            <para>
            The identifier of the process that will be enabled to set the foreground window. If this parameter is <c>ASFW_ANY</c>, all
            processes will be enabled to set the foreground window.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>
            If the function fails, the return value is zero. The function will fail if the calling process cannot set the foreground window.
            To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            The system restricts which processes can set the foreground window. A process can set the foreground window only if one of the
            following conditions is true:
            </para>
            <list type="bullet">
            <item>
            <term>The process is the foreground process.</term>
            </item>
            <item>
            <term>The process was started by the foreground process.</term>
            </item>
            <item>
            <term>The process received the last input event.</term>
            </item>
            <item>
            <term>There is no foreground process.</term>
            </item>
            <item>
            <term>The foreground process is being debugged.</term>
            </item>
            <item>
            <term>The foreground is not locked (see LockSetForegroundWindow).</term>
            </item>
            <item>
            <term>The foreground lock time-out has expired (see <c>SPI_GETFOREGROUNDLOCKTIMEOUT</c> in SystemParametersInfo).</term>
            </item>
            <item>
            <term>No menus are active.</term>
            </item>
            </list>
            <para>
            A process that can set the foreground window can enable another process to set the foreground window by calling
            <c>AllowSetForegroundWindow</c>. The process specified by dwProcessId loses the ability to set the foreground window the next
            time the user generates input, unless the input is directed at that process, or the next time a process calls
            <c>AllowSetForegroundWindow</c>, unless that process is specified.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.AnimateWindow(Vanara.PInvoke.HWND,System.UInt32,System.UInt32)">
            <summary>
            <para>
            Enables you to produce special effects when showing or hiding windows. There are four types of animation: roll, slide, collapse
            or expand, and alpha-blended fade.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to animate. The calling thread must own this window.</para>
            </param>
            <param name="dwTime">
            <para>Type: <c>DWORD</c></para>
            <para>The time it takes to play the animation, in milliseconds. Typically, an animation takes 200 milliseconds to play.</para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>
            The type of animation. This parameter can be one or more of the following values. Note that, by default, these flags take effect
            when showing a window. To take effect when hiding a window, use <c>AW_HIDE</c> and a logical OR operator with the appropriate flags.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AW_ACTIVATE 0x00020000</term>
            <term>Activates the window. Do not use this value with AW_HIDE.</term>
            </item>
            <item>
            <term>AW_BLEND 0x00080000</term>
            <term>Uses a fade effect. This flag can be used only if hwnd is a top-level window.</term>
            </item>
            <item>
            <term>AW_CENTER 0x00000010</term>
            <term>
            Makes the window appear to collapse inward if AW_HIDE is used or expand outward if the AW_HIDE is not used. The various direction
            flags have no effect.
            </term>
            </item>
            <item>
            <term>AW_HIDE 0x00010000</term>
            <term>Hides the window. By default, the window is shown.</term>
            </item>
            <item>
            <term>AW_HOR_POSITIVE 0x00000001</term>
            <term>
            Animates the window from left to right. This flag can be used with roll or slide animation. It is ignored when used with
            AW_CENTER or AW_BLEND.
            </term>
            </item>
            <item>
            <term>AW_HOR_NEGATIVE 0x00000002</term>
            <term>
            Animates the window from right to left. This flag can be used with roll or slide animation. It is ignored when used with
            AW_CENTER or AW_BLEND.
            </term>
            </item>
            <item>
            <term>AW_SLIDE 0x00040000</term>
            <term>Uses slide animation. By default, roll animation is used. This flag is ignored when used with AW_CENTER.</term>
            </item>
            <item>
            <term>AW_VER_POSITIVE 0x00000004</term>
            <term>
            Animates the window from top to bottom. This flag can be used with roll or slide animation. It is ignored when used with
            AW_CENTER or AW_BLEND.
            </term>
            </item>
            <item>
            <term>AW_VER_NEGATIVE 0x00000008</term>
            <term>
            Animates the window from bottom to top. This flag can be used with roll or slide animation. It is ignored when used with
            AW_CENTER or AW_BLEND.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. The function will fail in the following situations:</para>
            <list type="bullet">
            <item>
            <term>If the window is already visible and you are trying to show the window.</term>
            </item>
            <item>
            <term>If the window is already hidden and you are trying to hide the window.</term>
            </item>
            <item>
            <term>If there is no direction specified for the slide or roll animation.</term>
            </item>
            <item>
            <term>When trying to animate a child window with <c>AW_BLEND</c>.</term>
            </item>
            <item>
            <term>If the thread does not own the window. Note that, in this case, <c>AnimateWindow</c> fails but GetLastError returns <c>ERROR_SUCCESS</c>.</term>
            </item>
            </list>
            <para>To get extended error information, call the GetLastError function.</para>
            </returns>
            <remarks>
            <para>To show or hide a window without special effects, use ShowWindow.</para>
            <para>
            When using slide or roll animation, you must specify the direction. It can be either <c>AW_HOR_POSITIVE</c>,
            <c>AW_HOR_NEGATIVE</c>, AW_VER_POSITIVE, or AW_VER_NEGATIVE.
            </para>
            <para>
            You can combine <c>AW_HOR_POSITIVE</c> or <c>AW_HOR_NEGATIVE</c> with <c>AW_VER_POSITIVE</c> or <c>AW_VER_NEGATIVE</c> to animate
            a window diagonally.
            </para>
            <para>
            The window procedures for the window and its child windows should handle any WM_PRINT or WM_PRINTCLIENT messages. Dialog boxes,
            controls, and common controls already handle <c>WM_PRINTCLIENT</c>. The default window procedure already handles <c>WM_PRINT</c>.
            </para>
            <para>If a child window is displayed partially clipped, when it is animated it will have holes where it is clipped.</para>
            <para><c>AnimateWindow</c> supports RTL windows.</para>
            <para>Avoid animating a window that has a drop shadow because it produces visually distracting, jerky animations.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.AnyPopup">
            <summary>
            <para>
            Indicates whether an owned, visible, top-level pop-up, or overlapped window exists on the screen. The function searches the
            entire screen, not just the calling application's client area.
            </para>
            <para>This function is provided only for compatibility with 16-bit versions of Windows. It is generally not useful.</para>
            </summary>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If a pop-up window exists, the return value is nonzero, even if the pop-up window is completely covered by other windows.</para>
            <para>If a pop-up window does not exist, the return value is zero.</para>
            </returns>
            <remarks>
            <para>This function does not detect unowned pop-up windows or windows that do not have the <c>WS_VISIBLE</c> style bit set.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ArrangeIconicWindows(Vanara.PInvoke.HWND)">
            <summary>
            <para>Arranges all the minimized (iconic) child windows of the specified parent window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the parent window.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>UINT</c></c></para>
            <para>If the function succeeds, the return value is the height of one row of icons.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            An application that maintains its own minimized child windows can use the <c>ArrangeIconicWindows</c> function to arrange icons
            in a parent window. This function can also arrange icons on the desktop. To retrieve the window handle to the desktop window, use
            the GetDesktopWindow function.
            </para>
            <para>
            An application sends the WM_MDIICONARRANGE message to the multiple-document interface (MDI) client window to prompt the client
            window to arrange its minimized MDI child windows.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.BeginDeferWindowPos(System.Int32)">
            <summary>
            <para>Allocates memory for a multiple-window- position structure and returns the handle to the structure.</para>
            </summary>
            <param name="nNumWindows">
            <para>Type: <c>int</c></para>
            <para>
            The initial number of windows for which to store position information. The DeferWindowPos function increases the size of the
            structure, if necessary.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HDWP</c></c></para>
            <para>
            If the function succeeds, the return value identifies the multiple-window-position structure. If insufficient system resources
            are available to allocate the structure, the return value is <c>NULL</c>. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>The multiple-window-position structure is an internal structure; an application cannot access it directly.</para>
            <para>
            DeferWindowPos fills the multiple-window-position structure with information about the target position for one or more windows
            about to be moved. The EndDeferWindowPos function accepts the handle to this structure and repositions the windows by using the
            information stored in the structure.
            </para>
            <para>
            If any of the windows in the multiple-window- position structure have the <c>SWP_HIDEWINDOW</c> or <c>SWP_SHOWWINDOW</c> flag
            set, none of the windows are repositioned.
            </para>
            <para>
            If the system must increase the size of the multiple-window- position structure beyond the initial size specified by the
            nNumWindows parameter but cannot allocate enough memory to do so, the system fails the entire window positioning sequence (
            <c>BeginDeferWindowPos</c>, DeferWindowPos, and EndDeferWindowPos). By specifying the maximum size needed, an application can
            detect and process failure early in the process.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.BringWindowToTop(Vanara.PInvoke.HWND)">
            <summary>
            <para>
            Brings the specified window to the top of the Z order. If the window is a top-level window, it is activated. If the window is a
            child window, the top-level parent window associated with the child window is activated.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to bring to the top of the Z order.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>Use the <c>BringWindowToTop</c> function to uncover any window that is partially or completely obscured by other windows.</para>
            <para>
            Calling this function is similar to calling the SetWindowPos function to change a window's position in the Z order.
            <c>BringWindowToTop</c> does not make a window a top-level window.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CalculatePopupWindowPosition(Vanara.PInvoke.POINT@,Vanara.PInvoke.SIZE@,Vanara.PInvoke.User32.TrackPopupMenuFlags,Vanara.PInvoke.PRECT,Vanara.PInvoke.RECT@)">
            <summary>
            <para>
            Calculates an appropriate pop-up window position using the specified anchor point, pop-up window size, flags, and the optional
            exclude rectangle. When the specified pop-up window size is smaller than the desktop window size, use the
            <c>CalculatePopupWindowPosition</c> function to ensure that the pop-up window is fully visible on the desktop window, regardless
            of the specified anchor point.
            </para>
            </summary>
            <param name="anchorPoint">
            <para>Type: <c>const POINT*</c></para>
            <para>The specified anchor point.</para>
            </param>
            <param name="windowSize">
            <para>Type: <c>const SIZE*</c></para>
            <para>The specified window size.</para>
            </param>
            <param name="flags">
            <para>Type: <c>UINT</c></para>
            <para>
            Use one of the following flags to specify how the function positions the pop-up window horizontally and vertically. The flags are
            the same as the vertical and horizontal positioning flags of the TrackPopupMenuEx function.
            </para>
            <para>Use one of the following flags to specify how the function positions the pop-up window horizontally.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TPM_CENTERALIGN 0x0004L</term>
            <term>Centers pop-up window horizontally relative to the coordinate specified by the anchorPoint-&gt;x parameter.</term>
            </item>
            <item>
            <term>TPM_LEFTALIGN 0x0000L</term>
            <term>Positions the pop-up window so that its left edge is aligned with the coordinate specified by the anchorPoint-&gt;x parameter.</term>
            </item>
            <item>
            <term>TPM_RIGHTALIGN 0x0008L</term>
            <term>Positions the pop-up window so that its right edge is aligned with the coordinate specified by the anchorPoint-&gt;x parameter.</term>
            </item>
            </list>
            <para>Uses one of the following flags to specify how the function positions the pop-up window vertically.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TPM_BOTTOMALIGN 0x0020L</term>
            <term>
            Positions the pop-up window so that its bottom edge is aligned with the coordinate specified by the anchorPoint-&gt;y parameter.
            </term>
            </item>
            <item>
            <term>TPM_TOPALIGN 0x0000L</term>
            <term>Positions the pop-up window so that its top edge is aligned with the coordinate specified by the anchorPoint-&gt;y parameter.</term>
            </item>
            <item>
            <term>TPM_VCENTERALIGN 0x0010L</term>
            <term>Centers the pop-up window vertically relative to the coordinate specified by the anchorPoint-&gt;y parameter.</term>
            </item>
            </list>
            <para>Use one of the following flags to specify whether to accommodate horizontal or vertical alignment.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TPM_HORIZONTAL 0x0000L</term>
            <term>
            If the pop-up window cannot be shown at the specified location without overlapping the excluded rectangle, the system tries to
            accommodate the requested horizontal alignment before the requested vertical alignment.
            </term>
            </item>
            <item>
            <term>TPM_VERTICAL 0x0040L</term>
            <term>
            If the pop-up window cannot be shown at the specified location without overlapping the excluded rectangle, the system tries to
            accommodate the requested vertical alignment before the requested horizontal alignment.
            </term>
            </item>
            </list>
            <para>The following flag is available starting with Windows 7.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TPM_WORKAREA 0x10000L</term>
            <term>
            Restricts the pop-up window to within the work area. If this flag is not set, the pop-up window is restricted to the work area
            only if the input point is within the work area. For more information, see the rcWork and rcMonitor members of the MONITORINFO structure.
            </term>
            </item>
            </list>
            </param>
            <param name="excludeRect">
            <para>Type: <c>RECT*</c></para>
            <para>A pointer to a structure that specifies the exclude rectangle. It can be <c>NULL</c>.</para>
            </param>
            <param name="popupWindowPosition">
            <para>Type: <c>RECT*</c></para>
            <para>A pointer to a structure that specifies the pop-up window position.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>
            If the function succeeds, it returns <c>TRUE</c>; otherwise, it returns <c>FALSE</c>. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para><c>TPM_WORKAREA</c> is supported for the TrackPopupMenu and TrackPopupMenuEx functions.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CallWindowProc(Vanara.PInvoke.User32.WindowProc,Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>Passes message information to the specified window procedure.</summary>
            <param name="lpPrevWndFunc">
            <para>Type: <c>WNDPROC</c></para>
            <para>
            The previous window procedure. If this value is obtained by calling the GetWindowLong function with the nIndex parameter set to
            <c>GWL_WNDPROC</c> or <c>DWL_DLGPROC</c>, it is actually either the address of a window or dialog box procedure, or a special
            internal value meaningful only to <c>CallWindowProc</c>.
            </para>
            </param>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window procedure to receive the message.</para>
            </param>
            <param name="Msg">
            <para>Type: <c>UINT</c></para>
            <para>The message.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information. The contents of this parameter depend on the value of the Msg parameter.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information. The contents of this parameter depend on the value of the Msg parameter.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>LRESULT</c></c></para>
            <para>The return value specifies the result of the message processing and depends on the message sent.</para>
            </returns>
            <remarks>
            <para>
            Use the <c>CallWindowProc</c> function for window subclassing. Usually, all windows with the same class share one window
            procedure. A subclass is a window or set of windows with the same class whose messages are intercepted and processed by another
            window procedure (or procedures) before being passed to the window procedure of the class.
            </para>
            <para>
            The SetWindowLong function creates the subclass by changing the window procedure associated with a particular window, causing the
            system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the
            new window procedure to the previous window procedure by calling <c>CallWindowProc</c>. This allows the application to create a
            chain of window procedures.
            </para>
            <para>
            If <c>STRICT</c> is defined, the lpPrevWndFunc parameter has the data type <c>WNDPROC</c>. The <c>WNDPROC</c> type is declared as follows:
            </para>
            <para>
            If <c>STRICT</c> is not defined, the lpPrevWndFunc parameter has the data type <c>FARPROC</c>. The <c>FARPROC</c> type is
            declared as follows:
            </para>
            <para>
            In C, the <c>FARPROC</c> declaration indicates a callback function that has an unspecified parameter list. In C++, however, the
            empty parameter list in the declaration indicates that a function has no parameters. This subtle distinction can break careless
            code. Following is one way to handle this situation:
            </para>
            <para>
            For further information about functions declared with empty argument lists, refer to The C++ Programming Language, Second
            Edition, by Bjarne Stroustrup.
            </para>
            <para>
            The <c>CallWindowProc</c> function handles Unicode-to-ANSI conversion. You cannot take advantage of this conversion if you call
            the window procedure directly.
            </para>
            <para>Examples</para>
            <para>For an example, see Subclassing a Window</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CallWindowProc(System.IntPtr,Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>Passes message information to the specified window procedure.</summary>
            <param name="lpPrevWndFunc">
            <para>Type: <c>WNDPROC</c></para>
            <para>
            The previous window procedure. If this value is obtained by calling the GetWindowLong function with the nIndex parameter set to
            <c>GWL_WNDPROC</c> or <c>DWL_DLGPROC</c>, it is actually either the address of a window or dialog box procedure, or a special
            internal value meaningful only to <c>CallWindowProc</c>.
            </para>
            </param>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window procedure to receive the message.</para>
            </param>
            <param name="Msg">
            <para>Type: <c>UINT</c></para>
            <para>The message.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information. The contents of this parameter depend on the value of the Msg parameter.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information. The contents of this parameter depend on the value of the Msg parameter.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>LRESULT</c></c></para>
            <para>The return value specifies the result of the message processing and depends on the message sent.</para>
            </returns>
            <remarks>
            <para>
            Use the <c>CallWindowProc</c> function for window subclassing. Usually, all windows with the same class share one window
            procedure. A subclass is a window or set of windows with the same class whose messages are intercepted and processed by another
            window procedure (or procedures) before being passed to the window procedure of the class.
            </para>
            <para>
            The SetWindowLong function creates the subclass by changing the window procedure associated with a particular window, causing the
            system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the
            new window procedure to the previous window procedure by calling <c>CallWindowProc</c>. This allows the application to create a
            chain of window procedures.
            </para>
            <para>
            If <c>STRICT</c> is defined, the lpPrevWndFunc parameter has the data type <c>WNDPROC</c>. The <c>WNDPROC</c> type is declared as follows:
            </para>
            <para>
            If <c>STRICT</c> is not defined, the lpPrevWndFunc parameter has the data type <c>FARPROC</c>. The <c>FARPROC</c> type is
            declared as follows:
            </para>
            <para>
            In C, the <c>FARPROC</c> declaration indicates a callback function that has an unspecified parameter list. In C++, however, the
            empty parameter list in the declaration indicates that a function has no parameters. This subtle distinction can break careless
            code. Following is one way to handle this situation:
            </para>
            <para>
            For further information about functions declared with empty argument lists, refer to The C++ Programming Language, Second
            Edition, by Bjarne Stroustrup.
            </para>
            <para>
            The <c>CallWindowProc</c> function handles Unicode-to-ANSI conversion. You cannot take advantage of this conversion if you call
            the window procedure directly.
            </para>
            <para>Examples</para>
            <para>For an example, see Subclassing a Window</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CascadeWindows(Vanara.PInvoke.HWND,System.UInt32,Vanara.PInvoke.RECT@,System.UInt32,Vanara.PInvoke.HWND[])">
            <summary>
            <para>Cascades the specified child windows of the specified parent window.</para>
            </summary>
            <param name="hwndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the parent window. If this parameter is <c>NULL</c>, the desktop window is assumed.</para>
            </param>
            <param name="wHow">
            <para>Type: <c>UINT</c></para>
            <para>A cascade flag. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MDITILE_SKIPDISABLED 0x0002</term>
            <term>Prevents disabled MDI child windows from being cascaded.</term>
            </item>
            <item>
            <term>MDITILE_ZORDER 0x0004</term>
            <term>
            Arranges the windows in Z order. If this value is not specified, the windows are arranged using the order specified in the lpKids array.
            </term>
            </item>
            </list>
            </param>
            <param name="lpRect">
            <para>Type: <c>const RECT*</c></para>
            <para>
            A pointer to a structure that specifies the rectangular area, in client coordinates, within which the windows are arranged. This
            parameter can be <c>NULL</c>, in which case the client area of the parent window is used.
            </para>
            </param>
            <param name="cKids">
            <para>Type: <c>UINT</c></para>
            <para>The number of elements in the array specified by the lpKids parameter. This parameter is ignored if lpKids is <c>NULL</c>.</para>
            </param>
            <param name="lpKids">
            <para>Type: <c>const HWND*</c></para>
            <para>
            An array of handles to the child windows to arrange. If a specified child window is a top-level window with the style
            <c>WS_EX_TOPMOST</c> or <c>WS_EX_TOOLWINDOW</c>, the child window is not arranged. If this parameter is <c>NULL</c>, all child
            windows of the specified parent window (or of the desktop window) are arranged.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>WORD</c></c></para>
            <para>If the function succeeds, the return value is the number of windows arranged.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            By default, <c>CascadeWindows</c> arranges the windows in the order provided by the lpKids array, but preserves the Z-Order. If
            you specify the <c>MDITILE_ZORDER</c> flag, <c>CascadeWindows</c> arranges the windows in Z order.
            </para>
            <para>Calling <c>CascadeWindows</c> causes all maximized windows to be restored to their previous size.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ChangeWindowMessageFilter(System.UInt32,Vanara.PInvoke.User32.MessageFilterFlag)">
            <summary>
            <para>
            [Using the <c>ChangeWindowMessageFilter</c> function is not recommended, as it has process-wide scope. Instead, use the
            ChangeWindowMessageFilterEx function to control access to specific windows as needed. <c>ChangeWindowMessageFilter</c> may not be
            supported in future versions of Windows.]
            </para>
            <para>Adds or removes a message from the User Interface Privilege Isolation (UIPI) message filter.</para>
            </summary>
            <param name="message">
            <para>Type: <c>UINT</c></para>
            <para>The message to add to or remove from the filter.</para>
            </param>
            <param name="dwFlag">
            <para>Type: <c>DWORD</c></para>
            <para>The action to be performed. One of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MSGFLT_ADD 1</term>
            <term>Adds the message to the filter. This has the effect of allowing the message to be received.</term>
            </item>
            <item>
            <term>MSGFLT_REMOVE 2</term>
            <term>Removes the message from the filter. This has the effect of blocking the message.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para><c>TRUE</c> if successful; otherwise, <c>FALSE</c>. To get extended error information, call GetLastError.</para>
            <para>
            <c>Note</c> A message can be successfully removed from the filter, but that is not a guarantee that the message will be blocked.
            See the Remarks section for more details.
            </para>
            </returns>
            <remarks>
            <para>
            UIPI is a security feature that prevents messages from being received from a lower integrity level sender. All such messages with
            a value above <c>WM_USER</c> are blocked by default. The filter, somewhat contrary to intuition, is a list of messages that are
            allowed through. Therefore, adding a message to the filter allows that message to be received from a lower integrity sender,
            while removing a message blocks that message from being received.
            </para>
            <para>
            Certain messages with a value less than <c>WM_USER</c> are required to pass through the filter regardless of the filter setting.
            You can call this function to remove one of those messages from the filter and it will return <c>TRUE</c>. However, the message
            will still be received by the calling process.
            </para>
            <para>
            Processes at or below <c>SECURITY_MANDATORY_LOW_RID</c> are not allowed to change the filter. If those processes call this
            function, it will fail.
            </para>
            <para>For more information on integrity levels, see Understanding and Working in Protected Mode Internet Explorer.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ChangeWindowMessageFilterEx(Vanara.PInvoke.HWND,System.UInt32,Vanara.PInvoke.User32.MessageFilterExAction,Vanara.PInvoke.User32.CHANGEFILTERSTRUCT@)">
            <summary>
            <para>Modifies the User Interface Privilege Isolation (UIPI) message filter for a specified window.</para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose UIPI message filter is to be modified.</para>
            </param>
            <param name="message">
            <para>Type: <c>UINT</c></para>
            <para>The message that the message filter allows through or blocks.</para>
            </param>
            <param name="action">
            <para>Type: <c>DWORD</c></para>
            <para>The action to be performed, and can take one of the following values:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MSGFLT_ALLOW 1</term>
            <term>
            Allows the message through the filter. This enables the message to be received by hWnd, regardless of the source of the message,
            even it comes from a lower privileged process.
            </term>
            </item>
            <item>
            <term>MSGFLT_DISALLOW 2</term>
            <term>
            Blocks the message to be delivered to hWnd if it comes from a lower privileged process, unless the message is allowed
            process-wide by using the ChangeWindowMessageFilter function or globally.
            </term>
            </item>
            <item>
            <term>MSGFLT_RESET 0</term>
            <term>
            Resets the window message filter for hWnd to the default. Any message allowed globally or process-wide will get through, but any
            message not included in those two categories, and which comes from a lower privileged process, will be blocked.
            </term>
            </item>
            </list>
            </param>
            <param name="pChangeFilterStruct">
            <para>Type: <c>PCHANGEFILTERSTRUCT</c></para>
            <para>Optional pointer to a CHANGEFILTERSTRUCT structure.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>
            If the function succeeds, it returns <c>TRUE</c>; otherwise, it returns <c>FALSE</c>. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            UIPI is a security feature that prevents messages from being received from a lower-integrity-level sender. You can use this
            function to allow specific messages to be delivered to a window even if the message originates from a process at a lower
            integrity level. Unlike the ChangeWindowMessageFilter function, which controls the process message filter, the
            <c>ChangeWindowMessageFilterEx</c> function controls the window message filter.
            </para>
            <para>
            An application may use the ChangeWindowMessageFilter function to allow or block a message in a process-wide manner. If the
            message is allowed by either the process message filter or the window message filter, it will be delivered to the window.
            </para>
            <para>
            Note that processes at or below <c>SECURITY_MANDATORY_LOW_RID</c> are not allowed to change the message filter. If those
            processes call this function, it will fail and generate the extended error code, <c>ERROR_ACCESS_DENIED</c>.
            </para>
            <para>
            Certain messages whose value is smaller than <c>WM_USER</c> are required to be passed through the filter, regardless of the
            filter setting. There will be no effect when you attempt to use this function to allow or block such messages.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ChildWindowFromPoint(Vanara.PInvoke.HWND,Vanara.PInvoke.POINT)">
            <summary>
            <para>
            Determines which, if any, of the child windows belonging to a parent window contains the specified point. The search is
            restricted to immediate child windows. Grandchildren, and deeper descendant windows are not searched.
            </para>
            <para>To skip certain child windows, use the ChildWindowFromPointEx function.</para>
            </summary>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the parent window.</para>
            </param>
            <param name="Point">
            <para>Type: <c>POINT</c></para>
            <para>A structure that defines the client coordinates, relative to hWndParent, of the point to be checked.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>
            The return value is a handle to the child window that contains the point, even if the child window is hidden or disabled. If the
            point lies outside the parent window, the return value is <c>NULL</c>. If the point is within the parent window but not within
            any child window, the return value is a handle to the parent window.
            </para>
            </returns>
            <remarks>
            <para>
            The system maintains an internal list, containing the handles of the child windows associated with a parent window. The order of
            the handles in the list depends on the Z order of the child windows. If more than one child window contains the specified point,
            the system returns a handle to the first window in the list that contains the point.
            </para>
            <para>
            <c>ChildWindowFromPoint</c> treats an <c>HTTRANSPARENT</c> area of a standard control the same as other parts of the control. In
            contrast, RealChildWindowFromPoint treats an <c>HTTRANSPARENT</c> area differently; it returns the child window behind a
            transparent area of a control. For example, if the point is in a transparent area of a groupbox, <c>ChildWindowFromPoint</c>
            returns the groupbox while <c>RealChildWindowFromPoint</c> returns the child window behind the groupbox. However, both APIs
            return a static field, even though it, too, returns <c>HTTRANSPARENT</c>.
            </para>
            <para>Examples</para>
            <para>For an example, see "Creating a Combo Box Toolbar" in Using Combo Boxes.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ChildWindowFromPointEx(Vanara.PInvoke.HWND,Vanara.PInvoke.POINT,Vanara.PInvoke.User32.ChildWindowSkipOptions)">
            <summary>
            <para>
            Determines which, if any, of the child windows belonging to the specified parent window contains the specified point. The
            function can ignore invisible, disabled, and transparent child windows. The search is restricted to immediate child windows.
            Grandchildren and deeper descendants are not searched.
            </para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the parent window.</para>
            </param>
            <param name="pt">
            <para>Type: <c>POINT</c></para>
            <para>A structure that defines the client coordinates (relative to hwndParent) of the point to be checked.</para>
            </param>
            <param name="flags">
            <para>Type: <c>UINT</c></para>
            <para>The child windows to be skipped. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>CWP_ALL 0x0000</term>
            <term>Does not skip any child windows</term>
            </item>
            <item>
            <term>CWP_SKIPDISABLED 0x0002</term>
            <term>Skips disabled child windows</term>
            </item>
            <item>
            <term>CWP_SKIPINVISIBLE 0x0001</term>
            <term>Skips invisible child windows</term>
            </item>
            <item>
            <term>CWP_SKIPTRANSPARENT 0x0004</term>
            <term>Skips transparent child windows</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>
            The return value is a handle to the first child window that contains the point and meets the criteria specified by uFlags. If the
            point is within the parent window but not within any child window that meets the criteria, the return value is a handle to the
            parent window. If the point lies outside the parent window or if the function fails, the return value is <c>NULL</c>.
            </para>
            </returns>
            <remarks>
            <para>
            The system maintains an internal list that contains the handles of the child windows associated with a parent window. The order
            of the handles in the list depends on the Z order of the child windows. If more than one child window contains the specified
            point, the system returns a handle to the first window in the list that contains the point and meets the criteria specified by uFlags.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CloseWindow(Vanara.PInvoke.HWND)">
            <summary>
            <para>Minimizes (but does not destroy) the specified window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be minimized.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>To destroy a window, an application must use the DestroyWindow function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateWindow(System.String,System.String,Vanara.PInvoke.User32.WindowStyles,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.HWND,Vanara.PInvoke.HMENU,Vanara.PInvoke.HINSTANCE,System.IntPtr)">
            <summary>
            <para>Creates an overlapped, pop-up, or child window. It specifies the window class, window title, window style, and (optionally) the initial position and size of the window. The function also specifies the window's parent or owner, if any, and the window's menu.</para>
            <para>To use extended window styles in addition to the styles supported by <c>CreateWindow</c>, use the CreateWindowEx function.</para>
            </summary>
            <param name="lpClassName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>A <c>null</c>-terminated string or a class atom created by a previous call to the RegisterClass or RegisterClassEx function. The atom must be in the low-order word of lpClassName; the high-order word must be zero. If lpClassName is a string, it specifies the window class name. The class name can be any name registered with <c>RegisterClass</c> or <c>RegisterClassEx</c>, provided that the module that registers the class is also the module that creates the window. The class name can also be any of the predefined system class names. For a list of system class names, see the Remarks section.</para>
            </param>
            <param name="lpWindowName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The window name. If the window style specifies a title bar, the window title pointed to by lpWindowName is displayed in the title bar. When using <c>CreateWindow</c> to create controls, such as buttons, check boxes, and static controls, use lpWindowName to specify the text of the control. When creating a static control with the <c>SS_ICON</c> style, use lpWindowName to specify the icon name or identifier. To specify an identifier, use the syntax "#num".</para>
            </param>
            <param name="dwStyle">
            <para>Type: <c>DWORD</c></para>
            <para>The style of the window being created. This parameter can be a combination of the window style values, plus the control styles indicated in the Remarks section.</para>
            </param>
            <param name="x">
            <para>Type: <c>int</c></para>
            <para>The initial horizontal position of the window. For an overlapped or pop-up window, the x parameter is the initial x-coordinate of the window's upper-left corner, in screen coordinates. For a child window, x is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent window's client area. If this parameter is set to <c>CW_USEDEFAULT</c>, the system selects the default position for the window's upper-left corner and ignores the y parameter. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if it is specified for a pop-up or child window, the x and y parameters are set to zero.</para>
            </param>
            <param name="y">
            <para>Type: <c>int</c></para>
            <para>The initial vertical position of the window. For an overlapped or pop-up window, the y parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates. For a child window, y is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left corner of the parent window's client area. For a list box, y is the initial y-coordinate of the upper-left corner of the list box's client area relative to the upper-left corner of the parent window's client area.</para>
            <para>If an overlapped window is created with the <c>WS_VISIBLE</c> style bit set and the x parameter is set to <c>CW_USEDEFAULT</c>, then the y parameter determines how the window is shown. If the y parameter is <c>CW_USEDEFAULT</c>, then the window manager calls ShowWindow with the <c>SW_SHOW</c> flag after the window has been created. If the y parameter is some other value, then the window manager calls <c>ShowWindow</c> with that value as the nCmdShow parameter.</para>
            </param>
            <param name="nWidth">
            <para>Type: <c>int</c></para>
            <para>The width, in device units, of the window. For overlapped windows, nWidth is either the window's width, in screen coordinates, or <c>CW_USEDEFAULT</c>. If nWidth is <c>CW_USEDEFAULT</c>, the system selects a default width and height for the window; the default width extends from the initial x-coordinate to the right edge of the screen, and the default height extends from the initial y-coordinate to the top of the icon area. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if <c>CW_USEDEFAULT</c> is specified for a pop-up or child window, nWidth and nHeight are set to zero.</para>
            </param>
            <param name="nHeight">
            <para>Type: <c>int</c></para>
            <para>The height, in device units, of the window. For overlapped windows, nHeight is the window's height, in screen coordinates. If nWidth is set to <c>CW_USEDEFAULT</c>, the system ignores nHeight.</para>
            </param>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid window handle. This parameter is optional for pop-up windows.</para>
            <para>To create a message-only window, supply <c>HWND_MESSAGE</c> or a handle to an existing message-only window.</para>
            </param>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>A handle to a menu, or specifies a child-window identifier depending on the window style. For an overlapped or pop-up window, hMenu identifies the menu to be used with the window; it can be <c>NULL</c> if the class menu is to be used. For a child window, hMenu specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The application determines the child-window identifier; it must be unique for all child windows with the same parent window.</para>
            </param>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to the instance of the module to be associated with the window.</para>
            </param>
            <param name="lpParam">
            <para>Type: <c>LPVOID</c></para>
            <para>A pointer to a value to be passed to the window through the CREATESTRUCT structure (<c>lpCreateParams</c> member) pointed to by the lParam param of the WM_CREATE message. This message is sent to the created window by this function before it returns.</para>
            <para>If an application calls <c>CreateWindow</c> to create a MDI client window, lpParam should point to a CLIENTCREATESTRUCT structure. If an MDI client window calls <c>CreateWindow</c> to create an MDI child window, lpParam should point to a MDICREATESTRUCT structure. lpParam may be <c>NULL</c> if no additional data is needed.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>If the function succeeds, the return value is a handle to the new window.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            <para>This function typically fails for one of the following reasons:</para>
            <list type="bullet">
            <item>
            <term>an invalid parameter value</term>
            </item>
            <item>
            <term>the system class was registered by a different module</term>
            </item>
            <item>
            <term>The <c>WH_CBT</c> hook is installed and returns a failure code</term>
            </item>
            <item>
            <term>if one of the controls in the dialog template is not registered, or its window window procedure fails WM_CREATE or WM_NCCREATE</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Before returning, <c>CreateWindow</c> sends a WM_CREATE message to the window procedure. For overlapped, pop-up, and child windows, <c>CreateWindow</c> sends <c>WM_CREATE</c>, WM_GETMINMAXINFO, and WM_NCCREATE messages to the window. The lParam parameter of the <c>WM_CREATE</c> message contains a pointer to a CREATESTRUCT structure. If the <c>WS_VISIBLE</c> style is specified, <c>CreateWindow</c> sends the window all the messages required to activate and show the window.</para>
            <para>If the created window is a child window, its default position is at the bottom of the Z-order. If the created window is a top-level window, its default position is at the top of the Z-order (but beneath all topmost windows unless the created window is itself topmost).</para>
            <para>For information on controlling whether the Taskbar displays a button for the created window, see Managing Taskbar Buttons.</para>
            <para>For information on removing a window, see the DestroyWindow function.</para>
            <para>The following predefined system classes can be specified in the lpClassName parameter. Note the corresponding control styles you can use in the dwStyle parameter.</para>
            <list type="table">
            <listheader>
            <term>System class</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>BUTTON</term>
            <term>Designates a small rectangular child window that represents a button the user can click to turn it on or off. Button controls can be used alone or in groups, and they can either be labeled or appear without text. Button controls typically change appearance when the user clicks them. For more information, see Buttons For a table of the button styles you can specify in the dwStyle parameter, see Button Styles.</term>
            </item>
            <item>
            <term>COMBOBOX</term>
            <term>Designates a control consisting of a list box and a selection field similar to an edit control. When using this style, an application should either display the list box at all times or enable a drop-down list box. If the list box is visible, typing characters into the selection field highlights the first list box entry that matches the characters typed. Conversely, selecting an item in the list box displays the selected text in the selection field. For more information, see Combo Boxes. For a table of the combo box styles you can specify in the dwStyle parameter, see Combo Box Styles.</term>
            </item>
            <item>
            <term>EDIT</term>
            <term>Designates a rectangular child window into which the user can type text from the keyboard. The user selects the control and gives it the keyboard focus by clicking it or moving to it by pressing the TAB key. The user can type text when the edit control displays a flashing caret; use the mouse to move the cursor, select characters to be replaced, or position the cursor for inserting characters; or use the BACKSPACE key to delete characters. For more information, see Edit Controls. For a table of the edit control styles you can specify in the dwStyle parameter, see Edit Control Styles.</term>
            </item>
            <item>
            <term>LISTBOX</term>
            <term>Designates a list of character strings. Specify this control whenever an application must present a list of names, such as file names, from which the user can choose. The user can select a string by clicking it. A selected string is highlighted, and a notification message is passed to the parent window. For more information, see List Boxes. For a table of the list box styles you can specify in the dwStyle parameter, see List Box Styles.</term>
            </item>
            <item>
            <term>MDICLIENT</term>
            <term>Designates an MDI client window. This window receives messages that control the MDI application's child windows. The recommended style bits are WS_CLIPCHILDREN and WS_CHILD. Specify the WS_HSCROLL and WS_VSCROLL styles to create an MDI client window that allows the user to scroll MDI child windows into view. For more information, see Multiple Document Interface.</term>
            </item>
            <item>
            <term>RichEdit</term>
            <term>Designates a Microsoft Rich Edit 1.0 control. This window lets the user view and edit text with character and paragraph formatting, and can include embedded Component Object Model (COM) objects. For more information, see Rich Edit Controls. For a table of the rich edit control styles you can specify in the dwStyle parameter, see Rich Edit Control Styles.</term>
            </item>
            <item>
            <term>RICHEDIT_CLASS</term>
            <term>Designates a Microsoft Rich Edit 2.0 control. This controls let the user view and edit text with character and paragraph formatting, and can include embedded COM objects. For more information, see Rich Edit Controls. For a table of the rich edit control styles you can specify in the dwStyle parameter, see Rich Edit Control Styles.</term>
            </item>
            <item>
            <term>SCROLLBAR</term>
            <term>Designates a rectangle that contains a scroll box and has direction arrows at both ends. The scroll bar sends a notification message to its parent window whenever the user clicks the control. The parent window is responsible for updating the position of the scroll box, if necessary. For more information, see Scroll Bars. For a table of the scroll bar control styles you can specify in the dwStyle parameter, see Scroll Bar Control Styles.</term>
            </item>
            <item>
            <term>STATIC</term>
            <term>Designates a simple text field, box, or rectangle used to label, box, or separate other controls. Static controls take no input and provide no output. For more information, see Static Controls. For a table of the static control styles you can specify in the dwStyle parameter, see Static Control Styles.</term>
            </item>
            </list>
            <para><c>CreateWindow</c> is implemented as a call to the CreateWindowEx function, as shown below.</para>
            <para><code>#define CreateWindowA(lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)\ CreateWindowExA(0L, lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam) #define CreateWindowW(lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)\ CreateWindowExW(0L, lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam) #ifdef UNICODE #define CreateWindow CreateWindowW #else #define CreateWindow CreateWindowA #endif</code></para>
            <para>Examples</para>
            <para>For an example, see Using Window Classes.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateWindowEx(Vanara.PInvoke.User32.WindowStylesEx,System.String,System.String,Vanara.PInvoke.User32.WindowStyles,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.HWND,Vanara.PInvoke.HMENU,Vanara.PInvoke.HINSTANCE,System.IntPtr)">
            <summary>
            <para>
            Creates an overlapped, pop-up, or child window with an extended window style; otherwise, this function is identical to the
            CreateWindow function. For more information about creating a window and for full descriptions of the other parameters of
            <c>CreateWindowEx</c>, see <c>CreateWindow</c>.
            </para>
            </summary>
            <param name="dwExStyle">
            <para>Type: <c>DWORD</c></para>
            <para>The extended window style of the window being created. For a list of possible values,see Extended Window Styles.</para>
            </param>
            <param name="lpClassName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A <c>null</c>-terminated string or a class atom created by a previous call to the RegisterClass or RegisterClassEx function. The
            atom must be in the low-order word of lpClassName; the high-order word must be zero. If lpClassName is a string, it specifies the
            window class name. The class name can be any name registered with <c>RegisterClass</c> or <c>RegisterClassEx</c>, provided that
            the module that registers the class is also the module that creates the window. The class name can also be any of the predefined
            system class names.
            </para>
            </param>
            <param name="lpWindowName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The window name. If the window style specifies a title bar, the window title pointed to by lpWindowName is displayed in the title
            bar. When using CreateWindow to create controls, such as buttons, check boxes, and static controls, use lpWindowName to specify
            the text of the control. When creating a static control with the <c>SS_ICON</c> style, use lpWindowName to specify the icon name
            or identifier. To specify an identifier, use the syntax "#num".
            </para>
            </param>
            <param name="dwStyle">
            <para>Type: <c>DWORD</c></para>
            <para>
            The style of the window being created. This parameter can be a combination of the window style values, plus the control styles
            indicated in the Remarks section.
            </para>
            </param>
            <param name="X">
            <para>Type: <c>int</c></para>
            <para>
            The initial horizontal position of the window. For an overlapped or pop-up window, the x parameter is the initial x-coordinate of
            the window's upper-left corner, in screen coordinates. For a child window, x is the x-coordinate of the upper-left corner of the
            window relative to the upper-left corner of the parent window's client area. If x is set to <c>CW_USEDEFAULT</c>, the system
            selects the default position for the window's upper-left corner and ignores the y parameter. <c>CW_USEDEFAULT</c> is valid only
            for overlapped windows; if it is specified for a pop-up or child window, the x and y parameters are set to zero.
            </para>
            </param>
            <param name="Y">
            <para>Type: <c>int</c></para>
            <para>
            The initial vertical position of the window. For an overlapped or pop-up window, the y parameter is the initial y-coordinate of
            the window's upper-left corner, in screen coordinates. For a child window, y is the initial y-coordinate of the upper-left corner
            of the child window relative to the upper-left corner of the parent window's client area. For a list box y is the initial
            y-coordinate of the upper-left corner of the list box's client area relative to the upper-left corner of the parent window's
            client area.
            </para>
            <para>
            If an overlapped window is created with the <c>WS_VISIBLE</c> style bit set and the x parameter is set to <c>CW_USEDEFAULT</c>,
            then the y parameter determines how the window is shown. If the y parameter is <c>CW_USEDEFAULT</c>, then the window manager
            calls ShowWindow with the <c>SW_SHOW</c> flag after the window has been created. If the y parameter is some other value, then the
            window manager calls <c>ShowWindow</c> with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name="nWidth">
            <para>Type: <c>int</c></para>
            <para>
            The width, in device units, of the window. For overlapped windows, nWidth is the window's width, in screen coordinates, or
            <c>CW_USEDEFAULT</c>. If nWidth is <c>CW_USEDEFAULT</c>, the system selects a default width and height for the window; the
            default width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial
            y-coordinate to the top of the icon area. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if <c>CW_USEDEFAULT</c> is
            specified for a pop-up or child window, the nWidth and nHeight parameter are set to zero.
            </para>
            </param>
            <param name="nHeight">
            <para>Type: <c>int</c></para>
            <para>
            The height, in device units, of the window. For overlapped windows, nHeight is the window's height, in screen coordinates. If the
            nWidth parameter is set to <c>CW_USEDEFAULT</c>, the system ignores nHeight.
            </para>
            </param>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid
            window handle. This parameter is optional for pop-up windows.
            </para>
            <para>To create a message-only window, supply <c>HWND_MESSAGE</c> or a handle to an existing message-only window.</para>
            </param>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>
            A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window,
            hMenu identifies the menu to be used with the window; it can be <c>NULL</c> if the class menu is to be used. For a child window,
            hMenu specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The
            application determines the child-window identifier; it must be unique for all child windows with the same parent window.
            </para>
            </param>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to the instance of the module to be associated with the window.</para>
            </param>
            <param name="lpParam">
            <para>Type: <c>LPVOID</c></para>
            <para>
            Pointer to a value to be passed to the window through the CREATESTRUCT structure ( <c>lpCreateParams</c> member) pointed to by
            the lParam param of the <c>WM_CREATE</c> message. This message is sent to the created window by this function before it returns.
            </para>
            <para>
            If an application calls CreateWindow to create a MDI client window, lpParam should point to a CLIENTCREATESTRUCT structure. If an
            MDI client window calls <c>CreateWindow</c> to create an MDI child window, lpParam should point to a MDICREATESTRUCT structure.
            lpParam may be <c>NULL</c> if no additional data is needed.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>If the function succeeds, the return value is a handle to the new window.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            <para>This function typically fails for one of the following reasons:</para>
            <list type="bullet">
            <item>
            <term>an invalid parameter value</term>
            </item>
            <item>
            <term>the system class was registered by a different module</term>
            </item>
            <item>
            <term>The <c>WH_CBT</c> hook is installed and returns a failure code</term>
            </item>
            <item>
            <term>if one of the controls in the dialog template is not registered, or its window window procedure fails WM_CREATE or WM_NCCREATE</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>CreateWindowEx</c> function sends WM_NCCREATE, WM_NCCALCSIZE, and WM_CREATE messages to the window being created.</para>
            <para>
            If the created window is a child window, its default position is at the bottom of the Z-order. If the created window is a
            top-level window, its default position is at the top of the Z-order (but beneath all topmost windows unless the created window is
            itself topmost).
            </para>
            <para>For information on controlling whether the Taskbar displays a button for the created window, see Managing Taskbar Buttons.</para>
            <para>For information on removing a window, see the DestroyWindow function.</para>
            <para>
            The following predefined control classes can be specified in the lpClassName parameter. Note the corresponding control styles you
            can use in the dwStyle parameter.
            </para>
            <list type="table">
            <listheader>
            <term>Class</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>BUTTON</term>
            <term>
            Designates a small rectangular child window that represents a button the user can click to turn it on or off. Button controls can
            be used alone or in groups, and they can either be labeled or appear without text. Button controls typically change appearance
            when the user clicks them. For more information, see Buttons. For a table of the button styles you can specify in the dwStyle
            parameter, see Button Styles.
            </term>
            </item>
            <item>
            <term>COMBOBOX</term>
            <term>
            Designates a control consisting of a list box and a selection field similar to an edit control. When using this style, an
            application should either display the list box at all times or enable a drop-down list box. If the list box is visible, typing
            characters into the selection field highlights the first list box entry that matches the characters typed. Conversely, selecting
            an item in the list box displays the selected text in the selection field. For more information, see Combo Boxes. For a table of
            the combo box styles you can specify in the dwStyle parameter, see Combo Box Styles.
            </term>
            </item>
            <item>
            <term>EDIT</term>
            <term>
            Designates a rectangular child window into which the user can type text from the keyboard. The user selects the control and gives
            it the keyboard focus by clicking it or moving to it by pressing the TAB key. The user can type text when the edit control
            displays a flashing caret; use the mouse to move the cursor, select characters to be replaced, or position the cursor for
            inserting characters; or use the key to delete characters. For more information, see Edit Controls. For a table of the edit
            control styles you can specify in the dwStyle parameter, see Edit Control Styles.
            </term>
            </item>
            <item>
            <term>LISTBOX</term>
            <term>
            Designates a list of character strings. Specify this control whenever an application must present a list of names, such as
            filenames, from which the user can choose. The user can select a string by clicking it. A selected string is highlighted, and a
            notification message is passed to the parent window. For more information, see List Boxes. For a table of the list box styles you
            can specify in the dwStyle parameter, see List Box Styles.
            </term>
            </item>
            <item>
            <term>MDICLIENT</term>
            <term>
            Designates an MDI client window. This window receives messages that control the MDI application's child windows. The recommended
            style bits are WS_CLIPCHILDREN and WS_CHILD. Specify the WS_HSCROLL and WS_VSCROLL styles to create an MDI client window that
            allows the user to scroll MDI child windows into view. For more information, see Multiple Document Interface.
            </term>
            </item>
            <item>
            <term>RichEdit</term>
            <term>
            Designates a Microsoft Rich Edit 1.0 control. This window lets the user view and edit text with character and paragraph
            formatting, and can include embedded Component Object Model (COM) objects. For more information, see Rich Edit Controls. For a
            table of the rich edit control styles you can specify in the dwStyle parameter, see Rich Edit Control Styles.
            </term>
            </item>
            <item>
            <term>RICHEDIT_CLASS</term>
            <term>
            Designates a Microsoft Rich Edit 2.0 control. This controls let the user view and edit text with character and paragraph
            formatting, and can include embedded COM objects. For more information, see Rich Edit Controls. For a table of the rich edit
            control styles you can specify in the dwStyle parameter, see Rich Edit Control Styles.
            </term>
            </item>
            <item>
            <term>SCROLLBAR</term>
            <term>
            Designates a rectangle that contains a scroll box and has direction arrows at both ends. The scroll bar sends a notification
            message to its parent window whenever the user clicks the control. The parent window is responsible for updating the position of
            the scroll box, if necessary. For more information, see Scroll Bars. For a table of the scroll bar control styles you can specify
            in the dwStyle parameter, see Scroll Bar Control Styles.
            </term>
            </item>
            <item>
            <term>STATIC</term>
            <term>
            Designates a simple text field, box, or rectangle used to label, box, or separate other controls. Static controls take no input
            and provide no output. For more information, see Static Controls. For a table of the static control styles you can specify in the
            dwStyle parameter, see Static Control Styles.
            </term>
            </item>
            </list>
            <para>
            The <c>WS_EX_NOACTIVATE</c> value for dwExStyle prevents foreground activation by the system. To prevent queue activation when
            the user clicks on the window, you must process the WM_MOUSEACTIVATE message appropriately. To bring the window to the foreground
            or to activate it programmatically, use SetForegroundWindow or SetActiveWindow. Returning <c>FALSE</c> to WM_NCACTIVATE prevents
            the window from losing queue activation. However, the return value is ignored at activation time.
            </para>
            <para>
            With <c>WS_EX_COMPOSITED</c> set, all descendants of a window get bottom-to-top painting order using double-buffering.
            Bottom-to-top painting order allows a descendent window to have translucency (alpha) and transparency (color-key) effects, but
            only if the descendent window also has the <c>WS_EX_TRANSPARENT</c> bit set. Double-buffering allows the window and its
            descendents to be painted without flicker.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.CreateWindowEx(Vanara.PInvoke.User32.WindowStylesEx,System.IntPtr,System.String,Vanara.PInvoke.User32.WindowStyles,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.HWND,Vanara.PInvoke.HMENU,Vanara.PInvoke.HINSTANCE,System.IntPtr)">
            <summary>
            <para>
            Creates an overlapped, pop-up, or child window with an extended window style; otherwise, this function is identical to the
            CreateWindow function. For more information about creating a window and for full descriptions of the other parameters of
            <c>CreateWindowEx</c>, see <c>CreateWindow</c>.
            </para>
            </summary>
            <param name="dwExStyle">
            <para>Type: <c>DWORD</c></para>
            <para>The extended window style of the window being created. For a list of possible values,see Extended Window Styles.</para>
            </param>
            <param name="lpClassName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A <c>null</c>-terminated string or a class atom created by a previous call to the RegisterClass or RegisterClassEx function. The
            atom must be in the low-order word of lpClassName; the high-order word must be zero. If lpClassName is a string, it specifies the
            window class name. The class name can be any name registered with <c>RegisterClass</c> or <c>RegisterClassEx</c>, provided that
            the module that registers the class is also the module that creates the window. The class name can also be any of the predefined
            system class names.
            </para>
            </param>
            <param name="lpWindowName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The window name. If the window style specifies a title bar, the window title pointed to by lpWindowName is displayed in the title
            bar. When using CreateWindow to create controls, such as buttons, check boxes, and static controls, use lpWindowName to specify
            the text of the control. When creating a static control with the <c>SS_ICON</c> style, use lpWindowName to specify the icon name
            or identifier. To specify an identifier, use the syntax "#num".
            </para>
            </param>
            <param name="dwStyle">
            <para>Type: <c>DWORD</c></para>
            <para>
            The style of the window being created. This parameter can be a combination of the window style values, plus the control styles
            indicated in the Remarks section.
            </para>
            </param>
            <param name="X">
            <para>Type: <c>int</c></para>
            <para>
            The initial horizontal position of the window. For an overlapped or pop-up window, the x parameter is the initial x-coordinate of
            the window's upper-left corner, in screen coordinates. For a child window, x is the x-coordinate of the upper-left corner of the
            window relative to the upper-left corner of the parent window's client area. If x is set to <c>CW_USEDEFAULT</c>, the system
            selects the default position for the window's upper-left corner and ignores the y parameter. <c>CW_USEDEFAULT</c> is valid only
            for overlapped windows; if it is specified for a pop-up or child window, the x and y parameters are set to zero.
            </para>
            </param>
            <param name="Y">
            <para>Type: <c>int</c></para>
            <para>
            The initial vertical position of the window. For an overlapped or pop-up window, the y parameter is the initial y-coordinate of
            the window's upper-left corner, in screen coordinates. For a child window, y is the initial y-coordinate of the upper-left corner
            of the child window relative to the upper-left corner of the parent window's client area. For a list box y is the initial
            y-coordinate of the upper-left corner of the list box's client area relative to the upper-left corner of the parent window's
            client area.
            </para>
            <para>
            If an overlapped window is created with the <c>WS_VISIBLE</c> style bit set and the x parameter is set to <c>CW_USEDEFAULT</c>,
            then the y parameter determines how the window is shown. If the y parameter is <c>CW_USEDEFAULT</c>, then the window manager
            calls ShowWindow with the <c>SW_SHOW</c> flag after the window has been created. If the y parameter is some other value, then the
            window manager calls <c>ShowWindow</c> with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name="nWidth">
            <para>Type: <c>int</c></para>
            <para>
            The width, in device units, of the window. For overlapped windows, nWidth is the window's width, in screen coordinates, or
            <c>CW_USEDEFAULT</c>. If nWidth is <c>CW_USEDEFAULT</c>, the system selects a default width and height for the window; the
            default width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial
            y-coordinate to the top of the icon area. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if <c>CW_USEDEFAULT</c> is
            specified for a pop-up or child window, the nWidth and nHeight parameter are set to zero.
            </para>
            </param>
            <param name="nHeight">
            <para>Type: <c>int</c></para>
            <para>
            The height, in device units, of the window. For overlapped windows, nHeight is the window's height, in screen coordinates. If the
            nWidth parameter is set to <c>CW_USEDEFAULT</c>, the system ignores nHeight.
            </para>
            </param>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid
            window handle. This parameter is optional for pop-up windows.
            </para>
            <para>To create a message-only window, supply <c>HWND_MESSAGE</c> or a handle to an existing message-only window.</para>
            </param>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>
            A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window,
            hMenu identifies the menu to be used with the window; it can be <c>NULL</c> if the class menu is to be used. For a child window,
            hMenu specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The
            application determines the child-window identifier; it must be unique for all child windows with the same parent window.
            </para>
            </param>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to the instance of the module to be associated with the window.</para>
            </param>
            <param name="lpParam">
            <para>Type: <c>LPVOID</c></para>
            <para>
            Pointer to a value to be passed to the window through the CREATESTRUCT structure ( <c>lpCreateParams</c> member) pointed to by
            the lParam param of the <c>WM_CREATE</c> message. This message is sent to the created window by this function before it returns.
            </para>
            <para>
            If an application calls CreateWindow to create a MDI client window, lpParam should point to a CLIENTCREATESTRUCT structure. If an
            MDI client window calls <c>CreateWindow</c> to create an MDI child window, lpParam should point to a MDICREATESTRUCT structure.
            lpParam may be <c>NULL</c> if no additional data is needed.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>If the function succeeds, the return value is a handle to the new window.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            <para>This function typically fails for one of the following reasons:</para>
            <list type="bullet">
            <item>
            <term>an invalid parameter value</term>
            </item>
            <item>
            <term>the system class was registered by a different module</term>
            </item>
            <item>
            <term>The <c>WH_CBT</c> hook is installed and returns a failure code</term>
            </item>
            <item>
            <term>if one of the controls in the dialog template is not registered, or its window window procedure fails WM_CREATE or WM_NCCREATE</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>CreateWindowEx</c> function sends WM_NCCREATE, WM_NCCALCSIZE, and WM_CREATE messages to the window being created.</para>
            <para>
            If the created window is a child window, its default position is at the bottom of the Z-order. If the created window is a
            top-level window, its default position is at the top of the Z-order (but beneath all topmost windows unless the created window is
            itself topmost).
            </para>
            <para>For information on controlling whether the Taskbar displays a button for the created window, see Managing Taskbar Buttons.</para>
            <para>For information on removing a window, see the DestroyWindow function.</para>
            <para>
            The following predefined control classes can be specified in the lpClassName parameter. Note the corresponding control styles you
            can use in the dwStyle parameter.
            </para>
            <list type="table">
            <listheader>
            <term>Class</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>BUTTON</term>
            <term>
            Designates a small rectangular child window that represents a button the user can click to turn it on or off. Button controls can
            be used alone or in groups, and they can either be labeled or appear without text. Button controls typically change appearance
            when the user clicks them. For more information, see Buttons. For a table of the button styles you can specify in the dwStyle
            parameter, see Button Styles.
            </term>
            </item>
            <item>
            <term>COMBOBOX</term>
            <term>
            Designates a control consisting of a list box and a selection field similar to an edit control. When using this style, an
            application should either display the list box at all times or enable a drop-down list box. If the list box is visible, typing
            characters into the selection field highlights the first list box entry that matches the characters typed. Conversely, selecting
            an item in the list box displays the selected text in the selection field. For more information, see Combo Boxes. For a table of
            the combo box styles you can specify in the dwStyle parameter, see Combo Box Styles.
            </term>
            </item>
            <item>
            <term>EDIT</term>
            <term>
            Designates a rectangular child window into which the user can type text from the keyboard. The user selects the control and gives
            it the keyboard focus by clicking it or moving to it by pressing the TAB key. The user can type text when the edit control
            displays a flashing caret; use the mouse to move the cursor, select characters to be replaced, or position the cursor for
            inserting characters; or use the key to delete characters. For more information, see Edit Controls. For a table of the edit
            control styles you can specify in the dwStyle parameter, see Edit Control Styles.
            </term>
            </item>
            <item>
            <term>LISTBOX</term>
            <term>
            Designates a list of character strings. Specify this control whenever an application must present a list of names, such as
            filenames, from which the user can choose. The user can select a string by clicking it. A selected string is highlighted, and a
            notification message is passed to the parent window. For more information, see List Boxes. For a table of the list box styles you
            can specify in the dwStyle parameter, see List Box Styles.
            </term>
            </item>
            <item>
            <term>MDICLIENT</term>
            <term>
            Designates an MDI client window. This window receives messages that control the MDI application's child windows. The recommended
            style bits are WS_CLIPCHILDREN and WS_CHILD. Specify the WS_HSCROLL and WS_VSCROLL styles to create an MDI client window that
            allows the user to scroll MDI child windows into view. For more information, see Multiple Document Interface.
            </term>
            </item>
            <item>
            <term>RichEdit</term>
            <term>
            Designates a Microsoft Rich Edit 1.0 control. This window lets the user view and edit text with character and paragraph
            formatting, and can include embedded Component Object Model (COM) objects. For more information, see Rich Edit Controls. For a
            table of the rich edit control styles you can specify in the dwStyle parameter, see Rich Edit Control Styles.
            </term>
            </item>
            <item>
            <term>RICHEDIT_CLASS</term>
            <term>
            Designates a Microsoft Rich Edit 2.0 control. This controls let the user view and edit text with character and paragraph
            formatting, and can include embedded COM objects. For more information, see Rich Edit Controls. For a table of the rich edit
            control styles you can specify in the dwStyle parameter, see Rich Edit Control Styles.
            </term>
            </item>
            <item>
            <term>SCROLLBAR</term>
            <term>
            Designates a rectangle that contains a scroll box and has direction arrows at both ends. The scroll bar sends a notification
            message to its parent window whenever the user clicks the control. The parent window is responsible for updating the position of
            the scroll box, if necessary. For more information, see Scroll Bars. For a table of the scroll bar control styles you can specify
            in the dwStyle parameter, see Scroll Bar Control Styles.
            </term>
            </item>
            <item>
            <term>STATIC</term>
            <term>
            Designates a simple text field, box, or rectangle used to label, box, or separate other controls. Static controls take no input
            and provide no output. For more information, see Static Controls. For a table of the static control styles you can specify in the
            dwStyle parameter, see Static Control Styles.
            </term>
            </item>
            </list>
            <para>
            The <c>WS_EX_NOACTIVATE</c> value for dwExStyle prevents foreground activation by the system. To prevent queue activation when
            the user clicks on the window, you must process the WM_MOUSEACTIVATE message appropriately. To bring the window to the foreground
            or to activate it programmatically, use SetForegroundWindow or SetActiveWindow. Returning <c>FALSE</c> to WM_NCACTIVATE prevents
            the window from losing queue activation. However, the return value is ignored at activation time.
            </para>
            <para>
            With <c>WS_EX_COMPOSITED</c> set, all descendants of a window get bottom-to-top painting order using double-buffering.
            Bottom-to-top painting order allows a descendent window to have translucency (alpha) and transparency (color-key) effects, but
            only if the descendent window also has the <c>WS_EX_TRANSPARENT</c> bit set. Double-buffering allows the window and its
            descendents to be painted without flicker.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DeferWindowPos(Vanara.PInvoke.HDWP,Vanara.PInvoke.HWND,Vanara.PInvoke.HWND,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.User32.SetWindowPosFlags)">
            <summary>
            <para>
            Updates the specified multiple-window – position structure for the specified window. The function then returns a handle to the
            updated structure. The EndDeferWindowPos function uses the information in this structure to change the position and size of a
            number of windows simultaneously. The BeginDeferWindowPos function creates the structure.
            </para>
            </summary>
            <param name="hWinPosInfo">
            <para>Type: <c>HDWP</c></para>
            <para>
            A handle to a multiple-window – position structure that contains size and position information for one or more windows. This
            structure is returned by BeginDeferWindowPos or by the most recent call to <c>DeferWindowPos</c>.
            </para>
            </param>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window for which update information is stored in the structure. All windows in a multiple-window – position
            structure must have the same parent.
            </para>
            </param>
            <param name="hWndInsertAfter">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window that precedes the positioned window in the Z order. This parameter must be a window handle or one of the
            following values. This parameter is ignored if the <c>SWP_NOZORDER</c> flag is set in the uFlags parameter.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>HWND_BOTTOM ((HWND)1)</term>
            <term>
            Places the window at the bottom of the Z order. If the hWnd parameter identifies a topmost window, the window loses its topmost
            status and is placed at the bottom of all other windows.
            </term>
            </item>
            <item>
            <term>HWND_NOTOPMOST ((HWND)-2)</term>
            <term>
            Places the window above all non-topmost windows (that is, behind all topmost windows). This flag has no effect if the window is
            already a non-topmost window.
            </term>
            </item>
            <item>
            <term>HWND_TOP ((HWND)0)</term>
            <term>Places the window at the top of the Z order.</term>
            </item>
            <item>
            <term>HWND_TOPMOST ((HWND)-1)</term>
            <term>Places the window above all non-topmost windows. The window maintains its topmost position even when it is deactivated.</term>
            </item>
            </list>
            </param>
            <param name="x">
            <para>Type: <c>int</c></para>
            <para>The x-coordinate of the window's upper-left corner.</para>
            </param>
            <param name="y">
            <para>Type: <c>int</c></para>
            <para>The y-coordinate of the window's upper-left corner.</para>
            </param>
            <param name="cx">
            <para>Type: <c>int</c></para>
            <para>The window's new width, in pixels.</para>
            </param>
            <param name="cy">
            <para>Type: <c>int</c></para>
            <para>The window's new height, in pixels.</para>
            </param>
            <param name="uFlags">
            <para>Type: <c>UINT</c></para>
            <para>A combination of the following values that affect the size and position of the window.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SWP_DRAWFRAME 0x0020</term>
            <term>Draws a frame (defined in the window's class description) around the window.</term>
            </item>
            <item>
            <term>SWP_FRAMECHANGED 0x0020</term>
            <term>
            Sends a WM_NCCALCSIZE message to the window, even if the window's size is not being changed. If this flag is not specified,
            WM_NCCALCSIZE is sent only when the window's size is being changed.
            </term>
            </item>
            <item>
            <term>SWP_HIDEWINDOW 0x0080</term>
            <term>Hides the window.</term>
            </item>
            <item>
            <term>SWP_NOACTIVATE 0x0010</term>
            <term>
            Does not activate the window. If this flag is not set, the window is activated and moved to the top of either the topmost or
            non-topmost group (depending on the setting of the hWndInsertAfter parameter).
            </term>
            </item>
            <item>
            <term>SWP_NOCOPYBITS 0x0100</term>
            <term>
            Discards the entire contents of the client area. If this flag is not specified, the valid contents of the client area are saved
            and copied back into the client area after the window is sized or repositioned.
            </term>
            </item>
            <item>
            <term>SWP_NOMOVE 0x0002</term>
            <term>Retains the current position (ignores the x and y parameters).</term>
            </item>
            <item>
            <term>SWP_NOOWNERZORDER 0x0200</term>
            <term>Does not change the owner window's position in the Z order.</term>
            </item>
            <item>
            <term>SWP_NOREDRAW 0x0008</term>
            <term>
            Does not redraw changes. If this flag is set, no repainting of any kind occurs. This applies to the client area, the nonclient
            area (including the title bar and scroll bars), and any part of the parent window uncovered as a result of the window being
            moved. When this flag is set, the application must explicitly invalidate or redraw any parts of the window and parent window that
            need redrawing.
            </term>
            </item>
            <item>
            <term>SWP_NOREPOSITION 0x0200</term>
            <term>Same as the SWP_NOOWNERZORDER flag.</term>
            </item>
            <item>
            <term>SWP_NOSENDCHANGING 0x0400</term>
            <term>Prevents the window from receiving the WM_WINDOWPOSCHANGING message.</term>
            </item>
            <item>
            <term>SWP_NOSIZE 0x0001</term>
            <term>Retains the current size (ignores the cx and cy parameters).</term>
            </item>
            <item>
            <term>SWP_NOZORDER 0x0004</term>
            <term>Retains the current Z order (ignores the hWndInsertAfter parameter).</term>
            </item>
            <item>
            <term>SWP_SHOWWINDOW 0x0040</term>
            <term>Displays the window.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HDWP</c></c></para>
            <para>
            The return value identifies the updated multiple-window – position structure. The handle returned by this function may differ
            from the handle passed to the function. The new handle that this function returns should be passed during the next call to the
            <c>DeferWindowPos</c> or EndDeferWindowPos function.
            </para>
            <para>
            If insufficient system resources are available for the function to succeed, the return value is <c>NULL</c>. To get extended
            error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            If a call to <c>DeferWindowPos</c> fails, the application should abandon the window-positioning operation and not call EndDeferWindowPos.
            </para>
            <para>
            If <c>SWP_NOZORDER</c> is not specified, the system places the window identified by the hWnd parameter in the position following
            the window identified by the hWndInsertAfter parameter. If hWndInsertAfter is <c>NULL</c> or <c>HWND_TOP</c>, the system places
            the hWnd window at the top of the Z order. If hWndInsertAfter is set to <c>HWND_BOTTOM</c>, the system places the hWnd window at
            the bottom of the Z order.
            </para>
            <para>All coordinates for child windows are relative to the upper-left corner of the parent window's client area.</para>
            <para>
            A window can be made a topmost window either by setting hWndInsertAfter to the <c>HWND_TOPMOST</c> flag and ensuring that the
            <c>SWP_NOZORDER</c> flag is not set, or by setting the window's position in the Z order so that it is above any existing topmost
            windows. When a non-topmost window is made topmost, its owned windows are also made topmost. Its owners, however, are not changed.
            </para>
            <para>
            If neither the <c>SWP_NOACTIVATE</c> nor <c>SWP_NOZORDER</c> flag is specified (that is, when the application requests that a
            window be simultaneously activated and its position in the Z order changed), the value specified in hWndInsertAfter is used only
            in the following circumstances:
            </para>
            <list type="bullet">
            <item>
            <term>Neither the <c>HWND_TOPMOST</c> nor <c>HWND_NOTOPMOST</c> flag is specified in hWndInsertAfter.</term>
            </item>
            <item>
            <term>The window identified by hWnd is not the active window.</term>
            </item>
            </list>
            <para>
            An application cannot activate an inactive window without also bringing it to the top of the Z order. An application can change
            an activated window's position in the Z order without restrictions, or it can activate a window and then move it to the top of
            the topmost or non-topmost windows.
            </para>
            <para>
            A topmost window is no longer topmost if it is repositioned to the bottom ( <c>HWND_BOTTOM</c>) of the Z order or after any
            non-topmost window. When a topmost window is made non-topmost, its owners and its owned windows are also made non-topmost windows.
            </para>
            <para>
            A non-topmost window may own a topmost window, but not vice versa. Any window (for example, a dialog box) owned by a topmost
            window is itself made a topmost window to ensure that all owned windows stay above their owner.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DefFrameProc(Vanara.PInvoke.HWND,Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Provides default processing for any window messages that the window procedure of a multiple-document interface (MDI) frame window
            does not process. All window messages that are not explicitly processed by the window procedure must be passed to the
            <c>DefFrameProc</c> function, not the DefWindowProc function.
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the MDI frame window.</para>
            </param>
            <param name="hWndMDIClient">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the MDI client window.</para>
            </param>
            <param name="uMsg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be processed.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>LRESULT</c></c></para>
            <para>
            The return value specifies the result of the message processing and depends on the message. If the hWndMDIClient parameter is
            <c>NULL</c>, the return value is the same as for the DefWindowProc function.
            </para>
            </returns>
            <remarks>
            <para>
            When an application's window procedure does not handle a message, it typically passes the message to the DefWindowProc function
            to process the message. MDI applications use the <c>DefFrameProc</c> and DefMDIChildProc functions instead of
            <c>DefWindowProc</c> to provide default message processing. All messages that an application would usually pass to
            <c>DefWindowProc</c> (such as nonclient messages and the WM_SETTEXT message) should be passed to <c>DefFrameProc</c> instead. The
            <c>DefFrameProc</c> function also handles the following messages.
            </para>
            <list type="table">
            <listheader>
            <term>Message</term>
            <term>Response</term>
            </listheader>
            <item>
            <term>WM_COMMAND</term>
            <term>
            Activates the MDI child window that the user chooses. This message is sent when the user chooses an MDI child window from the
            window menu of the MDI frame window. The window identifier accompanying this message identifies the MDI child window to be activated.
            </term>
            </item>
            <item>
            <term>WM_MENUCHAR</term>
            <term>Opens the window menu of the active MDI child window when the user presses the ALT+ – (minus) key combination.</term>
            </item>
            <item>
            <term>WM_SETFOCUS</term>
            <term>Passes the keyboard focus to the MDI client window, which in turn passes it to the active MDI child window.</term>
            </item>
            <item>
            <term>WM_SIZE</term>
            <term>
            Resizes the MDI client window to fit in the new frame window's client area. If the frame window procedure sizes the MDI client
            window to a different size, it should not pass the message to the DefWindowProc function.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DefMDIChildProc(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Provides default processing for any window message that the window procedure of a multiple-document interface (MDI) child window
            does not process. A window message not processed by the window procedure must be passed to the <c>DefMDIChildProc</c> function,
            not to the DefWindowProc function.
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the MDI child window.</para>
            </param>
            <param name="uMsg">
            <para>Type: <c>UINT</c></para>
            <para>The message to be processed.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message-specific information.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>LRESULT</c></c></para>
            <para>The return value specifies the result of the message processing and depends on the message.</para>
            </returns>
            <remarks>
            <para>
            The <c>DefMDIChildProc</c> function assumes that the parent window of the MDI child window identified by the hWnd parameter was
            created with the <c>MDICLIENT</c> class.
            </para>
            <para>
            When an application's window procedure does not handle a message, it typically passes the message to the DefWindowProc function
            to process the message. MDI applications use the DefFrameProc and <c>DefMDIChildProc</c> functions instead of
            <c>DefWindowProc</c> to provide default message processing. All messages that an application would usually pass to
            <c>DefWindowProc</c> (such as nonclient messages and the WM_SETTEXT message) should be passed to <c>DefMDIChildProc</c> instead.
            In addition, <c>DefMDIChildProc</c> also handles the following messages.
            </para>
            <list type="table">
            <listheader>
            <term>Message</term>
            <term>Response</term>
            </listheader>
            <item>
            <term>WM_CHILDACTIVATE</term>
            <term>Performs activation processing when MDI child windows are sized, moved, or displayed. This message must be passed.</term>
            </item>
            <item>
            <term>WM_GETMINMAXINFO</term>
            <term>Calculates the size of a maximized MDI child window, based on the current size of the MDI client window.</term>
            </item>
            <item>
            <term>WM_MENUCHAR</term>
            <term>Passes the message to the MDI frame window.</term>
            </item>
            <item>
            <term>WM_MOVE</term>
            <term>Recalculates MDI client scroll bars if they are present.</term>
            </item>
            <item>
            <term>WM_SETFOCUS</term>
            <term>Activates the child window if it is not the active MDI child window.</term>
            </item>
            <item>
            <term>WM_SIZE</term>
            <term>
            Performs operations necessary for changing the size of a window, especially for maximizing or restoring an MDI child window.
            Failing to pass this message to the DefMDIChildProc function produces highly undesirable results.
            </term>
            </item>
            <item>
            <term>WM_SYSCOMMAND</term>
            <term>Handles window menu commands: SC_NEXTWINDOW, SC_PREVWINDOW, SC_MOVE, SC_SIZE, and SC_MAXIMIZE.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DefWindowProc(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Calls the default window procedure to provide default processing for any window messages that an application does not process.
            This function ensures that every message is processed. <c>DefWindowProc</c> is called with the same parameters received by the
            window procedure.
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window procedure that received the message.</para>
            </param>
            <param name="Msg">
            <para>Type: <c>UINT</c></para>
            <para>The message.</para>
            </param>
            <param name="wParam">
            <para>Type: <c>WPARAM</c></para>
            <para>Additional message information. The content of this parameter depends on the value of the Msg parameter.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Additional message information. The content of this parameter depends on the value of the Msg parameter.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>LRESULT</c></c></para>
            <para>The return value is the result of the message processing and depends on the message.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.DeregisterShellHookWindow(Vanara.PInvoke.HWND)">
            <summary>
            <para>[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]</para>
            <para>Unregisters a specified Shell window that is registered to receive Shell hook messages.</para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be unregistered. The window was registered with a call to the RegisterShellHookWindow function.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para><c>TRUE</c> if the function succeeds; <c>FALSE</c> if the function fails.</para>
            </returns>
            <remarks>
            <para>
            This function was not included in the SDK headers and libraries until Windows XP with Service Pack 1 (SP1) and Windows Server
            2003. If you do not have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DestroyWindow(Vanara.PInvoke.HWND)">
            <summary>
            <para>
            Destroys the specified window. The function sends WM_DESTROY and WM_NCDESTROY messages to the window to deactivate it and remove
            the keyboard focus from it. The function also destroys the window's menu, flushes the thread message queue, destroys timers,
            removes clipboard ownership, and breaks the clipboard viewer chain (if the window is at the top of the viewer chain).
            </para>
            <para>
            If the specified window is a parent or owner window, <c>DestroyWindow</c> automatically destroys the associated child or owned
            windows when it destroys the parent or owner window. The function first destroys child or owned windows, and then it destroys the
            parent or owner window.
            </para>
            <para><c>DestroyWindow</c> also destroys modeless dialog boxes created by the CreateDialog function.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be destroyed.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>A thread cannot use <c>DestroyWindow</c> to destroy a window created by a different thread.</para>
            <para>
            If the window being destroyed is a child window that does not have the <c>WS_EX_NOPARENTNOTIFY</c> style, a WM_PARENTNOTIFY
            message is sent to the parent.
            </para>
            <para>Examples</para>
            <para>For an example, see Destroying a Window.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DisableProcessWindowsGhosting">
            <summary>
            Disables the window ghosting feature for the calling GUI process. Window ghosting is a Windows Manager feature that lets the user
            minimize, move, or close the main window of an application that is not responding.
            </summary>
            <remarks>After calling <c>DisableProcessWindowsGhosting</c>, the ghosting feature is disabled for the duration of the process.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.DragDetect(Vanara.PInvoke.HWND,Vanara.PInvoke.POINT)">
            <summary>
            Captures the mouse and tracks its movement until the user releases the left button, presses the ESC key, or moves the mouse
            outside the drag rectangle around the specified point. The width and height of the drag rectangle are specified by the
            <c>SM_CXDRAG</c> and <c>SM_CYDRAG</c> values returned by the GetSystemMetrics function.
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window receiving mouse input.</para>
            </param>
            <param name="pt">
            <para>Type: <c>POINT</c></para>
            <para>
            Initial position of the mouse, in screen coordinates. The function determines the coordinates of the drag rectangle by using this point.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the user moved the mouse outside of the drag rectangle while holding down the left button, the return value is nonzero.</para>
            <para>
            If the user did not move the mouse outside of the drag rectangle while holding down the left button, the return value is zero.
            </para>
            </returns>
            <remarks>The system metrics for the drag rectangle are configurable, allowing for larger or smaller drag rectangles.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnableWindow(Vanara.PInvoke.HWND,System.Boolean)">
            <summary>
            Enables or disables mouse and keyboard input to the specified window or control. When input is disabled, the window does not
            receive input such as mouse clicks and key presses. When input is enabled, the window receives all input.
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be enabled or disabled.</para>
            </param>
            <param name="bEnable">
            <para>Type: <c>BOOL</c></para>
            <para>
            Indicates whether to enable or disable the window. If this parameter is <c>TRUE</c>, the window is enabled. If the parameter is
            <c>FALSE</c>, the window is disabled.
            </para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the window was previously disabled, the return value is nonzero.</para>
            <para>If the window was not previously disabled, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            If the window is being disabled, the system sends a WM_CANCELMODE message. If the enabled state of a window is changing, the
            system sends a WM_ENABLE message after the <c>WM_CANCELMODE</c> message. (These messages are sent before <c>EnableWindow</c>
            returns.) If a window is already disabled, its child windows are implicitly disabled, although they are not sent a
            <c>WM_ENABLE</c> message.
            </para>
            <para>
            A window must be enabled before it can be activated. For example, if an application is displaying a modeless dialog box and has
            disabled its main window, the application must enable the main window before destroying the dialog box. Otherwise, another window
            will receive the keyboard focus and be activated. If a child window is disabled, it is ignored when the system tries to determine
            which window should receive mouse messages.
            </para>
            <para>
            By default, a window is enabled when it is created. To create a window that is initially disabled, an application can specify the
            <c>WS_DISABLED</c> style in the CreateWindow or CreateWindowEx function. After a window has been created, an application can use
            <c>EnableWindow</c> to enable or disable the window.
            </para>
            <para>
            An application can use this function to enable or disable a control in a dialog box. A disabled control cannot receive the
            keyboard focus, nor can a user gain access to it.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EndDeferWindowPos(System.IntPtr)">
            <summary>
            <para>Simultaneously updates the position and size of one or more windows in a single screen-refreshing cycle.</para>
            </summary>
            <param name="hWinPosInfo">
            <para>Type: <c>HDWP</c></para>
            <para>
            A handle to a multiple-window – position structure that contains size and position information for one or more windows. This
            internal structure is returned by the BeginDeferWindowPos function or by the most recent call to the DeferWindowPos function.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>EndDeferWindowPos</c> function sends the WM_WINDOWPOSCHANGING and WM_WINDOWPOSCHANGED messages to each window identified
            in the internal structure.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EndTask(Vanara.PInvoke.HWND,System.Boolean,System.Boolean)">
            <summary>
            <para>[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]</para>
            <para>Forcibly closes the specified window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be closed.</para>
            </param>
            <param name="fShutDown">
            <para>Type: <c>BOOL</c></para>
            <para>Ignored. Must be <c>FALSE</c>.</para>
            </param>
            <param name="fForce">
            <para>Type: <c>BOOL</c></para>
            <para>
            A <c>TRUE</c> for this parameter will force the destruction of the window if an initial attempt fails to gently close the window
            using WM_CLOSE. With a <c>FALSE</c> for this parameter, only the close with <c>WM_CLOSE</c> is attempted.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is <c>FALSE</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            This function was not included in the SDK headers and libraries until Windows XP with Service Pack 1 (SP1) and Windows Server
            2003. If you do not have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnumChildWindows(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.EnumWindowsProc,System.IntPtr)">
            <summary>
            Enumerates the child windows that belong to the specified parent window by passing the handle to each child window, in turn, to
            an application-defined callback function. <c>EnumChildWindows</c> continues until the last child window is enumerated or the
            callback function returns <c>FALSE</c>.
            </summary>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the parent window whose child windows are to be enumerated. If this parameter is <c>NULL</c>, this function is
            equivalent to EnumWindows.
            </para>
            </param>
            <param name="lpEnumFunc">
            <para>Type: <c>WNDENUMPROC</c></para>
            <para>A pointer to an application-defined callback function. For more information, see EnumChildProc.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>An application-defined value to be passed to the callback function.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>The return value is not used.</para>
            </returns>
            <remarks>
            <para>If a child window has created child windows of its own, <c>EnumChildWindows</c> enumerates those windows as well.</para>
            <para>
            A child window that is moved or repositioned in the Z order during the enumeration process will be properly enumerated. The
            function does not enumerate a child window that is destroyed before being enumerated or that is created during the enumeration process.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnumChildWindows(Vanara.PInvoke.HWND)">
            <summary>
            Enumerates the child windows that belong to the specified parent window by passing the handle to each child window, in turn, to
            an application-defined callback function. <c>EnumChildWindows</c> continues until the last child window is enumerated or the
            callback function returns <c>FALSE</c>.
            </summary>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the parent window whose child windows are to be enumerated. If this parameter is <see cref="P:Vanara.PInvoke.HWND.NULL"/>, this
            function is equivalent to EnumWindows.
            </para>
            </param>
            <returns>An ordered sequence of child window handles.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnumThreadWindows(System.UInt32,Vanara.PInvoke.User32.EnumWindowsProc,System.IntPtr)">
            <summary>
            <para>
            Enumerates all nonchild windows associated with a thread by passing the handle to each window, in turn, to an application-defined
            callback function. <c>EnumThreadWindows</c> continues until the last window is enumerated or the callback function returns
            <c>FALSE</c>. To enumerate child windows of a particular window, use the EnumChildWindows function.
            </para>
            </summary>
            <param name="dwThreadId">
            <para>Type: <c>DWORD</c></para>
            <para>The identifier of the thread whose windows are to be enumerated.</para>
            </param>
            <param name="lpfn">
            <para>Type: <c>WNDENUMPROC</c></para>
            <para>A pointer to an application-defined callback function. For more information, see EnumThreadWndProc.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>An application-defined value to be passed to the callback function.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>
            If the callback function returns <c>TRUE</c> for all windows in the thread specified by dwThreadId, the return value is
            <c>TRUE</c>. If the callback function returns <c>FALSE</c> on any enumerated window, or if there are no windows found in the
            thread specified by dwThreadId, the return value is <c>FALSE</c>.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnumWindows(Vanara.PInvoke.User32.EnumWindowsProc,System.IntPtr)">
            <summary>
            <para>
            Enumerates all top-level windows on the screen by passing the handle to each window, in turn, to an application-defined callback
            function. <c>EnumWindows</c> continues until the last top-level window is enumerated or the callback function returns <c>FALSE</c>.
            </para>
            </summary>
            <param name="lpEnumFunc">
            <para>Type: <c>WNDENUMPROC</c></para>
            <para>A pointer to an application-defined callback function. For more information, see EnumWindowsProc.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>An application-defined value to be passed to the callback function.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            <para>
            If EnumWindowsProc returns zero, the return value is also zero. In this case, the callback function should call SetLastError to
            obtain a meaningful error code to be returned to the caller of <c>EnumWindows</c>.
            </para>
            </returns>
            <remarks>
            <para>
            The <c>EnumWindows</c> function does not enumerate child windows, with the exception of a few top-level windows owned by the
            system that have the <c>WS_CHILD</c> style.
            </para>
            <para>
            This function is more reliable than calling the GetWindow function in a loop. An application that calls <c>GetWindow</c> to
            perform this task risks being caught in an infinite loop or referencing a handle to a window that has been destroyed.
            </para>
            <para><c>Note</c> For Windows 8 and later, <c>EnumWindows</c> enumerates only top-level windows of desktop apps.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.FindWindow(System.String,System.String)">
            <summary>
            <para>
            Retrieves a handle to the top-level window whose class name and window name match the specified strings. This function does not
            search child windows. This function does not perform a case-sensitive search.
            </para>
            <para>To search child windows, beginning with a specified child window, use the FindWindowEx function.</para>
            </summary>
            <param name="lpClassName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The class name or a class atom created by a previous call to the RegisterClass or RegisterClassEx function. The atom must be in
            the low-order word of lpClassName; the high-order word must be zero.
            </para>
            <para>
            If lpClassName points to a string, it specifies the window class name. The class name can be any name registered with
            RegisterClass or RegisterClassEx, or any of the predefined control-class names.
            </para>
            <para>If lpClassName is <c>NULL</c>, it finds any window whose title matches the lpWindowName parameter.</para>
            </param>
            <param name="lpWindowName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The window name (the window's title). If this parameter is <c>NULL</c>, all window names match.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>If the function succeeds, the return value is a handle to the window that has the specified class name and window name.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the lpWindowName parameter is not <c>NULL</c>, <c>FindWindow</c> calls the GetWindowText function to retrieve the window name
            for comparison. For a description of a potential problem that can arise, see the Remarks for <c>GetWindowText</c>.
            </para>
            <para>Examples</para>
            <para>For an example, see Retrieving the Number of Mouse Wheel Scroll Lines.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.FindWindowEx(Vanara.PInvoke.HWND,Vanara.PInvoke.HWND,System.String,System.String)">
            <summary>
            Retrieves a handle to a window whose class name and window name match the specified strings. The function searches child windows,
            beginning with the one following the specified child window. This function does not perform a case-sensitive search.
            </summary>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the parent window whose child windows are to be searched.</para>
            <para>
            If <c>hwndParent</c> is <c>NULL</c>, the function uses the desktop window as the parent window. The function searches among
            windows that are child windows of the desktop.
            </para>
            <para>If <c>hwndParent</c> is <c>HWND_MESSAGE</c>, the function searches all message-only windows.</para>
            </param>
            <param name="hWndChildAfter">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to a child window. The search begins with the next child window in the Z order. The child window must be a direct child
            window of <c>hwndParent</c>, not just a descendant window.
            </para>
            <para>If <c>hwndChildAfter</c> is <c>NULL</c>, the search begins with the first child window of <c>hwndParent</c>.</para>
            <para>
            Note that if both <c>hwndParent</c> and <c>hwndChildAfter</c> are <c>NULL</c>, the function searches all top-level and
            message-only windows.
            </para>
            </param>
            <param name="lpszClass">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The class name or a class atom created by a previous call to the RegisterClass or RegisterClassEx function. The atom must be
            placed in the low-order word of <c>lpszClass</c>; the high-order word must be zero.
            </para>
            <para>
            If <c>lpszClass</c> is a string, it specifies the window class name. The class name can be any name registered with RegisterClass
            or RegisterClassEx, or any of the predefined control-class names, or it can be <c>MAKEINTATOM(0x8000)</c>. In this latter case,
            0x8000 is the atom for a menu class. For more information, see the Remarks section of this topic.
            </para>
            </param>
            <param name="lpszWindow">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The window name (the window's title). If this parameter is <c>NULL</c>, all window names match.</para>
            </param>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>If the function succeeds, the return value is a handle to the window that has the specified class and window names.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>The FindWindowEx function searches only direct child windows. It does not search other descendants.</para>
            <para>
            If the <c>lpszWindow</c> parameter is not <c>NULL</c>, <c>FindWindowEx</c> calls the GetWindowText function to retrieve the
            window name for comparison. For a description of a potential problem that can arise, see the Remarks section of <c>GetWindowText</c>.
            </para>
            <para>An application can call this function in the following way.</para>
            <para>
            Note that 0x8000 is the atom for a menu class. When an application calls this function, the function checks whether a context
            menu is being displayed that the application created.
            </para>
            <para>
            <para>Note</para>
            <para>
            The winuser.h header defines FindWindowEx as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.FindWindowEx(Vanara.PInvoke.HWND,Vanara.PInvoke.HWND,System.IntPtr,System.String)">
            <summary>
            Retrieves a handle to a window whose class name and window name match the specified strings. The function searches child windows,
            beginning with the one following the specified child window. This function does not perform a case-sensitive search.
            </summary>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the parent window whose child windows are to be searched.</para>
            <para>
            If <c>hwndParent</c> is <c>NULL</c>, the function uses the desktop window as the parent window. The function searches among
            windows that are child windows of the desktop.
            </para>
            <para>If <c>hwndParent</c> is <c>HWND_MESSAGE</c>, the function searches all message-only windows.</para>
            </param>
            <param name="hWndChildAfter">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to a child window. The search begins with the next child window in the Z order. The child window must be a direct child
            window of <c>hwndParent</c>, not just a descendant window.
            </para>
            <para>If <c>hwndChildAfter</c> is <c>NULL</c>, the search begins with the first child window of <c>hwndParent</c>.</para>
            <para>
            Note that if both <c>hwndParent</c> and <c>hwndChildAfter</c> are <c>NULL</c>, the function searches all top-level and
            message-only windows.
            </para>
            </param>
            <param name="lpszClass">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The class name or a class atom created by a previous call to the RegisterClass or RegisterClassEx function. The atom must be
            placed in the low-order word of <c>lpszClass</c>; the high-order word must be zero.
            </para>
            <para>
            If <c>lpszClass</c> is a string, it specifies the window class name. The class name can be any name registered with RegisterClass
            or RegisterClassEx, or any of the predefined control-class names, or it can be <c>MAKEINTATOM(0x8000)</c>. In this latter case,
            0x8000 is the atom for a menu class. For more information, see the Remarks section of this topic.
            </para>
            </param>
            <param name="lpszWindow">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The window name (the window's title). If this parameter is <c>NULL</c>, all window names match.</para>
            </param>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>If the function succeeds, the return value is a handle to the window that has the specified class and window names.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>The FindWindowEx function searches only direct child windows. It does not search other descendants.</para>
            <para>
            If the <c>lpszWindow</c> parameter is not <c>NULL</c>, <c>FindWindowEx</c> calls the GetWindowText function to retrieve the
            window name for comparison. For a description of a potential problem that can arise, see the Remarks section of <c>GetWindowText</c>.
            </para>
            <para>An application can call this function in the following way.</para>
            <para>
            Note that 0x8000 is the atom for a menu class. When an application calls this function, the function checks whether a context
            menu is being displayed that the application created.
            </para>
            <para>
            <para>Note</para>
            <para>
            The winuser.h header defines FindWindowEx as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.FlashWindow(Vanara.PInvoke.HWND,System.Boolean)">
            <summary>
            <para>Flashes the specified window one time. It does not change the active state of the window.</para>
            <para>To flash the window a specified number of times, use the FlashWindowEx function.</para>
            </summary>
            <param name="hWnd">A handle to the window to be flashed. The window can be either open or minimized.</param>
            <param name="bInvert">
            <para>
            If this parameter is <c>TRUE</c>, the window is flashed from one state to the other. If it is <c>FALSE</c>, the window is
            returned to its original state (either active or inactive).
            </para>
            <para>
            When an application is minimized and this parameter is <c>TRUE</c>, the taskbar window button flashes active/inactive. If it is
            <c>FALSE</c>, the taskbar window button flashes inactive, meaning that it does not change colors. It flashes, as if it were being
            redrawn, but it does not provide the visual invert clue to the user.
            </para>
            </param>
            <returns>
            The return value specifies the window's state before the call to the <c>FlashWindow</c> function. If the window caption was drawn
            as active before the call, the return value is nonzero. Otherwise, the return value is zero.
            </returns>
            <remarks>
            <para>
            Flashing a window means changing the appearance of its caption bar as if the window were changing from inactive to active status,
            or vice versa. (An inactive caption bar changes to an active caption bar; an active caption bar changes to an inactive caption bar.)
            </para>
            <para>
            Typically, a window is flashed to inform the user that the window requires attention but that it does not currently have the
            keyboard focus.
            </para>
            <para>
            The <c>FlashWindow</c> function flashes the window only once; for repeated flashing, the application should create a system timer.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.FlashWindowEx(Vanara.PInvoke.User32.FLASHWINFO@)">
            <summary>Flashes the specified window. It does not change the active state of the window.</summary>
            <param name="pfwi">A pointer to a FLASHWINFO structure.</param>
            <returns>
            The return value specifies the window's state before the call to the <c>FlashWindowEx</c> function. If the window caption was
            drawn as active before the call, the return value is nonzero. Otherwise, the return value is zero.
            </returns>
            <remarks>
            Typically, you flash a window to inform the user that the window requires attention but does not currently have the keyboard
            focus. When a window flashes, it appears to change from inactive to active status. An inactive caption bar changes to an active
            caption bar; an active caption bar changes to an inactive caption bar.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetActiveWindow">
            <summary>
            <para>Retrieves the window handle to the active window attached to the calling thread's message queue.</para>
            </summary>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>
            The return value is the handle to the active window attached to the calling thread's message queue. Otherwise, the return value
            is <c>NULL</c>.
            </para>
            </returns>
            <remarks>
            <para>To get the handle to the foreground window, you can use GetForegroundWindow.</para>
            <para>To get the window handle to the active window in the message queue for another thread, use GetGUIThreadInfo.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetAltTabInfo(Vanara.PInvoke.HWND,System.Int32,Vanara.PInvoke.User32.ALTTABINFO@,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>Retrieves status information for the specified window if it is the application-switching (ALT+TAB) window.</para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window for which status information will be retrieved. This window must be the application-switching window.</para>
            </param>
            <param name="iItem">
            <para>Type: <c>int</c></para>
            <para>
            The index of the icon in the application-switching window. If the pszItemText parameter is not <c>NULL</c>, the name of the item
            is copied to the pszItemText string. If this parameter is –1, the name of the item is not copied.
            </para>
            </param>
            <param name="pati">
            <para>Type: <c>PALTTABINFO</c></para>
            <para>
            A pointer to an ALTTABINFO structure to receive the status information. Note that you must set the <c>csSize</c> member to before
            calling this function.
            </para>
            </param>
            <param name="pszItemText">
            <para>Type: <c>LPTSTR</c></para>
            <para>The name of the item. If this parameter is <c>NULL</c>, the name of the item is not copied.</para>
            </param>
            <param name="cchItemText">
            <para>Type: <c>UINT</c></para>
            <para>The size, in characters, of the pszItemText buffer.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The application-switching window enables you to switch to the most recently used application window. To display the
            application-switching window, press ALT+TAB. To select an application from the list, continue to hold ALT down and press TAB to
            move through the list. Add SHIFT to reverse direction through the list.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetAncestor(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.GetAncestorFlag)">
            <summary>
            <para>Retrieves the handle to the ancestor of the specified window.</para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose ancestor is to be retrieved. If this parameter is the desktop window, the function returns <c>NULL</c>.
            </para>
            </param>
            <param name="gaFlags">
            <para>Type: <c>UINT</c></para>
            <para>The ancestor to be retrieved. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>GA_PARENT 1</term>
            <term>Retrieves the parent window. This does not include the owner, as it does with the GetParent function.</term>
            </item>
            <item>
            <term>GA_ROOT 2</term>
            <term>Retrieves the root window by walking the chain of parent windows.</term>
            </item>
            <item>
            <term>GA_ROOTOWNER 3</term>
            <term>Retrieves the owned root window by walking the chain of parent and owner windows returned by GetParent.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>The return value is the handle to the ancestor window.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetCapture">
            <summary>
            Retrieves a handle to the window (if any) that has captured the mouse. Only one window at a time can capture the mouse; this
            window receives mouse input whether or not the cursor is within its borders.
            </summary>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>
            The return value is a handle to the capture window associated with the current thread. If no window in the thread has captured
            the mouse, the return value is <c>NULL</c>.
            </para>
            </returns>
            <remarks>
            <para>
            A <c>NULL</c> return value means the current thread has not captured the mouse. However, it is possible that another thread or
            process has captured the mouse.
            </para>
            <para>To get a handle to the capture window on another thread, use the GetGUIThreadInfo function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetChildWindow(Vanara.PInvoke.HWND)">
            <summary>
            Retrieves the child window at the top of the Z order, if the specified window is a parent window; otherwise, the retrieved
            handle is NULL. The function examines only child windows of the specified window. It does not examine descendant windows.
            </summary>
            <param name="hWnd">A handle to a window.</param>
            <returns>
            If the function succeeds, the return value is a window handle. If no window exists with the specified relationship to the
            specified window, the return value is NULL. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetClassInfo(Vanara.PInvoke.HINSTANCE,System.String,Vanara.PInvoke.User32.WNDCLASS@)">
            <summary>
            <para>Retrieves information about a window class.</para>
            <para>
            <c>Note</c> The <c>GetClassInfo</c> function has been superseded by the GetClassInfoEx function. You can still use
            <c>GetClassInfo</c>, however, if you do not need information about the class small icon.
            </para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>
            A handle to the instance of the application that created the class. To retrieve information about classes defined by the system
            (such as buttons or list boxes), set this parameter to <c>NULL</c>.
            </para>
            </param>
            <param name="lpClassName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The class name. The name must be that of a preregistered class or a class registered by a previous call to the RegisterClass or
            RegisterClassEx function.
            </para>
            <para>
            Alternatively, this parameter can be an atom. If so, it must be a class atom created by a previous call to RegisterClass or
            RegisterClassEx. The atom must be in the low-order word of lpClassName; the high-order word must be zero.
            </para>
            </param>
            <param name="lpWndClass">
            <para>Type: <c>LPWNDCLASS</c></para>
            <para>A pointer to a WNDCLASS structure that receives the information about the class.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function finds a matching class and successfully copies the data, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetClassInfoEx(Vanara.PInvoke.HINSTANCE,System.String,Vanara.PInvoke.User32.WNDCLASSEX@)">
            <summary>
            <para>
            Retrieves information about a window class, including a handle to the small icon associated with the window class. The
            GetClassInfo function does not retrieve a handle to the small icon.
            </para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>
            A handle to the instance of the application that created the class. To retrieve information about classes defined by the system
            (such as buttons or list boxes), set this parameter to <c>NULL</c>.
            </para>
            </param>
            <param name="lpszClass">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The class name. The name must be that of a preregistered class or a class registered by a previous call to the RegisterClass or
            RegisterClassEx function. Alternatively, this parameter can be a class atom created by a previous call to <c>RegisterClass</c> or
            <c>RegisterClassEx</c>. The atom must be in the low-order word of lpszClass; the high-order word must be zero.
            </para>
            </param>
            <param name="lpwcx">
            <para>Type: <c>LPWNDCLASSEX</c></para>
            <para>A pointer to a WNDCLASSEX structure that receives the information about the class.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function finds a matching class and successfully copies the data, the return value is nonzero.</para>
            <para>
            If the function does not find a matching class and successfully copy the data, the return value is zero. To get extended error
            information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>Class atoms are created using the RegisterClass or RegisterClassEx function, not the GlobalAddAtom function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetClassInfoEx(Vanara.PInvoke.HINSTANCE,System.IntPtr,Vanara.PInvoke.User32.WNDCLASSEX@)">
            <summary>
            <para>
            Retrieves information about a window class, including a handle to the small icon associated with the window class. The
            GetClassInfo function does not retrieve a handle to the small icon.
            </para>
            </summary>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>
            A handle to the instance of the application that created the class. To retrieve information about classes defined by the system
            (such as buttons or list boxes), set this parameter to <c>NULL</c>.
            </para>
            </param>
            <param name="lpszClass">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The class name. The name must be that of a preregistered class or a class registered by a previous call to the RegisterClass or
            RegisterClassEx function. Alternatively, this parameter can be a class atom created by a previous call to <c>RegisterClass</c> or
            <c>RegisterClassEx</c>. The atom must be in the low-order word of lpszClass; the high-order word must be zero.
            </para>
            </param>
            <param name="lpwcx">
            <para>Type: <c>LPWNDCLASSEX</c></para>
            <para>A pointer to a WNDCLASSEX structure that receives the information about the class.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function finds a matching class and successfully copies the data, the return value is nonzero.</para>
            <para>
            If the function does not find a matching class and successfully copy the data, the return value is zero. To get extended error
            information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>Class atoms are created using the RegisterClass or RegisterClassEx function, not the GlobalAddAtom function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetClassLong(Vanara.PInvoke.HWND,System.Int32)">
            <summary>
            <para>Retrieves the specified value from the WNDCLASSEX structure associated with the specified window.</para>
            <para>
            <c>Note</c> To write code that is compatible with both 32-bit and 64-bit versions of Windows, use <c>GetClassLongPtr</c>. When
            compiling for 32-bit Windows, <c>GetClassLongPtr</c> is defined as a call to the GetClassLong function.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
            </param>
            <param name="nIndex">
            <para>Type: <c>int</c></para>
            <para>
            The value to be retrieved. To retrieve a value from the extra class memory, specify the positive, zero-based byte offset of the
            value to be retrieved. Valid values are in the range zero through the number of bytes of extra class memory, minus eight; for
            example, if you specified 24 or more bytes of extra class memory, a value of 16 would be an index to the third integer. To
            retrieve any other value from the WNDCLASSEX structure, specify one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>GCW_ATOM -32</term>
            <term>
            Retrieves an ATOM value that uniquely identifies the window class. This is the same atom that the RegisterClassEx function returns.
            </term>
            </item>
            <item>
            <term>GCL_CBCLSEXTRA -20</term>
            <term>Retrieves the size, in bytes, of the extra memory associated with the class.</term>
            </item>
            <item>
            <term>GCL_CBWNDEXTRA -18</term>
            <term>
            Retrieves the size, in bytes, of the extra window memory associated with each window in the class. For information on how to
            access this memory, see GetWindowLongPtr.
            </term>
            </item>
            <item>
            <term>GCLP_HBRBACKGROUND -10</term>
            <term>Retrieves a handle to the background brush associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HCURSOR -12</term>
            <term>Retrieves a handle to the cursor associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HICON -14</term>
            <term>Retrieves a handle to the icon associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HICONSM -34</term>
            <term>Retrieves a handle to the small icon associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HMODULE -16</term>
            <term>Retrieves a handle to the module that registered the class.</term>
            </item>
            <item>
            <term>GCLP_MENUNAME -8</term>
            <term>Retrieves the pointer to the menu name string. The string identifies the menu resource associated with the class.</term>
            </item>
            <item>
            <term>GCL_STYLE -26</term>
            <term>Retrieves the window-class style bits.</term>
            </item>
            <item>
            <term>GCLP_WNDPROC -24</term>
            <term>
            Retrieves the address of the window procedure, or a handle representing the address of the window procedure. You must use the
            CallWindowProc function to call the window procedure.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>ULONG_PTR</c></c></para>
            <para>If the function succeeds, the return value is the requested value.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            Reserve extra class memory by specifying a nonzero value in the <c>cbClsExtra</c> member of the WNDCLASSEX structure used with
            the RegisterClassEx function.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetClassLong(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.GetClassLongFlag)">
            <summary>
            <para>Retrieves the specified value from the WNDCLASSEX structure associated with the specified window.</para>
            <para>
            <c>Note</c> To write code that is compatible with both 32-bit and 64-bit versions of Windows, use <c>GetClassLongPtr</c>. When
            compiling for 32-bit Windows, <c>GetClassLongPtr</c> is defined as a call to the GetClassLong function.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
            </param>
            <param name="nIndex">
            <para>Type: <c>int</c></para>
            <para>
            The value to be retrieved. To retrieve a value from the extra class memory, specify the positive, zero-based byte offset of the
            value to be retrieved. Valid values are in the range zero through the number of bytes of extra class memory, minus eight; for
            example, if you specified 24 or more bytes of extra class memory, a value of 16 would be an index to the third integer. To
            retrieve any other value from the WNDCLASSEX structure, specify one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>GCW_ATOM -32</term>
            <term>
            Retrieves an ATOM value that uniquely identifies the window class. This is the same atom that the RegisterClassEx function returns.
            </term>
            </item>
            <item>
            <term>GCL_CBCLSEXTRA -20</term>
            <term>Retrieves the size, in bytes, of the extra memory associated with the class.</term>
            </item>
            <item>
            <term>GCL_CBWNDEXTRA -18</term>
            <term>
            Retrieves the size, in bytes, of the extra window memory associated with each window in the class. For information on how to
            access this memory, see GetWindowLongPtr.
            </term>
            </item>
            <item>
            <term>GCLP_HBRBACKGROUND -10</term>
            <term>Retrieves a handle to the background brush associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HCURSOR -12</term>
            <term>Retrieves a handle to the cursor associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HICON -14</term>
            <term>Retrieves a handle to the icon associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HICONSM -34</term>
            <term>Retrieves a handle to the small icon associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HMODULE -16</term>
            <term>Retrieves a handle to the module that registered the class.</term>
            </item>
            <item>
            <term>GCLP_MENUNAME -8</term>
            <term>Retrieves the pointer to the menu name string. The string identifies the menu resource associated with the class.</term>
            </item>
            <item>
            <term>GCL_STYLE -26</term>
            <term>Retrieves the window-class style bits.</term>
            </item>
            <item>
            <term>GCLP_WNDPROC -24</term>
            <term>
            Retrieves the address of the window procedure, or a handle representing the address of the window procedure. You must use the
            CallWindowProc function to call the window procedure.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>ULONG_PTR</c></c></para>
            <para>If the function succeeds, the return value is the requested value.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            Reserve extra class memory by specifying a nonzero value in the <c>cbClsExtra</c> member of the WNDCLASSEX structure used with
            the RegisterClassEx function.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetClassName(Vanara.PInvoke.HWND,System.Text.StringBuilder,System.Int32)">
            <summary>Retrieves the name of the class to which the specified window belongs.</summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
            </param>
            <param name="lpClassName">
            <para>Type: <c>LPTSTR</c></para>
            <para>The class name string.</para>
            </param>
            <param name="nMaxCount">
            <para>Type: <c>int</c></para>
            <para>The length</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>int</c></c></para>
            <para>
            If the function succeeds, the return value is the number of characters copied to the buffer, not including the terminating null character.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetClassWord(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.GCW)">
            <summary>
            <para>
            Retrieves the 16-bit ( <c>WORD</c>) value at the specified offset into the extra class memory for the window class to which the
            specified window belongs.
            </para>
            <para>
            <c>Note</c> This function is deprecated for any use other than <c>nIndex</c> set to <c>GCW_ATOM</c>. The function is provided
            only for compatibility with 16-bit versions of Windows. Applications should use the GetClassLongPtr or GetClassLongPtr function.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
            </param>
            <param name="nIndex">
            <para>Type: <c>int</c></para>
            <para>
            The zero-based byte offset of the value to be retrieved. Valid values are in the range zero through the number of bytes of class
            memory, minus two; for example, if you specified 10 or more bytes of extra class memory, a value of eight would be an index to
            the fifth 16-bit integer. There is an additional valid value as shown in the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term><c>GCW_ATOM</c> -32</term>
            <term>
            Retrieves an <c>ATOM</c> value that uniquely identifies the window class. This is the same atom that the RegisterClass or
            RegisterClassEx function returns.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>WORD</c></para>
            <para>If the function succeeds, the return value is the requested 16-bit value.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            Reserve extra class memory by specifying a nonzero value in the <c>cbClsExtra</c> member of the WNDCLASS structure used with the
            RegisterClass function.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetClientRect(Vanara.PInvoke.HWND,Vanara.PInvoke.RECT@)">
            <summary>
            Retrieves the coordinates of a window's client area. The client coordinates specify the upper-left and lower-right corners of the
            client area. Because client coordinates are relative to the upper-left corner of a window's client area, the coordinates of the
            upper-left corner are (0,0).
            </summary>
            <param name="hWnd">A handle to the window whose client coordinates are to be retrieved.</param>
            <param name="lpRect">
            A pointer to a RECT structure that receives the client coordinates. The left and top members are zero. The right and bottom
            members contain the width and height of the window.
            </param>
            <returns>
            If the function succeeds, the return value is true. If the function fails, the return value is false. To get extended error
            information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetDesktopWindow">
            <summary>
            Retrieves a handle to the desktop window. The desktop window covers the entire screen. The desktop window is the area on top of
            which other windows are painted.
            </summary>
            <returns>The return value is a handle to the desktop window.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetFocus">
            <summary>
            Retrieves the handle to the window that has the keyboard focus, if the window is attached to the calling thread's message queue.
            </summary>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>
            The return value is the handle to the window with the keyboard focus. If the calling thread's message queue does not have an
            associated window with the keyboard focus, the return value is <c>NULL</c>.
            </para>
            </returns>
            <remarks>
            <para>
            <c>GetFocus</c> returns the window with the keyboard focus for the current thread's message queue. If <c>GetFocus</c> returns
            <c>NULL</c>, another thread's queue may be attached to a window that has the keyboard focus.
            </para>
            <para>
            Use the GetForegroundWindow function to retrieve the handle to the window with which the user is currently working. You can
            associate your thread's message queue with the windows owned by another thread by using the AttachThreadInput function.
            </para>
            <para>
            To get the window with the keyboard focus on the foreground queue or the queue of another thread, use the GetGUIThreadInfo function.
            </para>
            <para>Examples</para>
            <para>For an example, see "Creating a Combo Box Toolbar" in Using Combo Boxes.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetForegroundWindow">
            <summary>
            <para>
            Retrieves a handle to the foreground window (the window with which the user is currently working). The system assigns a slightly
            higher priority to the thread that creates the foreground window than it does to other threads.
            </para>
            </summary>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>
            The return value is a handle to the foreground window. The foreground window can be <c>NULL</c> in certain circumstances, such as
            when a window is losing activation.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetGUIThreadInfo(System.UInt32,Vanara.PInvoke.User32.GUITHREADINFO@)">
            <summary>
            <para>Retrieves information about the active window or a specified GUI thread.</para>
            </summary>
            <param name="idThread">
            <para>Type: <c>DWORD</c></para>
            <para>
            The identifier for the thread for which information is to be retrieved. To retrieve this value, use the GetWindowThreadProcessId
            function. If this parameter is <c>NULL</c>, the function returns information for the foreground thread.
            </para>
            </param>
            <param name="pgui">
            <para>Type: <c>LPGUITHREADINFO</c></para>
            <para>
            A pointer to a GUITHREADINFO structure that receives information describing the thread. Note that you must set the <c>cbSize</c>
            member to before calling this function.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            This function succeeds even if the active window is not owned by the calling process. If the specified thread does not exist or
            have an input queue, the function will fail.
            </para>
            <para>
            This function is useful for retrieving out-of-context information about a thread. The information retrieved is the same as if an
            application retrieved the information about itself.
            </para>
            <para>
            For an edit control, the returned <c>rcCaret</c> rectangle contains the caret plus information on text direction and padding.
            Thus, it may not give the correct position of the cursor. The Sans Serif font uses four characters for the cursor:
            </para>
            <list type="table">
            <listheader>
            <term>Cursor character</term>
            <term>Unicode code point</term>
            </listheader>
            <item>
            <term>CURSOR_LTR</term>
            <term>0xf00c</term>
            </item>
            <item>
            <term>CURSOR_RTL</term>
            <term>0xf00d</term>
            </item>
            <item>
            <term>CURSOR_THAI</term>
            <term>0xf00e</term>
            </item>
            <item>
            <term>CURSOR_USA</term>
            <term>0xfff (this is a marker value with no associated glyph)</term>
            </item>
            </list>
            <para>To get the actual insertion point in the <c>rcCaret</c> rectangle, perform the following steps.</para>
            <list type="number">
            <item>
            <term>Call GetKeyboardLayout to retrieve the current input language.</term>
            </item>
            <item>
            <term>Determine the character used for the cursor, based on the current input language.</term>
            </item>
            <item>
            <term>
            Call CreateFont using Sans Serif for the font, the height given by <c>rcCaret</c>, and a width of . For fnWeight, call . If
            pvParam is greater than 1, set fnWeight to 700, otherwise set fnWeight to 400.
            </term>
            </item>
            <item>
            <term>Select the font into a device context (DC) and use GetCharABCWidths to get the width of the appropriate cursor character.</term>
            </item>
            <item>
            <term>Add the width to <c>rcCaret</c>. <c>left</c> to obtain the actual insertion point.</term>
            </item>
            </list>
            <para>
            The function may not return valid window handles in the GUITHREADINFO structure when called to retrieve information for the
            foreground thread, such as when a window is losing activation.
            </para>
            <para>DPI Virtualization</para>
            <para>
            The coordinates returned in the <c>rcCaret</c> rect of the GUITHREADINFO struct are logical coordinates in terms of the window
            associated with the caret. They are not virtualized into the mode of the calling thread.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetLastActivePopup(Vanara.PInvoke.HWND)">
            <summary>
            <para>Determines which pop-up window owned by the specified window was most recently active.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the owner window.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>
            The return value identifies the most recently active pop-up window. The return value is the same as the hWnd parameter, if any of
            the following conditions are met:
            </para>
            <list type="bullet">
            <item>
            <term>The window identified by hWnd was most recently active.</term>
            </item>
            <item>
            <term>The window identified by hWnd does not own any pop-up windows.</term>
            </item>
            <item>
            <term>The window identifies by hWnd is not a top-level window, or it is owned by another window.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetLayeredWindowAttributes(Vanara.PInvoke.HWND,Vanara.PInvoke.COLORREF@,System.Byte@,Vanara.PInvoke.User32.LayeredWindowAttributes@)">
            <summary>
            <para>Retrieves the opacity and transparency color key of a layered window.</para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the layered window. A layered window is created by specifying <c>WS_EX_LAYERED</c> when creating the window with the
            CreateWindowEx function or by setting <c>WS_EX_LAYERED</c> using SetWindowLong after the window has been created.
            </para>
            </param>
            <param name="pcrKey">
            <para>Type: <c>COLORREF*</c></para>
            <para>
            A pointer to a COLORREF value that receives the transparency color key to be used when composing the layered window. All pixels
            painted by the window in this color will be transparent. This can be <c>NULL</c> if the argument is not needed.
            </para>
            </param>
            <param name="pbAlpha">
            <para>Type: <c>BYTE*</c></para>
            <para>
            The Alpha value used to describe the opacity of the layered window. Similar to the <c>SourceConstantAlpha</c> member of the
            BLENDFUNCTION structure. When the variable referred to by pbAlpha is 0, the window is completely transparent. When the variable
            referred to by pbAlpha is 255, the window is opaque. This can be <c>NULL</c> if the argument is not needed.
            </para>
            </param>
            <param name="pdwFlags">
            <para>Type: <c>DWORD*</c></para>
            <para>
            A layering flag. This parameter can be <c>NULL</c> if the value is not needed. The layering flag can be one or more of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>LWA_ALPHA 0x00000002</term>
            <term>Use pbAlpha to determine the opacity of the layered window.</term>
            </item>
            <item>
            <term>LWA_COLORKEY 0x00000001</term>
            <term>Use pcrKey as the transparency color.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            <c>GetLayeredWindowAttributes</c> can be called only if the application has previously called SetLayeredWindowAttributes on the
            window. The function will fail if the layered window was setup with UpdateLayeredWindow.
            </para>
            <para>For more information, see Using Layered Windows.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetNextWindow(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.GetWindowCmd)">
            <summary>
            <para>
            Retrieves a handle to the next or previous window in the Z-Order. The next window is below the specified window; the previous
            window is above.
            </para>
            <para>
            If the specified window is a topmost window, the function searches for a topmost window. If the specified window is a top-level
            window, the function searches for a top-level window. If the specified window is a child window, the function searches for a
            child window.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to a window. The window handle retrieved is relative to this window, based on the value of the wCmd parameter.</para>
            </param>
            <param name="wCmd">
            <para>Type: <c>UINT</c></para>
            <para>
            Indicates whether the function returns a handle to the next window or the previous window. This parameter can be either of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>GW_HWNDNEXT 2</term>
            <term>Returns a handle to the window below the given window.</term>
            </item>
            <item>
            <term>GW_HWNDPREV 3</term>
            <term>Returns a handle to the window above the given window.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>None</para>
            </returns>
            <remarks>
            <para>This function is implemented as a call to the GetWindow function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetParent(Vanara.PInvoke.HWND)">
            <summary>
            <para>Retrieves a handle to the specified window's parent or owner.</para>
            <para>To retrieve a handle to a specified ancestor, use the GetAncestor function.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose parent window handle is to be retrieved.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>
            If the window is a child window, the return value is a handle to the parent window. If the window is a top-level window with the
            <c>WS_POPUP</c> style, the return value is a handle to the owner window.
            </para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            <para>This function typically fails for one of the following reasons:</para>
            <list type="bullet">
            <item>
            <term>The window is a top-level window that is unowned or does not have the <c>WS_POPUP</c> style.</term>
            </item>
            <item>
            <term>The owner window has <c>WS_POPUP</c> style.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            To obtain a window's owner window, instead of using <c>GetParent</c>, use GetWindow with the <c>GW_OWNER</c> flag. To obtain the
            parent window and not the owner, instead of using <c>GetParent</c>, use GetAncestor with the <c>GA_PARENT</c> flag.
            </para>
            <para>Examples</para>
            <para>For an example, see Initializing a Dialog Box.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetProcessDefaultLayout(Vanara.PInvoke.User32.DefaultLayout@)">
            <summary>
            <para>Retrieves the default layout that is used when windows are created with no parent or owner.</para>
            </summary>
            <param name="pdwDefaultLayout">
            <para>Type: <c>DWORD*</c></para>
            <para>The current default process layout. For a list of values, see SetProcessDefaultLayout.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The layout specifies how text and graphics are laid out in a window; the default is left to right. The
            <c>GetProcessDefaultLayout</c> function lets you know if the default layout has changed, from using SetProcessDefaultLayout.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetShellWindow">
            <summary>
            <para>Retrieves a handle to the Shell's desktop window.</para>
            </summary>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>The return value is the handle of the Shell's desktop window. If no Shell process is present, the return value is <c>NULL</c>.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetTitleBarInfo(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.TITLEBARINFO@)">
            <summary>
            <para>Retrieves information about the specified title bar.</para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the title bar whose information is to be retrieved.</para>
            </param>
            <param name="pti">
            <para>Type: <c>PTITLEBARINFO</c></para>
            <para>
            A pointer to a TITLEBARINFO structure to receive the information. Note that you must set the <c>cbSize</c> member to before
            calling this function.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetTopWindow(Vanara.PInvoke.HWND)">
            <summary>
            <para>
            Examines the Z order of the child windows associated with the specified parent window and retrieves a handle to the child window
            at the top of the Z order.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the parent window whose child windows are to be examined. If this parameter is <c>NULL</c>, the function returns a
            handle to the window at the top of the Z order.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>
            If the function succeeds, the return value is a handle to the child window at the top of the Z order. If the specified window has
            no child windows, the return value is <c>NULL</c>. To get extended error information, use the GetLastError function.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindow(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.GetWindowCmd)">
            <summary>
            <para>Retrieves a handle to a window that has the specified relationship (Z-Order or owner) to the specified window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to a window. The window handle retrieved is relative to this window, based on the value of the uCmd parameter.</para>
            </param>
            <param name="uCmd">
            <para>Type: <c>UINT</c></para>
            <para>
            The relationship between the specified window and the window whose handle is to be retrieved. This parameter can be one of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>GW_CHILD 5</term>
            <term>
            The retrieved handle identifies the child window at the top of the Z order, if the specified window is a parent window;
            otherwise, the retrieved handle is NULL. The function examines only child windows of the specified window. It does not examine
            descendant windows.
            </term>
            </item>
            <item>
            <term>GW_ENABLEDPOPUP 6</term>
            <term>
            The retrieved handle identifies the enabled popup window owned by the specified window (the search uses the first such window
            found using GW_HWNDNEXT); otherwise, if there are no enabled popup windows, the retrieved handle is that of the specified window.
            </term>
            </item>
            <item>
            <term>GW_HWNDFIRST 0</term>
            <term>
            The retrieved handle identifies the window of the same type that is highest in the Z order. If the specified window is a topmost
            window, the handle identifies a topmost window. If the specified window is a top-level window, the handle identifies a top-level
            window. If the specified window is a child window, the handle identifies a sibling window.
            </term>
            </item>
            <item>
            <term>GW_HWNDLAST 1</term>
            <term>
            The retrieved handle identifies the window of the same type that is lowest in the Z order. If the specified window is a topmost
            window, the handle identifies a topmost window. If the specified window is a top-level window, the handle identifies a top-level
            window. If the specified window is a child window, the handle identifies a sibling window.
            </term>
            </item>
            <item>
            <term>GW_HWNDNEXT 2</term>
            <term>
            The retrieved handle identifies the window below the specified window in the Z order. If the specified window is a topmost
            window, the handle identifies a topmost window. If the specified window is a top-level window, the handle identifies a top-level
            window. If the specified window is a child window, the handle identifies a sibling window.
            </term>
            </item>
            <item>
            <term>GW_HWNDPREV 3</term>
            <term>
            The retrieved handle identifies the window above the specified window in the Z order. If the specified window is a topmost
            window, the handle identifies a topmost window. If the specified window is a top-level window, the handle identifies a top-level
            window. If the specified window is a child window, the handle identifies a sibling window.
            </term>
            </item>
            <item>
            <term>GW_OWNER 4</term>
            <term>The retrieved handle identifies the specified window's owner window, if any. For more information, see Owned Windows.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>
            If the function succeeds, the return value is a window handle. If no window exists with the specified relationship to the
            specified window, the return value is <c>NULL</c>. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            The EnumChildWindows function is more reliable than calling <c>GetWindow</c> in a loop. An application that calls
            <c>GetWindow</c> to perform this task risks being caught in an infinite loop or referencing a handle to a window that has been destroyed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindow(Vanara.PInvoke.HWND,System.UInt32)">
            <summary>Retrieves a handle to a window that has the specified relationship (Z-Order or owner) to the specified window.</summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to a window. The window handle retrieved is relative to this window, based on the value of the uCmd parameter.</para>
            </param>
            <param name="uCmd">
            <para>Type: <c>UINT</c></para>
            <para>
            The relationship between the specified window and the window whose handle is to be retrieved. This parameter can be one of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>GW_CHILD 5</term>
            <term>
            The retrieved handle identifies the child window at the top of the Z order, if the specified window is a parent window;
            otherwise, the retrieved handle is NULL. The function examines only child windows of the specified window. It does not examine
            descendant windows.
            </term>
            </item>
            <item>
            <term>GW_ENABLEDPOPUP 6</term>
            <term>
            The retrieved handle identifies the enabled popup window owned by the specified window (the search uses the first such window
            found using GW_HWNDNEXT); otherwise, if there are no enabled popup windows, the retrieved handle is that of the specified window.
            </term>
            </item>
            <item>
            <term>GW_HWNDFIRST 0</term>
            <term>
            The retrieved handle identifies the window of the same type that is highest in the Z order. If the specified window is a topmost
            window, the handle identifies a topmost window. If the specified window is a top-level window, the handle identifies a top-level
            window. If the specified window is a child window, the handle identifies a sibling window.
            </term>
            </item>
            <item>
            <term>GW_HWNDLAST 1</term>
            <term>
            The retrieved handle identifies the window of the same type that is lowest in the Z order. If the specified window is a topmost
            window, the handle identifies a topmost window. If the specified window is a top-level window, the handle identifies a top-level
            window. If the specified window is a child window, the handle identifies a sibling window.
            </term>
            </item>
            <item>
            <term>GW_HWNDNEXT 2</term>
            <term>
            The retrieved handle identifies the window below the specified window in the Z order. If the specified window is a topmost
            window, the handle identifies a topmost window. If the specified window is a top-level window, the handle identifies a top-level
            window. If the specified window is a child window, the handle identifies a sibling window.
            </term>
            </item>
            <item>
            <term>GW_HWNDPREV 3</term>
            <term>
            The retrieved handle identifies the window above the specified window in the Z order. If the specified window is a topmost
            window, the handle identifies a topmost window. If the specified window is a top-level window, the handle identifies a top-level
            window. If the specified window is a child window, the handle identifies a sibling window.
            </term>
            </item>
            <item>
            <term>GW_OWNER 4</term>
            <term>The retrieved handle identifies the specified window's owner window, if any. For more information, see Owned Windows.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>
            If the function succeeds, the return value is a window handle. If no window exists with the specified relationship to the
            specified window, the return value is <c>NULL</c>. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            The EnumChildWindows function is more reliable than calling <c>GetWindow</c> in a loop. An application that calls
            <c>GetWindow</c> to perform this task risks being caught in an infinite loop or referencing a handle to a window that has been destroyed.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowContextHelpId(Vanara.PInvoke.HWND)">
            <summary>Retrieves the Help context identifier, if any, associated with the specified window.</summary>
            <param name="Arg1">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window for which the Help context identifier is to be retrieved.</para>
            </param>
            <returns>
            <para>Type: <c>DWORD</c></para>
            <para>Returns the Help context identifier if the window has one, or zero otherwise.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowDisplayAffinity(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.WindowDisplayAffinity@)">
            <summary>
            <para>Retrieves the current display affinity setting, from any process, for a given window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window.</para>
            </param>
            <param name="pdwAffinity">
            <para>Type: <c>DWORD*</c></para>
            <para>The display affinity setting.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>
            This function succeeds only when the window is layered and Desktop Windows Manager is composing the desktop. If this function
            succeeds, it returns <c>TRUE</c>; otherwise, it returns <c>FALSE</c>. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            This function currently only supports one flag, <c>WDA_MONITOR</c> (0x01). This flag enables a window's contents to be displayed
            only on the monitor.
            </para>
            <para>
            This function and SetWindowDisplayAffinity are designed to support the window content protection feature unique to Windows 7.
            This feature enables applications to protect their own onscreen window content from being captured or copied via a specific set
            of public operating system features and APIs. However, it works only when the Desktop Window Manager (DWM) is composing the desktop.
            </para>
            <para>
            It is important to note that unlike a security feature or an implementation of Digital Rights Management (DRM), there is no
            guarantee that using SetWindowDisplayAffinity and <c>GetWindowDisplayAffinity</c>, and other necessary functions such as
            DwmIsCompositionEnabled, will strictly protect windowed content, as in the case where someone takes a photograph of the screen.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowFeedbackSetting(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.FEEDBACK_TYPE,Vanara.PInvoke.User32.GWFS,System.UInt32@,System.Boolean@)">
            <summary>Retrieves the feedback configuration for a window.</summary>
            <param name="hwnd">The window to check for feedback configuration.</param>
            <param name="feedback">One of the values from the FEEDBACK_TYPE enumeration.</param>
            <param name="dwFlags">
            Specify GWFS_INCLUDE_ANCESTORS to check the parent window chain until a value is found. The default is 0 and indicates that only
            the specified window will be checked.
            </param>
            <param name="pSize">
            <para>The size of memory region that the config parameter points to.</para>
            <para>The pSize parameter specifies the size of the configuration data for the feedback type in feedback and must be sizeof(BOOL).</para>
            </param>
            <param name="config">
            <para>The configuration data.</para>
            <para>The config parameter must point to a value of type BOOL.</para>
            </param>
            <returns>
            Returns TRUE if the specified feedback setting is configured on the specified window. Otherwise, it returns FALSE (and config
            won't be modified).
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowInfo(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.WINDOWINFO@)">
            <summary>
            <para>Retrieves information about the specified window.</para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose information is to be retrieved.</para>
            </param>
            <param name="pwi">
            <para>Type: <c>PWINDOWINFO</c></para>
            <para>
            A pointer to a WINDOWINFO structure to receive the information. Note that you must set the <c>cbSize</c> member to before calling
            this function.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero.</para>
            <para>To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowModuleFileName(Vanara.PInvoke.HWND,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>Retrieves the full path and file name of the module associated with the specified window handle.</para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose module file name is to be retrieved.</para>
            </param>
            <param name="pszFileName">
            <para>Type: <c>LPTSTR</c></para>
            <para>The path and file name.</para>
            </param>
            <param name="cchFileNameMax">
            <para>Type: <c>UINT</c></para>
            <para>The maximum number of characters that can be copied into the lpszFileName buffer.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>UINT</c></c></para>
            <para>The return value is the total number of characters copied into the buffer.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowPlacement(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.WINDOWPLACEMENT@)">
            <summary>
            <para>Retrieves the show state and the restored, minimized, and maximized positions of the specified window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window.</para>
            </param>
            <param name="lpwndpl">
            <para>Type: <c>WINDOWPLACEMENT*</c></para>
            <para>
            A pointer to the WINDOWPLACEMENT structure that receives the show state and position information. Before calling
            <c>GetWindowPlacement</c>, set the <c>length</c> member to . <c>GetWindowPlacement</c> fails if lpwndpl-&gt; length is not set correctly.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>flags</c> member of WINDOWPLACEMENT retrieved by this function is always zero. If the window identified by the hWnd
            parameter is maximized, the <c>showCmd</c> member is SW_SHOWMAXIMIZED. If the window is minimized, <c>showCmd</c> is
            SW_SHOWMINIMIZED. Otherwise, it is SW_SHOWNORMAL.
            </para>
            <para>
            The <c>length</c> member of WINDOWPLACEMENT must be set to sizeof( <c>WINDOWPLACEMENT</c>). If this member is not set correctly,
            the function returns <c>FALSE</c>. For additional remarks on the proper use of window placement coordinates, see <c>WINDOWPLACEMENT</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowRect(Vanara.PInvoke.HWND,Vanara.PInvoke.RECT@)">
            <summary>
            Retrieves the dimensions of the bounding rectangle of the specified window. The dimensions are given in screen coordinates that
            are relative to the upper-left corner of the screen.
            </summary>
            <param name="hWnd">A handle to the window.</param>
            <param name="lpRect">
            A pointer to a RECT structure that receives the screen coordinates of the upper-left and lower-right corners of the window.
            </param>
            <returns>
            If the function succeeds, the return value is true. If the function fails, the return value is false. To get extended error
            information, call GetLastError.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowText(Vanara.PInvoke.HWND,System.Text.StringBuilder,System.Int32)">
            <summary>
            <para>
            Copies the text of the specified window's title bar (if it has one) into a buffer. If the specified window is a control, the text
            of the control is copied. However, <c>GetWindowText</c> cannot retrieve the text of a control in another application.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window or control containing the text.</para>
            </param>
            <param name="lpString">
            <para>Type: <c>LPTSTR</c></para>
            <para>
            The buffer that will receive the text. If the string is as long or longer than the buffer, the string is truncated and terminated
            with a null character.
            </para>
            </param>
            <param name="nMaxCount">
            <para>Type: <c>int</c></para>
            <para>
            The maximum number of characters to copy to the buffer, including the null character. If the text exceeds this limit, it is truncated.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>int</c></c></para>
            <para>
            If the function succeeds, the return value is the length, in characters, of the copied string, not including the terminating null
            character. If the window has no title bar or text, if the title bar is empty, or if the window or control handle is invalid, the
            return value is zero. To get extended error information, call GetLastError.
            </para>
            <para>This function cannot retrieve the text of an edit control in another application.</para>
            </returns>
            <remarks>
            <para>
            If the target window is owned by the current process, <c>GetWindowText</c> causes a WM_GETTEXT message to be sent to the
            specified window or control. If the target window is owned by another process and has a caption, <c>GetWindowText</c> retrieves
            the window caption text. If the window does not have a caption, the return value is a null string. This behavior is by design. It
            allows applications to call <c>GetWindowText</c> without becoming unresponsive if the process that owns the target window is not
            responding. However, if the target window is not responding and it belongs to the calling application, <c>GetWindowText</c> will
            cause the calling application to become unresponsive.
            </para>
            <para>To retrieve the text of a control in another process, send a WM_GETTEXT message directly instead of calling <c>GetWindowText</c>.</para>
            <para>Examples</para>
            <para>For an example, see Sending a Message.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowTextLength(Vanara.PInvoke.HWND)">
            <summary>
            <para>
            Retrieves the length, in characters, of the specified window's title bar text (if the window has a title bar). If the specified
            window is a control, the function retrieves the length of the text within the control. However, <c>GetWindowTextLength</c> cannot
            retrieve the length of the text of an edit control in another application.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window or control.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>int</c></c></para>
            <para>
            If the function succeeds, the return value is the length, in characters, of the text. Under certain conditions, this value may
            actually be greater than the length of the text. For more information, see the following Remarks section.
            </para>
            <para>If the window has no text, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the target window is owned by the current process, <c>GetWindowTextLength</c> causes a WM_GETTEXTLENGTH message to be sent to
            the specified window or control.
            </para>
            <para>
            Under certain conditions, the <c>GetWindowTextLength</c> function may return a value that is larger than the actual length of the
            text. This occurs with certain mixtures of ANSI and Unicode, and is due to the system allowing for the possible existence of
            double-byte character set (DBCS) characters within the text. The return value, however, will always be at least as large as the
            actual length of the text; you can thus always use it to guide buffer allocation. This behavior can occur when an application
            uses both ANSI functions and common dialogs, which use Unicode. It can also occur when an application uses the ANSI version of
            <c>GetWindowTextLength</c> with a window whose window procedure is Unicode, or the Unicode version of <c>GetWindowTextLength</c>
            with a window whose window procedure is ANSI. For more information on ANSI and ANSI functions, see Conventions for Function Prototypes.
            </para>
            <para>
            To obtain the exact length of the text, use the WM_GETTEXT, LB_GETTEXT, or CB_GETLBTEXT messages, or the GetWindowText function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetWindowThreadProcessId(Vanara.PInvoke.HWND,System.UInt32@)">
            <summary>
            <para>
            Retrieves the identifier of the thread that created the specified window and, optionally, the identifier of the process that
            created the window.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window.</para>
            </param>
            <param name="lpdwProcessId">
            <para>Type: <c>LPDWORD</c></para>
            <para>
            A pointer to a variable that receives the process identifier. If this parameter is not <c>NULL</c>,
            <c>GetWindowThreadProcessId</c> copies the identifier of the process to the variable; otherwise, it does not.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>DWORD</c></c></para>
            <para>The return value is the identifier of the thread that created the window.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.ImpersonateDdeClientWindow(Vanara.PInvoke.HWND,Vanara.PInvoke.HWND)">
            <summary>
            Enables a Dynamic Data Exchange (DDE) server application to impersonate a DDE client application's security context. This
            protects secure server data from unauthorized DDE clients.
            </summary>
            <param name="hWndClient">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the DDE client window to be impersonated. The client window must have established a DDE conversation with the server
            window identified by the hWndServer parameter.
            </para>
            </param>
            <param name="hWndServer">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the DDE server window. An application must create the server window before calling this function.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            An application should call the RevertToSelf function to undo the impersonation set by the <c>ImpersonateDdeClientWindow</c> function.
            </para>
            <para>A DDEML application should use the DdeImpersonateClient function.</para>
            <para>Security Considerations</para>
            <para>
            Using this function incorrectly might compromise the security of your program. It is very important to check the return value of
            the call. If the function fails for any reason, the client is not impersonated and any subsequent client request is made in the
            security context of the calling process. If the calling process is running as a highly privileged account, such as LocalSystem or
            as a member of an administrative group, the user may be able to perform actions that would otherwise be disallowed. Therefore, if
            the call fails or raises an error do not continue execution of the client request.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.InternalGetWindowText(Vanara.PInvoke.HWND,System.Text.StringBuilder,System.Int32)">
            <summary>
            <para>[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]</para>
            <para>Copies the text of the specified window's title bar (if it has one) into a buffer.</para>
            <para>
            This function is similar to the GetWindowText function. However, it obtains the window text directly from the window structure
            associated with the specified window's handle and then always provides the text as a Unicode string. This is unlike
            <c>GetWindowText</c> which obtains the text by sending the window a WM_GETTEXT message. If the specified window is a control, the
            text of the control is obtained.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window or control containing the text.</para>
            </param>
            <param name="pString">
            <para>Type: <c>LPWSTR</c></para>
            <para>The buffer that is to receive the text.</para>
            <para>If the string is as long or longer than the buffer, the string is truncated and terminated with a null character.</para>
            </param>
            <param name="cchMaxCount">
            <para>Type: <c>int</c></para>
            <para>
            The maximum number of characters to be copied to the buffer, including the null character. If the text exceeds this limit, it is truncated.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>int</c></c></para>
            <para>
            If the function succeeds, the return value is the length, in characters, of the copied string, not including the terminating null
            character. If the window has no title bar or text, if the title bar is empty, or if the window or control handle is invalid, the
            return value is zero. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            This function was not included in the SDK headers and libraries until Windows XP with Service Pack 1 (SP1) and Windows Server
            2003. If you do not have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsChild(Vanara.PInvoke.HWND,Vanara.PInvoke.HWND)">
            <summary>
            <para>
            Determines whether a window is a child window or descendant window of a specified parent window. A child window is the direct
            descendant of a specified parent window if that parent window is in the chain of parent windows; the chain of parent windows
            leads from the original overlapped or pop-up window to the child window.
            </para>
            </summary>
            <param name="hWndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the parent window.</para>
            </param>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be tested.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the window is a child or descendant window of the specified parent window, the return value is nonzero.</para>
            <para>If the window is not a child or descendant window of the specified parent window, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsGUIThread(System.Boolean)">
            <summary>
            <para>Determines whether the calling thread is already a GUI thread. It can also optionally convert the thread to a GUI thread.</para>
            </summary>
            <param name="bConvert">
            <para>Type: <c>BOOL</c></para>
            <para>If <c>TRUE</c> and the thread is not a GUI thread, convert the thread to a GUI thread.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>The function returns a nonzero value in the following situations:</para>
            <list type="bullet">
            <item>
            <term>If the calling thread is already a GUI thread.</term>
            </item>
            <item>
            <term>If bConvert is <c>TRUE</c> and the function successfully converts the thread to a GUI thread.</term>
            </item>
            </list>
            <para>Otherwise, the function returns zero.</para>
            <para>
            If bConvert is <c>TRUE</c> and the function cannot successfully convert the thread to a GUI thread, <c>IsGUIThread</c> returns <c>ERROR_NOT_ENOUGH_MEMORY</c>.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsHungAppWindow(Vanara.PInvoke.HWND)">
            <summary>
            <para>[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]</para>
            <para>
            Determines whether the system considers that a specified application is not responding. An application is considered to be not
            responding if it is not waiting for input, is not in startup processing, and has not called PeekMessage within the internal
            timeout period of 5 seconds.
            </para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be tested.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>
            The return value is <c>TRUE</c> if the window stops responding; otherwise, it is <c>FALSE</c>. Ghost windows always return <c>TRUE</c>.
            </para>
            </returns>
            <remarks>
            <para>The Windows timeout criteria of 5 seconds is subject to change.</para>
            <para>
            This function was not included in the SDK headers and libraries until Windows XP Service Pack 1 (SP1) and Windows Server 2003. If
            you do not have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsIconic(Vanara.PInvoke.HWND)">
            <summary>
            <para>Determines whether the specified window is minimized (iconic).</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be tested.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the window is iconic, the return value is nonzero.</para>
            <para>If the window is not iconic, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsProcessDPIAware">
            <summary>
            <para>[</para>
            <para>
            IsProcessDPIAware is available for use in the operating systems specified in the Requirements section. It may be altered or
            unavailable in subsequent versions. Instead, use GetProcessDPIAwareness.
            </para>
            <para>]</para>
            <para>
            Determines whether the current process is dots per inch (dpi) aware such that it adjusts the sizes of UI elements to compensate
            for the dpi setting.
            </para>
            </summary>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para><c>TRUE</c> if the process is dpi aware; otherwise, <c>FALSE</c>.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsWindow(Vanara.PInvoke.HWND)">
            <summary>
            <para>Determines whether the specified window handle identifies an existing window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be tested.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the window handle identifies an existing window, the return value is nonzero.</para>
            <para>If the window handle does not identify an existing window, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            A thread should not use <c>IsWindow</c> for a window that it did not create because the window could be destroyed after this
            function was called. Further, because window handles are recycled the handle could even point to a different window.
            </para>
            <para>Examples</para>
            <para>For an example, see Creating a Modeless Dialog Box.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsWindowEnabled(Vanara.PInvoke.HWND)">
            <summary>Determines whether the specified window is enabled for mouse and keyboard input.</summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be tested.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the window is enabled, the return value is nonzero.</para>
            <para>If the window is not enabled, the return value is zero.</para>
            </returns>
            <remarks>A child window receives input only if it is both enabled and visible.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsWindowRedirectedForPrint(Vanara.PInvoke.HWND)">
            <summary>
            The <c>IsWindowRedirectedForPrint</c> function determines whether the specified window is currently redirected for printing.
            </summary>
            <param name="hWnd">The h WND.</param>
            <returns>
            If the window is currently redirected for printing, the function returns a nonzero value; otherwise, it returns zero.
            </returns>
            <remarks>
            <para>
            A window is redirected for printing when it processes a call to <c>PrintWindow</c>. In a call to <c>PrintWindow</c>, a window
            renders its content to an off-screen device context.
            </para>
            <para>
            This function has no associated import library or header file; you must call it by using the <c>LoadLibrary</c> and
            <c>GetProcAddress</c> functions.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsWindowUnicode(Vanara.PInvoke.HWND)">
            <summary>
            <para>Determines whether the specified window is a native Unicode window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be tested.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the window is a native Unicode window, the return value is nonzero.</para>
            <para>If the window is not a native Unicode window, the return value is zero. The window is a native ANSI window.</para>
            </returns>
            <remarks>
            <para>
            The character set of a window is determined by the use of the RegisterClass function. If the window class was registered with the
            ANSI version of <c>RegisterClass</c> ( <c>RegisterClassA</c>), the character set of the window is ANSI. If the window class was
            registered with the Unicode version of <c>RegisterClass</c> ( <c>RegisterClassW</c>), the character set of the window is Unicode.
            </para>
            <para>
            The system does automatic two-way translation (Unicode to ANSI) for window messages. For example, if an ANSI window message is
            sent to a window that uses the Unicode character set, the system translates that message into a Unicode message before calling
            the window procedure. The system calls <c>IsWindowUnicode</c> to determine whether to translate the message.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsWindowVisible(Vanara.PInvoke.HWND)">
            <summary>
            <para>Determines the visibility state of the specified window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be tested.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>
            If the specified window, its parent window, its parent's parent window, and so forth, have the <c>WS_VISIBLE</c> style, the
            return value is nonzero. Otherwise, the return value is zero.
            </para>
            <para>
            Because the return value specifies whether the window has the <c>WS_VISIBLE</c> style, it may be nonzero even if the window is
            totally obscured by other windows.
            </para>
            </returns>
            <remarks>
            <para>
            The visibility state of a window is indicated by the <c>WS_VISIBLE</c> style bit. When <c>WS_VISIBLE</c> is set, the window is
            displayed and subsequent drawing into it is displayed as long as the window has the <c>WS_VISIBLE</c> style.
            </para>
            <para>
            Any drawing to a window with the <c>WS_VISIBLE</c> style will not be displayed if the window is obscured by other windows or is
            clipped by its parent window.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.IsZoomed(Vanara.PInvoke.HWND)">
            <summary>
            <para>Determines whether a window is maximized.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be tested.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the window is zoomed, the return value is nonzero.</para>
            <para>If the window is not zoomed, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.LockSetForegroundWindow(Vanara.PInvoke.User32.LSFW)">
            <summary>
            The foreground process can call the <c>LockSetForegroundWindow</c> function to disable calls to the SetForegroundWindow function.
            </summary>
            <param name="uLockCode">
            <para>Type: <c>UINT</c></para>
            <para>Specifies whether to enable or disable calls to SetForegroundWindow. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>LSFW_LOCK 1</term>
            <term>Disables calls to SetForegroundWindow.</term>
            </item>
            <item>
            <term>LSFW_UNLOCK 2</term>
            <term>Enables calls to SetForegroundWindow.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The system automatically enables calls to SetForegroundWindow if the user presses the ALT key or takes some action that causes
            the system itself to change the foreground window (for example, clicking a background window).
            </para>
            <para>
            This function is provided so applications can prevent other applications from making a foreground change that can interrupt its
            interaction with the user.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.LogicalToPhysicalPoint(Vanara.PInvoke.HWND,Vanara.PInvoke.POINT@)">
            <summary>
            <para>Converts the logical coordinates of a point in a window to physical coordinates.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose transform is used for the conversion. Top level windows are fully supported. In the case of child
            windows, only the area of overlap between the parent and the child window is converted.
            </para>
            </param>
            <param name="lpPoint">
            <para>Type: <c>LPPOINT</c></para>
            <para>
            A pointer to a POINT structure that specifies the logical coordinates to be converted. The new physical coordinates are copied
            into this structure if the function succeeds.
            </para>
            </param>
            <returns>
            <para>None</para>
            </returns>
            <remarks>
            <para>
            Windows Vista introduces the concept of physical coordinates. Desktop Window Manager (DWM) scales non-dots per inch (dpi) aware
            windows when the display is high dpi. The window seen on the screen corresponds to the physical coordinates. The application
            continues to work in logical space. Therefore, the application's view of the window is different from that which appears on the
            screen. For scaled windows, logical and physical coordinates are different.
            </para>
            <para>
            <c>LogicalToPhysicalPoint</c> is a transformation API that can be called by a process that declares itself as dpi aware. The
            function uses the window identified by the hWnd parameter and the logical coordinates given in the POINT structure to compute the
            physical coordinates.
            </para>
            <para>
            The <c>LogicalToPhysicalPoint</c> function replaces the logical coordinates in the POINT structure with the physical coordinates.
            The physical coordinates are relative to the upper-left corner of the screen. The coordinates have to be inside the client area
            of hWnd.
            </para>
            <para>
            On all platforms, <c>LogicalToPhysicalPoint</c> will fail on a window that has either 0 width or height; an application must
            first establish a non-0 width and height by calling, for example, MoveWindow. On some versions of Windows (including Windows 7),
            <c>LogicalToPhysicalPoint</c> will still fail if <c>MoveWindow</c> has been called after a call to ShowWindow with <c>SH_HIDE</c>
            has hidden the window.
            </para>
            <para>
            In Windows 8, system–DPI aware applications translate between physical and logical space using PhysicalToLogicalPoint and
            LogicalToPhysicalPoint. In Windows 8.1, the additional virtualization of the system and inter-process communications means that
            for the majority of applications, you do not need these APIs. As a result, in Windows 8.1, PhysicalToLogicalPoint and
            LogicalToPhysicalPoint no longer transform points. The system returns all points to an application in its own coordinate space.
            This behavior preserves functionality for the majority of applications, but there are some exceptions in which you must make
            changes to ensure that the application works as expected. In those cases, use PhysicalToLogicalPointForPerMonitorDPI and LogicalToPhysicalPointForPerMonitorDPI.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.MoveWindow(Vanara.PInvoke.HWND,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            <para>
            Changes the position and dimensions of the specified window. For a top-level window, the position and dimensions are relative to
            the upper-left corner of the screen. For a child window, they are relative to the upper-left corner of the parent window's client area.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window.</para>
            </param>
            <param name="X">
            <para>Type: <c>int</c></para>
            <para>The new position of the left side of the window.</para>
            </param>
            <param name="Y">
            <para>Type: <c>int</c></para>
            <para>The new position of the top of the window.</para>
            </param>
            <param name="nWidth">
            <para>Type: <c>int</c></para>
            <para>The new width of the window.</para>
            </param>
            <param name="nHeight">
            <para>Type: <c>int</c></para>
            <para>The new height of the window.</para>
            </param>
            <param name="bRepaint">
            <para>Type: <c>BOOL</c></para>
            <para>
            Indicates whether the window is to be repainted. If this parameter is <c>TRUE</c>, the window receives a message. If the
            parameter is <c>FALSE</c>, no repainting of any kind occurs. This applies to the client area, the nonclient area (including the
            title bar and scroll bars), and any part of the parent window uncovered as a result of moving a child window.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the bRepaint parameter is <c>TRUE</c>, the system sends the WM_PAINT message to the window procedure immediately after moving
            the window (that is, the <c>MoveWindow</c> function calls the UpdateWindow function). If bRepaint is <c>FALSE</c>, the
            application must explicitly invalidate or redraw any parts of the window and parent window that need redrawing.
            </para>
            <para>
            <c>MoveWindow</c> sends the WM_WINDOWPOSCHANGING, WM_WINDOWPOSCHANGED, WM_MOVE, WM_SIZE, and WM_NCCALCSIZE messages to the window.
            </para>
            <para>Examples</para>
            <para>For an example, see Creating, Enumerating, and Sizing Child Windows.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.NotifyWinEvent(System.UInt32,Vanara.PInvoke.HWND,System.Int32,System.Int32)">
            <summary>
            Signals the system that a predefined event occurred. If any client applications have registered a hook function for the event,
            the system calls the client's hook function.
            </summary>
            <param name="winEvent">The win event.</param>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>Handle to the window that contains the object that generated the event.</para>
            </param>
            <param name="idObject">
            <para>Type: <c>LONG</c></para>
            <para>
            Identifies the object that generated the event. This value is either one of the predefined object identifiers or a custom object
            ID value.
            </para>
            </param>
            <param name="idChild">
            <para>Type: <c>LONG</c></para>
            <para>
            Identifies whether the event was generated by an object or by a child element of the object. If this value is CHILDID_SELF, the
            event was generated by the object itself. If not CHILDID_SELF, this value is the child ID of the element that generated the event.
            </para>
            </param>
            <remarks>
            <para>
            Servers call this function to notify the system that an event has occurred. Microsoft Active Accessibility checks to see if any
            client applications have set hook procedures for the event and, if so, calls the appropriate hook procedures.
            </para>
            <para>If no hook procedures are registered for the event, the performance penalty for calling this function is minor.</para>
            <para>
            Servers call <c>NotifyWinEvent</c> to announce the event to the system after the event has occurred; they must never notify the
            system of an event before the event has occurred.
            </para>
            <para>
            When the client's hook procedure is called, it receives a number of parameters that describe the event and the object that
            generated the event. The hook procedure uses the AccessibleObjectFromEvent function to retrieve a pointer to the IAccessible
            interface of the object that generated the event.
            </para>
            <para>
            Servers may receive a WM_GETOBJECT message immediately after calling this function. This can happen if there are any in-context
            clients that call AccessibleObjectFromEvent in the event callback.
            </para>
            <para>
            When servers call this function, they must be ready to handle WM_GETOBJECT, return an IAccessible interface pointer, and handle
            any of the <c>IAccessible</c> methods.
            </para>
            <para>
            <c>Note to Server Developers:</c> When you call <c>NotifyWinEvent</c>, if any clients are listening for that event in-context,
            their event handlers, which typically send WM_GETOBJECT and call IAccessible methods, will execute before <c>NotifyWinEvent</c>
            returns. When you call <c>NotifyWinEvent</c>, you should be prepared to handle these calls, if they occur. If you need to do
            extra setup to allow for this, you should do so before you call <c>NotifyWinEvent</c>, not after.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.OpenIcon(Vanara.PInvoke.HWND)">
            <summary>
            <para>Restores a minimized (iconic) window to its previous size and position; it then activates the window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to be restored and activated.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para><c>OpenIcon</c> sends a WM_QUERYOPEN message to the given window.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.PhysicalToLogicalPoint(Vanara.PInvoke.HWND,Vanara.PInvoke.POINT@)">
            <summary>
            <para>Converts the physical coordinates of a point in a window to logical coordinates.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window whose transform is used for the conversion. Top level windows are fully supported. In the case of child
            windows, only the area of overlap between the parent and the child window is converted.
            </para>
            </param>
            <param name="lpPoint">
            <para>Type: <c>LPPOINT</c></para>
            <para>
            A pointer to a POINT structure that specifies the physical/screen coordinates to be converted. The new logical coordinates are
            copied into this structure if the function succeeds.
            </para>
            </param>
            <returns>
            <para>None</para>
            </returns>
            <remarks>
            <para>
            Windows Vista introduces the concept of physical coordinates. Desktop Window Manager (DWM) scales non-dots per inch (dpi) aware
            windows when the display is high dpi. The window seen on the screen corresponds to the physical coordinates. The application
            continues to work in logical space. Therefore, the application's view of the window is different from that which appears on the
            screen. For scaled windows, logical and physical coordinates are different.
            </para>
            <para>
            The function uses the window identified by the hWnd parameter and the physical coordinates given in the POINT structure to
            compute the logical coordinates. The logical coordinates are the unscaled coordinates that appear to the application in a
            programmatic way. In other words, the logical coordinates are the coordinates the application recognizes, which can be different
            from the physical coordinates. The API then replaces the physical coordinates with the logical coordinates. The new coordinates
            are in the world coordinates whose origin is (0, 0) on the desktop. The coordinates passed to the API have to be on the hWnd.
            </para>
            <para>The source coordinates are in device units.</para>
            <para>
            On all platforms, <c>PhysicalToLogicalPoint</c> will fail on a window that has either 0 width or height; an application must
            first establish a non-0 width and height by calling, for example, MoveWindow. On some versions of Windows (including Windows 7),
            <c>PhysicalToLogicalPoint</c> will still fail if <c>MoveWindow</c> has been called after a call to ShowWindow with <c>SH_HIDE</c>
            has hidden the window.
            </para>
            <para>
            In Windows 8, system–DPI aware applications translate between physical and logical space using PhysicalToLogicalPoint and
            LogicalToPhysicalPoint. In Windows 8.1, the additional virtualization of the system and inter-process communications means that
            for the majority of applications, you do not need these APIs. As a result, in Windows 8.1, PhysicalToLogicalPoint and
            LogicalToPhysicalPoint no longer transform points. The system returns all points to an application in its own coordinate space.
            This behavior preserves functionality for the majority of applications, but there are some exceptions in which you must make
            changes to ensure that the application works as expected. In those cases, use PhysicalToLogicalPointForPerMonitorDPI and LogicalToPhysicalPointForPerMonitorDPI.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.PrintWindow(Vanara.PInvoke.HWND,Vanara.PInvoke.HDC,Vanara.PInvoke.User32.PW)">
            <summary>
            The <c>PrintWindow</c> function copies a visual window into the specified device context (DC), typically a printer DC.
            </summary>
            <param name="hwnd">A handle to the window that will be copied.</param>
            <param name="hdcBlt">A handle to the device context.</param>
            <param name="nFlags">
            <para>The drawing options. It can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>PW_CLIENTONLY</term>
            <term>Only the client area of the window is copied to hdcBlt. By default, the entire window is copied.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>If the function succeeds, it returns a nonzero value.</para>
            <para>If the function fails, it returns zero.</para>
            </returns>
            <remarks>
            <para>
            <c>Note</c> This is a blocking or synchronous function and might not return immediately. How quickly this function returns
            depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that
            are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user
            interface could make the application appear to be unresponsive.
            </para>
            <para>
            The application that owns the window referenced by hWnd processes the <c>PrintWindow</c> call and renders the image in the device
            context that is referenced by hdcBlt. The application receives a WM_PRINT message or, if the <c>PW_PRINTCLIENT</c> flag is
            specified, a WM_PRINTCLIENT message. For more information, see <c>WM_PRINT</c> and <c>WM_PRINTCLIENT</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.RealChildWindowFromPoint(Vanara.PInvoke.HWND,Vanara.PInvoke.POINT)">
            <summary>
            <para>
            Retrieves a handle to the child window at the specified point. The search is restricted to immediate child windows; grandchildren
            and deeper descendant windows are not searched.
            </para>
            </summary>
            <param name="hwndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose child is to be retrieved.</para>
            </param>
            <param name="ptParentClientCoords">
            <para>Type: <c>POINT</c></para>
            <para>A POINT structure that defines the client coordinates of the point to be checked.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>The return value is a handle to the child window that contains the specified point.</para>
            </returns>
            <remarks>
            <para>
            <c>RealChildWindowFromPoint</c> treats <c>HTTRANSPARENT</c> areas of a standard control differently from other areas of the
            control; it returns the child window behind a transparent part of a control. In contrast, ChildWindowFromPoint treats
            <c>HTTRANSPARENT</c> areas of a control the same as other areas. For example, if the point is in a transparent area of a
            groupbox, <c>RealChildWindowFromPoint</c> returns the child window behind a groupbox, whereas <c>ChildWindowFromPoint</c> returns
            the groupbox. However, both APIs return a static field, even though it, too, returns <c>HTTRANSPARENT</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.RealGetWindowClass(Vanara.PInvoke.HWND,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>Retrieves a string that specifies the window type.</para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose type will be retrieved.</para>
            </param>
            <param name="ptszClassName">
            <para>Type: <c>LPTSTR</c></para>
            <para>A pointer to a string that receives the window type.</para>
            </param>
            <param name="cchClassNameMax">
            <para>Type: <c>UINT</c></para>
            <para>The length, in characters, of the buffer pointed to by the pszType parameter.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>UINT</c></c></para>
            <para>If the function succeeds, the return value is the number of characters copied to the specified buffer.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterClass(Vanara.PInvoke.User32.WNDCLASS@)">
            <summary>
            <para>Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function.</para>
            <para>
            <c>Note</c> The <c>RegisterClass</c> function has been superseded by the RegisterClassEx function. You can still use
            <c>RegisterClass</c>, however, if you do not need to set the class small icon.
            </para>
            </summary>
            <param name="lpWndClass">
            <para>Type: <c>const WNDCLASS*</c></para>
            <para>
            A pointer to a WNDCLASS structure. You must fill the structure with the appropriate class attributes before passing it to the function.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>ATOM</c></c></para>
            <para>
            If the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can
            only be used by the CreateWindow, CreateWindowEx, GetClassInfo, GetClassInfoEx, FindWindow, FindWindowEx, and UnregisterClass
            functions and the <c>IActiveIMMap::FilterClientWindows</c> method.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If you register the window class by using <c>RegisterClassA</c>, the application tells the system that the windows of the created
            class expect messages with text or character parameters to use the ANSI character set; if you register it by using
            <c>RegisterClassW</c>, the application requests that the system pass text parameters of messages as Unicode. The IsWindowUnicode
            function enables applications to query the nature of each window. For more information on ANSI and Unicode functions, see
            Conventions for Function Prototypes.
            </para>
            <para>All window classes that an application registers are unregistered when it terminates.</para>
            <para>
            No window classes registered by a DLL are unregistered when the DLL is unloaded. A DLL must explicitly unregister its classes
            when it is unloaded.
            </para>
            <para>Examples</para>
            <para>For an example, see Associating a Window Procedure with a Window Class.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterClassEx(Vanara.PInvoke.User32.WNDCLASSEX@)">
            <summary>Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function.</summary>
            <param name="Arg1">
            <para>Type: <c>const WNDCLASSEX*</c></para>
            <para>
            A pointer to a WNDCLASSEX structure. You must fill the structure with the appropriate class attributes before passing it to the function.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>ATOM</c></c></para>
            <para>
            If the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can
            only be used by the CreateWindow, CreateWindowEx, GetClassInfo, GetClassInfoEx, FindWindow, FindWindowEx, and UnregisterClass
            functions and the <c>IActiveIMMap::FilterClientWindows</c> method.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If you register the window class by using <c>RegisterClassExA</c>, the application tells the system that the windows of the
            created class expect messages with text or character parameters to use the ANSI character set; if you register it by using
            <c>RegisterClassExW</c>, the application requests that the system pass text parameters of messages as Unicode. The
            IsWindowUnicode function enables applications to query the nature of each window. For more information on ANSI and Unicode
            functions, see Conventions for Function Prototypes.
            </para>
            <para>All window classes that an application registers are unregistered when it terminates.</para>
            <para>
            No window classes registered by a DLL are unregistered when the DLL is unloaded. A DLL must explicitly unregister its classes
            when it is unloaded.
            </para>
            <para>Examples</para>
            <para>For an example, see Using Window Classes.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.RegisterShellHookWindow(Vanara.PInvoke.HWND)">
            <summary>
            <para>[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]</para>
            <para>Registers a specified Shell window to receive certain messages for events or notifications that are useful to Shell applications.</para>
            <para>
            The event messages received are only those sent to the Shell window associated with the specified window's desktop. Many of the
            messages are the same as those that can be received after calling the SetWindowsHookEx function and specifying <c>WH_SHELL</c>
            for the hook type. The difference with <c>RegisterShellHookWindow</c> is that the messages are received through the specified
            window's WindowProc and not through a call back procedure.
            </para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window to register for Shell hook messages.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para><c>TRUE</c> if the function succeeds; otherwise, <c>FALSE</c>.</para>
            </returns>
            <remarks>
            <para>
            As with normal window messages, the second parameter of the window procedure identifies the message as a
            <c>WM_SHELLHOOKMESSAGE</c>. However, for these Shell hook messages, the message value is not a pre-defined constant like other
            message IDs such as WM_COMMAND. The value must be obtained dynamically using a call to RegisterWindowMessage as shown here:
            </para>
            <para>
            This precludes handling these messages using a traditional switch statement which requires ID values that are known at compile
            time. For handling Shell hook messages, the normal practice is to code an If statement in the default section of your switch
            statement and then handle the message if the value of the message ID is the same as the value obtained from the
            RegisterWindowMessage call.
            </para>
            <para>
            The following table describes the wParam and lParam parameter values passed to the window procedure for the Shell hook messages.
            </para>
            <list type="table">
            <listheader>
            <term>wParam</term>
            <term>lParam</term>
            </listheader>
            <item>
            <term>HSHELL_GETMINRECT</term>
            <term>A pointer to a SHELLHOOKINFO structure.</term>
            </item>
            <item>
            <term>HSHELL_WINDOWACTIVATED</term>
            <term>A handle to the activated window.</term>
            </item>
            <item>
            <term>HSHELL_RUDEAPPACTIVATED</term>
            <term>A handle to the activated window.</term>
            </item>
            <item>
            <term>HSHELL_WINDOWREPLACING</term>
            <term>A handle to the window replacing the top-level window.</term>
            </item>
            <item>
            <term>HSHELL_WINDOWREPLACED</term>
            <term>A handle to the window being replaced.</term>
            </item>
            <item>
            <term>HSHELL_WINDOWCREATED</term>
            <term>A handle to the window being created.</term>
            </item>
            <item>
            <term>HSHELL_WINDOWDESTROYED</term>
            <term>A handle to the top-level window being destroyed.</term>
            </item>
            <item>
            <term>HSHELL_ACTIVATESHELLWINDOW</term>
            <term>Not used.</term>
            </item>
            <item>
            <term>HSHELL_TASKMAN</term>
            <term>Can be ignored.</term>
            </item>
            <item>
            <term>HSHELL_REDRAW</term>
            <term>A handle to the window that needs to be redrawn.</term>
            </item>
            <item>
            <term>HSHELL_FLASH</term>
            <term>A handle to the window that needs to be flashed.</term>
            </item>
            <item>
            <term>HSHELL_ENDTASK</term>
            <term>A handle to the window that should be forced to exit.</term>
            </item>
            <item>
            <term>HSHELL_APPCOMMAND</term>
            <term>
            The APPCOMMAND which has been unhandled by the application or other hooks. See WM_APPCOMMAND and use the GET_APPCOMMAND_LPARAM
            macro to retrieve this parameter.
            </term>
            </item>
            <item>
            <term>HSHELL_MONITORCHANGED</term>
            <term>A handle to the window that moved to a different monitor.</term>
            </item>
            </list>
            <para>
            This function was not included in the SDK headers and libraries until Windows XP with Service Pack 1 (SP1) and Windows Server
            2003. If you do not have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ReleaseCapture">
            <summary>
            Releases the mouse capture from a window in the current thread and restores normal mouse input processing. A window that has
            captured the mouse receives all mouse input, regardless of the position of the cursor, except when a mouse button is clicked
            while the cursor hot spot is in the window of another thread.
            </summary>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>An application calls this function after calling the SetCapture function.</para>
            <para>Examples</para>
            <para>For an example, see Drawing Lines with the Mouse.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetActiveWindow(Vanara.PInvoke.HWND)">
            <summary>Activates a window. The window must be attached to the calling thread's message queue.</summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the top-level window to be activated.</para>
            </param>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>If the function succeeds, the return value is the handle to the window that was previously active.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The <c>SetActiveWindow</c> function activates a window, but not if the application is in the background. The window will be
            brought into the foreground (top of Z-Order) if its application is in the foreground when the system activates the window.
            </para>
            <para>
            If the window identified by the hWnd parameter was created by the calling thread, the active window status of the calling thread
            is set to hWnd. Otherwise, the active window status of the calling thread is set to <c>NULL</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetAdditionalForegroundBoostProcesses(Vanara.PInvoke.HWND,System.UInt32,Vanara.PInvoke.HPROCESS[])">
             <summary>
             <note type="warning"><c>SetAdditionalForegroundBoostProcesses</c> is a <c>limited access feature</c>. Contact
             foregroundboostprocs@microsoft.com for more information.</note>
             <para>
             SetAdditionalForegroundBoostProcesses is a performance assist API to help applications with a multi-process application model
             where multiple processes contribute to a foreground experience, either as data or rendering. Examples include browsers (with the
             browser manager or frame, tabs, plugins, etc. hosted in different processes) and IDEs (which spawn processes for compilation and
             other tasks).
             </para>
             <para>
             Applications can use this API to provide a foreground priority boost to worker processes that help support the main application.
             Such applications can have a uniform priority boost applied to all of their constituent processes when the application's top
             level window is in the foreground.
             </para>
             </summary>
             <param name="topLevelWindow">A handle to the top level window (HWND) of the application.</param>
             <param name="processHandleCount">
             The number of process handles in <c>processHandleArray</c>. This function can be called at a single time with a maximum of 32
             handles. Set this parameter to <c>0</c> along with setting <c>processHandleArray</c> to <c>NULL</c> to clear a prior boost configuration.
             </param>
             <param name="processHandleArray">
             A group of process handles to be foreground boosted or de-boosted. Set this parameter to <c>NULL</c> along with setting
             <c>processHandleCount</c> to <c>0</c> to clear a prior boost configuration.
             </param>
             <returns>
             Returns <c>TRUE</c> if the call succeeds in boosting the application, <c>FALSE</c> otherwise.
             <c>SetAdditionalForegroundBoostProcesses</c> sets the last error code, so the application can call GetLastError() to obtain
             extended information if the call failed (for example, ERROR_INVALID_PARAMETER, ERROR_NOT_ENOUGH_MEMORY, or ERROR_ACCESS_DENIED).
             </returns>
             <remarks>
             <para>
             This function takes a group of process handles that all get foreground boosted or de-boosted when the passed-in top level HWND
             moves to the foreground or background respectively. Whenever the passed-in top level HWND becomes the foreground window, a
             foreground boost will also be applied to the processes passed in the handle array. A similar de-boost happens when the top level
             HWND moves to the background.
             </para>
             <para>
             The top level HWND passed to this function must be owned by the calling process. The calling process should have the
             <c>PROCESS_SET_INFORMATION</c> access right on the process handles in the <c>processHandleArray</c> - in other words, you must
             have full control of every window in your process. If some external component injects a window that takes foreground, or if a
             dialog box appears, then you lose your boost.
             </para>
             <para>If you have two top level windows, you need to call this function for each one.</para>
             <para>
             If the passed-in top level HWND is already in the foreground when <c>SetAdditionalForegroundBoostProcesses</c> is called, all of
             the processes in the <c>processHandleArray</c> are immediately boosted.
             </para>
             <para>
             A process whose handle is in the <c>processHandleArray</c> will get a foreground boost only when the top level HWND becomes the
             foreground window.
             </para>
             <para>Additional foreground boost is applied only when:</para>
             <list type="number">
             <item>
             <term>The foreground window changes, or</term>
             </item>
             <item>
             <term>
             If this function is called while the window is in the foreground and the new list has the process handle, or the list does not
             include the process handle while it was previously included.
             </term>
             </item>
             </list>
             <para>
             When the process owning the top level HWND exits or terminates, the additional boosting relationship is torn down and secondary
             processes do not receive any additional foreground boosting.
             </para>
             <para>
             The primary process's top level HWND will continue to hold references to secondary processes until either the primary process's
             top level HWND clears its grouped boost state, or the HWND is destroyed.
             </para>
             </remarks>
             <example>
             <para>
             In this simple scenario, the application sets up its foreground process boost configuration when the top level window is created.
             When WM_CREATE is handled, the function is called with handles in the lParam and the count of handles in the wParam. These
             processes will get foreground or background priority boosted as m_AppWindow moves in and out of being the foreground window. If
             the m_AppWindow is the foreground window when the function is called, the processes will also get an immediate foreground
             priority boost.
             </para>
             <code language="cpp"><![CDATA[case WM_CREATE:   
            
            	  // 
            	  // Configure the passed in worker processes (handles) in lParam, to get foreground priority boost when m_AppWindow moves in and 
            	  // out of the foreground. 
            	  //  
            	  
            	  HANDLE* pMyHandles = retinterpret_cast<HANDLE*>(lParam);
            	  DWORD cHandles = reinterpret_cast<DWORD>(wParam);
            	  
            	  if (!SetAdditionalForegroundBoostProcesses(m_AppWindow, cHandles, pMyHandles))
            	  {
            	  	printf(“SetAdditionalForegroundBoostProcesses() setup failed with error code: % d\n”, GetLastError());
            	  } 
            	  
               break;]]></code>
             </example>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetCapture(Vanara.PInvoke.HWND)">
            <summary>
            <para>
            Sets the mouse capture to the specified window belonging to the current thread. <c>SetCapture</c> captures mouse input either
            when the mouse is over the capturing window, or when the mouse button was pressed while the mouse was over the capturing window
            and the button is still down. Only one window at a time can capture the mouse.
            </para>
            <para>
            If the mouse cursor is over a window created by another thread, the system will direct mouse input to the specified window only
            if a mouse button is down.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window in the current thread that is to capture the mouse.</para>
            </param>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>
            The return value is a handle to the window that had previously captured the mouse. If there is no such window, the return value
            is <c>NULL</c>.
            </para>
            </returns>
            <remarks>
            <para>
            Only the foreground window can capture the mouse. When a background window attempts to do so, the window receives messages only
            for mouse events that occur when the cursor hot spot is within the visible portion of the window. Also, even if the foreground
            window has captured the mouse, the user can still click another window, bringing it to the foreground.
            </para>
            <para>
            When the window no longer requires all mouse input, the thread that created the window should call the ReleaseCapture function to
            release the mouse.
            </para>
            <para>This function cannot be used to capture mouse input meant for another process.</para>
            <para>When the mouse is captured, menu hotkeys and other keyboard accelerators do not work.</para>
            <para>Examples</para>
            <para>For an example, see Drawing Lines with the Mouse.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetClassLong(Vanara.PInvoke.HWND,System.Int32,System.IntPtr)">
            <summary>
            Replaces the specified value at the specified offset in the extra class memory or the WNDCLASSEX structure for the class to which
            the specified window belongs.
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
            </param>
            <param name="nIndex">
            <para>Type: <c>int</c></para>
            <para>
            The value to be replaced. To set a value in the extra class memory, specify the positive, zero-based byte offset of the value to
            be set. Valid values are in the range zero through the number of bytes of extra class memory, minus eight; for example, if you
            specified 24 or more bytes of extra class memory, a value of 16 would be an index to the third integer. To set a value other than
            the WNDCLASSEX structure, specify one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>GCL_CBCLSEXTRA -20</term>
            <term>
            Sets the size, in bytes, of the extra memory associated with the class. Setting this value does not change the number of extra
            bytes already allocated.
            </term>
            </item>
            <item>
            <term>GCL_CBWNDEXTRA -18</term>
            <term>
            Sets the size, in bytes, of the extra window memory associated with each window in the class. Setting this value does not change
            the number of extra bytes already allocated. For information on how to access this memory, see SetWindowLongPtr.
            </term>
            </item>
            <item>
            <term>GCLP_ HBRBACKGROUND -10</term>
            <term>Replaces a handle to the background brush associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HCURSOR -12</term>
            <term>Replaces a handle to the cursor associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HICON -14</term>
            <term>Replaces a handle to the icon associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HICONSM -34</term>
            <term>Retrieves a handle to the small icon associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HMODULE -16</term>
            <term>Replaces a handle to the module that registered the class.</term>
            </item>
            <item>
            <term>GCLP_MENUNAME -8</term>
            <term>Replaces the pointer to the menu name string. The string identifies the menu resource associated with the class.</term>
            </item>
            <item>
            <term>GCL_STYLE -26</term>
            <term>Replaces the window-class style bits.</term>
            </item>
            <item>
            <term>GCLP_WNDPROC -24</term>
            <term>Replaces the pointer to the window procedure associated with the class.</term>
            </item>
            </list>
            </param>
            <param name="dwNewLong">
            <para>Type: <c>LONG_PTR</c></para>
            <para>The replacement value.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>ULONG_PTR</c></c></para>
            <para>
            If the function succeeds, the return value is the previous value of the specified offset. If this was not previously set, the
            return value is zero.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If you use the <c>SetClassLongPtr</c> function and the <c>GCLP_WNDPROC</c> index to replace the window procedure, the window
            procedure must conform to the guidelines specified in the description of the WindowProc callback function.
            </para>
            <para>
            Calling <c>SetClassLongPtr</c> with the <c>GCLP_WNDPROC</c> index creates a subclass of the window class that affects all windows
            subsequently created with the class. An application can subclass a system class, but should not subclass a window class created
            by another process.
            </para>
            <para>
            Reserve extra class memory by specifying a nonzero value in the <c>cbClsExtra</c> member of the WNDCLASSEX structure used with
            the RegisterClassEx function.
            </para>
            <para>
            Use the <c>SetClassLongPtr</c> function with care. For example, it is possible to change the background color for a class by
            using <c>SetClassLongPtr</c>, but this change does not immediately repaint all windows belonging to the class.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetClassLong(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.GetClassLongFlag,System.IntPtr)">
            <summary>
            Replaces the specified value at the specified offset in the extra class memory or the WNDCLASSEX structure for the class to which
            the specified window belongs.
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
            </param>
            <param name="nIndex">
            <para>Type: <c>int</c></para>
            <para>
            The value to be replaced. To set a value in the extra class memory, specify the positive, zero-based byte offset of the value to
            be set. Valid values are in the range zero through the number of bytes of extra class memory, minus eight; for example, if you
            specified 24 or more bytes of extra class memory, a value of 16 would be an index to the third integer. To set a value other than
            the WNDCLASSEX structure, specify one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>GCL_CBCLSEXTRA -20</term>
            <term>
            Sets the size, in bytes, of the extra memory associated with the class. Setting this value does not change the number of extra
            bytes already allocated.
            </term>
            </item>
            <item>
            <term>GCL_CBWNDEXTRA -18</term>
            <term>
            Sets the size, in bytes, of the extra window memory associated with each window in the class. Setting this value does not change
            the number of extra bytes already allocated. For information on how to access this memory, see SetWindowLongPtr.
            </term>
            </item>
            <item>
            <term>GCLP_ HBRBACKGROUND -10</term>
            <term>Replaces a handle to the background brush associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HCURSOR -12</term>
            <term>Replaces a handle to the cursor associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HICON -14</term>
            <term>Replaces a handle to the icon associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HICONSM -34</term>
            <term>Retrieves a handle to the small icon associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HMODULE -16</term>
            <term>Replaces a handle to the module that registered the class.</term>
            </item>
            <item>
            <term>GCLP_MENUNAME -8</term>
            <term>Replaces the pointer to the menu name string. The string identifies the menu resource associated with the class.</term>
            </item>
            <item>
            <term>GCL_STYLE -26</term>
            <term>Replaces the window-class style bits.</term>
            </item>
            <item>
            <term>GCLP_WNDPROC -24</term>
            <term>Replaces the pointer to the window procedure associated with the class.</term>
            </item>
            </list>
            </param>
            <param name="dwNewLong">
            <para>Type: <c>LONG_PTR</c></para>
            <para>The replacement value.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>ULONG_PTR</c></c></para>
            <para>
            If the function succeeds, the return value is the previous value of the specified offset. If this was not previously set, the
            return value is zero.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If you use the <c>SetClassLongPtr</c> function and the <c>GCLP_WNDPROC</c> index to replace the window procedure, the window
            procedure must conform to the guidelines specified in the description of the WindowProc callback function.
            </para>
            <para>
            Calling <c>SetClassLongPtr</c> with the <c>GCLP_WNDPROC</c> index creates a subclass of the window class that affects all windows
            subsequently created with the class. An application can subclass a system class, but should not subclass a window class created
            by another process.
            </para>
            <para>
            Reserve extra class memory by specifying a nonzero value in the <c>cbClsExtra</c> member of the WNDCLASSEX structure used with
            the RegisterClassEx function.
            </para>
            <para>
            Use the <c>SetClassLongPtr</c> function with care. For example, it is possible to change the background color for a class by
            using <c>SetClassLongPtr</c>, but this change does not immediately repaint all windows belonging to the class.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetClassWord(Vanara.PInvoke.HWND,System.Int32,System.UInt16)">
            <summary>
            <para>
            Replaces the 16-bit ( <c>WORD</c>) value at the specified offset into the extra class memory for the window class to which the
            specified window belongs.
            </para>
            <para>
            <c>Note</c> This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the
            SetClassLong function.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
            </param>
            <param name="nIndex">
            <para>Type: <c>int</c></para>
            <para>
            The zero-based byte offset of the value to be replaced. Valid values are in the range zero through the number of bytes of class
            memory minus two; for example, if you specified 10 or more bytes of extra class memory, a value of 8 would be an index to the
            fifth 16-bit integer.
            </para>
            </param>
            <param name="wNewWord">
            <para>Type: <c>WORD</c></para>
            <para>The replacement value.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>WORD</c></c></para>
            <para>
            If the function succeeds, the return value is the previous value of the specified 16-bit integer. If the value was not previously
            set, the return value is zero.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            Reserve extra class memory by specifying a nonzero value in the <c>cbClsExtra</c> member of the WNDCLASS structure used with the
            RegisterClass function.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetFocus(Vanara.PInvoke.HWND)">
            <summary>Sets the keyboard focus to the specified window. The window must be attached to the calling thread's message queue.</summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that will receive the keyboard input. If this parameter is <c>NULL</c>, keystrokes are ignored.</para>
            </param>
            <returns>
            <para>Type: <c>HWND</c></para>
            <para>
            If the function succeeds, the return value is the handle to the window that previously had the keyboard focus. If the hWnd
            parameter is invalid or the window is not attached to the calling thread's message queue, the return value is <c>NULL</c>. To get
            extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            The <c>SetFocus</c> function sends a WM_KILLFOCUS message to the window that loses the keyboard focus and a WM_SETFOCUS message
            to the window that receives the keyboard focus. It also activates either the window that receives the focus or the parent of the
            window that receives the focus.
            </para>
            <para>
            If a window is active but does not have the focus, any key pressed will produce the WM_SYSCHAR, WM_SYSKEYDOWN, or WM_SYSKEYUP
            message. If the <c>VK_MENU</c> key is also pressed, the
            </para>
            <para>
            By using the AttachThreadInput function, a thread can attach its input processing to another thread. This allows a thread to call
            <c>SetFocus</c> to set the keyboard focus to a window attached to another thread's message queue.
            </para>
            <para>Examples</para>
            <para>For an example, see Initializing a Dialog Box.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetForegroundWindow(Vanara.PInvoke.HWND)">
            <summary>
            <para>
            Brings the thread that created the specified window into the foreground and activates the window. Keyboard input is directed to
            the window, and various visual cues are changed for the user. The system assigns a slightly higher priority to the thread that
            created the foreground window than it does to other threads.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that should be activated and brought to the foreground.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the window was brought to the foreground, the return value is nonzero.</para>
            <para>If the window was not brought to the foreground, the return value is zero.</para>
            </returns>
            <remarks>
            <para>
            The system restricts which processes can set the foreground window. A process can set the foreground window only if one of the
            following conditions is true:
            </para>
            <list type="bullet">
            <item>
            <term>The process is the foreground process.</term>
            </item>
            <item>
            <term>The process was started by the foreground process.</term>
            </item>
            <item>
            <term>The process received the last input event.</term>
            </item>
            <item>
            <term>There is no foreground process.</term>
            </item>
            <item>
            <term>The process is being debugged.</term>
            </item>
            <item>
            <term>The foreground process is not a Modern Application or the Start Screen.</term>
            </item>
            <item>
            <term>The foreground is not locked (see LockSetForegroundWindow).</term>
            </item>
            <item>
            <term>The foreground lock time-out has expired (see <c>SPI_GETFOREGROUNDLOCKTIMEOUT</c> in SystemParametersInfo).</term>
            </item>
            <item>
            <term>No menus are active.</term>
            </item>
            </list>
            <para>
            An application cannot force a window to the foreground while the user is working with another window. Instead, Windows flashes
            the taskbar button of the window to notify the user.
            </para>
            <para>
            A process that can set the foreground window can enable another process to set the foreground window by calling the
            AllowSetForegroundWindow function. The process specified by dwProcessId loses the ability to set the foreground window the next
            time the user generates input, unless the input is directed at that process, or the next time a process calls
            <c>AllowSetForegroundWindow</c>, unless that process is specified.
            </para>
            <para>The foreground process can disable calls to <c>SetForegroundWindow</c> by calling the LockSetForegroundWindow function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetLayeredWindowAttributes(Vanara.PInvoke.HWND,Vanara.PInvoke.COLORREF,System.Byte,Vanara.PInvoke.User32.LayeredWindowAttributes)">
            <summary>
            <para>Sets the opacity and transparency color key of a layered window.</para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the layered window. A layered window is created by specifying <c>WS_EX_LAYERED</c> when creating the window with the
            CreateWindowEx function or by setting <c>WS_EX_LAYERED</c> via SetWindowLong after the window has been created.
            </para>
            <para>
            <c>Windows 8:</c> The <c>WS_EX_LAYERED</c> style is supported for top-level windows and child windows. Previous Windows versions
            support <c>WS_EX_LAYERED</c> only for top-level windows.
            </para>
            </param>
            <param name="crKey">
            <para>Type: <c>COLORREF</c></para>
            <para>
            A COLORREF structure that specifies the transparency color key to be used when composing the layered window. All pixels painted
            by the window in this color will be transparent. To generate a <c>COLORREF</c>, use the RGB macro.
            </para>
            </param>
            <param name="bAlpha">
            <para>Type: <c>BYTE</c></para>
            <para>
            Alpha value used to describe the opacity of the layered window. Similar to the <c>SourceConstantAlpha</c> member of the
            BLENDFUNCTION structure. When bAlpha is 0, the window is completely transparent. When bAlpha is 255, the window is opaque.
            </para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>An action to be taken. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>LWA_ALPHA 0x00000002</term>
            <term>Use bAlpha to determine the opacity of the layered window.</term>
            </item>
            <item>
            <term>LWA_COLORKEY 0x00000001</term>
            <term>Use crKey as the transparency color.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Note that once <c>SetLayeredWindowAttributes</c> has been called for a layered window, subsequent UpdateLayeredWindow calls will
            fail until the layering style bit is cleared and set again.
            </para>
            <para>For more information, see Using Layered Windows.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetParent(Vanara.PInvoke.HWND,Vanara.PInvoke.HWND)">
            <summary>
            <para>Changes the parent window of the specified child window.</para>
            </summary>
            <param name="hWndChild">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the child window.</para>
            </param>
            <param name="hWndNewParent">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the new parent window. If this parameter is <c>NULL</c>, the desktop window becomes the new parent window. If this
            parameter is <c>HWND_MESSAGE</c>, the child window becomes a message-only window.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>If the function succeeds, the return value is a handle to the previous parent window.</para>
            <para>If the function fails, the return value is <c>NULL</c>. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>An application can use the <c>SetParent</c> function to set the parent window of a pop-up, overlapped, or child window.</para>
            <para>If the window identified by the hWndChild parameter is visible, the system performs the appropriate redrawing and repainting.</para>
            <para>
            For compatibility reasons, <c>SetParent</c> does not modify the <c>WS_CHILD</c> or <c>WS_POPUP</c> window styles of the window
            whose parent is being changed. Therefore, if hWndNewParent is <c>NULL</c>, you should also clear the <c>WS_CHILD</c> bit and set
            the <c>WS_POPUP</c> style after calling <c>SetParent</c>. Conversely, if hWndNewParent is not <c>NULL</c> and the window was
            previously a child of the desktop, you should clear the <c>WS_POPUP</c> style and set the <c>WS_CHILD</c> style before calling <c>SetParent</c>.
            </para>
            <para>
            When you change the parent of a window, you should synchronize the UISTATE of both windows. For more information, see
            WM_CHANGEUISTATE and WM_UPDATEUISTATE.
            </para>
            <para>
            Unexpected behavior or errors may occur if hWndNewParent and hWndChild are running in different DPI awareness modes. The table
            below outlines this behavior:
            </para>
            <list type="table">
            <listheader>
            <term>Operation</term>
            <term>Windows 8.1</term>
            <term>Windows 10 (1607 and earlier)</term>
            <term>Windows 10 (1703 and later)</term>
            </listheader>
            <item>
            <term>SetParent (In-Proc)</term>
            <term>N/A</term>
            <term>Forced reset (of current process)</term>
            <term>Fail (ERROR_INVALID_STATE)</term>
            </item>
            <item>
            <term>SetParent (Cross-Proc)</term>
            <term>Forced reset (of child window's process)</term>
            <term>Forced reset (of child window's process)</term>
            <term>Forced reset (of child window's process)</term>
            </item>
            </list>
            <para>For more information on DPI awareness, see the Windows High DPI documentation.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetProcessDefaultLayout(Vanara.PInvoke.User32.DefaultLayout)">
            <summary>
            <para>Changes the default layout when windows are created with no parent or owner only for the currently running process.</para>
            </summary>
            <param name="dwDefaultLayout">
            <para>Type: <c>DWORD</c></para>
            <para>The default process layout. This parameter can be 0 or the following value.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>LAYOUT_RTL 0x00000001</term>
            <term>Sets the default horizontal layout to be right to left.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The layout specifies how text and graphics are laid out; the default is left to right. The <c>SetProcessDefaultLayout</c>
            function changes layout to be right to left, which is the standard in Arabic and Hebrew cultures.
            </para>
            <para>
            After the <c>LAYOUT_RTL</c> flag is selected, flags normally specifying right or left are reversed. To avoid confusion, consider
            defining alternate words for standard flags, such as those in the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Standard flag</term>
            <term>Suggested alternate name</term>
            </listheader>
            <item>
            <term>WS_EX_RIGHT</term>
            <term>WS_EX_TRAILING</term>
            </item>
            <item>
            <term>WS_EX_RTLREADING</term>
            <term>WS_EX_REVERSEREADING</term>
            </item>
            <item>
            <term>WS_EX_LEFTSCROLLBAR</term>
            <term>WS_EX_LEADSCROLLBAR</term>
            </item>
            <item>
            <term>ES_LEFT</term>
            <term>ES_LEAD</term>
            </item>
            <item>
            <term>ES_RIGHT</term>
            <term>ES_TRAIL</term>
            </item>
            <item>
            <term>EC_LEFTMARGIN</term>
            <term>EC_LEADMARGIN</term>
            </item>
            <item>
            <term>EC_RIGHTMARGIN</term>
            <term>EC_TRAILMARGIN</term>
            </item>
            </list>
            <para>
            If using this function with a mirrored window, note that the <c>SetProcessDefaultLayout</c> function does not mirror the whole
            process and all the device contexts (DCs) created in it. It mirrors only the mirrored window's DCs. To mirror any DC, use the
            SetLayout function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetProcessDPIAware">
            <summary>
            <para>This function has no parameters.</para>
            </summary>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero. Otherwise, the return value is zero.</para>
            </returns>
            <remarks>
            <para>For more information, see Setting the default DPI awareness for a process.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetWindowContextHelpId(Vanara.PInvoke.HWND,System.UInt32)">
            <summary>Associates a Help context identifier with the specified window.</summary>
            <param name="arg1">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window with which to associate the Help context identifier.</para>
            </param>
            <param name="arg2">
            <para>Type: <c>DWORD</c></para>
            <para>The Help context identifier.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns nonzero if successful, or zero otherwise.</para>
            <para>To retrieve extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            If a child window does not have a Help context identifier, it inherits the identifier of its parent window. Likewise, if an owned
            window does not have a Help context identifier, it inherits the identifier of its owner window. This inheritance of Help context
            identifiers allows an application to set just one identifier for a dialog box and all of its controls.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetWindowDisplayAffinity(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.WindowDisplayAffinity)">
            <summary>
            <para>Stores the display affinity setting in kernel mode on the hWnd associated with the window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window.</para>
            </param>
            <param name="dwAffinity">
            <para>Type: <c>DWORD</c></para>
            <para>
            The display affinity setting. This setting specifies where the window's contents are can be displayed. Set this value to
            WDA_MONITOR to display the window's contents only on a monitor.
            </para>
            <para>Set this value to WDA_NONE to remove the monitor-only affinity.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>
            If the function succeeds, it returns <c>TRUE</c>; otherwise, it returns <c>FALSE</c> when, for example, the function call is made
            on a non top-level window. To get extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            This function and GetWindowDisplayAffinity are designed to support the window content protection feature that is new to Windows
            7. This feature enables applications to protect their own onscreen window content from being captured or copied through a
            specific set of public operating system features and APIs. However, it works only when the Desktop Window Manager(DWM) is
            composing the desktop.
            </para>
            <para>
            It is important to note that unlike a security feature or an implementation of Digital Rights Management (DRM), there is no
            guarantee that using <c>SetWindowDisplayAffinity</c> and GetWindowDisplayAffinity, and other necessary functions such as
            DwmIsCompositionEnabled, will strictly protect windowed content, for example where someone takes a photograph of the screen.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetWindowFeedbackSetting(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.FEEDBACK_TYPE,System.UInt32,System.UInt32,System.IntPtr)">
            <summary>Sets the feedback configuration for a window.</summary>
            <param name="hwnd">The window to configure feedback on.</param>
            <param name="feedback">One of the values from the FEEDBACK_TYPE enumeration.</param>
            <param name="dwFlags">Reserved. Must be 0.</param>
            <param name="size">
            The size, in bytes, of the configuration data. Must be sizeof(BOOL) or 0 if the feedback setting is being reset.
            </param>
            <param name="configuration">The configuration data. Must be BOOL or NULL if the feedback setting is being reset.</param>
            <returns>Returns TRUE if successful; otherwise, returns FALSE.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetWindowPlacement(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.WINDOWPLACEMENT@)">
            <summary>
            <para>Sets the show state and the restored, minimized, and maximized positions of the specified window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window.</para>
            </param>
            <param name="lpwndpl">
            <para>Type: <c>const WINDOWPLACEMENT*</c></para>
            <para>A pointer to a WINDOWPLACEMENT structure that specifies the new show state and window positions.</para>
            <para>
            Before calling <c>SetWindowPlacement</c>, set the <c>length</c> member of the WINDOWPLACEMENT structure to sizeof(
            <c>WINDOWPLACEMENT</c>). <c>SetWindowPlacement</c> fails if the <c>length</c> member is not set correctly.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the information specified in WINDOWPLACEMENT would result in a window that is completely off the screen, the system will
            automatically adjust the coordinates so that the window is visible, taking into account changes in screen resolution and multiple
            monitor configuration.
            </para>
            <para>
            The <c>length</c> member of WINDOWPLACEMENT must be set to . If this member is not set correctly, the function returns
            <c>FALSE</c>. For additional remarks on the proper use of window placement coordinates, see <c>WINDOWPLACEMENT</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetWindowPos(Vanara.PInvoke.HWND,Vanara.PInvoke.HWND,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.User32.SetWindowPosFlags)">
            <summary>
            <para>
            Changes the size, position, and Z order of a child, pop-up, or top-level window. These windows are ordered according to their
            appearance on the screen. The topmost window receives the highest rank and is the first window in the Z order.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window.</para>
            </param>
            <param name="hWndInsertAfter">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window to precede the positioned window in the Z order. This parameter must be a window handle or one of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>HWND_BOTTOM (HWND)1</term>
            <term>
            Places the window at the bottom of the Z order. If the hWnd parameter identifies a topmost window, the window loses its topmost
            status and is placed at the bottom of all other windows.
            </term>
            </item>
            <item>
            <term>HWND_NOTOPMOST (HWND)-2</term>
            <term>
            Places the window above all non-topmost windows (that is, behind all topmost windows). This flag has no effect if the window is
            already a non-topmost window.
            </term>
            </item>
            <item>
            <term>HWND_TOP (HWND)0</term>
            <term>Places the window at the top of the Z order.</term>
            </item>
            <item>
            <term>HWND_TOPMOST (HWND)-1</term>
            <term>Places the window above all non-topmost windows. The window maintains its topmost position even when it is deactivated.</term>
            </item>
            </list>
            <para>For more information about how this parameter is used, see the following Remarks section.</para>
            </param>
            <param name="X">
            <para>Type: <c>int</c></para>
            <para>The new position of the left side of the window, in client coordinates.</para>
            </param>
            <param name="Y">
            <para>Type: <c>int</c></para>
            <para>The new position of the top of the window, in client coordinates.</para>
            </param>
            <param name="cx">
            <para>Type: <c>int</c></para>
            <para>The new width of the window, in pixels.</para>
            </param>
            <param name="cy">
            <para>Type: <c>int</c></para>
            <para>The new height of the window, in pixels.</para>
            </param>
            <param name="uFlags">
            <para>Type: <c>UINT</c></para>
            <para>The window sizing and positioning flags. This parameter can be a combination of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SWP_ASYNCWINDOWPOS 0x4000</term>
            <term>
            If the calling thread and the thread that owns the window are attached to different input queues, the system posts the request to
            the thread that owns the window. This prevents the calling thread from blocking its execution while other threads process the request.
            </term>
            </item>
            <item>
            <term>SWP_DEFERERASE 0x2000</term>
            <term>Prevents generation of the WM_SYNCPAINT message.</term>
            </item>
            <item>
            <term>SWP_DRAWFRAME 0x0020</term>
            <term>Draws a frame (defined in the window's class description) around the window.</term>
            </item>
            <item>
            <term>SWP_FRAMECHANGED 0x0020</term>
            <term>
            Applies new frame styles set using the SetWindowLong function. Sends a WM_NCCALCSIZE message to the window, even if the window's
            size is not being changed. If this flag is not specified, WM_NCCALCSIZE is sent only when the window's size is being changed.
            </term>
            </item>
            <item>
            <term>SWP_HIDEWINDOW 0x0080</term>
            <term>Hides the window.</term>
            </item>
            <item>
            <term>SWP_NOACTIVATE 0x0010</term>
            <term>
            Does not activate the window. If this flag is not set, the window is activated and moved to the top of either the topmost or
            non-topmost group (depending on the setting of the hWndInsertAfter parameter).
            </term>
            </item>
            <item>
            <term>SWP_NOCOPYBITS 0x0100</term>
            <term>
            Discards the entire contents of the client area. If this flag is not specified, the valid contents of the client area are saved
            and copied back into the client area after the window is sized or repositioned.
            </term>
            </item>
            <item>
            <term>SWP_NOMOVE 0x0002</term>
            <term>Retains the current position (ignores X and Y parameters).</term>
            </item>
            <item>
            <term>SWP_NOOWNERZORDER 0x0200</term>
            <term>Does not change the owner window's position in the Z order.</term>
            </item>
            <item>
            <term>SWP_NOREDRAW 0x0008</term>
            <term>
            Does not redraw changes. If this flag is set, no repainting of any kind occurs. This applies to the client area, the nonclient
            area (including the title bar and scroll bars), and any part of the parent window uncovered as a result of the window being
            moved. When this flag is set, the application must explicitly invalidate or redraw any parts of the window and parent window that
            need redrawing.
            </term>
            </item>
            <item>
            <term>SWP_NOREPOSITION 0x0200</term>
            <term>Same as the SWP_NOOWNERZORDER flag.</term>
            </item>
            <item>
            <term>SWP_NOSENDCHANGING 0x0400</term>
            <term>Prevents the window from receiving the WM_WINDOWPOSCHANGING message.</term>
            </item>
            <item>
            <term>SWP_NOSIZE 0x0001</term>
            <term>Retains the current size (ignores the cx and cy parameters).</term>
            </item>
            <item>
            <term>SWP_NOZORDER 0x0004</term>
            <term>Retains the current Z order (ignores the hWndInsertAfter parameter).</term>
            </item>
            <item>
            <term>SWP_SHOWWINDOW 0x0040</term>
            <term>Displays the window.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            As part of the Vista re-architecture, all services were moved off the interactive desktop into Session 0. hwnd and window manager
            operations are only effective inside a session and cross-session attempts to manipulate the hwnd will fail. For more information,
            see The Windows Vista Developer Story: Application Compatibility Cookbook.
            </para>
            <para>
            If you have changed certain window data using SetWindowLong, you must call <c>SetWindowPos</c> for the changes to take effect.
            Use the following combination for uFlags: .
            </para>
            <para>
            A window can be made a topmost window either by setting the hWndInsertAfter parameter to <c>HWND_TOPMOST</c> and ensuring that
            the <c>SWP_NOZORDER</c> flag is not set, or by setting a window's position in the Z order so that it is above any existing
            topmost windows. When a non-topmost window is made topmost, its owned windows are also made topmost. Its owners, however, are not changed.
            </para>
            <para>
            If neither the <c>SWP_NOACTIVATE</c> nor <c>SWP_NOZORDER</c> flag is specified (that is, when the application requests that a
            window be simultaneously activated and its position in the Z order changed), the value specified in hWndInsertAfter is used only
            in the following circumstances.
            </para>
            <list type="bullet">
            <item>
            <term>Neither the <c>HWND_TOPMOST</c> nor <c>HWND_NOTOPMOST</c> flag is specified in hWndInsertAfter.</term>
            </item>
            <item>
            <term>The window identified by hWnd is not the active window.</term>
            </item>
            </list>
            <para>
            An application cannot activate an inactive window without also bringing it to the top of the Z order. Applications can change an
            activated window's position in the Z order without restrictions, or it can activate a window and then move it to the top of the
            topmost or non-topmost windows.
            </para>
            <para>
            If a topmost window is repositioned to the bottom ( <c>HWND_BOTTOM</c>) of the Z order or after any non-topmost window, it is no
            longer topmost. When a topmost window is made non-topmost, its owners and its owned windows are also made non-topmost windows.
            </para>
            <para>
            A non-topmost window can own a topmost window, but the reverse cannot occur. Any window (for example, a dialog box) owned by a
            topmost window is itself made a topmost window, to ensure that all owned windows stay above their owner.
            </para>
            <para>If an application is not in the foreground, and should be in the foreground, it must call the SetForegroundWindow function.</para>
            <para>
            To use <c>SetWindowPos</c> to bring a window to the top, the process that owns the window must have SetForegroundWindow permission.
            </para>
            <para>Examples</para>
            <para>For an example, see Initializing a Dialog Box.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetWindowText(Vanara.PInvoke.HWND,System.String)">
            <summary>
            <para>
            Changes the text of the specified window's title bar (if it has one). If the specified window is a control, the text of the
            control is changed. However, <c>SetWindowText</c> cannot change the text of a control in another application.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window or control whose text is to be changed.</para>
            </param>
            <param name="lpString">
            <para>Type: <c>LPCTSTR</c></para>
            <para>The new title or control text.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If the target window is owned by the current process, <c>SetWindowText</c> causes a WM_SETTEXT message to be sent to the
            specified window or control. If the control is a list box control created with the <c>WS_CAPTION</c> style, however,
            <c>SetWindowText</c> sets the text for the control, not for the list box entries.
            </para>
            <para>To set the text of a control in another process, send the WM_SETTEXT message directly instead of calling <c>SetWindowText</c>.</para>
            <para>
            The <c>SetWindowText</c> function does not expand tab characters (ASCII code 0x09). Tab characters are displayed as vertical bar
            (|) characters.
            </para>
            <para>Examples</para>
            <para>For an example, see Sending a Message.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ShowOwnedPopups(Vanara.PInvoke.HWND,System.Boolean)">
            <summary>
            <para>Shows or hides all pop-up windows owned by the specified window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that owns the pop-up windows to be shown or hidden.</para>
            </param>
            <param name="fShow">
            <para>Type: <c>BOOL</c></para>
            <para>
            If this parameter is <c>TRUE</c>, all hidden pop-up windows are shown. If this parameter is <c>FALSE</c>, all visible pop-up
            windows are hidden.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            <c>ShowOwnedPopups</c> shows only windows hidden by a previous call to <c>ShowOwnedPopups</c>. For example, if a pop-up window is
            hidden by using the ShowWindow function, subsequently calling <c>ShowOwnedPopups</c> with the fShow parameter set to <c>TRUE</c>
            does not cause the window to be shown.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ShowWindow(Vanara.PInvoke.HWND,Vanara.PInvoke.ShowWindowCommand)">
            <summary>
            <para>Sets the specified window's show state.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window.</para>
            </param>
            <param name="nCmdShow">
            <para>Type: <c>int</c></para>
            <para>
            Controls how the window is to be shown. This parameter is ignored the first time an application calls <c>ShowWindow</c>, if the
            program that launched the application provides a STARTUPINFO structure. Otherwise, the first time <c>ShowWindow</c> is called,
            the value should be the value obtained by the WinMain function in its nCmdShow parameter. In subsequent calls, this parameter can
            be one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SW_FORCEMINIMIZE 11</term>
            <term>
            Minimizes a window, even if the thread that owns the window is not responding. This flag should only be used when minimizing
            windows from a different thread.
            </term>
            </item>
            <item>
            <term>SW_HIDE 0</term>
            <term>Hides the window and activates another window.</term>
            </item>
            <item>
            <term>SW_MAXIMIZE 3</term>
            <term>Maximizes the specified window.</term>
            </item>
            <item>
            <term>SW_MINIMIZE 6</term>
            <term>Minimizes the specified window and activates the next top-level window in the Z order.</term>
            </item>
            <item>
            <term>SW_RESTORE 9</term>
            <term>
            Activates and displays the window. If the window is minimized or maximized, the system restores it to its original size and
            position. An application should specify this flag when restoring a minimized window.
            </term>
            </item>
            <item>
            <term>SW_SHOW 5</term>
            <term>Activates the window and displays it in its current size and position.</term>
            </item>
            <item>
            <term>SW_SHOWDEFAULT 10</term>
            <term>
            Sets the show state based on the SW_ value specified in the STARTUPINFO structure passed to the CreateProcess function by the
            program that started the application.
            </term>
            </item>
            <item>
            <term>SW_SHOWMAXIMIZED 3</term>
            <term>Activates the window and displays it as a maximized window.</term>
            </item>
            <item>
            <term>SW_SHOWMINIMIZED 2</term>
            <term>Activates the window and displays it as a minimized window.</term>
            </item>
            <item>
            <term>SW_SHOWMINNOACTIVE 7</term>
            <term>Displays the window as a minimized window. This value is similar to SW_SHOWMINIMIZED, except the window is not activated.</term>
            </item>
            <item>
            <term>SW_SHOWNA 8</term>
            <term>
            Displays the window in its current size and position. This value is similar to SW_SHOW, except that the window is not activated.
            </term>
            </item>
            <item>
            <term>SW_SHOWNOACTIVATE 4</term>
            <term>
            Displays a window in its most recent size and position. This value is similar to SW_SHOWNORMAL, except that the window is not activated.
            </term>
            </item>
            <item>
            <term>SW_SHOWNORMAL 1</term>
            <term>
            Activates and displays a window. If the window is minimized or maximized, the system restores it to its original size and
            position. An application should specify this flag when displaying the window for the first time.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the window was previously visible, the return value is nonzero.</para>
            <para>If the window was previously hidden, the return value is zero.</para>
            </returns>
            <remarks>
            <para>To perform certain special effects when showing or hiding a window, use AnimateWindow.</para>
            <para>
            The first time an application calls <c>ShowWindow</c>, it should use the WinMain function's nCmdShow parameter as its nCmdShow
            parameter. Subsequent calls to <c>ShowWindow</c> must use one of the values in the given list, instead of the one specified by
            the <c>WinMain</c> function's nCmdShow parameter.
            </para>
            <para>
            As noted in the discussion of the nCmdShow parameter, the nCmdShow value is ignored in the first call to <c>ShowWindow</c> if the
            program that launched the application specifies startup information in the structure. In this case, <c>ShowWindow</c> uses the
            information specified in the STARTUPINFO structure to show the window. On subsequent calls, the application must call
            <c>ShowWindow</c> with nCmdShow set to <c>SW_SHOWDEFAULT</c> to use the startup information provided by the program that launched
            the application. This behavior is designed for the following situations:
            </para>
            <list type="bullet">
            <item>
            <term>Applications create their main window by calling CreateWindow with the <c>WS_VISIBLE</c> flag set.</term>
            </item>
            <item>
            <term>
            Applications create their main window by calling CreateWindow with the <c>WS_VISIBLE</c> flag cleared, and later call
            <c>ShowWindow</c> with the <c>SW_SHOW</c> flag set to make it visible.
            </term>
            </item>
            </list>
            <para>Examples</para>
            <para>For an example, see Creating a Main Window.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.ShowWindowAsync(Vanara.PInvoke.HWND,Vanara.PInvoke.ShowWindowCommand)">
            <summary>
            <para>Sets the show state of a window without waiting for the operation to complete.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window.</para>
            </param>
            <param name="nCmdShow">
            <para>Type: <c>int</c></para>
            <para>Controls how the window is to be shown. For a list of possible values, see the description of the ShowWindow function.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the operation was successfully started, the return value is nonzero.</para>
            </returns>
            <remarks>
            <para>
            This function posts a show-window event to the message queue of the given window. An application can use this function to avoid
            becoming nonresponsive while waiting for a nonresponsive application to finish processing a show-window event.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SoundSentry">
            <summary>
            <para>Triggers a visual signal to indicate that a sound is playing.</para>
            </summary>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>This function returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>TRUE</term>
            <term>The visual signal was or will be displayed correctly.</term>
            </item>
            <item>
            <term>FALSE</term>
            <term>An error prevented the signal from being displayed.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Set the notification behavior by calling SystemParametersInfo with the <c>SPI_SETSOUNDSENTRY</c> value.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SwitchToThisWindow(Vanara.PInvoke.HWND,System.Boolean)">
            <summary>
            <para>[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]</para>
            <para>Switches focus to the specified window and brings it to the foreground.</para>
            </summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window.</para>
            </param>
            <param name="fUnknown">
            <para>Type: <c>BOOL</c></para>
            <para>
            A <c>TRUE</c> for this parameter indicates that the window is being switched to using the Alt/Ctl+Tab key sequence. This
            parameter should be <c>FALSE</c> otherwise.
            </para>
            </param>
            <returns>
            <para>This function does not return a value.</para>
            </returns>
            <remarks>
            <para>This function is typically called to maintain window z-ordering.</para>
            <para>
            This function was not included in the SDK headers and libraries until Windows XP with Service Pack 1 (SP1) and Windows Server
            2003. If you do not have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.TileWindows(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.MdiTileFlags,Vanara.PInvoke.PRECT,System.UInt32,Vanara.PInvoke.HWND[])">
            <summary>
            <para>Tiles the specified child windows of the specified parent window.</para>
            </summary>
            <param name="hwndParent">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the parent window. If this parameter is <c>NULL</c>, the desktop window is assumed.</para>
            </param>
            <param name="wHow">
            <para>Type: <c>UINT</c></para>
            <para>
            The tiling flags. This parameter can be one of the following values—optionally combined with <c>MDITILE_SKIPDISABLED</c> to
            prevent disabled MDI child windows from being tiled.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MDITILE_HORIZONTAL 0x0001</term>
            <term>Tiles windows horizontally.</term>
            </item>
            <item>
            <term>MDITILE_VERTICAL 0x0000</term>
            <term>Tiles windows vertically.</term>
            </item>
            </list>
            </param>
            <param name="lpRect">
            <para>Type: <c>const RECT*</c></para>
            <para>
            A pointer to a structure that specifies the rectangular area, in client coordinates, within which the windows are arranged. If
            this parameter is <c>NULL</c>, the client area of the parent window is used.
            </para>
            </param>
            <param name="cKids">
            <para>Type: <c>UINT</c></para>
            <para>The number of elements in the array specified by the lpKids parameter. This parameter is ignored if lpKids is <c>NULL</c>.</para>
            </param>
            <param name="lpKids">
            <para>Type: <c>const HWND*</c></para>
            <para>
            An array of handles to the child windows to arrange. If a specified child window is a top-level window with the style
            <c>WS_EX_TOPMOST</c> or <c>WS_EX_TOOLWINDOW</c>, the child window is not arranged. If this parameter is <c>NULL</c>, all child
            windows of the specified parent window (or of the desktop window) are arranged.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>WORD</c></c></para>
            <para>If the function succeeds, the return value is the number of windows arranged.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>Calling <c>TileWindows</c> causes all maximized windows to be restored to their previous size.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.TranslateMDISysAccel(Vanara.PInvoke.HWND,Vanara.PInvoke.MSG@)">
            <summary>
            Processes accelerator keystrokes for window menu commands of the multiple-document interface (MDI) child windows associated with
            the specified MDI client window. The function translates WM_KEYUP and WM_KEYDOWN messages to WM_SYSCOMMAND messages and sends
            them to the appropriate MDI child windows.
            </summary>
            <param name="hWndClient">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the MDI client window.</para>
            </param>
            <param name="lpMsg">
            <para>Type: <c>LPMSG</c></para>
            <para>
            A pointer to a message retrieved by using the GetMessage or PeekMessage function. The message must be an MSG structure and
            contain message information from the application's message queue.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the message is translated into a system command, the return value is nonzero.</para>
            <para>If the message is not translated into a system command, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.UnregisterClass(System.String,Vanara.PInvoke.HINSTANCE)">
            <summary>Unregisters a window class, freeing the memory required for the class.</summary>
            <param name="lpClassName">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A null-terminated string or a class atom. If lpClassName is a string, it specifies the window class name. This class name must
            have been registered by a previous call to the RegisterClass or RegisterClassEx function. System classes, such as dialog box
            controls, cannot be unregistered. If this parameter is an atom, it must be a class atom created by a previous call to the
            <c>RegisterClass</c> or <c>RegisterClassEx</c> function. The atom must be in the low-order word of lpClassName; the high-order
            word must be zero.
            </para>
            </param>
            <param name="hInstance">
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to the instance of the module that created the class.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>
            If the class could not be found or if a window still exists that was created with the class, the return value is zero. To get
            extended error information, call GetLastError.
            </para>
            </returns>
            <remarks>
            <para>Before calling this function, an application must destroy all windows created with the specified class.</para>
            <para>All window classes that an application registers are unregistered when it terminates.</para>
            <para>Class atoms are special atoms returned only by RegisterClass and RegisterClassEx.</para>
            <para>No window classes registered by a DLL are unregistered when the .dll is unloaded.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.UpdateLayeredWindow(Vanara.PInvoke.HWND,Vanara.PInvoke.HDC,Vanara.PInvoke.POINT@,Vanara.PInvoke.SIZE@,Vanara.PInvoke.HDC,Vanara.PInvoke.POINT@,Vanara.PInvoke.COLORREF,Vanara.PInvoke.Gdi32.BLENDFUNCTION@,Vanara.PInvoke.User32.UpdateLayeredWindowFlags)">
            <summary>
            <para>Updates the position, size, shape, content, and translucency of a layered window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to a layered window. A layered window is created by specifying <c>WS_EX_LAYERED</c> when creating the window with the
            CreateWindowEx function.
            </para>
            <para>
            <c>Windows 8:</c> The <c>WS_EX_LAYERED</c> style is supported for top-level windows and child windows. Previous Windows versions
            support <c>WS_EX_LAYERED</c> only for top-level windows.
            </para>
            </param>
            <param name="hdcDst">
            <para>Type: <c>HDC</c></para>
            <para>
            A handle to a DC for the screen. This handle is obtained by specifying <c>NULL</c> when calling the function. It is used for
            palette color matching when the window contents are updated. If hdcDst is <c>NULL</c>, the default palette will be used.
            </para>
            <para>If hdcSrc is <c>NULL</c>, hdcDst must be <c>NULL</c>.</para>
            </param>
            <param name="pptDst">
            <para>Type: <c>POINT*</c></para>
            <para>
            A pointer to a structure that specifies the new screen position of the layered window. If the current position is not changing,
            pptDst can be <c>NULL</c>.
            </para>
            </param>
            <param name="psize">
            <para>Type: <c>SIZE*</c></para>
            <para>
            A pointer to a structure that specifies the new size of the layered window. If the size of the window is not changing, psize can
            be <c>NULL</c>. If hdcSrc is <c>NULL</c>, psize must be <c>NULL</c>.
            </para>
            </param>
            <param name="hdcSrc">
            <para>Type: <c>HDC</c></para>
            <para>
            A handle to a DC for the surface that defines the layered window. This handle can be obtained by calling the CreateCompatibleDC
            function. If the shape and visual context of the window are not changing, hdcSrc can be <c>NULL</c>.
            </para>
            </param>
            <param name="pptSrc">
            <para>Type: <c>POINT*</c></para>
            <para>
            A pointer to a structure that specifies the location of the layer in the device context. If hdcSrc is <c>NULL</c>, pptSrc should
            be <c>NULL</c>.
            </para>
            </param>
            <param name="crKey">
            <para>Type: <c>COLORREF</c></para>
            <para>
            A structure that specifies the color key to be used when composing the layered window. To generate a COLORREF, use the RGB macro.
            </para>
            </param>
            <param name="pblend">
            <para>Type: <c>BLENDFUNCTION*</c></para>
            <para>A pointer to a structure that specifies the transparency value to be used when composing the layered window.</para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ULW_ALPHA 0x00000002</term>
            <term>
            Use pblend as the blend function. If the display mode is 256 colors or less, the effect of this value is the same as the effect
            of ULW_OPAQUE.
            </term>
            </item>
            <item>
            <term>ULW_COLORKEY 0x00000001</term>
            <term>Use crKey as the transparency color.</term>
            </item>
            <item>
            <term>ULW_OPAQUE 0x00000004</term>
            <term>Draw an opaque layered window.</term>
            </item>
            </list>
            <para>If hdcSrc is <c>NULL</c>, dwFlags should be zero.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The source DC should contain the surface that defines the visible contents of the layered window. For example, you can select a
            bitmap into a device context obtained by calling the CreateCompatibleDC function.
            </para>
            <para>
            An application should call SetLayout on the hdcSrc device context to properly set the mirroring mode. <c>SetLayout</c> will
            properly mirror all drawing into an <c>HDC</c> while properly preserving text glyph and (optionally) bitmap direction order. It
            cannot modify drawing directly into the bits of a device-independent bitmap (DIB). For more information, see Window Layout and Mirroring.
            </para>
            <para>
            The <c>UpdateLayeredWindow</c> function maintains the window's appearance on the screen. The windows underneath a layered window
            do not need to be repainted when they are uncovered due to a call to <c>UpdateLayeredWindow</c>, because the system will
            automatically repaint them. This permits seamless animation of the layered window.
            </para>
            <para>
            <c>UpdateLayeredWindow</c> always updates the entire window. To update part of a window, use the traditional WM_PAINT and set the
            blend value using SetLayeredWindowAttributes.
            </para>
            <para>
            For best drawing performance by the layered window and any underlying windows, the layered window should be as small as possible.
            An application should also process the message and re-create its layered windows when the display's color depth changes.
            </para>
            <para>For more information, see Layered Windows.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.UpdateLayeredWindow(Vanara.PInvoke.HWND,Vanara.PInvoke.HDC,System.IntPtr,System.IntPtr,Vanara.PInvoke.HDC,System.IntPtr,Vanara.PInvoke.COLORREF,Vanara.PInvoke.Gdi32.BLENDFUNCTION@,Vanara.PInvoke.User32.UpdateLayeredWindowFlags)">
            <summary>
            <para>Updates the position, size, shape, content, and translucency of a layered window.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to a layered window. A layered window is created by specifying <c>WS_EX_LAYERED</c> when creating the window with the
            CreateWindowEx function.
            </para>
            <para>
            <c>Windows 8:</c> The <c>WS_EX_LAYERED</c> style is supported for top-level windows and child windows. Previous Windows versions
            support <c>WS_EX_LAYERED</c> only for top-level windows.
            </para>
            </param>
            <param name="hdcDst">
            <para>Type: <c>HDC</c></para>
            <para>
            A handle to a DC for the screen. This handle is obtained by specifying <c>NULL</c> when calling the function. It is used for
            palette color matching when the window contents are updated. If hdcDst is <c>NULL</c>, the default palette will be used.
            </para>
            <para>If hdcSrc is <c>NULL</c>, hdcDst must be <c>NULL</c>.</para>
            </param>
            <param name="pptDst">
            <para>Type: <c>POINT*</c></para>
            <para>
            A pointer to a structure that specifies the new screen position of the layered window. If the current position is not changing,
            pptDst can be <c>NULL</c>.
            </para>
            </param>
            <param name="psize">
            <para>Type: <c>SIZE*</c></para>
            <para>
            A pointer to a structure that specifies the new size of the layered window. If the size of the window is not changing, psize can
            be <c>NULL</c>. If hdcSrc is <c>NULL</c>, psize must be <c>NULL</c>.
            </para>
            </param>
            <param name="hdcSrc">
            <para>Type: <c>HDC</c></para>
            <para>
            A handle to a DC for the surface that defines the layered window. This handle can be obtained by calling the CreateCompatibleDC
            function. If the shape and visual context of the window are not changing, hdcSrc can be <c>NULL</c>.
            </para>
            </param>
            <param name="pptSrc">
            <para>Type: <c>POINT*</c></para>
            <para>
            A pointer to a structure that specifies the location of the layer in the device context. If hdcSrc is <c>NULL</c>, pptSrc should
            be <c>NULL</c>.
            </para>
            </param>
            <param name="crKey">
            <para>Type: <c>COLORREF</c></para>
            <para>
            A structure that specifies the color key to be used when composing the layered window. To generate a COLORREF, use the RGB macro.
            </para>
            </param>
            <param name="pblend">
            <para>Type: <c>BLENDFUNCTION*</c></para>
            <para>A pointer to a structure that specifies the transparency value to be used when composing the layered window.</para>
            </param>
            <param name="dwFlags">
            <para>Type: <c>DWORD</c></para>
            <para>This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ULW_ALPHA 0x00000002</term>
            <term>
            Use pblend as the blend function. If the display mode is 256 colors or less, the effect of this value is the same as the effect
            of ULW_OPAQUE.
            </term>
            </item>
            <item>
            <term>ULW_COLORKEY 0x00000001</term>
            <term>Use crKey as the transparency color.</term>
            </item>
            <item>
            <term>ULW_OPAQUE 0x00000004</term>
            <term>Draw an opaque layered window.</term>
            </item>
            </list>
            <para>If hdcSrc is <c>NULL</c>, dwFlags should be zero.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            The source DC should contain the surface that defines the visible contents of the layered window. For example, you can select a
            bitmap into a device context obtained by calling the CreateCompatibleDC function.
            </para>
            <para>
            An application should call SetLayout on the hdcSrc device context to properly set the mirroring mode. <c>SetLayout</c> will
            properly mirror all drawing into an <c>HDC</c> while properly preserving text glyph and (optionally) bitmap direction order. It
            cannot modify drawing directly into the bits of a device-independent bitmap (DIB). For more information, see Window Layout and Mirroring.
            </para>
            <para>
            The <c>UpdateLayeredWindow</c> function maintains the window's appearance on the screen. The windows underneath a layered window
            do not need to be repainted when they are uncovered due to a call to <c>UpdateLayeredWindow</c>, because the system will
            automatically repaint them. This permits seamless animation of the layered window.
            </para>
            <para>
            <c>UpdateLayeredWindow</c> always updates the entire window. To update part of a window, use the traditional WM_PAINT and set the
            blend value using SetLayeredWindowAttributes.
            </para>
            <para>
            For best drawing performance by the layered window and any underlying windows, the layered window should be as small as possible.
            An application should also process the message and re-create its layered windows when the display's color depth changes.
            </para>
            <para>For more information, see Layered Windows.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.UpdateLayeredWindowIndirect(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.UPDATELAYEREDWINDOWINFO@)">
            <summary>Updates the position, size, shape, content, and translucency of a layered window.</summary>
            <param name="hwnd">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to a layered window. A layered window is created by specifying <c>WS_EX_LAYERED</c> when creating the window with the
            <c>CreateWindowEx</c> function.
            </para>
            <para>
            <c>Windows 8:</c> The <c>WS_EX_LAYERED</c> style is supported for top-level windows and child windows. Previous Windows versions
            support <c>WS_EX_LAYERED</c> only for top-level windows.
            </para>
            </param>
            <param name="pULWInfo">
            <para>Type: <c>const <c>UPDATELAYEREDWINDOWINFO</c>*</c></para>
            <para>A pointer to a structure that contains the information for the window.</para>
            </param>
            <returns>
            <para>Type:</para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call <c>GetLastError</c>.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.WindowFromPhysicalPoint(Vanara.PInvoke.POINT)">
            <summary>
            <para>Retrieves a handle to the window that contains the specified physical point.</para>
            </summary>
            <param name="Point">
            <para>Type: <c>POINT</c></para>
            <para>The physical coordinates of the point.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>A handle to the window that contains the given physical point. If no window exists at the point, this value is <c>NULL</c>.</para>
            </returns>
            <remarks>
            <para>
            The <c>WindowFromPhysicalPoint</c> function does not retrieve a handle to a hidden or disabled window, even if the point is
            within the window.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.WindowFromPoint(Vanara.PInvoke.POINT)">
            <summary>
            <para>Retrieves a handle to the window that contains the specified point.</para>
            </summary>
            <param name="Point">
            <para>Type: <c>POINT</c></para>
            <para>The point to be checked.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HWND</c></c></para>
            <para>
            The return value is a handle to the window that contains the point. If no window exists at the given point, the return value is
            <c>NULL</c>. If the point is over a static text control, the return value is a handle to the window under the static text control.
            </para>
            </returns>
            <remarks>
            <para>
            The <c>WindowFromPoint</c> function does not retrieve a handle to a hidden or disabled window, even if the point is within the
            window. An application should use the ChildWindowFromPoint function for a nonrestrictive search.
            </para>
            <para>Examples</para>
            <para>For an example, see "Interface from Running Object Table" in About Text Object Model.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.WINNLSEnableIME(Vanara.PInvoke.HWND,System.Boolean)">
            <summary>
            <para>
            Temporarily enables or disables an Input Method Editor (IME) and, at the same time, turns on or off the display of all windows
            owned by the IME.
            </para>
            <para><c>Note</c> This function is obsolete and should not be used.</para>
            </summary>
            <param name="hWnd">Must be <c>NULL</c>. Specifying a particular IME for each application is not supported.</param>
            <param name="fEnable"><c>TRUE</c> to enable the IME; <c>FALSE</c> to disable.</param>
            <returns>The previous state of the IME. <c>TRUE</c> if it was enabled before this call, otherwise, <c>FALSE</c>.</returns>
            <remarks>
            <para>The terms "enabled" and "disabled" in regard to this function are defined as follows:</para>
            <para>
            If an IME is disabled, IME_WINDOWUPDATE(FALSE) is issued to the IME, which responds by deleting the conversion and system
            windows. With the IME disabled, keyboard messages are not sent to the IME, but are sent directly to the application. Even if the
            IME is disabled, the API that uses the SendIMEMessageEx function is still valid.
            </para>
            <para>
            If an IME is enabled, IME_WINDOWUPDATE(TRUE) is issued to the IME, which responds by redisplaying the conversion and system
            windows. With the IME enabled, keyboard messages are sent to the IME.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetClassLong32(Vanara.PInvoke.HWND,System.Int32)">
            <summary>
            <para>Retrieves the specified 32-bit ( <c>DWORD</c>) value from the WNDCLASSEX structure associated with the specified window.</para>
            <para>
            <c>Note</c> If you are retrieving a pointer or a handle, this function has been superseded by the GetClassLongPtr function.
            (Pointers and handles are 32 bits on 32-bit Windows and 64 bits on 64-bit Windows.)
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
            </param>
            <param name="nIndex">
            <para>Type: <c>int</c></para>
            <para>
            The value to be retrieved. To retrieve a value from the extra class memory, specify the positive, zero-based byte offset of the
            value to be retrieved. Valid values are in the range zero through the number of bytes of extra class memory, minus four; for
            example, if you specified 12 or more bytes of extra class memory, a value of 8 would be an index to the third integer. To
            retrieve any other value from the WNDCLASSEX structure, specify one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>GCW_ATOM -32</term>
            <term>
            Retrieves an ATOM value that uniquely identifies the window class. This is the same atom that the RegisterClassEx function returns.
            </term>
            </item>
            <item>
            <term>GCL_CBCLSEXTRA -20</term>
            <term>Retrieves the size, in bytes, of the extra memory associated with the class.</term>
            </item>
            <item>
            <term>GCL_CBWNDEXTRA -18</term>
            <term>
            Retrieves the size, in bytes, of the extra window memory associated with each window in the class. For information on how to
            access this memory, see GetWindowLong.
            </term>
            </item>
            <item>
            <term>GCL_HBRBACKGROUND -10</term>
            <term>Retrieves a handle to the background brush associated with the class.</term>
            </item>
            <item>
            <term>GCL_HCURSOR -12</term>
            <term>Retrieves a handle to the cursor associated with the class.</term>
            </item>
            <item>
            <term>GCL_HICON -14</term>
            <term>Retrieves a handle to the icon associated with the class.</term>
            </item>
            <item>
            <term>GCL_HICONSM -34</term>
            <term>Retrieves a handle to the small icon associated with the class.</term>
            </item>
            <item>
            <term>GCL_HMODULE -16</term>
            <term>Retrieves a handle to the module that registered the class.</term>
            </item>
            <item>
            <term>GCL_MENUNAME -8</term>
            <term>Retrieves the address of the menu name string. The string identifies the menu resource associated with the class.</term>
            </item>
            <item>
            <term>GCL_STYLE -26</term>
            <term>Retrieves the window-class style bits.</term>
            </item>
            <item>
            <term>GCL_WNDPROC -24</term>
            <term>
            Retrieves the address of the window procedure, or a handle representing the address of the window procedure. You must use the
            CallWindowProc function to call the window procedure.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>DWORD</c></c></para>
            <para>If the function succeeds, the return value is the requested value.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            Reserve extra class memory by specifying a nonzero value in the <c>cbClsExtra</c> member of the WNDCLASSEX structure used with
            the RegisterClassEx function.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetClassLongPtr(Vanara.PInvoke.HWND,System.Int32)">
            <summary>
            <para>Retrieves the specified value from the WNDCLASSEX structure associated with the specified window.</para>
            <para>
            <c>Note</c> To write code that is compatible with both 32-bit and 64-bit versions of Windows, use <c>GetClassLongPtr</c>. When
            compiling for 32-bit Windows, <c>GetClassLongPtr</c> is defined as a call to the GetClassLong function.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
            </param>
            <param name="nIndex">
            <para>Type: <c>int</c></para>
            <para>
            The value to be retrieved. To retrieve a value from the extra class memory, specify the positive, zero-based byte offset of the
            value to be retrieved. Valid values are in the range zero through the number of bytes of extra class memory, minus eight; for
            example, if you specified 24 or more bytes of extra class memory, a value of 16 would be an index to the third integer. To
            retrieve any other value from the WNDCLASSEX structure, specify one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>GCW_ATOM -32</term>
            <term>
            Retrieves an ATOM value that uniquely identifies the window class. This is the same atom that the RegisterClassEx function returns.
            </term>
            </item>
            <item>
            <term>GCL_CBCLSEXTRA -20</term>
            <term>Retrieves the size, in bytes, of the extra memory associated with the class.</term>
            </item>
            <item>
            <term>GCL_CBWNDEXTRA -18</term>
            <term>
            Retrieves the size, in bytes, of the extra window memory associated with each window in the class. For information on how to
            access this memory, see GetWindowLongPtr.
            </term>
            </item>
            <item>
            <term>GCLP_HBRBACKGROUND -10</term>
            <term>Retrieves a handle to the background brush associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HCURSOR -12</term>
            <term>Retrieves a handle to the cursor associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HICON -14</term>
            <term>Retrieves a handle to the icon associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HICONSM -34</term>
            <term>Retrieves a handle to the small icon associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HMODULE -16</term>
            <term>Retrieves a handle to the module that registered the class.</term>
            </item>
            <item>
            <term>GCLP_MENUNAME -8</term>
            <term>Retrieves the pointer to the menu name string. The string identifies the menu resource associated with the class.</term>
            </item>
            <item>
            <term>GCL_STYLE -26</term>
            <term>Retrieves the window-class style bits.</term>
            </item>
            <item>
            <term>GCLP_WNDPROC -24</term>
            <term>
            Retrieves the address of the window procedure, or a handle representing the address of the window procedure. You must use the
            CallWindowProc function to call the window procedure.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>Type: <c>ULONG_PTR</c></c></para>
            <para>If the function succeeds, the return value is the requested value.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            Reserve extra class memory by specifying a nonzero value in the <c>cbClsExtra</c> member of the WNDCLASSEX structure used with
            the RegisterClassEx function.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetClassLong32(Vanara.PInvoke.HWND,System.Int32,System.Int32)">
            <summary>
            <para>
            Replaces the specified 32-bit ( <c>long</c>) value at the specified offset into the extra class memory or the WNDCLASSEX
            structure for the class to which the specified window belongs.
            </para>
            <para>
            <c>Note</c> This function has been superseded by the SetClassLongPtr function. To write code that is compatible with both 32-bit
            and 64-bit versions of Windows, use <c>SetClassLongPtr</c>.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
            </param>
            <param name="nIndex">
            <para>Type: <c>int</c></para>
            <para>
            The value to be replaced. To set a 32-bit value in the extra class memory, specify the positive, zero-based byte offset of the
            value to be set. Valid values are in the range zero through the number of bytes of extra class memory, minus four; for example,
            if you specified 12 or more bytes of extra class memory, a value of 8 would be an index to the third 32-bit integer. To set any
            other value from the WNDCLASSEX structure, specify one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>GCL_CBCLSEXTRA -20</term>
            <term>
            Sets the size, in bytes, of the extra memory associated with the class. Setting this value does not change the number of extra
            bytes already allocated.
            </term>
            </item>
            <item>
            <term>GCL_CBWNDEXTRA -18</term>
            <term>
            Sets the size, in bytes, of the extra window memory associated with each window in the class. Setting this value does not change
            the number of extra bytes already allocated. For information on how to access this memory, see SetWindowLong.
            </term>
            </item>
            <item>
            <term>GCL_HBRBACKGROUND -10</term>
            <term>Replaces a handle to the background brush associated with the class.</term>
            </item>
            <item>
            <term>GCL_HCURSOR -12</term>
            <term>Replaces a handle to the cursor associated with the class.</term>
            </item>
            <item>
            <term>GCL_HICON -14</term>
            <term>Replaces a handle to the icon associated with the class.</term>
            </item>
            <item>
            <term>GCL_HICONSM -34</term>
            <term>Replace a handle to the small icon associated with the class.</term>
            </item>
            <item>
            <term>GCL_HMODULE -16</term>
            <term>Replaces a handle to the module that registered the class.</term>
            </item>
            <item>
            <term>GCL_MENUNAME -8</term>
            <term>Replaces the address of the menu name string. The string identifies the menu resource associated with the class.</term>
            </item>
            <item>
            <term>GCL_STYLE -26</term>
            <term>Replaces the window-class style bits.</term>
            </item>
            <item>
            <term>GCL_WNDPROC -24</term>
            <term>Replaces the address of the window procedure associated with the class.</term>
            </item>
            </list>
            </param>
            <param name="dwNewLong">
            <para>Type: <c>LONG</c></para>
            <para>The replacement value.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>DWORD</c></c></para>
            <para>
            If the function succeeds, the return value is the previous value of the specified 32-bit integer. If the value was not previously
            set, the return value is zero.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If you use the <c>SetClassLong</c> function and the <c>GCL_WNDPROC</c> index to replace the window procedure, the window
            procedure must conform to the guidelines specified in the description of the WindowProc callback function.
            </para>
            <para>
            Calling <c>SetClassLong</c> with the <c>GCL_WNDPROC</c> index creates a subclass of the window class that affects all windows
            subsequently created with the class. An application can subclass a system class, but should not subclass a window class created
            by another process.
            </para>
            <para>
            Reserve extra class memory by specifying a nonzero value in the <c>cbClsExtra</c> member of the WNDCLASSEX structure used with
            the RegisterClassEx function.
            </para>
            <para>
            Use the <c>SetClassLong</c> function with care. For example, it is possible to change the background color for a class by using
            <c>SetClassLong</c>, but this change does not immediately repaint all windows belonging to the class.
            </para>
            <para>Examples</para>
            <para>For an example, see Displaying an Icon.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetClassLongPtr(Vanara.PInvoke.HWND,System.Int32,System.IntPtr)">
            <summary>
            Replaces the specified value at the specified offset in the extra class memory or the WNDCLASSEX structure for the class to which
            the specified window belongs.
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window and, indirectly, the class to which the window belongs.</para>
            </param>
            <param name="nIndex">
            <para>Type: <c>int</c></para>
            <para>
            The value to be replaced. To set a value in the extra class memory, specify the positive, zero-based byte offset of the value to
            be set. Valid values are in the range zero through the number of bytes of extra class memory, minus eight; for example, if you
            specified 24 or more bytes of extra class memory, a value of 16 would be an index to the third integer. To set a value other than
            the WNDCLASSEX structure, specify one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>GCL_CBCLSEXTRA -20</term>
            <term>
            Sets the size, in bytes, of the extra memory associated with the class. Setting this value does not change the number of extra
            bytes already allocated.
            </term>
            </item>
            <item>
            <term>GCL_CBWNDEXTRA -18</term>
            <term>
            Sets the size, in bytes, of the extra window memory associated with each window in the class. Setting this value does not change
            the number of extra bytes already allocated. For information on how to access this memory, see SetWindowLongPtr.
            </term>
            </item>
            <item>
            <term>GCLP_ HBRBACKGROUND -10</term>
            <term>Replaces a handle to the background brush associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HCURSOR -12</term>
            <term>Replaces a handle to the cursor associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HICON -14</term>
            <term>Replaces a handle to the icon associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HICONSM -34</term>
            <term>Retrieves a handle to the small icon associated with the class.</term>
            </item>
            <item>
            <term>GCLP_HMODULE -16</term>
            <term>Replaces a handle to the module that registered the class.</term>
            </item>
            <item>
            <term>GCLP_MENUNAME -8</term>
            <term>Replaces the pointer to the menu name string. The string identifies the menu resource associated with the class.</term>
            </item>
            <item>
            <term>GCL_STYLE -26</term>
            <term>Replaces the window-class style bits.</term>
            </item>
            <item>
            <term>GCLP_WNDPROC -24</term>
            <term>Replaces the pointer to the window procedure associated with the class.</term>
            </item>
            </list>
            </param>
            <param name="dwNewLong">
            <para>Type: <c>LONG_PTR</c></para>
            <para>The replacement value.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>ULONG_PTR</c></c></para>
            <para>
            If the function succeeds, the return value is the previous value of the specified offset. If this was not previously set, the
            return value is zero.
            </para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            If you use the <c>SetClassLongPtr</c> function and the <c>GCLP_WNDPROC</c> index to replace the window procedure, the window
            procedure must conform to the guidelines specified in the description of the WindowProc callback function.
            </para>
            <para>
            Calling <c>SetClassLongPtr</c> with the <c>GCLP_WNDPROC</c> index creates a subclass of the window class that affects all windows
            subsequently created with the class. An application can subclass a system class, but should not subclass a window class created
            by another process.
            </para>
            <para>
            Reserve extra class memory by specifying a nonzero value in the <c>cbClsExtra</c> member of the WNDCLASSEX structure used with
            the RegisterClassEx function.
            </para>
            <para>
            Use the <c>SetClassLongPtr</c> function with care. For example, it is possible to change the background color for a class by
            using <c>SetClassLongPtr</c>, but this change does not immediately repaint all windows belonging to the class.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.ALTTABINFO">
            <summary>
            <para>Contains status information for the application-switching (ALT+TAB) window.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ALTTABINFO.cbSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The size, in bytes, of the structure. The caller must set this to .</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ALTTABINFO.cItems">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The number of items in the window.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ALTTABINFO.cColumns">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The number of columns in the window.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ALTTABINFO.cRows">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The number of rows in the window.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ALTTABINFO.iColFocus">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The column of the item that has the focus.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ALTTABINFO.iRowFocus">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The row of the item that has the focus.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ALTTABINFO.cxItem">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The width of each icon in the application-switching window.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ALTTABINFO.cyItem">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The height of each icon in the application-switching window.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.ALTTABINFO.ptStart">
            <summary>
            <para>Type: <c>POINT</c></para>
            <para>The top-left corner of the first icon.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.CHANGEFILTERSTRUCT">
            <summary>
            <para>Contains extended result information obtained by calling the ChangeWindowMessageFilterEx function.</para>
            </summary>
            <remarks>
            <para>
            Certain messages whose value is smaller than <c>WM_USER</c> are required to pass through the filter, regardless of the filter
            setting. There will be no effect when you attempt to use this function to allow or block such messages.
            </para>
            <para>
            An application may use the ChangeWindowMessageFilter function to allow or block a message in a process-wide manner. If the
            message is allowed by either the process message filter or the window message filter, it will be delivered to the window.
            </para>
            <para>The following table lists the possible values returned in <c>ExtStatus</c>.</para>
            <list type="table">
            <listheader>
            <term>Message already allowed at higher scope</term>
            <term>Message already allowed by window's message filter</term>
            <term>Operation requested</term>
            <term>Indicator returned in ExtStatus on success</term>
            </listheader>
            <item>
            <term>No</term>
            <term>No</term>
            <term>MSGFLT_ALLOW</term>
            <term>MSGFLTINFO_NONE</term>
            </item>
            <item>
            <term>No</term>
            <term>No</term>
            <term>MSGFLT_DISALLOW</term>
            <term>MSGFLTINFO_ALREADYDISALLOWED_FORWND</term>
            </item>
            <item>
            <term>No</term>
            <term>No</term>
            <term>MSGFLT_RESET</term>
            <term>MSGFLTINFO_NONE</term>
            </item>
            <item>
            <term>No</term>
            <term>Yes</term>
            <term>MSGFLT_ALLOW</term>
            <term>MSGFLTINFO_ALREADYALLOWED_FORWND</term>
            </item>
            <item>
            <term>No</term>
            <term>Yes</term>
            <term>MSGFLT_DISALLOW</term>
            <term>MSGFLTINFO_NONE</term>
            </item>
            <item>
            <term>No</term>
            <term>Yes</term>
            <term>MSGFLT_RESET</term>
            <term>MSGFLTINFO_NONE</term>
            </item>
            <item>
            <term>Yes</term>
            <term>No</term>
            <term>MSGFLT_ALLOW</term>
            <term>MSGFLTINFO_NONE</term>
            </item>
            <item>
            <term>Yes</term>
            <term>No</term>
            <term>MSGFLT_DISALLOW</term>
            <term>MSGFLTINFO_ALLOWED_HIGHER</term>
            </item>
            <item>
            <term>Yes</term>
            <term>No</term>
            <term>MSGFLT_RESET</term>
            <term>MSGFLTINFO_NONE</term>
            </item>
            <item>
            <term>Yes</term>
            <term>Yes</term>
            <term>MSGFLT_ALLOW</term>
            <term>MSGFLTINFO_ALREADYALLOWED_FORWND</term>
            </item>
            <item>
            <term>Yes</term>
            <term>Yes</term>
            <term>MSGFLT_DISALLOW</term>
            <term>MSGFLTINFO_ALLOWED_HIGHER</term>
            </item>
            <item>
            <term>Yes</term>
            <term>Yes</term>
            <term>MSGFLT_RESET</term>
            <term>MSGFLTINFO_NONE</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.CHANGEFILTERSTRUCT.cbSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The size of the structure, in bytes. Must be set to , otherwise the function fails with <c>ERROR_INVALID_PARAMETER</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CHANGEFILTERSTRUCT.ExtStatus">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>If the function succeeds, this field contains one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MSGFLTINFO_NONE 0</term>
            <term>See the Remarks section. Applies to MSGFLT_ALLOW and MSGFLT_DISALLOW.</term>
            </item>
            <item>
            <term>MSGFLTINFO_ALLOWED_HIGHER 3</term>
            <term>The message is allowed at a scope higher than the window. Applies to MSGFLT_DISALLOW.</term>
            </item>
            <item>
            <term>MSGFLTINFO_ALREADYALLOWED_FORWND 1</term>
            <term>
            The message has already been allowed by this window's message filter, and the function thus succeeded with no change to the
            window's message filter. Applies to MSGFLT_ALLOW.
            </term>
            </item>
            <item>
            <term>MSGFLTINFO_ALREADYDISALLOWED_FORWND 2</term>
            <term>
            The message has already been blocked by this window's message filter, and the function thus succeeded with no change to the
            window's message filter. Applies to MSGFLT_DISALLOW.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CHANGEFILTERSTRUCT.Default">
            <summary>The default value for this structure with the size field set appropriately.</summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.CREATESTRUCT">
            <summary>
            Defines the initialization parameters passed to the window procedure of an application. These members are identical to the
            parameters of the CreateWindowEx function.
            </summary>
            <remarks>
            <para>
            Because the <c>lpszClass</c> member can contain a pointer to a local (and thus inaccessable) atom, do not obtain the class name
            by using this member. Use the GetClassName function instead.
            </para>
            <para>
            You should access the data represented by the <c>lpCreateParams</c> member using a pointer that has been declared using the
            <c>UNALIGNED</c> type, because the pointer may not be <c>DWORD</c> aligned. This is demonstrated in the following example:
            </para>
            <para>
            <code>typedef struct tagMyData { // Define creation data here. } MYDATA; typedef struct tagMyDlgData { SHORT cbExtra; MYDATA myData; } MYDLGDATA, UNALIGNED *PMYDLGDATA; PMYDLGDATA pMyDlgdata = (PMYDLGDATA) (((LPCREATESTRUCT) lParam)-&gt;lpCreateParams);</code>
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.CREATESTRUCT.lpCreateParams">
            <summary>
            <para>Type: <c>LPVOID</c></para>
            <para>
            Contains additional data which may be used to create the window. If the window is being created as a result of a call to the
            CreateWindow or CreateWindowEx function, this member contains the value of the lpParam parameter specified in the function call.
            </para>
            <para>
            If the window being created is a MDI client window, this member contains a pointer to a CLIENTCREATESTRUCT structure. If the
            window being created is a MDI child window, this member contains a pointer to an MDICREATESTRUCT structure.
            </para>
            <para>
            If the window is being created from a dialog template, this member is the address of a <c>SHORT</c> value that specifies the
            size, in bytes, of the window creation data. The value is immediately followed by the creation data. For more information,
            see the following Remarks section.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CREATESTRUCT.hInstance">
            <summary>
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to the module that owns the new window.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CREATESTRUCT.hMenu">
            <summary>
            <para>Type: <c>HMENU</c></para>
            <para>A handle to the menu to be used by the new window.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CREATESTRUCT.hwndParent">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the parent window, if the window is a child window. If the window is owned, this member identifies the owner
            window. If the window is not a child or owned window, this member is <c>NULL</c>.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CREATESTRUCT.cy">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The height of the new window, in pixels.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CREATESTRUCT.cx">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The width of the new window, in pixels.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CREATESTRUCT.y">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            The y-coordinate of the upper left corner of the new window. If the new window is a child window, coordinates are relative
            to the parent window. Otherwise, the coordinates are relative to the screen origin.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CREATESTRUCT.x">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            The x-coordinate of the upper left corner of the new window. If the new window is a child window, coordinates are relative
            to the parent window. Otherwise, the coordinates are relative to the screen origin.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CREATESTRUCT.style">
            <summary>
            <para>Type: <c>LONG</c></para>
            <para>The style for the new window. For a list of possible values, see Window Styles.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CREATESTRUCT.lpszName">
            <summary>
            <para>Type: <c>LPCTSTR</c></para>
            <para>The name of the new window.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CREATESTRUCT.lpszClass">
            <summary>
            <para>Type: <c>LPCTSTR</c></para>
            <para>A pointer to a null-terminated string or an atom that specifies the class name of the new window.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.CREATESTRUCT.dwExStyle">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The extended window style for the new window. For a list of possible values, see Extended Window Styles.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.FLASHWINFO">
            <summary>Contains the flash status for a window and the number of times the system should flash the window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FLASHWINFO.cbSize">
            <summary>The size of the structure, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FLASHWINFO.hwnd">
            <summary>A handle to the window to be flashed. The window can be either opened or minimized.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FLASHWINFO.dwFlags">
            <summary>
            <para>The flash status. This parameter can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>FLASHW_ALL 0x00000003</term>
            <term>Flash both the window caption and taskbar button. This is equivalent to setting the FLASHW_CAPTION | FLASHW_TRAY flags.</term>
            </item>
            <item>
            <term>FLASHW_CAPTION 0x00000001</term>
            <term>Flash the window caption.</term>
            </item>
            <item>
            <term>FLASHW_STOP 0</term>
            <term>Stop flashing. The system restores the window to its original state.</term>
            </item>
            <item>
            <term>FLASHW_TIMER 0x00000004</term>
            <term>Flash continuously, until the FLASHW_STOP flag is set.</term>
            </item>
            <item>
            <term>FLASHW_TIMERNOFG 0x0000000C</term>
            <term>Flash continuously until the window comes to the foreground.</term>
            </item>
            <item>
            <term>FLASHW_TRAY 0x00000002</term>
            <term>Flash the taskbar button.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FLASHWINFO.uCount">
            <summary>The number of times to flash the window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.FLASHWINFO.dwTimeout">
            <summary>
            The rate at which the window is to be flashed, in milliseconds. If <c>dwTimeout</c> is zero, the function uses the default
            cursor blink rate.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.GUITHREADINFO">
            <summary>
            <para>Contains information about a GUI thread.</para>
            </summary>
            <remarks>
            <para>
            This structure is used with the GetGUIThreadInfo function to retrieve information about the active window or a specified GUI thread.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.GUITHREADINFO.cbSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The size of this structure, in bytes. The caller must set this member to .</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GUITHREADINFO.flags">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The thread state. This member can be one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>GUI_CARETBLINKING 0x00000001</term>
            <term>The caret's blink state. This bit is set if the caret is visible.</term>
            </item>
            <item>
            <term>GUI_INMENUMODE 0x00000004</term>
            <term>The thread's menu state. This bit is set if the thread is in menu mode.</term>
            </item>
            <item>
            <term>GUI_INMOVESIZE 0x00000002</term>
            <term>The thread's move state. This bit is set if the thread is in a move or size loop.</term>
            </item>
            <item>
            <term>GUI_POPUPMENUMODE 0x00000010</term>
            <term>The thread's pop-up menu state. This bit is set if the thread has an active pop-up menu.</term>
            </item>
            <item>
            <term>GUI_SYSTEMMENUMODE 0x00000008</term>
            <term>The thread's system menu state. This bit is set if the thread is in a system menu mode.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GUITHREADINFO.hwndActive">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the active window within the thread.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GUITHREADINFO.hwndFocus">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that has the keyboard focus.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GUITHREADINFO.hwndCapture">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that has captured the mouse.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GUITHREADINFO.hwndMenuOwner">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that owns any active menus.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GUITHREADINFO.hwndMoveSize">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window in a move or size loop.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GUITHREADINFO.hwndCaret">
            <summary>
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window that is displaying the caret.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.GUITHREADINFO.rcCaret">
            <summary>
            <para>Type: <c>RECT</c></para>
            <para>The caret's bounding rectangle, in client coordinates, relative to the window specified by the <c>hwndCaret</c> member.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.TITLEBARINFO">
            <summary>
            <para>Contains title bar information.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TITLEBARINFO.cbSize">
            <summary>The size, in bytes, of the structure. The caller must set this member to sizeof(TITLEBARINFO).</summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TITLEBARINFO.rcTitleBar">
            <summary>
            <para>Type: <c>RECT</c></para>
            <para>The coordinates of the title bar. These coordinates include all title-bar elements except the window menu.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.TITLEBARINFO.rgstate">
            <summary>
            <para>Type: <c>DWORD[CCHILDREN_TITLEBAR+1]</c></para>
            <para>
            An array that receives a value for each element of the title bar. The following are the title bar elements represented by the array.
            </para>
            <list type="table">
            <listheader>
            <term>Index</term>
            <term>Title Bar Element</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The title bar itself.</term>
            </item>
            <item>
            <term>1</term>
            <term>Reserved.</term>
            </item>
            <item>
            <term>2</term>
            <term>Minimize button.</term>
            </item>
            <item>
            <term>3</term>
            <term>Maximize button.</term>
            </item>
            <item>
            <term>4</term>
            <term>Help button.</term>
            </item>
            <item>
            <term>5</term>
            <term>Close button.</term>
            </item>
            </list>
            <para>Each array element is a combination of one or more of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>STATE_SYSTEM_FOCUSABLE 0x00100000</term>
            <term>The element can accept the focus.</term>
            </item>
            <item>
            <term>STATE_SYSTEM_INVISIBLE 0x00008000</term>
            <term>The element is invisible.</term>
            </item>
            <item>
            <term>STATE_SYSTEM_OFFSCREEN 0x00010000</term>
            <term>The element has no visible representation.</term>
            </item>
            <item>
            <term>STATE_SYSTEM_UNAVAILABLE 0x00000001</term>
            <term>The element is unavailable.</term>
            </item>
            <item>
            <term>STATE_SYSTEM_PRESSED 0x00000008</term>
            <term>The element is in the pressed state.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.UPDATELAYEREDWINDOWINFO">
            <summary>
            <para>
            Used by UpdateLayeredWindowIndirect to provide position, size, shape, content, and translucency information for a layered window.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UPDATELAYEREDWINDOWINFO.cbSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The size, in bytes, of this structure.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UPDATELAYEREDWINDOWINFO.hdcDst">
            <summary>
            <para>Type: <c>HDC</c></para>
            <para>
            A handle to a DC for the screen. This handle is obtained by specifying <c>NULL</c> in this member when calling
            UpdateLayeredWindowIndirect. The handle is used for palette color matching when the window contents are updated. If
            <c>hdcDst</c> is <c>NULL</c>, the default palette is used.
            </para>
            <para>If <c>hdcSrc</c> is <c>NULL</c>, <c>hdcDst</c> must be <c>NULL</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UPDATELAYEREDWINDOWINFO.pptDst">
            <summary>
            <para>Type: <c>const POINT*</c></para>
            <para>
            The new screen position of the layered window. If the new position is unchanged from the current position, <c>pptDst</c> can
            be <c>NULL</c>.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UPDATELAYEREDWINDOWINFO.psize">
            <summary>
            <para>Type: <c>const SIZE*</c></para>
            <para>
            The new size of the layered window. If the size of the window will not change, this parameter can be <c>NULL</c>. If
            <c>hdcSrc</c> is <c>NULL</c>, <c>psize</c> must be <c>NULL</c>.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UPDATELAYEREDWINDOWINFO.hdcSrc">
            <summary>
            <para>Type: <c>HDC</c></para>
            <para>
            A handle to the DC for the surface that defines the layered window. This handle can be obtained by calling the
            CreateCompatibleDC function. If the shape and visual context of the window will not change, <c>hdcSrc</c> can be <c>NULL</c>.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UPDATELAYEREDWINDOWINFO.pptSrc">
            <summary>
            <para>Type: <c>const POINT*</c></para>
            <para>The location of the layer in the device context. If <c>hdcSrc</c> is <c>NULL</c>, <c>pptSrc</c> should be <c>NULL</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UPDATELAYEREDWINDOWINFO.crKey">
            <summary>
            <para>Type: <c>COLORREF</c></para>
            <para>The color key to be used when composing the layered window. To generate a COLORREF, use the RGB macro.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UPDATELAYEREDWINDOWINFO.pblend">
            <summary>
            <para>Type: <c>const BLENDFUNCTION*</c></para>
            <para>The transparency value to be used when composing the layered window.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UPDATELAYEREDWINDOWINFO.dwFlags">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ULW_ALPHA 0x00000002</term>
            <term>
            Use pblend as the blend function. If the display mode is 256 colors or less, the effect of this value is the same as the
            effect of ULW_OPAQUE.
            </term>
            </item>
            <item>
            <term>ULW_COLORKEY 0x00000001</term>
            <term>Use crKey as the transparency color.</term>
            </item>
            <item>
            <term>ULW_OPAQUE 0x00000004</term>
            <term>Draw an opaque layered window.</term>
            </item>
            <item>
            <term>ULW_EX_NORESIZE 0x00000008</term>
            <term>
            Force the UpdateLayeredWindowIndirect function to fail if the current window size does not match the size specified in the psize.
            </term>
            </item>
            </list>
            <para>If <c>hdcSrc</c> is <c>NULL</c>, <c>dwFlags</c> should be zero.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.UPDATELAYEREDWINDOWINFO.prcDirty">
            <summary>
            <para>Type: <c>const RECT*</c></para>
            <para>
            The area to be updated. This parameter can be <c>NULL</c>. If it is non-NULL, only the area in this rectangle is updated from
            the source DC.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.WINDOWINFO">
            <summary>
            <para>Contains window information.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWINFO.cbSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The size of the structure, in bytes. The caller must set this member to .</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWINFO.rcWindow">
            <summary>
            <para>Type: <c>RECT</c></para>
            <para>The coordinates of the window.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWINFO.rcClient">
            <summary>
            <para>Type: <c>RECT</c></para>
            <para>The coordinates of the client area.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWINFO.dwStyle">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The window styles. For a table of window styles, see Window Styles.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWINFO.dwExStyle">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The extended window styles. For a table of extended window styles, see Extended Window Styles.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWINFO.dwWindowStatus">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            The window status. If this member is <c>WS_ACTIVECAPTION</c> (0x0001), the window is active. Otherwise, this member is zero.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWINFO.cxWindowBorders">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The width of the window border, in pixels.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWINFO.cyWindowBorders">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The height of the window border, in pixels.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWINFO.atomWindowType">
            <summary>
            <para>Type: <c>ATOM</c></para>
            <para>The window class atom (see RegisterClass).</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWINFO.wCreatorVersion">
            <summary>
            <para>Type: <c>WORD</c></para>
            <para>The Windows version of the application that created the window.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.WINDOWPLACEMENT">
            <summary>
            <para>Contains information about the placement of a window on the screen.</para>
            </summary>
            <remarks>
            <para>
            If the window is a top-level window that does not have the <c>WS_EX_TOOLWINDOW</c> window style, then the coordinates represented
            by the following members are in workspace coordinates: <c>ptMinPosition</c>, <c>ptMaxPosition</c>, and <c>rcNormalPosition</c>.
            Otherwise, these members are in screen coordinates.
            </para>
            <para>
            Workspace coordinates differ from screen coordinates in that they take the locations and sizes of application toolbars (including
            the taskbar) into account. Workspace coordinate (0,0) is the upper-left corner of the workspace area, the area of the screen not
            being used by application toolbars.
            </para>
            <para>
            The coordinates used in a <c>WINDOWPLACEMENT</c> structure should be used only by the GetWindowPlacement and SetWindowPlacement
            functions. Passing workspace coordinates to functions which expect screen coordinates (such as SetWindowPos) will result in the
            window appearing in the wrong location. For example, if the taskbar is at the top of the screen, saving window coordinates using
            <c>GetWindowPlacement</c> and restoring them using <c>SetWindowPos</c> causes the window to appear to "creep" up the screen.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWPLACEMENT.length">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>
            The length of the structure, in bytes. Before calling the GetWindowPlacement or SetWindowPlacement functions, set this member
            to .
            </para>
            <para>GetWindowPlacement and SetWindowPlacement fail if this member is not set correctly.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWPLACEMENT.flags">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>
            The flags that control the position of the minimized window and the method by which the window is restored. This member can
            be one or more of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WPF_ASYNCWINDOWPLACEMENT 0x0004</term>
            <term>
            If the calling thread and the thread that owns the window are attached to different input queues, the system posts the
            request to the thread that owns the window. This prevents the calling thread from blocking its execution while other threads
            process the request.
            </term>
            </item>
            <item>
            <term>WPF_RESTORETOMAXIMIZED 0x0002</term>
            <term>
            The restored window will be maximized, regardless of whether it was maximized before it was minimized. This setting is only
            valid the next time the window is restored. It does not change the default restoration behavior. This flag is only valid when
            the SW_SHOWMINIMIZED value is specified for the showCmd member.
            </term>
            </item>
            <item>
            <term>WPF_SETMINPOSITION 0x0001</term>
            <term>
            The coordinates of the minimized window may be specified. This flag must be specified if the coordinates are set in the
            ptMinPosition member.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWPLACEMENT.showCmd">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The current show state of the window. This member can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SW_HIDE 0</term>
            <term>Hides the window and activates another window.</term>
            </item>
            <item>
            <term>SW_MAXIMIZE 3</term>
            <term>Maximizes the specified window.</term>
            </item>
            <item>
            <term>SW_MINIMIZE 6</term>
            <term>Minimizes the specified window and activates the next top-level window in the z-order.</term>
            </item>
            <item>
            <term>SW_RESTORE 9</term>
            <term>
            Activates and displays the window. If the window is minimized or maximized, the system restores it to its original size and
            position. An application should specify this flag when restoring a minimized window.
            </term>
            </item>
            <item>
            <term>SW_SHOW 5</term>
            <term>Activates the window and displays it in its current size and position.</term>
            </item>
            <item>
            <term>SW_SHOWMAXIMIZED 3</term>
            <term>Activates the window and displays it as a maximized window.</term>
            </item>
            <item>
            <term>SW_SHOWMINIMIZED 2</term>
            <term>Activates the window and displays it as a minimized window.</term>
            </item>
            <item>
            <term>SW_SHOWMINNOACTIVE 7</term>
            <term>Displays the window as a minimized window. This value is similar to SW_SHOWMINIMIZED, except the window is not activated.</term>
            </item>
            <item>
            <term>SW_SHOWNA 8</term>
            <term>Displays the window in its current size and position. This value is similar to SW_SHOW, except the window is not activated.</term>
            </item>
            <item>
            <term>SW_SHOWNOACTIVATE 4</term>
            <term>
            Displays a window in its most recent size and position. This value is similar to SW_SHOWNORMAL, except the window is not activated.
            </term>
            </item>
            <item>
            <term>SW_SHOWNORMAL 1</term>
            <term>
            Activates and displays a window. If the window is minimized or maximized, the system restores it to its original size and
            position. An application should specify this flag when displaying the window for the first time.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWPLACEMENT.ptMinPosition">
            <summary>
            <para>Type: <c>POINT</c></para>
            <para>The coordinates of the window's upper-left corner when the window is minimized.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWPLACEMENT.ptMaxPosition">
            <summary>
            <para>Type: <c>POINT</c></para>
            <para>The coordinates of the window's upper-left corner when the window is maximized.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WINDOWPLACEMENT.rcNormalPosition">
            <summary>
            <para>Type: <c>RECT</c></para>
            <para>The window's coordinates when the window is in the restored position.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.WNDCLASS">
            <summary>
            <para>Contains the window class attributes that are registered by the RegisterClass function.</para>
            <para>
            This structure has been superseded by the WNDCLASSEX structure used with the RegisterClassEx function. You can still use
            <c>WNDCLASS</c> and RegisterClass if you do not need to set the small icon associated with the window class.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASS.style">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The class style(s). This member can be any combination of the Class Styles.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASS.lpfnWndProc">
            <summary>
            <para>Type: <c>WNDPROC</c></para>
            <para>
            A pointer to the window procedure. You must use the CallWindowProc function to call the window procedure. For more
            information, see WindowProc.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASS.cbClsExtra">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The number of extra bytes to allocate following the window-class structure. The system initializes the bytes to zero.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASS.cbWndExtra">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            The number of extra bytes to allocate following the window instance. The system initializes the bytes to zero. If an
            application uses <c>WNDCLASS</c> to register a dialog box created by using the <c>CLASS</c> directive in the resource file,
            it must set this member to <c>DLGWINDOWEXTRA</c>.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASS.hInstance">
            <summary>
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to the instance that contains the window procedure for the class.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASS.hIcon">
            <summary>
            <para>Type: <c>HICON</c></para>
            <para>
            A handle to the class icon. This member must be a handle to an icon resource. If this member is <c>NULL</c>, the system
            provides a default icon.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASS.hCursor">
            <summary>
            <para>Type: <c>HCURSOR</c></para>
            <para>
            A handle to the class cursor. This member must be a handle to a cursor resource. If this member is <c>NULL</c>, an
            application must explicitly set the cursor shape whenever the mouse moves into the application's window.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASS.hbrBackground">
            <summary>
            <para>Type: <c>HBRUSH</c></para>
            <para>
            A handle to the class background brush. This member can be a handle to the physical brush to be used for painting the
            background, or it can be a color value. A color value must be one of the following standard system colors (the value 1 must
            be added to the chosen color found in <see cref="T:Vanara.PInvoke.SystemColorIndex"/>). If a color value is given, you must convert it to one
            of the following <c>HBRUSH</c> types:
            </para>
            <list type="bullet">
            <item>
            <term>COLOR_ACTIVEBORDER</term>
            </item>
            <item>
            <term>COLOR_ACTIVECAPTION</term>
            </item>
            <item>
            <term>COLOR_APPWORKSPACE</term>
            </item>
            <item>
            <term>COLOR_BACKGROUND</term>
            </item>
            <item>
            <term>COLOR_BTNFACE</term>
            </item>
            <item>
            <term>COLOR_BTNSHADOW</term>
            </item>
            <item>
            <term>COLOR_BTNTEXT</term>
            </item>
            <item>
            <term>COLOR_CAPTIONTEXT</term>
            </item>
            <item>
            <term>COLOR_GRAYTEXT</term>
            </item>
            <item>
            <term>COLOR_HIGHLIGHT</term>
            </item>
            <item>
            <term>COLOR_HIGHLIGHTTEXT</term>
            </item>
            <item>
            <term>COLOR_INACTIVEBORDER</term>
            </item>
            <item>
            <term>COLOR_INACTIVECAPTION</term>
            </item>
            <item>
            <term>COLOR_MENU</term>
            </item>
            <item>
            <term>COLOR_MENUTEXT</term>
            </item>
            <item>
            <term>COLOR_SCROLLBAR</term>
            </item>
            <item>
            <term>COLOR_WINDOW</term>
            </item>
            <item>
            <term>COLOR_WINDOWFRAME</term>
            </item>
            <item>
            <term>COLOR_WINDOWTEXT</term>
            </item>
            </list>
            <para>The system automatically deletes class background brushes when the class is unregistered by using</para>
            <para>UnregisterClass</para>
            <para>. An application should not delete these brushes.</para>
            <para>
            When this member is <c>NULL</c>, an application must paint its own background whenever it is requested to paint in its
            client area. To determine whether the background must be painted, an application can either process the WM_ERASEBKGND
            message or test the <c>fErase</c> member of the PAINTSTRUCT structure filled by the BeginPaint function.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASS.lpszMenuName">
            <summary>
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            The resource name of the class menu, as the name appears in the resource file. If you use an integer to identify the menu,
            use the MAKEINTRESOURCE macro. If this member is <c>NULL</c>, windows belonging to this class have no default menu.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASS.lpszClassName">
            <summary>
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a null-terminated string or is an atom. If this parameter is an atom, it must be a class atom created by a
            previous call to the RegisterClass or RegisterClassEx function. The atom must be in the low-order word of
            <c>lpszClassName</c>; the high-order word must be zero.
            </para>
            <para>
            If <c>lpszClassName</c> is a string, it specifies the window class name. The class name can be any name registered with
            RegisterClass or RegisterClassEx, or any of the predefined control-class names.
            </para>
            <para>
            The maximum length for <c>lpszClassName</c> is 256. If <c>lpszClassName</c> is greater than the maximum length, the
            RegisterClass function will fail.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.WNDCLASSEX">
            <summary>
            <para>Contains window class information. It is used with the RegisterClassEx and GetClassInfoEx functions.</para>
            <para>
            The <c>WNDCLASSEX</c> structure is similar to the WNDCLASS structure. There are two differences. <c>WNDCLASSEX</c> includes the
            <c>cbSize</c> member, which specifies the size of the structure, and the <c>hIconSm</c> member, which contains a handle to a
            small icon associated with the window class.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASSEX.cbSize">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>
            The size, in bytes, of this structure. Set this member to . Be sure to set this member before calling the GetClassInfoEx function.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASSEX.style">
            <summary>
            <para>Type: <c>UINT</c></para>
            <para>The class style(s). This member can be any combination of the Class Styles.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASSEX.lpfnWndProc">
            <summary>
            <para>Type: <c>WNDPROC</c></para>
            <para>
            A pointer to the window procedure. You must use the CallWindowProc function to call the window procedure. For more
            information, see WindowProc.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASSEX.cbClsExtra">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The number of extra bytes to allocate following the window-class structure. The system initializes the bytes to zero.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASSEX.cbWndExtra">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            The number of extra bytes to allocate following the window instance. The system initializes the bytes to zero. If an
            application uses <c>WNDCLASSEX</c> to register a dialog box created by using the <c>CLASS</c> directive in the resource file,
            it must set this member to <c>DLGWINDOWEXTRA</c>.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASSEX.hInstance">
            <summary>
            <para>Type: <c>HINSTANCE</c></para>
            <para>A handle to the instance that contains the window procedure for the class.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASSEX.hIcon">
            <summary>
            <para>Type: <c>HICON</c></para>
            <para>
            A handle to the class icon. This member must be a handle to an icon resource. If this member is <c>NULL</c>, the system
            provides a default icon.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASSEX.hCursor">
            <summary>
            <para>Type: <c>HCURSOR</c></para>
            <para>
            A handle to the class cursor. This member must be a handle to a cursor resource. If this member is <c>NULL</c>, an
            application must explicitly set the cursor shape whenever the mouse moves into the application's window.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASSEX.hbrBackground">
            <summary>
            <para>Type: <c>HBRUSH</c></para>
            <para>
            A handle to the class background brush. This member can be a handle to the brush to be used for painting the background, or
            it can be a color value. A color value must be one of the following standard system colors (the value 1 must be added to the
            chosen color). If a color value is given, you must convert it to one of the following <c>HBRUSH</c> types:
            </para>
            <list type="bullet">
            <item>
            <term>COLOR_ACTIVEBORDER</term>
            </item>
            <item>
            <term>COLOR_ACTIVECAPTION</term>
            </item>
            <item>
            <term>COLOR_APPWORKSPACE</term>
            </item>
            <item>
            <term>COLOR_BACKGROUND</term>
            </item>
            <item>
            <term>COLOR_BTNFACE</term>
            </item>
            <item>
            <term>COLOR_BTNSHADOW</term>
            </item>
            <item>
            <term>COLOR_BTNTEXT</term>
            </item>
            <item>
            <term>COLOR_CAPTIONTEXT</term>
            </item>
            <item>
            <term>COLOR_GRAYTEXT</term>
            </item>
            <item>
            <term>COLOR_HIGHLIGHT</term>
            </item>
            <item>
            <term>COLOR_HIGHLIGHTTEXT</term>
            </item>
            <item>
            <term>COLOR_INACTIVEBORDER</term>
            </item>
            <item>
            <term>COLOR_INACTIVECAPTION</term>
            </item>
            <item>
            <term>COLOR_MENU</term>
            </item>
            <item>
            <term>COLOR_MENUTEXT</term>
            </item>
            <item>
            <term>COLOR_SCROLLBAR</term>
            </item>
            <item>
            <term>COLOR_WINDOW</term>
            </item>
            <item>
            <term>COLOR_WINDOWFRAME</term>
            </item>
            <item>
            <term>COLOR_WINDOWTEXT</term>
            </item>
            </list>
            <para>The system automatically deletes class background brushes when the class is unregistered by using</para>
            <para>UnregisterClass</para>
            <para>. An application should not delete these brushes.</para>
            <para>
            When this member is <c>NULL</c>, an application must paint its own background whenever it is requested to paint in its client
            area. To determine whether the background must be painted, an application can either process the WM_ERASEBKGND message or
            test the <c>fErase</c> member of the PAINTSTRUCT structure filled by the BeginPaint function.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASSEX.lpszMenuName">
            <summary>
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            Pointer to a null-terminated character string that specifies the resource name of the class menu, as the name appears in the
            resource file. If you use an integer to identify the menu, use the MAKEINTRESOURCE macro. If this member is <c>NULL</c>,
            windows belonging to this class have no default menu.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASSEX.lpszClassName">
            <summary>
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A pointer to a null-terminated string or is an atom. If this parameter is an atom, it must be a class atom created by a
            previous call to the RegisterClass or RegisterClassEx function. The atom must be in the low-order word of
            <c>lpszClassName</c>; the high-order word must be zero.
            </para>
            <para>
            If <c>lpszClassName</c> is a string, it specifies the window class name. The class name can be any name registered with
            RegisterClass or RegisterClassEx, or any of the predefined control-class names.
            </para>
            <para>
            The maximum length for <c>lpszClassName</c> is 256. If <c>lpszClassName</c> is greater than the maximum length, the
            RegisterClassEx function will fail.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.User32.WNDCLASSEX.hIconSm">
            <summary>
            <para>Type: <c>HICON</c></para>
            <para>
            A handle to a small icon that is associated with the window class. If this member is <c>NULL</c>, the system searches the
            icon resource specified by the <c>hIcon</c> member for an icon of the appropriate size to use as the small icon.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.WNDCLASSEXB">
            <summary>
            <para>Contains window class information. It is used with the RegisterClassEx and GetClassInfoEx functions.</para>
            <para>
            The <c>WNDCLASSEX</c> structure is similar to the WNDCLASS structure. There are two differences. <c>WNDCLASSEX</c> includes the
            <c>cbSize</c> member, which specifies the size of the structure, and the <c>hIconSm</c> member, which contains a handle to a
            small icon associated with the window class.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.User32.SafeHWND">
            <summary>
            Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> to a window or dialog that releases a created HWND instance at disposal using DestroyWindow.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHWND.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.HWND"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHWND.op_Implicit(Vanara.PInvoke.User32.SafeHWND)~Vanara.PInvoke.HWND">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.User32.SafeHWND"/> to <see cref="T:Vanara.PInvoke.HWND"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.SafeHWND.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.User32.PropEnumProc">
            <summary>
            An application-defined callback function used with the EnumProps function. The function receives property entries from a window's
            property list. The <c>PROPENUMPROC</c> type defines a pointer to this callback function. PropEnumProc is a placeholder for the
            application-defined function name.
            </summary>
            <param name="hwnd">Handle to the window whose property list is being enumerated.</param>
            <param name="lpszString">
            Pointer to a null-terminated string. This string is the string component of a property list entry. This is the string that was
            specified, along with a data handle, when the property was added to the window's property list via a call to the SetProp function.
            </param>
            <param name="hData">Handle to data. This handle is the data component of a property list entry.</param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>Return <c>TRUE</c> to continue the property list enumeration.</para>
            <para>Return <c>FALSE</c> to stop the property list enumeration.</para>
            </returns>
            <remarks>
            <para>The following restrictions apply to this callback function:</para>
            <list type="bullet">
            <item>
            <term>
            The callback function can call the RemoveProp function. However, <c>RemoveProp</c> can remove only the property passed to the
            callback function through the callback function's parameters.
            </term>
            </item>
            <item>
            <term>The callback function should not attempt to add properties.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.User32.PropEnumProcEx">
            <summary>
            Application-defined callback function used with the EnumPropsEx function. The function receives property entries from a window's
            property list. The PROPENUMPROCEX type defines a pointer to this callback function. <c>PropEnumProcEx</c> is a placeholder for
            the application-defined function name.
            </summary>
            <param name="hwnd">Handle to the window whose property list is being enumerated.</param>
            <param name="lpszString">
            Pointer to a null-terminated string. This string is the string component of a property list entry. This is the string that was
            specified, along with a data handle, when the property was added to the window's property list via a call to the SetProp function.
            </param>
            <param name="hData">Handle to data. This handle is the data component of a property list entry.</param>
            <param name="dwData">
            Application-defined data. This is the value that was specified as the lParam parameter of the call to EnumPropsEx that initiated
            the enumeration.
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>Return <c>TRUE</c> to continue the property list enumeration.</para>
            <para>Return <c>FALSE</c> to stop the property list enumeration.</para>
            </returns>
            <remarks>
            <para>The following restrictions apply to this callback function:</para>
            <list type="bullet">
            <item>
            <term>
            The callback function can call the RemoveProp function. However, <c>RemoveProp</c> can remove only the property passed to the
            callback function through the callback function's parameters.
            </term>
            </item>
            <item>
            <term>The callback function should not attempt to add properties.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnumProps(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.PropEnumProc)">
            <summary>
            <para>
            Enumerates all entries in the property list of a window by passing them, one by one, to the specified callback function.
            <c>EnumProps</c> continues until the last entry is enumerated or the callback function returns <c>FALSE</c>.
            </para>
            <para>To pass application-defined data to the callback function, use EnumPropsEx function.</para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose property list is to be enumerated.</para>
            </param>
            <param name="lpEnumFunc">
            <para>Type: <c>PROPENUMPROC</c></para>
            <para>A pointer to the callback function. For more information about the callback function, see the PropEnumProc function.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>int</c></c></para>
            <para>
            The return value specifies the last value returned by the callback function. It is -1 if the function did not find a property for enumeration.
            </para>
            </returns>
            <remarks>
            <para>
            An application can remove only those properties it has added. It must not remove properties added by other applications or by the
            system itself.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.EnumPropsEx(Vanara.PInvoke.HWND,Vanara.PInvoke.User32.PropEnumProcEx,System.IntPtr)">
            <summary>
            <para>
            Enumerates all entries in the property list of a window by passing them, one by one, to the specified callback function.
            <c>EnumPropsEx</c> continues until the last entry is enumerated or the callback function returns <c>FALSE</c>.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose property list is to be enumerated.</para>
            </param>
            <param name="lpEnumFunc">
            <para>Type: <c>PROPENUMPROCEX</c></para>
            <para>A pointer to the callback function. For more information about the callback function, see the PropEnumProcEx function.</para>
            </param>
            <param name="lParam">
            <para>Type: <c>LPARAM</c></para>
            <para>Application-defined data to be passed to the callback function.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>int</c></c></para>
            <para>
            The return value specifies the last value returned by the callback function. It is -1 if the function did not find a property for enumeration.
            </para>
            </returns>
            <remarks>
            <para>
            An application can remove only those properties it has added. It must not remove properties added by other applications or by the
            system itself.
            </para>
            <para>Examples</para>
            <para>For an example, see Listing Window Properties for a Given Window.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.GetProp(Vanara.PInvoke.HWND,System.String)">
            <summary>
            <para>
            Retrieves a data handle from the property list of the specified window. The character string identifies the handle to be
            retrieved. The string and handle must have been added to the property list by a previous call to the SetProp function.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose property list is to be searched.</para>
            </param>
            <param name="lpString">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            An atom that identifies a string. If this parameter is an atom, it must have been created by using the GlobalAddAtom function.
            The atom, a 16-bit value, must be placed in the low-order word of the lpString parameter; the high-order word must be zero.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HANDLE</c></c></para>
            <para>
            If the property list contains the string, the return value is the associated data handle. Otherwise, the return value is <c>NULL</c>.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.User32.RemoveProp(Vanara.PInvoke.HWND,System.String)">
            <summary>
            <para>
            Removes an entry from the property list of the specified window. The specified character string identifies the entry to be removed.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose property list is to be changed.</para>
            </param>
            <param name="lpString">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A null-terminated character string or an atom that identifies a string. If this parameter is an atom, it must have been created
            using the GlobalAddAtom function. The atom, a 16-bit value, must be placed in the low-order word of lpString; the high-order word
            must be zero.
            </para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>HANDLE</c></c></para>
            <para>
            The return value identifies the specified data. If the data cannot be found in the specified property list, the return value is <c>NULL</c>.
            </para>
            </returns>
            <remarks>
            <para>
            The return value is the hData value that was passed to SetProp; it is an application-defined value. Note, this function only
            destroys the association between the data and the window. If appropriate, the application must free the data handles associated
            with entries removed from a property list. The application can remove only those properties it has added. It must not remove
            properties added by other applications or by the system itself.
            </para>
            <para>
            The <c>RemoveProp</c> function returns the data handle associated with the string so that the application can free the data
            associated with the handle.
            </para>
            <para>
            Starting with Windows Vista, <c>RemoveProp</c> is subject to the restrictions of User Interface Privilege Isolation (UIPI). A
            process can only call this function on a window belonging to a process of lesser or equal integrity level. When UIPI blocks
            property changes, GetLastError will return <c>5</c>.
            </para>
            <para>Examples</para>
            <para>For an example, see Deleting a Window Property.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.User32.SetProp(Vanara.PInvoke.HWND,System.String,System.IntPtr)">
            <summary>
            <para>
            Adds a new entry or changes an existing entry in the property list of the specified window. The function adds a new entry to the
            list if the specified character string does not exist already in the list. The new entry contains the string and the handle.
            Otherwise, the function replaces the string's current handle with the specified handle.
            </para>
            </summary>
            <param name="hWnd">
            <para>Type: <c>HWND</c></para>
            <para>A handle to the window whose property list receives the new entry.</para>
            </param>
            <param name="lpString">
            <para>Type: <c>LPCTSTR</c></para>
            <para>
            A null-terminated string or an atom that identifies a string. If this parameter is an atom, it must be a global atom created by a
            previous call to the GlobalAddAtom function. The atom must be placed in the low-order word of lpString; the high-order word must
            be zero.
            </para>
            </param>
            <param name="hData">
            <para>Type: <c>HANDLE</c></para>
            <para>A handle to the data to be copied to the property list. The data handle can identify any value useful to the application.</para>
            </param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the data handle and string are added to the property list, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            Before a window is destroyed (that is, before it returns from processing the WM_NCDESTROY message), an application must remove
            all entries it has added to the property list. The application must use the RemoveProp function to remove the entries.
            </para>
            <para>
            <c>SetProp</c> is subject to the restrictions of User Interface Privilege Isolation (UIPI). A process can only call this function
            on a window belonging to a process of lesser or equal integrity level. When UIPI blocks property changes, GetLastError will
            return 5.
            </para>
            <para>Examples</para>
            <para>For an example, see Adding a Window Property.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.MsgPumpDelegate">
            <summary>Delegate for a method that processes a <see cref="T:Vanara.PInvoke.MSG"/> structure.</summary>
            <param name="msg">The <see cref="T:Vanara.PInvoke.MSG"/> structure to process.</param>
        </member>
        <member name="T:Vanara.PInvoke.MsgPumpPredicateDelegate">
            <summary>
            Delegate for a method that processes a <see cref="T:Vanara.PInvoke.MSG"/> structure and returns a value determining if the next step should be processed.
            </summary>
            <param name="msg">The <see cref="T:Vanara.PInvoke.MSG"/> structure to process.</param>
            <returns><see langword="true"/> if the pump should proceed; otherwise <see langword="false"/>.</returns>
        </member>
        <member name="T:Vanara.PInvoke.IMessagePump">
            <summary>Interface defining a message pump.</summary>
        </member>
        <member name="M:Vanara.PInvoke.IMessagePump.Run(Vanara.PInvoke.IWindowInstance)">
            <summary>Runs the message pump on the optionally specified window.</summary>
            <param name="mainWindow">The window instance.</param>
            <returns>
            The result of <see cref="M:Vanara.PInvoke.User32.PeekMessage(Vanara.PInvoke.MSG@,Vanara.PInvoke.HWND,System.UInt32,System.UInt32,Vanara.PInvoke.User32.PM)"/> or <see cref="M:Vanara.PInvoke.User32.GetMessage(Vanara.PInvoke.MSG@,Vanara.PInvoke.HWND,System.UInt32,System.UInt32)"/>.
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.IWindowInstance">
            <summary>An interface that represents a Win32 window with created and destroyed events.</summary>
        </member>
        <member name="E:Vanara.PInvoke.IWindowInstance.Destroyed">
            <summary>Occurs when the window has been destroyed.</summary>
        </member>
        <member name="P:Vanara.PInvoke.IWindowInstance.Handle">
            <summary>Gets the window handle.</summary>
            <value>The window handle.</value>
        </member>
        <member name="T:Vanara.PInvoke.MessagePump">
            <summary>A basic message pump to use independently or with a window instance.</summary>
            <example>
            Simple example of a window creation and message pump.
            <code>using (var win = new BasicMessageWindow() { Text = "Title", Visible = true })
                return new MessagePump().Run(win);</code></example>
            <seealso cref="T:Vanara.PInvoke.IMessagePump" />
        </member>
        <member name="F:Vanara.PInvoke.MessagePump.quitMsg">
            <summary>Easy access to WM_QUIT value.</summary>
        </member>
        <member name="M:Vanara.PInvoke.MessagePump.Run(Vanara.PInvoke.IWindowInstance)">
            <inhertdoc/>
        </member>
        <member name="M:Vanara.PInvoke.MessagePump.RunLoop">
            <summary>Defines and executes the message pump.</summary>
            <returns>
            The result of <see cref="M:Vanara.PInvoke.User32.PeekMessage(Vanara.PInvoke.MSG@,Vanara.PInvoke.HWND,System.UInt32,System.UInt32,Vanara.PInvoke.User32.PM)"/> or <see cref="M:Vanara.PInvoke.User32.GetMessage(Vanara.PInvoke.MSG@,Vanara.PInvoke.HWND,System.UInt32,System.UInt32)"/>.
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.ExaminedMessagePump">
            <summary>A message pump with events to process each step to use independently or with a window instance.</summary>
            <seealso cref="T:Vanara.PInvoke.MessagePump"/>
        </member>
        <member name="E:Vanara.PInvoke.ExaminedMessagePump.PostProcess">
            <summary>Occurs after <see cref="M:Vanara.PInvoke.User32.DispatchMessage(Vanara.PInvoke.MSG@)"/>.</summary>
        </member>
        <member name="E:Vanara.PInvoke.ExaminedMessagePump.PostTranslate">
            <summary>Occurs after <see cref="M:Vanara.PInvoke.User32.TranslateMessage(Vanara.PInvoke.MSG@)"/> and determines if message should be dispatched.</summary>
        </member>
        <member name="E:Vanara.PInvoke.ExaminedMessagePump.PreProcess">
            <summary>
            Occurs after <see cref="M:Vanara.PInvoke.User32.PeekMessage(Vanara.PInvoke.MSG@,Vanara.PInvoke.HWND,System.UInt32,System.UInt32,Vanara.PInvoke.User32.PM)"/> and determines if message should be translated or dispatched.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.ExaminedMessagePump.RunLoop">
            <inhertdoc/>
        </member>
        <member name="T:Vanara.PInvoke.SystemEventHandler">
            <summary>
            An event handler that is dependent on window messages. This class works on both windowed and console applications, creating a
            threaded message pump if needed.
            <para>
            To use, derive a class and override the <see cref="M:Vanara.PInvoke.SystemEventHandler.MessageFilter(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr,System.IntPtr@)"/> method. When handling the message, use the <see
            cref="M:Vanara.PInvoke.SystemEventHandler.RaiseEvent(System.Guid,System.Object[])"/> method to call the event.
            </para>
            <para>
            Delegates can be registered and unregistered using unique GUID values via the <see cref="M:Vanara.PInvoke.SystemEventHandler.AddEvent(System.Guid,System.Delegate)"/> and <see
            cref="M:Vanara.PInvoke.SystemEventHandler.RemoveEvent(System.Guid,System.Delegate)"/> methods.
            </para>
            </summary>
            <seealso cref="T:System.IDisposable"/>
        </member>
        <member name="M:Vanara.PInvoke.SystemEventHandler.#ctor(System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.SystemEventHandler"/> class.</summary>
            <param name="forceThread">
            if set to <see langword="true"/> a new thread is created for the message pump regardless of the current apartment state.
            </param>
            <exception cref="T:System.InvalidOperationException">System events not supported.</exception>
        </member>
        <member name="M:Vanara.PInvoke.SystemEventHandler.Finalize">
            <summary>Finalizes an instance of the <see cref="T:Vanara.PInvoke.SystemEventHandler"/> class.</summary>
        </member>
        <member name="E:Vanara.PInvoke.SystemEventHandler.MessageWindowHandleCreated">
            <summary>Occurs when the message window handle has been created.</summary>
        </member>
        <member name="P:Vanara.PInvoke.SystemEventHandler.IsRunningInThread">
            <summary>Gets a value indicating whether this instance is running in a thread.</summary>
            <value><see langword="true"/> if this instance is running in a thread; otherwise, <see langword="false"/>.</value>
        </member>
        <member name="P:Vanara.PInvoke.SystemEventHandler.MessageWindowHandle">
            <summary>Gets the message window handle which can be used to register for messaged events.</summary>
            <value>The message window handle.</value>
        </member>
        <member name="M:Vanara.PInvoke.SystemEventHandler.AddEvent(System.Guid,System.Delegate)">
            <summary>Adds a delegate and its associated key to the handler list.</summary>
            <param name="key">The key.</param>
            <param name="value">The delegate value.</param>
        </member>
        <member name="M:Vanara.PInvoke.SystemEventHandler.RemoveEvent(System.Guid,System.Delegate)">
            <summary>Removes a delegate and its associated key to the handler list.</summary>
            <param name="key">The key.</param>
            <param name="value">The delegate value.</param>
        </member>
        <member name="M:Vanara.PInvoke.SystemEventHandler.System#IDisposable#Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        </member>
        <member name="M:Vanara.PInvoke.SystemEventHandler.Dispose(System.Boolean)">
            <summary>Releases unmanaged and - optionally - managed resources.</summary>
            <param name="disposing">
            <see langword="true"/> to release both managed and unmanaged resources; <see langword="false"/> to release only unmanaged resources.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.SystemEventHandler.HasKey(System.Guid)">
            <summary>Determines whether the specified key has a delegate handler in its list.</summary>
            <param name="key">The key.</param>
            <returns><see langword="true"/> if the specified key exists; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Vanara.PInvoke.SystemEventHandler.MessageFilter(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr,System.IntPtr@)">
            <summary>Provides access to the WndProc listening for messages.</summary>
            <param name="hwnd">A handle to the window procedure that received the message.</param>
            <param name="msg">The message.</param>
            <param name="wParam">Additional message information. The content of this parameter depends on the value of the Msg parameter.</param>
            <param name="lParam">Additional message information. The content of this parameter depends on the value of the Msg parameter.</param>
            <param name="lReturn">The return value is the result of the message processing and depends on the message.</param>
            <returns>
            <see langword="true"/> if this message should be considered handled; or <see langword="false"/> to pass the message along to
            <see cref="M:Vanara.PInvoke.User32.DefWindowProc(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)"/>.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.SystemEventHandler.PreprocessMessage(Vanara.PInvoke.MSG@)">
            <summary>
            Allows derived classes to pre-process a message in a threaded message pump so that it is not passed along. Useful for things
            like <see cref="M:Vanara.PInvoke.User32.IsDialogMessage(Vanara.PInvoke.HWND,Vanara.PInvoke.MSG@)"/>.
            </summary>
            <param name="msg">The MSG.</param>
            <returns>
            <see langword="true"/> if the message was processed and should not be translated and dispatched; <see langword="false"/>
            otherwise. <see langword="false"/> is the default.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.SystemEventHandler.OnEventAdd(System.Guid)">
            <summary>Called when an event has been added.</summary>
            <param name="key">The event key.</param>
        </member>
        <member name="M:Vanara.PInvoke.SystemEventHandler.OnEventRemove(System.Guid)">
            <summary>Called when an event has been removed.</summary>
            <param name="key">The event key.</param>
        </member>
        <member name="M:Vanara.PInvoke.SystemEventHandler.OnMessageWindowHandleCreated">
            <summary>Called when the message window handle is created.</summary>
        </member>
        <member name="M:Vanara.PInvoke.SystemEventHandler.RaiseEvent(System.Guid,System.Object[])">
            <summary>Calls the delegate list associated with the key, passing the supplied parameters.</summary>
            <param name="key">The key.</param>
            <param name="args">The arguments.</param>
            <returns>The value returned by the call to the delegate list.</returns>
            <exception cref="T:System.InvalidOperationException">Event for {key} is not registered.</exception>
        </member>
        <member name="T:Vanara.PInvoke.VisibleWindow">
            <summary>A wrapper for a visible window.</summary>
            <seealso cref="T:Vanara.PInvoke.WindowBase"/>
        </member>
        <member name="M:Vanara.PInvoke.VisibleWindow.#ctor">
            <summary>Initializes an uninitialized and uncreated instance of the <see cref="T:Vanara.PInvoke.VisibleWindow"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.VisibleWindow.#ctor(Vanara.PInvoke.WindowClass,System.String,System.Nullable{Vanara.PInvoke.SIZE},System.Nullable{Vanara.PInvoke.POINT},Vanara.PInvoke.User32.WindowStyles,Vanara.PInvoke.User32.WindowStylesEx,Vanara.PInvoke.HWND,Vanara.PInvoke.HMENU)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.VisibleWindow"/> class.</summary>
            <param name="wc">The window class. If <see langword="null"/>, a new window class is created that is unique to this window.</param>
            <param name="text">
            The window name. If the window style specifies a title bar, the window title pointed to by lpWindowName is displayed in the title
            bar. When using CreateWindow to create controls, such as buttons, check boxes, and static controls, use lpWindowName to specify the
            text of the control. When creating a static control with the <c>SS_ICON</c> style, use lpWindowName to specify the icon name or
            identifier. To specify an identifier, use the syntax "#num".
            </param>
            <param name="size">
            The width and height, in device units, of the window. For overlapped windows, nWidth is the window's width, in screen coordinates, or
            <c>CW_USEDEFAULT</c>. If nWidth is <c>CW_USEDEFAULT</c>, the system selects a default width and height for the window; the default
            width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial
            y-coordinate to the top of the icon area. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if <c>CW_USEDEFAULT</c> is
            specified for a pop-up or child window, the nWidth and nHeight parameter are set to zero.
            </param>
            <param name="position">
            <para>
            The initial vertical position of the window. For an overlapped or pop-up window, the x parameter is the initial x-coordinate of the
            window's upper-left corner and the y parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates.
            For a child window, x is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent
            window's client area and y is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left
            corner. If x is set to <c>CW_USEDEFAULT</c>, the system selects the default position for the window's upper-left corner and ignores
            the y parameter. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if it is specified for a pop-up or child window, the x
            and y parameters are set to zero.
            </para>
            <para>
            If an overlapped window is created with the <c>WS_VISIBLE</c> style bit set and the x parameter is set to <c>CW_USEDEFAULT</c>, then
            the y parameter determines how the window is shown. If the y parameter is <c>CW_USEDEFAULT</c>, then the window manager calls
            ShowWindow with the <c>SW_SHOW</c> flag after the window has been created. If the y parameter is some other value, then the window
            manager calls <c>ShowWindow</c> with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name="style">
            <para>Type: <c>DWORD</c></para>
            <para>
            The style of the window being created. This parameter can be a combination of the window style values, plus the control styles
            indicated in the Remarks section.
            </para>
            </param>
            <param name="exStyle">The extended window style of the window being created. For a list of possible values,see Extended Window Styles.</param>
            <param name="parent">
            <para>
            A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid
            window handle. This parameter is optional for pop-up windows.
            </para>
            <para>To create a message-only window, supply <c>HWND_MESSAGE</c> or a handle to an existing message-only window.</para>
            </param>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>
            A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window, hMenu
            identifies the menu to be used with the window; it can be <c>NULL</c> if the class menu is to be used. For a child window, hMenu
            specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The
            application determines the child-window identifier; it must be unique for all child windows with the same parent window.
            </para>
            </param>
        </member>
        <member name="M:Vanara.PInvoke.VisibleWindow.#ctor(System.String,Vanara.PInvoke.HINSTANCE,System.String,System.Nullable{Vanara.PInvoke.SIZE},System.Nullable{Vanara.PInvoke.POINT},Vanara.PInvoke.User32.WindowStyles,Vanara.PInvoke.User32.WindowStylesEx,Vanara.PInvoke.HWND,Vanara.PInvoke.HMENU)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.VisibleWindow"/> class.</summary>
            <param name="className">The window class name. It is created using default values if it doesn't exist.</param>
            <param name="hInst">
            A handle to the instance of the application that created the class. To retrieve information about classes defined by the system (such
            as buttons or list boxes), set this parameter to NULL.
            </param>
            <param name="text">
            The window name. If the window style specifies a title bar, the window title pointed to by lpWindowName is displayed in the title
            bar. When using CreateWindow to create controls, such as buttons, check boxes, and static controls, use lpWindowName to specify the
            text of the control. When creating a static control with the <c>SS_ICON</c> style, use lpWindowName to specify the icon name or
            identifier. To specify an identifier, use the syntax "#num".
            </param>
            <param name="size">
            The width and height, in device units, of the window. For overlapped windows, nWidth is the window's width, in screen coordinates, or
            <c>CW_USEDEFAULT</c>. If nWidth is <c>CW_USEDEFAULT</c>, the system selects a default width and height for the window; the default
            width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial
            y-coordinate to the top of the icon area. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if <c>CW_USEDEFAULT</c> is
            specified for a pop-up or child window, the nWidth and nHeight parameter are set to zero.
            </param>
            <param name="position">
            <para>
            The initial vertical position of the window. For an overlapped or pop-up window, the x parameter is the initial x-coordinate of the
            window's upper-left corner and the y parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates.
            For a child window, x is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent
            window's client area and y is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left
            corner. If x is set to <c>CW_USEDEFAULT</c>, the system selects the default position for the window's upper-left corner and ignores
            the y parameter. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if it is specified for a pop-up or child window, the x
            and y parameters are set to zero.
            </para>
            <para>
            If an overlapped window is created with the <c>WS_VISIBLE</c> style bit set and the x parameter is set to <c>CW_USEDEFAULT</c>, then
            the y parameter determines how the window is shown. If the y parameter is <c>CW_USEDEFAULT</c>, then the window manager calls
            ShowWindow with the <c>SW_SHOW</c> flag after the window has been created. If the y parameter is some other value, then the window
            manager calls <c>ShowWindow</c> with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name="style">
            <para>Type: <c>DWORD</c></para>
            <para>
            The style of the window being created. This parameter can be a combination of the window style values, plus the control styles
            indicated in the Remarks section.
            </para>
            </param>
            <param name="exStyle">The extended window style of the window being created. For a list of possible values,see Extended Window Styles.</param>
            <param name="parent">
            <para>
            A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid
            window handle. This parameter is optional for pop-up windows.
            </para>
            <para>To create a message-only window, supply <c>HWND_MESSAGE</c> or a handle to an existing message-only window.</para>
            </param>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>
            A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window, hMenu
            identifies the menu to be used with the window; it can be <c>NULL</c> if the class menu is to be used. For a child window, hMenu
            specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The
            application determines the child-window identifier; it must be unique for all child windows with the same parent window.
            </para>
            </param>
        </member>
        <member name="M:Vanara.PInvoke.VisibleWindow.#ctor(Vanara.PInvoke.User32.WindowProc,System.String,System.Nullable{Vanara.PInvoke.SIZE},System.Nullable{Vanara.PInvoke.POINT},Vanara.PInvoke.User32.WindowStyles,Vanara.PInvoke.User32.WindowStylesEx,Vanara.PInvoke.HMENU,Vanara.PInvoke.HWND)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.VisibleWindow"/> class.</summary>
            <param name="wndProcOverride">The window procedure override delegate.</param>
            <param name="text">
            The window name. If the window style specifies a title bar, the window title pointed to by lpWindowName is displayed in the title
            bar. When using CreateWindow to create controls, such as buttons, check boxes, and static controls, use lpWindowName to specify the
            text of the control. When creating a static control with the <c>SS_ICON</c> style, use lpWindowName to specify the icon name or
            identifier. To specify an identifier, use the syntax "#num".
            </param>
            <param name="size">
            The width and height, in device units, of the window. For overlapped windows, nWidth is the window's width, in screen coordinates, or
            <c>CW_USEDEFAULT</c>. If nWidth is <c>CW_USEDEFAULT</c>, the system selects a default width and height for the window; the default
            width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial
            y-coordinate to the top of the icon area. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if <c>CW_USEDEFAULT</c> is
            specified for a pop-up or child window, the nWidth and nHeight parameter are set to zero.
            </param>
            <param name="position">
            <para>
            The initial vertical position of the window. For an overlapped or pop-up window, the x parameter is the initial x-coordinate of the
            window's upper-left corner and the y parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates.
            For a child window, x is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent
            window's client area and y is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left
            corner. If x is set to <c>CW_USEDEFAULT</c>, the system selects the default position for the window's upper-left corner and ignores
            the y parameter. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if it is specified for a pop-up or child window, the x
            and y parameters are set to zero.
            </para>
            <para>
            If an overlapped window is created with the <c>WS_VISIBLE</c> style bit set and the x parameter is set to <c>CW_USEDEFAULT</c>, then
            the y parameter determines how the window is shown. If the y parameter is <c>CW_USEDEFAULT</c>, then the window manager calls
            ShowWindow with the <c>SW_SHOW</c> flag after the window has been created. If the y parameter is some other value, then the window
            manager calls <c>ShowWindow</c> with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name="style">
            <para>Type: <c>DWORD</c></para>
            <para>
            The style of the window being created. This parameter can be a combination of the window style values, plus the control styles
            indicated in the Remarks section.
            </para>
            </param>
            <param name="exStyle">The extended window style of the window being created. For a list of possible values,see Extended Window Styles.</param>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>
            A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window, hMenu
            identifies the menu to be used with the window; it can be <c>NULL</c> if the class menu is to be used. For a child window, hMenu
            specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The
            application determines the child-window identifier; it must be unique for all child windows with the same parent window.
            </para>
            </param>
            <param name="parent">
            <para>
            A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid
            window handle. This parameter is optional for pop-up windows.
            </para>
            <para>To create a message-only window, supply <c>HWND_MESSAGE</c> or a handle to an existing message-only window.</para>
            </param>
        </member>
        <member name="P:Vanara.PInvoke.VisibleWindow.Bounds">
            <summary>
            Gets or sets the dimensions of the bounding rectangle of the specified window. The dimensions are given in screen coordinates that
            are relative to the upper-left corner of the screen.
            </summary>
            <value>A RECT structure with the screen coordinates of the upper-left and lower-right corners of the window.</value>
        </member>
        <member name="P:Vanara.PInvoke.VisibleWindow.ClientRect">
            <summary>
            Gets the coordinates of a window's client area. The client coordinates specify the upper-left and lower-right corners of the client
            area. Because client coordinates are relative to the upper-left corner of a window's client area, the coordinates of the upper-left
            corner are (0,0).
            </summary>
            <value>
            A RECT structure with the client coordinates. The left and top members are zero. The right and bottom members contain the width and
            height of the window.
            </value>
        </member>
        <member name="P:Vanara.PInvoke.VisibleWindow.Enabled">
            <summary>Gets a value indicating whether this <see cref="T:Vanara.PInvoke.BasicMessageWindow"/> is enabled.</summary>
            <value><see langword="true"/> if enabled; otherwise, <see langword="false"/>.</value>
        </member>
        <member name="P:Vanara.PInvoke.VisibleWindow.Focused">
            <summary>Gets a value indicating whether the window has input focus.</summary>
            <value><see langword="true"/> if focused; otherwise, <see langword="false"/>.</value>
        </member>
        <member name="P:Vanara.PInvoke.VisibleWindow.Position">
            <summary>
            Gets or sets the position of the window. The dimensions are given in screen coordinates that are relative to the upper-left corner of
            the screen.
            </summary>
            <value>The position of window.</value>
        </member>
        <member name="P:Vanara.PInvoke.VisibleWindow.ShowState">
            <summary>Gets or sets the window's show state.</summary>
            <value>The show state.</value>
        </member>
        <member name="P:Vanara.PInvoke.VisibleWindow.Size">
            <summary>Gets or sets the size of the window.</summary>
            <value>The size of window.</value>
        </member>
        <member name="P:Vanara.PInvoke.VisibleWindow.Styles">
            <summary>Gets or sets the value of the style bit for the window.</summary>
            <value>The styles value.</value>
        </member>
        <member name="P:Vanara.PInvoke.VisibleWindow.StylesEx">
            <summary>Gets or sets the value of the extended style bit for the window.</summary>
            <value>The extended styles value.</value>
        </member>
        <member name="P:Vanara.PInvoke.VisibleWindow.Text">
            <summary>Gets or sets the text of the window's title bar (if it has one).</summary>
            <value>The text of the title bar.</value>
        </member>
        <member name="P:Vanara.PInvoke.VisibleWindow.Visible">
            <summary>Gets a value indicating whether this window is visible.</summary>
            <value><see langword="true"/> if visible; otherwise, <see langword="false"/>.</value>
        </member>
        <member name="M:Vanara.PInvoke.VisibleWindow.Run``1(Vanara.PInvoke.WindowClass,System.String,System.Nullable{Vanara.PInvoke.SIZE},System.Nullable{Vanara.PInvoke.POINT},Vanara.PInvoke.User32.WindowStyles,Vanara.PInvoke.User32.WindowStylesEx,Vanara.PInvoke.HWND,Vanara.PInvoke.HMENU)">
            <summary>
            Creates a new instance of the <see cref="T:Vanara.PInvoke.VisibleWindow"/> class using the parameters, displays the window, and executes a simple
            message pump.
            </summary>
            <param name="wc">The window class. If <see langword="null"/>, a new window class is created that is unique to this window.</param>
            <param name="text">
            The window name. If the window style specifies a title bar, the window title pointed to by lpWindowName is displayed in the title
            bar. When using CreateWindow to create controls, such as buttons, check boxes, and static controls, use lpWindowName to specify the
            text of the control. When creating a static control with the <c>SS_ICON</c> style, use lpWindowName to specify the icon name or
            identifier. To specify an identifier, use the syntax "#num".
            </param>
            <param name="size">
            The width and height, in device units, of the window. For overlapped windows, nWidth is the window's width, in screen coordinates, or
            <c>CW_USEDEFAULT</c>. If nWidth is <c>CW_USEDEFAULT</c>, the system selects a default width and height for the window; the default
            width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial
            y-coordinate to the top of the icon area. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if <c>CW_USEDEFAULT</c> is
            specified for a pop-up or child window, the nWidth and nHeight parameter are set to zero.
            </param>
            <param name="position">
            <para>
            The initial vertical position of the window. For an overlapped or pop-up window, the x parameter is the initial x-coordinate of the
            window's upper-left corner and the y parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates.
            For a child window, x is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent
            window's client area and y is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left
            corner. If x is set to <c>CW_USEDEFAULT</c>, the system selects the default position for the window's upper-left corner and ignores
            the y parameter. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if it is specified for a pop-up or child window, the x
            and y parameters are set to zero.
            </para>
            <para>
            If an overlapped window is created with the <c>WS_VISIBLE</c> style bit set and the x parameter is set to <c>CW_USEDEFAULT</c>, then
            the y parameter determines how the window is shown. If the y parameter is <c>CW_USEDEFAULT</c>, then the window manager calls
            ShowWindow with the <c>SW_SHOW</c> flag after the window has been created. If the y parameter is some other value, then the window
            manager calls <c>ShowWindow</c> with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name="style">
            <para>Type: <c>DWORD</c></para>
            <para>
            The style of the window being created. This parameter can be a combination of the window style values, plus the control styles
            indicated in the Remarks section.
            </para>
            </param>
            <param name="exStyle">The extended window style of the window being created. For a list of possible values,see Extended Window Styles.</param>
            <param name="parent">
            <para>
            A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid
            window handle. This parameter is optional for pop-up windows.
            </para>
            <para>To create a message-only window, supply <c>HWND_MESSAGE</c> or a handle to an existing message-only window.</para>
            </param>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>
            A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window, hMenu
            identifies the menu to be used with the window; it can be <c>NULL</c> if the class menu is to be used. For a child window, hMenu
            specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The
            application determines the child-window identifier; it must be unique for all child windows with the same parent window.
            </para>
            </param>
        </member>
        <member name="M:Vanara.PInvoke.VisibleWindow.Run``1(System.String,System.Nullable{Vanara.PInvoke.SIZE},System.Nullable{Vanara.PInvoke.POINT},Vanara.PInvoke.User32.WindowStyles,Vanara.PInvoke.User32.WindowStylesEx,Vanara.PInvoke.HWND,Vanara.PInvoke.HMENU)">
            <summary>
            Creates a new instance of the <see cref="T:Vanara.PInvoke.VisibleWindow"/> class using the parameters, displays the window, and executes a simple
            message pump.
            </summary>
            <param name="text">
            The window name. If the window style specifies a title bar, the window title pointed to by lpWindowName is displayed in the title
            bar. When using CreateWindow to create controls, such as buttons, check boxes, and static controls, use lpWindowName to specify the
            text of the control. When creating a static control with the <c>SS_ICON</c> style, use lpWindowName to specify the icon name or
            identifier. To specify an identifier, use the syntax "#num".
            </param>
            <param name="size">
            The width and height, in device units, of the window. For overlapped windows, nWidth is the window's width, in screen coordinates, or
            <c>CW_USEDEFAULT</c>. If nWidth is <c>CW_USEDEFAULT</c>, the system selects a default width and height for the window; the default
            width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial
            y-coordinate to the top of the icon area. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if <c>CW_USEDEFAULT</c> is
            specified for a pop-up or child window, the nWidth and nHeight parameter are set to zero.
            </param>
            <param name="position">
            <para>
            The initial vertical position of the window. For an overlapped or pop-up window, the x parameter is the initial x-coordinate of the
            window's upper-left corner and the y parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates.
            For a child window, x is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent
            window's client area and y is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left
            corner. If x is set to <c>CW_USEDEFAULT</c>, the system selects the default position for the window's upper-left corner and ignores
            the y parameter. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if it is specified for a pop-up or child window, the x
            and y parameters are set to zero.
            </para>
            <para>
            If an overlapped window is created with the <c>WS_VISIBLE</c> style bit set and the x parameter is set to <c>CW_USEDEFAULT</c>, then
            the y parameter determines how the window is shown. If the y parameter is <c>CW_USEDEFAULT</c>, then the window manager calls
            ShowWindow with the <c>SW_SHOW</c> flag after the window has been created. If the y parameter is some other value, then the window
            manager calls <c>ShowWindow</c> with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name="style">
            <para>Type: <c>DWORD</c></para>
            <para>
            The style of the window being created. This parameter can be a combination of the window style values, plus the control styles
            indicated in the Remarks section.
            </para>
            </param>
            <param name="exStyle">The extended window style of the window being created. For a list of possible values,see Extended Window Styles.</param>
            <param name="parent">
            <para>
            A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid
            window handle. This parameter is optional for pop-up windows.
            </para>
            <para>To create a message-only window, supply <c>HWND_MESSAGE</c> or a handle to an existing message-only window.</para>
            </param>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>
            A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window, hMenu
            identifies the menu to be used with the window; it can be <c>NULL</c> if the class menu is to be used. For a child window, hMenu
            specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The
            application determines the child-window identifier; it must be unique for all child windows with the same parent window.
            </para>
            </param>
        </member>
        <member name="M:Vanara.PInvoke.VisibleWindow.Run(Vanara.PInvoke.User32.WindowProc,System.String,System.Nullable{Vanara.PInvoke.SIZE},System.Nullable{Vanara.PInvoke.POINT},Vanara.PInvoke.User32.WindowStyles,Vanara.PInvoke.User32.WindowStylesEx,Vanara.PInvoke.HWND,Vanara.PInvoke.HMENU)">
            <summary>
            Creates a new instance of the <see cref="T:Vanara.PInvoke.VisibleWindow"/> class using the parameters, displays the window, and executes a simple
            message pump.
            </summary>
            <param name="wndProc">The window procedure delegate.</param>
            <param name="text">
            The window name. If the window style specifies a title bar, the window title pointed to by lpWindowName is displayed in the title
            bar. When using CreateWindow to create controls, such as buttons, check boxes, and static controls, use lpWindowName to specify the
            text of the control. When creating a static control with the <c>SS_ICON</c> style, use lpWindowName to specify the icon name or
            identifier. To specify an identifier, use the syntax "#num".
            </param>
            <param name="size">
            The width and height, in device units, of the window. For overlapped windows, nWidth is the window's width, in screen coordinates, or
            <c>CW_USEDEFAULT</c>. If nWidth is <c>CW_USEDEFAULT</c>, the system selects a default width and height for the window; the default
            width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial
            y-coordinate to the top of the icon area. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if <c>CW_USEDEFAULT</c> is
            specified for a pop-up or child window, the nWidth and nHeight parameter are set to zero.
            </param>
            <param name="position">
            <para>
            The initial vertical position of the window. For an overlapped or pop-up window, the x parameter is the initial x-coordinate of the
            window's upper-left corner and the y parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates.
            For a child window, x is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent
            window's client area and y is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left
            corner. If x is set to <c>CW_USEDEFAULT</c>, the system selects the default position for the window's upper-left corner and ignores
            the y parameter. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if it is specified for a pop-up or child window, the x
            and y parameters are set to zero.
            </para>
            <para>
            If an overlapped window is created with the <c>WS_VISIBLE</c> style bit set and the x parameter is set to <c>CW_USEDEFAULT</c>, then
            the y parameter determines how the window is shown. If the y parameter is <c>CW_USEDEFAULT</c>, then the window manager calls
            ShowWindow with the <c>SW_SHOW</c> flag after the window has been created. If the y parameter is some other value, then the window
            manager calls <c>ShowWindow</c> with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name="style">
            <para>Type: <c>DWORD</c></para>
            <para>
            The style of the window being created. This parameter can be a combination of the window style values, plus the control styles
            indicated in the Remarks section.
            </para>
            </param>
            <param name="exStyle">The extended window style of the window being created. For a list of possible values,see Extended Window Styles.</param>
            <param name="parent">
            <para>
            A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid
            window handle. This parameter is optional for pop-up windows.
            </para>
            <para>To create a message-only window, supply <c>HWND_MESSAGE</c> or a handle to an existing message-only window.</para>
            </param>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>
            A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window, hMenu
            identifies the menu to be used with the window; it can be <c>NULL</c> if the class menu is to be used. For a child window, hMenu
            specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The
            application determines the child-window identifier; it must be unique for all child windows with the same parent window.
            </para>
            </param>
        </member>
        <member name="M:Vanara.PInvoke.VisibleWindow.ClientToScreen(Vanara.PInvoke.RECT@)">
            <summary>Converts a rectangle from this window's client coordinates to screen coordinates.</summary>
            <param name="clientRect">A <see cref="T:Vanara.PInvoke.RECT"/> in client coordinates.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.RECT"/> in screen coordinates.</returns>
        </member>
        <member name="M:Vanara.PInvoke.VisibleWindow.Focus">
            <summary>Sets input focus to the window.</summary>
        </member>
        <member name="M:Vanara.PInvoke.VisibleWindow.Hide">
            <summary>Hides the window (sets state to SW_HIDE).</summary>
        </member>
        <member name="M:Vanara.PInvoke.VisibleWindow.Invalidate(System.Boolean,Vanara.PInvoke.PRECT)">
            <summary>
            Invalidates the specified region of the windows (adds it to the window's update region, which is the area that will be repainted at
            the next paint operation), and causes a paint message to be sent to the window. Optionally, invalidates the child windows assigned to
            the window.
            </summary>
            <param name="erase"><see langword="true"/> to invalidate the window's child windows; otherwise, <see langword="false"/>.</param>
            <param name="pRect">
            A <see cref="T:Vanara.PInvoke.PRECT"/> that represents the region to invalidate. This value can be <see langword="null"/>, in which case the entire
            client region is invalidated.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.VisibleWindow.ScreenToClient(Vanara.PInvoke.RECT@)">
            <summary>Converts a rectangle from screen coordinates to this window's client coordinates.</summary>
            <param name="screenRect">A <see cref="T:Vanara.PInvoke.RECT"/> in screen coordinates.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.RECT"/> in client coordinates.</returns>
        </member>
        <member name="M:Vanara.PInvoke.VisibleWindow.SetPosition(Vanara.PInvoke.POINT,Vanara.PInvoke.SIZE,Vanara.PInvoke.HWND,Vanara.PInvoke.User32.SetWindowPosFlags)">
            <summary>
            Changes the size, position, and Z order of a child, pop-up, or top-level window. These windows are ordered according to their
            appearance on the screen. The topmost window receives the highest rank and is the first window in the Z order.
            </summary>
            <param name="hWndInsertAfter">
            <para>Type: <c>HWND</c></para>
            <para>
            A handle to the window to precede the positioned window in the Z order. This parameter must be a window handle or one of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>HWND_BOTTOM (HWND)1</term>
            <term>
            Places the window at the bottom of the Z order. If the hWnd parameter identifies a topmost window, the window loses its topmost
            status and is placed at the bottom of all other windows.
            </term>
            </item>
            <item>
            <term>HWND_NOTOPMOST (HWND)-2</term>
            <term>
            Places the window above all non-topmost windows (that is, behind all topmost windows). This flag has no effect if the window is
            already a non-topmost window.
            </term>
            </item>
            <item>
            <term>HWND_TOP (HWND)0</term>
            <term>Places the window at the top of the Z order.</term>
            </item>
            <item>
            <term>HWND_TOPMOST (HWND)-1</term>
            <term>Places the window above all non-topmost windows. The window maintains its topmost position even when it is deactivated.</term>
            </item>
            </list>
            <para>For more information about how this parameter is used, see the following Remarks section.</para>
            </param>
            <param name="position">The new position of the window, in client coordinates.</param>
            <param name="size">The new width of the window, in pixels.</param>
            <param name="flags">The window sizing and positioning flags. This parameter can be one of more values from <see cref="T:Vanara.PInvoke.User32.SetWindowPosFlags"/>.</param>
            <returns>
            <para>Type: <c>Type: <c>BOOL</c></c></para>
            <para>If the function succeeds, the return value is nonzero.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
            <remarks>
            <para>
            As part of the Vista re-architecture, all services were moved off the interactive desktop into Session 0. hwnd and window manager
            operations are only effective inside a session and cross-session attempts to manipulate the hwnd will fail. For more information, see
            The Windows Vista Developer Story: Application Compatibility Cookbook.
            </para>
            <para>
            If you have changed certain window data using SetWindowLong, you must call <c>SetWindowPos</c> for the changes to take effect. Use
            the following combination for uFlags: .
            </para>
            <para>
            A window can be made a topmost window either by setting the hWndInsertAfter parameter to <c>HWND_TOPMOST</c> and ensuring that the
            <c>SWP_NOZORDER</c> flag is not set, or by setting a window's position in the Z order so that it is above any existing topmost
            windows. When a non-topmost window is made topmost, its owned windows are also made topmost. Its owners, however, are not changed.
            </para>
            <para>
            If neither the <c>SWP_NOACTIVATE</c> nor <c>SWP_NOZORDER</c> flag is specified (that is, when the application requests that a window
            be simultaneously activated and its position in the Z order changed), the value specified in hWndInsertAfter is used only in the
            following circumstances.
            </para>
            <list type="bullet">
            <item>
            <term>Neither the <c>HWND_TOPMOST</c> nor <c>HWND_NOTOPMOST</c> flag is specified in hWndInsertAfter.</term>
            </item>
            <item>
            <term>The window identified by hWnd is not the active window.</term>
            </item>
            </list>
            <para>
            An application cannot activate an inactive window without also bringing it to the top of the Z order. Applications can change an
            activated window's position in the Z order without restrictions, or it can activate a window and then move it to the top of the
            topmost or non-topmost windows.
            </para>
            <para>
            If a topmost window is repositioned to the bottom ( <c>HWND_BOTTOM</c>) of the Z order or after any non-topmost window, it is no
            longer topmost. When a topmost window is made non-topmost, its owners and its owned windows are also made non-topmost windows.
            </para>
            <para>
            A non-topmost window can own a topmost window, but the reverse cannot occur. Any window (for example, a dialog box) owned by a
            topmost window is itself made a topmost window, to ensure that all owned windows stay above their owner.
            </para>
            <para>If an application is not in the foreground, and should be in the foreground, it must call the SetForegroundWindow function.</para>
            <para>To use <c>SetWindowPos</c> to bring a window to the top, the process that owns the window must have SetForegroundWindow permission.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.VisibleWindow.Show">
            <summary>Shows the window (sets state to SW_SHOWNORMAL).</summary>
        </member>
        <member name="M:Vanara.PInvoke.VisibleWindow.Validate(Vanara.PInvoke.PRECT)">
            <summary>
            The <c>Validate</c> function validates the client area within a rectangle by removing the rectangle from the update region of the
            this window.
            </summary>
            <param name="pRect">
            A <see cref="T:Vanara.PInvoke.RECT"/> structure that contains the client coordinates of the rectangle to be removed from the update region. If this
            parameter is <see langword="null"/>, the entire client area is removed.
            </param>
        </member>
        <member name="T:Vanara.PInvoke.IWindowHandle">
            <summary>Interface for a class that holds a window handle.</summary>
            <seealso cref="T:Vanara.PInvoke.IHandle"/>
        </member>
        <member name="P:Vanara.PInvoke.IWindowHandle.Handle">
            <summary>Gets the window handle.</summary>
            <value>The window handle.</value>
        </member>
        <member name="T:Vanara.PInvoke.WindowBase">
            <summary>Simple window wrapper.</summary>
            <seealso cref="T:System.MarshalByRefObject"/>
            <seealso cref="T:System.IDisposable"/>
            <seealso cref="T:Vanara.PInvoke.IHandle"/>
        </member>
        <member name="F:Vanara.PInvoke.WindowBase.customWndProc">
            <summary>A window procedure override delegate.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WindowBase"/> class without creating the window.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.#ctor(Vanara.PInvoke.User32.WindowProc)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WindowBase"/> class and defines a window procedure to use.</summary>
            <param name="wndProcOverride">The window procedure override delegate.</param>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.Finalize">
            <summary>Finalizes an instance of the <see cref="T:Vanara.PInvoke.BasicMessageWindow"/> class.</summary>
        </member>
        <member name="E:Vanara.PInvoke.WindowBase.Created">
            <summary>Occurs when the window is created and has a valid handle.</summary>
        </member>
        <member name="E:Vanara.PInvoke.WindowBase.Destroyed">
            <summary>Occurs when the window has been destroyed.</summary>
        </member>
        <member name="P:Vanara.PInvoke.WindowBase.ClassName">
            <summary>Gets the name of the windows class.</summary>
            <value>The name of the windows class.</value>
        </member>
        <member name="P:Vanara.PInvoke.WindowBase.CreateParam">
            <summary>Gets a <see cref="T:Vanara.PInvoke.User32.CREATESTRUCT"/> structure with all creation parameters.</summary>
            <value>The <see cref="T:Vanara.PInvoke.User32.CREATESTRUCT"/> structure with all creation parameters.</value>
        </member>
        <member name="P:Vanara.PInvoke.WindowBase.Handle">
            <summary>Gets the window handle.</summary>
            <value>The window handle.</value>
        </member>
        <member name="P:Vanara.PInvoke.WindowBase.Param">
            <summary>Gets or sets information about the window.</summary>
            <value>The information indexer.</value>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.CreateHandle(Vanara.PInvoke.WindowClass,System.String,System.Nullable{Vanara.PInvoke.SIZE},System.Nullable{Vanara.PInvoke.POINT},Vanara.PInvoke.User32.WindowStyles,Vanara.PInvoke.User32.WindowStylesEx,Vanara.PInvoke.HWND,Vanara.PInvoke.HMENU)">
            <summary>Creates a window and its handle with the specified creation parameters.</summary>
            <param name="wc">The window class. If <see langword="null"/>, a new window class is created that is unique to this window.</param>
            <param name="text">
            The window name. If the window style specifies a title bar, the window title pointed to by lpWindowName is displayed in the title
            bar. When using CreateWindow to create controls, such as buttons, check boxes, and static controls, use lpWindowName to specify the
            text of the control. When creating a static control with the <c>SS_ICON</c> style, use lpWindowName to specify the icon name or
            identifier. To specify an identifier, use the syntax "#num".
            </param>
            <param name="size">
            The width and height, in device units, of the window. For overlapped windows, nWidth is the window's width, in screen coordinates, or
            <c>CW_USEDEFAULT</c>. If nWidth is <c>CW_USEDEFAULT</c>, the system selects a default width and height for the window; the default
            width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial
            y-coordinate to the top of the icon area. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if <c>CW_USEDEFAULT</c> is
            specified for a pop-up or child window, the nWidth and nHeight parameter are set to zero.
            </param>
            <param name="position">
            <para>
            The initial vertical position of the window. For an overlapped or pop-up window, the x parameter is the initial x-coordinate of the
            window's upper-left corner and the y parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates.
            For a child window, x is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent
            window's client area and y is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left
            corner. If x is set to <c>CW_USEDEFAULT</c>, the system selects the default position for the window's upper-left corner and ignores
            the y parameter. <c>CW_USEDEFAULT</c> is valid only for overlapped windows; if it is specified for a pop-up or child window, the x
            and y parameters are set to zero.
            </para>
            <para>
            If an overlapped window is created with the <c>WS_VISIBLE</c> style bit set and the x parameter is set to <c>CW_USEDEFAULT</c>, then
            the y parameter determines how the window is shown. If the y parameter is <c>CW_USEDEFAULT</c>, then the window manager calls
            ShowWindow with the <c>SW_SHOW</c> flag after the window has been created. If the y parameter is some other value, then the window
            manager calls <c>ShowWindow</c> with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name="style">
            <para>Type: <c>DWORD</c></para>
            <para>
            The style of the window being created. This parameter can be a combination of the window style values, plus the control styles
            indicated in the Remarks section.
            </para>
            </param>
            <param name="exStyle">The extended window style of the window being created. For a list of possible values,see Extended Window Styles.</param>
            <param name="parent">
            <para>
            A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid
            window handle. This parameter is optional for pop-up windows.
            </para>
            <para>To create a message-only window, supply <c>HWND_MESSAGE</c> or a handle to an existing message-only window.</para>
            </param>
            <param name="hMenu">
            <para>Type: <c>HMENU</c></para>
            <para>
            A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window, hMenu
            identifies the menu to be used with the window; it can be <c>NULL</c> if the class menu is to be used. For a child window, hMenu
            specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The
            application determines the child-window identifier; it must be unique for all child windows with the same parent window.
            </para>
            </param>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.Vanara#PInvoke#IHandle#DangerousGetHandle">
            <inhertdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.Vanara#PInvoke#IWindowInit#InitWndProcOnNCCreate(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.DebugWriteMessageInfo(System.UInt32,System.String,System.String)">
            <summary>Writes message information to the debugger.</summary>
            <param name="msg">The message code.</param>
            <param name="sourceFilePath">The source file path.</param>
            <param name="caller">The calling method.</param>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.DebugWriteMethod(System.String,System.String)">
            <summary>Writes method information to the debugger.</summary>
            <param name="sourceFilePath">The source file path.</param>
            <param name="caller">The calling method.</param>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.Attach(Vanara.PInvoke.HWND,System.Boolean)">
            <summary>
            Attaches the specified window handle to this instance and associates this instance's <see cref="T:Vanara.PInvoke.User32.WindowProc"/> handlers using GWL_WNDPROC.
            </summary>
            <param name="hwnd">The window handle.</param>
            <param name="own">if set to <see langword="true"/>, the window will be destroyed and handle released on disposal.</param>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.DefWndProc(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>Invokes the default window procedure associated with this window.</summary>
            <param name="hwnd">A handle to the window procedure that received the message.</param>
            <param name="msg">The message.</param>
            <param name="wParam">
            Additional message information. The content of this parameter depends on the value of the <paramref name="msg"/> parameter.
            </param>
            <param name="lParam">
            Additional message information. The content of this parameter depends on the value of the <paramref name="msg"/> parameter.
            </param>
            <returns>The return value is the result of the message processing and depends on the message.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.Detach">
            <summary>
            Detaches this instance's <see cref="T:Vanara.PInvoke.User32.WindowProc"/> handlers using GWL_WNDPROC, restoring previous assignment, and destroys the window
            and closes the handle if owned.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.Dispose(System.Boolean)">
            <summary>Releases unmanaged and - optionally - managed resources.</summary>
            <param name="disposing">
            <see langword="true"/> to release both managed and unmanaged resources; <see langword="false"/> to release only unmanaged resources.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.OnHandleChanged(Vanara.PInvoke.HWND)">
            <summary>Called when this classes <see cref="M:Vanara.PInvoke.WindowBase.InternalWndProc(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)"/> method becomes primary.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.OnWndProcException(System.Exception)">
            <summary>Called when the <see cref="T:Vanara.PInvoke.User32.WindowProc"/> call throws an exception.</summary>
            <param name="ex">The exception.</param>
            <returns>
            <see langword="true"/> if the exception is handled and does not need to be thrown; <see langword="false"/> to throw the exception
            from within the <see cref="T:Vanara.PInvoke.User32.WindowProc"/> procedure.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.WndProc(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>Invokes the default window procedure associated with this window.</summary>
            <param name="hwnd">A handle to the window procedure that received the message.</param>
            <param name="msg">The message.</param>
            <param name="wParam">
            Additional message information. The content of this parameter depends on the value of the <paramref name="msg"/> parameter.
            </param>
            <param name="lParam">
            Additional message information. The content of this parameter depends on the value of the <paramref name="msg"/> parameter.
            </param>
            <returns>The return value is the result of the message processing and depends on the message.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WindowBase.InternalWndProc(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            This is the real <see cref="T:Vanara.PInvoke.User32.WindowProc"/> instance for the window. It calls either <see cref="M:Vanara.PInvoke.WindowBase.WndProc(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)"/>
            or <see cref="M:Vanara.PInvoke.WindowBase.DefWndProc(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)"/> depending on status.
            <para>It is responsible for setting <see cref="P:Vanara.PInvoke.WindowBase.CreateParam"/> and calling <see cref="E:Vanara.PInvoke.WindowBase.Created"/> and <see cref="E:Vanara.PInvoke.WindowBase.Destroyed"/>.</para>
            </summary>
            <param name="hwnd">A handle to the window procedure that received the message.</param>
            <param name="msg">The message.</param>
            <param name="wParam">
            Additional message information. The content of this parameter depends on the value of the <paramref name="msg"/> parameter.
            </param>
            <param name="lParam">
            Additional message information. The content of this parameter depends on the value of the <paramref name="msg"/> parameter.
            </param>
            <returns>The return value is the result of the message processing and depends on the message.</returns>
        </member>
        <member name="T:Vanara.PInvoke.IWindowInit">
            <summary>Interface identifying a class that can subclass a window proceedure.</summary>
        </member>
        <member name="M:Vanara.PInvoke.IWindowInit.InitWndProcOnNCCreate(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Method called on WM_NCCREATE which takes control of the window procedure. The window must provide a GCHandle pointer to itself in
            the lpParam parameter of CreateWindowEx. This method implentation should confirm it's HWND value against <paramref name="hwnd"/>
            and then using SetWindowLongPtr with GWLP_WNDPROC to update the window procedure.
            </summary>
            <param name="hwnd">A handle to the window.</param>
            <param name="msg">Always WM_NCCREATE.</param>
            <param name="wParam">A pointer to the window class' WindowProc delegate.</param>
            <param name="lParam">A pointer to a <see cref="T:Vanara.PInvoke.User32.CREATESTRUCT"/> instance with the window creation paramters.</param>
            <returns>The return should be IntPtr(1) to indicate success. Any other value will stop the completion of CreateWindowEx.</returns>
        </member>
        <member name="T:Vanara.PInvoke.WindowClass">
            <summary>Encapsulates a window class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WindowClass.wc">
            <summary>The instance of the <see cref="T:Vanara.PInvoke.User32.WNDCLASSEX"/> populated for the window class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WindowClass.#ctor(System.String,Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.User32.WindowProc,Vanara.PInvoke.User32.WindowClassStyles,Vanara.PInvoke.HICON,Vanara.PInvoke.HICON,Vanara.PInvoke.HCURSOR,Vanara.PInvoke.HBRUSH,System.String,System.Int32,System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WindowClass"/> class and registers the class name.</summary>
            <param name="className">
            <para>
            A string that specifies the window class name. The class name can be any name registered with RegisterClass or RegisterClassEx,
            or any of the predefined control-class names.
            </para>
            <para>
            The maximum length for <c>lpszClassName</c> is 256. If <c>lpszClassName</c> is greater than the maximum length, the
            RegisterClassEx function will fail.
            </para>
            </param>
            <param name="hInst">A handle to the instance that contains the window procedure for the class.</param>
            <param name="wndProc">
            A pointer to the window procedure. You must use the CallWindowProc function to call the window procedure. For more information,
            see WindowProc.
            </param>
            <param name="styles">The class style(s). This member can be any combination of the Class Styles.</param>
            <param name="hIcon">
            A handle to the class icon. This member must be a handle to an icon resource. If this member is <c>NULL</c>, the system provides
            a default icon.
            </param>
            <param name="hSmIcon">
            A handle to a small icon that is associated with the window class. If this member is <c>NULL</c>, the system searches the icon
            resource specified by the <c>hIcon</c> member for an icon of the appropriate size to use as the small icon.
            </param>
            <param name="hCursor">
            A handle to the class cursor. This member must be a handle to a cursor resource. If this member is <c>NULL</c>, an application
            must explicitly set the cursor shape whenever the mouse moves into the application's window.
            </param>
            <param name="hbrBkgd">
            A handle to the class background brush. This member can be a handle to the brush to be used for painting the background, or it
            can be a color value. A color value must be one of the following standard system colors (the value 1 must be added to the chosen color).
            <para>
            The system automatically deletes class background brushes when the class is unregistered by using <see cref="M:Vanara.PInvoke.User32.UnregisterClass(System.String,Vanara.PInvoke.HINSTANCE)"/>.
            An application should not delete these brushes.
            </para>
            <para>
            When this member is <c>NULL</c>, an application must paint its own background whenever it is requested to paint in its client
            area. To determine whether the background must be painted, an application can either process the WM_ERASEBKGND message or test
            the <c>fErase</c> member of the PAINTSTRUCT structure filled by the BeginPaint function.
            </para>
            </param>
            <param name="menuName">
            A string that specifies the resource name of the class menu, as the name appears in the resource file. If you use an integer to
            identify the menu, use the MAKEINTRESOURCE macro. If this member is <c>NULL</c>, windows belonging to this class have no default menu.
            </param>
            <param name="extraBytes">
            The number of extra bytes to allocate following the window-class structure. The system initializes the bytes to zero.
            </param>
            <param name="extraWinBytes">
            The number of extra bytes to allocate following the window instance. The system initializes the bytes to zero. If an application
            uses <c>WNDCLASSEX</c> to register a dialog box created by using the <c>CLASS</c> directive in the resource file, it must set
            this member to <c>DLGWINDOWEXTRA</c>.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.WindowClass.#ctor(Vanara.PInvoke.User32.WNDCLASSEX@,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WindowClass"/> class using a <see cref="T:Vanara.PInvoke.User32.WNDCLASSEX"/> instance.</summary>
            <param name="wcx">The <see cref="T:Vanara.PInvoke.User32.WNDCLASSEX"/> instance.</param>
            <param name="register">if set to <see langword="true"/>, <paramref name="wcx"/> is used to register the class.</param>
        </member>
        <member name="P:Vanara.PInvoke.WindowClass.MdiWindowBrush">
            <summary>Gets a handle to the brush representing the standard MDI window background (COLOR_APPWORKSPACE).</summary>
            <value>The standard MDI window background brush handle.</value>
        </member>
        <member name="P:Vanara.PInvoke.WindowClass.NullBrush">
            <summary>
            Gets a handle to a null brush (GetStockObject(NULL_BRUSH)). Use this for the background of non-displayable windows or to prevent
            flicker on custom drawn backgrounds.
            </summary>
            <value>The null background brush handle.</value>
        </member>
        <member name="P:Vanara.PInvoke.WindowClass.StdAppIcon">
            <summary>Gets a handle to the standard application icon (IDI_APPLICATION).</summary>
            <value>The standard application icon handle.</value>
        </member>
        <member name="P:Vanara.PInvoke.WindowClass.StdArrowCursor">
            <summary>Gets a handle to the standard arrow cursor (IDC_ARROW).</summary>
            <value>The standard arrow cursor handle.</value>
        </member>
        <member name="P:Vanara.PInvoke.WindowClass.WindowBrush">
            <summary>Gets a handle to the brush representing the standard window background (COLOR_WINDOW).</summary>
            <value>The standard window background brush handle.</value>
        </member>
        <member name="P:Vanara.PInvoke.WindowClass.ClassName">
            <summary>Gets the windows class name.</summary>
        </member>
        <member name="P:Vanara.PInvoke.WindowClass.Styles">
            <summary>Gets the class style(s).</summary>
        </member>
        <member name="P:Vanara.PInvoke.WindowClass.WndProc">
            <summary>Gets the <see cref="T:Vanara.PInvoke.User32.WindowProc"/> that is executed by this class.</summary>
            <value>The executing <see cref="T:Vanara.PInvoke.User32.WindowProc"/>.</value>
        </member>
        <member name="M:Vanara.PInvoke.WindowClass.GetInstanceFromWindow(Vanara.PInvoke.HWND)">
            <summary>Gets a <see cref="T:Vanara.PInvoke.WindowClass"/> instance associated with a window handle.</summary>
            <param name="hWnd">The window handle to examine.</param>
            <returns>
            If the function finds a matching window and successfully copies the data, the return value is a <see cref="T:Vanara.PInvoke.WindowClass"/>
            instance. If not, <see langword="null"/> is returned.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WindowClass.GetNamedInstance(System.String,Vanara.PInvoke.HINSTANCE)">
            <summary>Gets a <see cref="T:Vanara.PInvoke.WindowClass"/> instance by looking up the name.</summary>
            <param name="className">
            The class name. The name must be that of a preregistered class or a class registered by a previous call to the RegisterClass or
            RegisterClassEx function.
            </param>
            <param name="hInst">
            A handle to the instance of the application that created the class. To retrieve information about classes defined by the system
            (such as buttons or list boxes), set this parameter to NULL.
            </param>
            <returns>
            If the function finds a matching class and successfully copies the data, the return value is a <see cref="T:Vanara.PInvoke.WindowClass"/>
            instance. If not, <see langword="null"/> is returned.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WindowClass.MakeVisibleWindowClass(System.String,Vanara.PInvoke.User32.WindowProc,Vanara.PInvoke.HINSTANCE)">
            <summary>Creates a <see cref="T:Vanara.PInvoke.WindowClass"/> instance that uses common settings for a displayed window.</summary>
            <param name="className">
            <para>
            A string that specifies the window class name. The class name can be any name registered with RegisterClass or RegisterClassEx,
            or any of the predefined control-class names.
            </para>
            <para>
            The maximum length for <c>lpszClassName</c> is 256. If <c>lpszClassName</c> is greater than the maximum length, the
            RegisterClassEx function will fail.
            </para>
            </param>
            <param name="hInst">A handle to the instance that contains the window procedure for the class.</param>
            <param name="wndProc">
            A pointer to the window procedure. You must use the CallWindowProc function to call the window procedure. For more information,
            see WindowProc.
            </param>
            <returns>
            A new instance of <see cref="T:Vanara.PInvoke.WindowClass"/> with indicated parameters, standard app icon, arrow cursor, and window system color background.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WindowClass.Unregister">
            <summary>Unregisters this window class.</summary>
            <returns>
            <para>If the function succeeds, the return value is <see langword="true"/>.</para>
            <para>
            If the class could not be found or if a window still exists that was created with the class, the return value is <see
            langword="false"/>. To get extended error information, call GetLastError.
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WindowClass.PrimaryClassWndProc(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>An class function that processes messages sent to this class instance.</summary>
            <param name="hwnd">A handle to the window.</param>
            <param name="msg">The MSG.</param>
            <param name="wParam">Additional message information. The contents of this parameter depend on the value of the uMsg parameter.</param>
            <param name="lParam">Additional message information. The contents of this parameter depend on the value of the uMsg parameter.</param>
            <returns>The return value is the result of the message processing and depends on the message sent.</returns>
        </member>
        <member name="T:Vanara.Extensions.LOGFONTExtension">
            <summary>Extensions for the <see cref="T:Vanara.PInvoke.LOGFONT"/> structure.</summary>
        </member>
        <member name="M:Vanara.Extensions.LOGFONTExtension.GetPointSize(Vanara.PInvoke.LOGFONT)">
            <summary>Gets the point size of the font.</summary>
            <param name="lf">The LOGFONT structure.</param>
            <returns>The point size of the font.</returns>
        </member>
        <member name="M:Vanara.Extensions.LOGFONTExtension.SetPointSize(Vanara.PInvoke.LOGFONT@,System.Single)">
            <summary>Sets the point size of the font.</summary>
            <param name="lf">The LOGFONT structure.</param>
            <param name="value">The point size of the font.</param>
        </member>
    </members>
</doc>
